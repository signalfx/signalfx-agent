[
    {
        "monitorType": "kubelet-stats",
        "negated": true,
        "metricNames": [
            "container_cpu_utilization",
            "container_memory_failures_total",
            "container_memory_usage_bytes",
            "container_spec_cpu_period",
            "container_spec_cpu_quota",
            "container_spec_memory_limit_bytes",
            "machine_cpu_cores",
            "machine_memory_bytes",
            "pod_network_receive_bytes_total",
            "pod_network_receive_errors_total",
            "pod_network_transmit_bytes_total",
            "pod_network_transmit_errors_total"
        ]
    },
    {
        "monitorType": "collectd/spark",
        "negated": true,
        "metricNames": [
            "counter.spark.driver.disk_used",
            "counter.spark.driver.memory_used",
            "counter.spark.driver.total_input_bytes",
            "counter.spark.driver.total_shuffle_read",
            "counter.spark.driver.total_shuffle_write",
            "counter.spark.driver.total_tasks",
            "counter.spark.executor.disk_used",
            "counter.spark.executor.memory_used",
            "counter.spark.executor.total_input_bytes",
            "counter.spark.executor.total_shuffle_read",
            "counter.spark.executor.total_shuffle_write",
            "counter.spark.streaming.num_processed_records",
            "counter.spark.streaming.num_received_records",
            "counter.spark.streaming.num_total_completed_batches",
            "gauge.jvm.heap.committed",
            "gauge.jvm.heap.used",
            "gauge.jvm.non-heap.committed",
            "gauge.jvm.non-heap.used",
            "gauge.jvm.total.committed",
            "gauge.jvm.total.used",
            "gauge.master.aliveWorkers",
            "gauge.master.apps",
            "gauge.master.waitingApps",
            "gauge.master.workers",
            "gauge.spark.driver.max_memory",
            "gauge.spark.executor.count",
            "gauge.spark.executor.max_memory",
            "gauge.spark.job.num_active_stages",
            "gauge.spark.job.num_active_tasks",
            "gauge.spark.job.num_completed_stages",
            "gauge.spark.job.num_completed_tasks",
            "gauge.spark.job.num_failed_stages",
            "gauge.spark.job.num_failed_tasks",
            "gauge.spark.job.num_skipped_stages",
            "gauge.spark.job.num_skipped_tasks",
            "gauge.spark.job.num_tasks",
            "gauge.spark.num_active_stages",
            "gauge.spark.num_running_jobs",
            "gauge.spark.stage.disk_bytes_spilled",
            "gauge.spark.stage.executor_run_time",
            "gauge.spark.stage.input_bytes",
            "gauge.spark.stage.input_records",
            "gauge.spark.stage.memory_bytes_spilled",
            "gauge.spark.stage.output_bytes",
            "gauge.spark.stage.output_records",
            "gauge.spark.streaming.avg_input_rate",
            "gauge.spark.streaming.avg_processing_time",
            "gauge.spark.streaming.avg_scheduling_delay",
            "gauge.spark.streaming.avg_total_delay",
            "gauge.spark.streaming.num_active_batches",
            "gauge.spark.streaming.num_inactive_receivers",
            "gauge.worker.coresFree",
            "gauge.worker.coresUsed",
            "gauge.worker.executors",
            "gauge.worker.memFree_MB",
            "gauge.worker.memUsed_MB"
        ]
    },
    {
        "monitorType": "collectd/hadoopjmx",
        "negated": true,
        "metricNames": [
            "counter.hadoop-namenode-gc-count",
            "counter.hadoop-namenode-gc-time",
            "counter.hadoop-namenode-rpc-total-calls",
            "counter.hadoop-namenode-total-load",
            "counter.hadoop-namenode-volume-failures",
            "gauge.hadoop-datanode-fs-capacity",
            "gauge.hadoop-datanode-fs-dfs-remaining",
            "gauge.hadoop-datanode-fs-dfs-used",
            "gauge.hadoop-datanode-jvm-heap-used",
            "gauge.hadoop-datanode-rpc-call-queue-length",
            "gauge.hadoop-datanode-rpc-open-connections",
            "gauge.hadoop-datanode-rpc-processing-avg",
            "gauge.hadoop-datanode-rpc-queue-time-avg",
            "gauge.hadoop-namenode-capacity-total",
            "gauge.hadoop-namenode-capacity-used",
            "gauge.hadoop-namenode-current-heap-used",
            "gauge.hadoop-namenode-dead-datanodes",
            "gauge.hadoop-namenode-dfs-free",
            "gauge.hadoop-namenode-live-datanodes",
            "gauge.hadoop-namenode-max-heap",
            "gauge.hadoop-namenode-percent-remaining",
            "gauge.hadoop-namenode-rpc-avg-process-time",
            "gauge.hadoop-namenode-rpc-avg-queue",
            "gauge.hadoop-namenode-under-replicated-blocks",
            "gauge.hadoop-resourceManager-allocated-vcores",
            "gauge.hadoop-resourceManager-available-vcores"
        ]
    },
    {
        "monitorType": "collectd/jenkins",
        "negated": true,
        "metricNames": [
            "gauge.jenkins.job.duration",
            "gauge.jenkins.node.executor.count.value",
            "gauge.jenkins.node.executor.in-use.value",
            "gauge.jenkins.node.health-check.score",
            "gauge.jenkins.node.health.disk.space",
            "gauge.jenkins.node.health.plugins",
            "gauge.jenkins.node.health.temporary.space",
            "gauge.jenkins.node.health.thread-deadlock",
            "gauge.jenkins.node.online.status",
            "gauge.jenkins.node.queue.size.value",
            "gauge.jenkins.node.slave.online.status",
            "gauge.jenkins.node.vm.memory.heap.usage",
            "gauge.jenkins.node.vm.memory.non-heap.used",
            "gauge.jenkins.node.vm.memory.total.used"
        ]
    },
    {
        "monitorType": "collectd/docker",
        "negated": true,
        "metricNames": [
            "blkio.io_service_bytes_recursive.read",
            "blkio.io_service_bytes_recursive.write",
            "cpu.idle",
            "cpu.usage.system",
            "cpu.usage.total",
            "memory.buffered",
            "memory.cached",
            "memory.free",
            "memory.usage.limit",
            "memory.usage.total",
            "memory.used",
            "network.usage.rx_bytes",
            "network.usage.tx_bytes"
        ]
    },
    {
        "monitorType": "kafka_consumer",
        "negated": true,
        "metricNames": [
            "kafka.consumer.bytes-consumed-rate",
            "kafka.consumer.fetch-rate",
            "kafka.consumer.fetch-size-avg",
            "kafka.consumer.records-consumed-rate",
            "kafka.consumer.records-lag-max"
        ]
    },
    {
        "monitorType": "collectd/interface",
        "negated": true,
        "metricNames": [
            "if_errors.rx",
            "if_errors.tx",
            "if_octets.rx",
            "if_octets.tx"
        ]
    },
    {
        "monitorType": "kubernetes-cluster",
        "negated": true,
        "metricNames": [
            "kubernetes.container_restart_count",
            "kubernetes.daemon_set.current_scheduled",
            "kubernetes.daemon_set.desired_scheduled",
            "kubernetes.daemon_set.misscheduled",
            "kubernetes.daemon_set.ready",
            "kubernetes.deployment.available",
            "kubernetes.deployment.desired",
            "kubernetes.pod_phase",
            "kubernetes.replica_set.available",
            "kubernetes.replica_set.desired",
            "kubernetes.replication_controller.available",
            "kubernetes.replication_controller.desired"
        ]
    },
    {
        "monitorType": "collectd/df",
        "negated": true,
        "metricNames": [
            "df_complex.free",
            "df_complex.used"
        ]
    },
    {
        "monitorType": "collectd/disk",
        "negated": true,
        "metricNames": [
            "disk_ops.read",
            "disk_ops.write"
        ]
    },
    {
        "monitorType": "collectd/genericjmx",
        "negated": true,
        "metricNames": [
            "gauge.jvm.threads.count",
            "gauge.loaded_classes",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.max",
            "jmx_memory.used",
            "total_time_in_ms.collection_time"
        ]
    },
    {
        "monitorType": "collectd/memory",
        "negated": true,
        "metricNames": [
            "memory.active",
            "memory.buffered",
            "memory.cached",
            "memory.free",
            "memory.inactive",
            "memory.slab_recl",
            "memory.slab_unrecl",
            "memory.used",
            "memory.wired"
        ]
    },
    {
        "monitorType": "collectd/elasticsearch",
        "negated": true,
        "metricNames": [
            "counter.indices.get.total",
            "counter.indices.indexing.index-total",
            "counter.indices.merges.total",
            "counter.indices.search.query-time",
            "counter.indices.search.query-total",
            "counter.indices.total.indexing.index-time",
            "counter.indices.total.indexing.index-total",
            "counter.indices.total.merges.total",
            "counter.indices.total.merges.total-time",
            "counter.indices.total.search.query-time",
            "counter.indices.total.search.query-total",
            "counter.jvm.gc.time",
            "counter.jvm.uptime",
            "counter.thread_pool.bulk.rejected",
            "counter.thread_pool.flush.rejected",
            "counter.thread_pool.generic.rejected",
            "counter.thread_pool.get.rejected",
            "counter.thread_pool.index.rejected",
            "counter.thread_pool.merge.rejected",
            "counter.thread_pool.optimize.rejected",
            "counter.thread_pool.refresh.rejected",
            "counter.thread_pool.rejected",
            "counter.thread_pool.search.rejected",
            "counter.thread_pool.snapshot.rejected",
            "gauge.cluster.active-primary-shards",
            "gauge.cluster.active-shards",
            "gauge.cluster.number-of-data_nodes",
            "gauge.cluster.number-of-nodes",
            "gauge.cluster.relocating-shards",
            "gauge.cluster.unassigned-shards",
            "gauge.indices.cache.field.size",
            "gauge.indices.cache.filter.size",
            "gauge.indices.docs.count",
            "gauge.indices.docs.deleted",
            "gauge.indices.merges.current",
            "gauge.indices.segments.count",
            "gauge.indices.store.size",
            "gauge.indices.total.docs.count",
            "gauge.indices.total.docs.deleted",
            "gauge.indices.total.fielddata.memory-size",
            "gauge.indices.total.filter-cache.memory-size",
            "gauge.indices.total.store.size",
            "gauge.jvm.mem.heap-committed",
            "gauge.jvm.mem.heap-used",
            "gauge.process.open_file_descriptors"
        ]
    },
    {
        "monitorType": "collectd/cpu",
        "negated": true,
        "metricNames": [
            "cpu.utilization"
        ]
    },
    {
        "monitorType": "host-metadata",
        "negated": true,
        "metricNames": [
            "sfxagent.hostmetadata"
        ]
    },
    {
        "monitorType": "collectd/consul",
        "negated": true,
        "metricNames": [
            "gauge.consul.*runtime.alloc_bytes",
            "gauge.consul.*runtime.heap_objects",
            "gauge.consul.*runtime.num_goroutines",
            "gauge.consul.catalog.nodes.total",
            "gauge.consul.catalog.nodes_by_service",
            "gauge.consul.catalog.services.total",
            "gauge.consul.catalog.services_by_node",
            "gauge.consul.consul.dns.domain_query*.avg",
            "gauge.consul.consul.dns.domain_query.*avg",
            "gauge.consul.consul.dns.ptr_query*.avg",
            "gauge.consul.consul.dns.ptr_query.*avg",
            "gauge.consul.consul.leader.reconcile.avg",
            "gauge.consul.consul.rpc.query",
            "gauge.consul.health.nodes.critical",
            "gauge.consul.health.nodes.passing",
            "gauge.consul.health.nodes.warning",
            "gauge.consul.health.services.critical",
            "gauge.consul.health.services.passing",
            "gauge.consul.health.services.warning",
            "gauge.consul.is_leader",
            "gauge.consul.network.dc.latency.avg",
            "gauge.consul.network.node.latency.avg",
            "gauge.consul.network.node.latency.max",
            "gauge.consul.network.node.latency.min",
            "gauge.consul.peers",
            "gauge.consul.raft.apply",
            "gauge.consul.raft.commitTime.avg",
            "gauge.consul.raft.commitTime.max",
            "gauge.consul.raft.commitTime.min",
            "gauge.consul.raft.leader.dispatchLog.avg",
            "gauge.consul.raft.leader.dispatchLog.max",
            "gauge.consul.raft.leader.dispatchLog.min",
            "gauge.consul.raft.leader.lastContact.avg",
            "gauge.consul.raft.leader.lastContact.max",
            "gauge.consul.raft.leader.lastContact.min",
            "gauge.consul.raft.replication.appendEntries.rpc*.avg",
            "gauge.consul.raft.state.candidate",
            "gauge.consul.raft.state.leader",
            "gauge.consul.runtime.alloc_bytes*",
            "gauge.consul.runtime.heap_objects*",
            "gauge.consul.runtime.num_goroutines*",
            "gauge.consul.serf.events",
            "gauge.consul.serf.member.join",
            "gauge.consul.serf.member.left",
            "gauge.consul.serf.queue.Event.avg",
            "gauge.consul.serf.queue.Event.max"
        ]
    },
    {
        "monitorType": "collectd/solr",
        "negated": true,
        "metricNames": [
            "counter.solr.http_2xx_responses",
            "counter.solr.http_4xx_responses",
            "counter.solr.http_5xx_responses",
            "counter.solr.http_requests",
            "counter.solr.node_collections_requests",
            "counter.solr.node_cores_requests",
            "counter.solr.node_metrics_requests",
            "counter.solr.node_zookeeper_requests",
            "counter.solr.search_query_requests",
            "counter.solr.update_handler_requests",
            "gauge.solr.core_deleted_docs",
            "gauge.solr.core_index_size",
            "gauge.solr.core_max_docs",
            "gauge.solr.core_num_docs",
            "gauge.solr.core_totalspace",
            "gauge.solr.core_usablespace",
            "gauge.solr.document_cache_cumulative_hitratio",
            "gauge.solr.field_value_cache_cumulative_hitratio",
            "gauge.solr.jetty_request_latency",
            "gauge.solr.jvm_gc_cms_count",
            "gauge.solr.jvm_gc_cms_time",
            "gauge.solr.jvm_gc_parnew_count",
            "gauge.solr.jvm_gc_parnew_time",
            "gauge.solr.jvm_heap_usage",
            "gauge.solr.jvm_memory_pools_Code-Cache_usage",
            "gauge.solr.jvm_memory_pools_Metaspace_usage",
            "gauge.solr.jvm_memory_pools_Par-Eden-Space_usage",
            "gauge.solr.jvm_memory_pools_Par-Survivor-Space_usage",
            "gauge.solr.jvm_total_memory",
            "gauge.solr.jvm_total_memory_used",
            "gauge.solr.query_result_cache_cumulative_hitratio",
            "gauge.solr.search_query_response",
            "gauge.solr.searcher_warmup",
            "gauge.solr.update_request_handler_response"
        ]
    },
    {
        "monitorType": "collectd/zookeeper",
        "negated": true,
        "metricNames": [
            "counter.zk_packets_received",
            "counter.zk_packets_sent",
            "gauge.zk_approximate_data_size",
            "gauge.zk_avg_latency",
            "gauge.zk_ephemerals_count",
            "gauge.zk_followers",
            "gauge.zk_max_file_descriptor_count",
            "gauge.zk_num_alive_connections",
            "gauge.zk_open_file_descriptor_count",
            "gauge.zk_synced_followers",
            "gauge.zk_watch_count",
            "gauge.zk_znode_count"
        ]
    },
    {
        "monitorType": "collectd/signalfx-metadata",
        "negated": true,
        "metricNames": [
            "cpu.utilization",
            "disk.summary_utilization",
            "disk.utilization",
            "disk_ops.total",
            "memory.utilization",
            "network.total"
        ]
    },
    {
        "monitorType": "collectd/mysql",
        "negated": true,
        "metricNames": [
            "cache_result.qcache-hits",
            "cache_result.qcache-inserts",
            "cache_result.qcache-not_cached",
            "cache_result.qcache-prunes",
            "cache_size.qcache",
            "mysql_commands.*",
            "mysql_commands.delete",
            "mysql_commands.insert",
            "mysql_commands.select",
            "mysql_commands.update",
            "mysql_commands.update*",
            "mysql_locks.immediate",
            "mysql_locks.waited",
            "mysql_octets.rx",
            "mysql_octets.tx",
            "threads.cached",
            "threads.connected"
        ]
    },
    {
        "monitorType": "collectd/haproxy",
        "negated": true,
        "metricNames": [
            "counter.server_selected_total",
            "derive.bytes_in",
            "derive.bytes_out",
            "derive.denied_request",
            "derive.denied_response",
            "derive.error_connection",
            "derive.error_request",
            "derive.error_response",
            "derive.redispatched",
            "derive.requests",
            "derive.response_2xx",
            "derive.response_4xx",
            "derive.response_5xx",
            "derive.retries",
            "gauge.connection_rate",
            "gauge.idle_pct",
            "gauge.queue_current",
            "gauge.queue_time_avg",
            "gauge.request_rate",
            "gauge.response_time_avg",
            "gauge.session_current",
            "gauge.session_rate",
            "gauge.session_rate_all",
            "gauge.session_time_avg"
        ]
    },
    {
        "monitorType": "kafka_producer",
        "negated": true,
        "metricNames": [
            "kafka.producer.byte-rate",
            "kafka.producer.compression-rate",
            "kafka.producer.io-wait-time-ns-avg",
            "kafka.producer.outgoing-byte-rate",
            "kafka.producer.record-error-rate",
            "kafka.producer.record-retry-rate",
            "kafka.producer.record-send-rate",
            "kafka.producer.request-latency-avg",
            "kafka.producer.request-rate",
            "kafka.producer.response-rate"
        ]
    },
    {
        "monitorType": "collectd/apache",
        "negated": true,
        "metricNames": [
            "apache_bytes",
            "apache_connections",
            "apache_idle_workers",
            "apache_requests",
            "apache_scoreboard.*",
            "apache_scoreboard.open"
        ]
    },
    {
        "monitorType": "collectd/etcd",
        "negated": true,
        "metricNames": [
            "counter.etcd.leader.counts.fail",
            "counter.etcd.leader.counts.success",
            "counter.etcd.self.recvappendreq.cnt",
            "counter.etcd.self.sendappendreq.cnt",
            "counter.etcd.store.compareanddelete.fail",
            "counter.etcd.store.compareanddelete.success",
            "counter.etcd.store.compareandswap.fail",
            "counter.etcd.store.compareandswap.success",
            "counter.etcd.store.create.fail",
            "counter.etcd.store.create.success",
            "counter.etcd.store.delete.fail",
            "counter.etcd.store.delete.success",
            "counter.etcd.store.expire.count",
            "counter.etcd.store.gets.fail",
            "counter.etcd.store.gets.success",
            "counter.etcd.store.sets.fail",
            "counter.etcd.store.sets.success",
            "counter.etcd.store.update.fail",
            "counter.etcd.store.update.success",
            "gauge.etcd.leader.latency.current",
            "gauge.etcd.self.recvbandwidth.rate",
            "gauge.etcd.self.recvpkg.rate",
            "gauge.etcd.self.sendbandwidth.rate",
            "gauge.etcd.self.sendpkg.rate",
            "gauge.etcd.store.watchers"
        ]
    },
    {
        "monitorType": "collectd/redis",
        "negated": true,
        "metricNames": [
            "bytes.used_memory",
            "bytes.used_memory_rss",
            "counter.commands_processed",
            "counter.evicted_keys",
            "counter.expired_keys",
            "counter.rejected_connections",
            "counter.total_net_input_bytes",
            "counter.total_net_output_bytes",
            "counter.used_cpu_sys",
            "counter.used_cpu_user",
            "derive.keyspace_hits",
            "derive.keyspace_misses",
            "gauge.blocked_clients",
            "gauge.connected_clients",
            "gauge.master_repl_offset",
            "gauge.slave_repl_offset"
        ]
    },
    {
        "monitorType": "collectd/mongodb",
        "negated": true,
        "metricNames": [
            "counter.backgroundFlushing.flushes",
            "counter.extra_info.page_faults",
            "counter.network.bytesIn",
            "counter.network.bytesOut",
            "counter.network.numRequests",
            "counter.opcounters.delete",
            "counter.opcounters.insert",
            "counter.opcounters.query",
            "counter.opcounters.update",
            "gauge.backgroundFlushing.average_ms",
            "gauge.backgroundFlushing.last_ms",
            "gauge.connections.current",
            "gauge.dataSize",
            "gauge.extra_info.heap_usage_bytes",
            "gauge.globalLock.activeClients.readers",
            "gauge.globalLock.activeClients.writers",
            "gauge.globalLock.currentQueue.readers",
            "gauge.globalLock.currentQueue.writers",
            "gauge.indexSize",
            "gauge.mem.mapped",
            "gauge.mem.resident",
            "gauge.mem.virtual",
            "gauge.objects",
            "gauge.repl.active_nodes",
            "gauge.repl.is_primary_node",
            "gauge.repl.max_lag",
            "gauge.storageSize",
            "gauge.uptime"
        ]
    },
    {
        "monitorType": "collectd/couchbase",
        "negated": true,
        "metricNames": [
            "gauge.bucket.basic.diskUsed",
            "gauge.bucket.basic.itemCount",
            "gauge.bucket.basic.opsPerSec",
            "gauge.bucket.basic.quotaPercentUsed",
            "gauge.bucket.op.cmd_get",
            "gauge.bucket.op.couch_docs_fragmentation",
            "gauge.bucket.op.couch_views_ops",
            "gauge.bucket.op.curr_connections",
            "gauge.bucket.op.ep_bg_fetched",
            "gauge.bucket.op.ep_cache_miss_rate",
            "gauge.bucket.op.ep_diskqueue_drain",
            "gauge.bucket.op.ep_diskqueue_fill",
            "gauge.bucket.op.ep_mem_high_wat",
            "gauge.bucket.op.ep_num_value_ejects",
            "gauge.bucket.op.ep_oom_errors",
            "gauge.bucket.op.ep_queue_size",
            "gauge.bucket.op.ep_tmp_oom_errors",
            "gauge.bucket.op.mem_used",
            "gauge.bucket.op.vb_active_resident_items_ratio",
            "gauge.nodes.cmd_get",
            "gauge.nodes.couch_docs_actual_disk_size",
            "gauge.nodes.couch_docs_data_size",
            "gauge.nodes.curr_items_tot",
            "gauge.nodes.ep_bg_fetched",
            "gauge.nodes.mem_used",
            "gauge.nodes.ops",
            "gauge.nodes.system.cpu_utilization_rate",
            "gauge.nodes.system.mem_free",
            "gauge.nodes.system.mem_total",
            "gauge.nodes.system.swap_total",
            "gauge.nodes.system.swap_used"
        ]
    },
    {
        "monitorType": "collectd/nginx",
        "negated": true,
        "metricNames": [
            "connections.accepted",
            "connections.handled",
            "nginx_connections.*",
            "nginx_connections.active",
            "nginx_connections.reading",
            "nginx_connections.waiting",
            "nginx_connections.writing",
            "nginx_requests"
        ]
    },
    {
        "monitorType": "collectd/load",
        "negated": true,
        "metricNames": [
            "load.longterm",
            "load.midterm",
            "load.shortterm"
        ]
    },
    {
        "monitorType": "cadvisor",
        "negated": true,
        "metricNames": [
            "container_cpu_utilization",
            "container_memory_failures_total",
            "container_memory_usage_bytes",
            "container_spec_cpu_period",
            "container_spec_cpu_quota",
            "container_spec_memory_limit_bytes",
            "machine_cpu_cores",
            "machine_memory_bytes",
            "pod_network_receive_bytes_total",
            "pod_network_receive_errors_total",
            "pod_network_transmit_bytes_total",
            "pod_network_transmit_errors_total"
        ]
    },
    {
        "monitorType": "collectd/mesos",
        "negated": true,
        "metricNames": [
            "bytes.system_mem_total_bytes",
            "counter.master_dropped_messages",
            "counter.master_tasks_error",
            "counter.master_tasks_failed",
            "counter.master_tasks_finished",
            "counter.master_tasks_lost",
            "counter.slave_tasks_failed",
            "counter.slave_tasks_finished",
            "counter.slave_tasks_lost",
            "cpu.*",
            "cpu.idle",
            "disk_ops.read",
            "disk_ops.write",
            "gauge.master_elected",
            "gauge.master_frameworks_active",
            "gauge.master_frameworks_connected",
            "gauge.master_slaves_connected",
            "gauge.master_tasks_running",
            "gauge.master_tasks_staging",
            "gauge.master_uptime_secs",
            "gauge.slave_executors_running",
            "gauge.slave_registered",
            "gauge.slave_tasks_running",
            "gauge.slave_tasks_staging",
            "gauge.slave_uptime_secs",
            "gauge.system_cpus_total",
            "memory.free",
            "memory.used",
            "percent.master_cpus_percent",
            "percent.master_disk_percent",
            "percent.master_mem_percent",
            "percent.slave_cpus_percent",
            "percent.slave_disk_percent",
            "percent.slave_mem_percent"
        ]
    },
    {
        "monitorType": "collectd/cassandra",
        "negated": true,
        "metricNames": [
            "counter.cassandra.ClientRequest.RangeSlice.Latency.Count",
            "counter.cassandra.ClientRequest.RangeSlice.Timeouts.Count",
            "counter.cassandra.ClientRequest.RangeSlice.Unavailables.Count",
            "counter.cassandra.ClientRequest.Read.Latency.Count",
            "counter.cassandra.ClientRequest.Read.Timeouts.Count",
            "counter.cassandra.ClientRequest.Read.Unavailables.Count",
            "counter.cassandra.ClientRequest.Write.Latency.Count",
            "counter.cassandra.ClientRequest.Write.Timeouts.Count",
            "counter.cassandra.ClientRequest.Write.Unavailables.Count",
            "cpu.idle",
            "gauge.cassandra.ClientRequest.RangeSlice.Latency.99thPercentile",
            "gauge.cassandra.ClientRequest.Read.Latency.50thPercentile",
            "gauge.cassandra.ClientRequest.Read.Latency.99thPercentile",
            "gauge.cassandra.ClientRequest.Read.Latency.Max",
            "gauge.cassandra.ClientRequest.Write.Latency.50thPercentile",
            "gauge.cassandra.ClientRequest.Write.Latency.99thPercentile",
            "gauge.cassandra.ClientRequest.Write.Latency.Max",
            "gauge.cassandra.Compaction.PendingTasks.Value",
            "gauge.cassandra.Storage.Load.Count",
            "gauge.cassandra.Storage.TotalHintsInProgress.Count",
            "if_octets.rx",
            "if_octets.tx"
        ]
    },
    {
        "monitorType": "collectd/memcached",
        "negated": true,
        "metricNames": [
            "df.cache.free",
            "df.cache.used",
            "memcached_command.get",
            "memcached_command.set",
            "memcached_connections.current",
            "memcached_items.current",
            "memcached_octets.rx",
            "memcached_octets.tx",
            "memcached_ops.evictions",
            "memcached_ops.hits",
            "memcached_ops.misses"
        ]
    },
    {
        "monitorType": "collectd/marathon",
        "negated": true,
        "metricNames": [
            "gauge.jvm.memory.total.used",
            "gauge.jvm.threads.count",
            "gauge.marathon.app.cpu.allocated",
            "gauge.marathon.app.cpu.allocated.per.instance",
            "gauge.marathon.app.disk.allocated",
            "gauge.marathon.app.disk.allocated.per.instance",
            "gauge.marathon.app.instances.total",
            "gauge.marathon.app.memory.allocated",
            "gauge.marathon.app.memory.allocated.per.instance",
            "gauge.marathon.app.tasks.running",
            "gauge.marathon.app.tasks.staged",
            "gauge.marathon.app.tasks.unhealthy",
            "gauge.marathon.task.healthchecks.failing.total",
            "gauge.marathon.task.healthchecks.passing.total",
            "gauge.service.mesosphere.marathon.uptime"
        ]
    },
    {
        "monitorType": "collectd/hadoop",
        "negated": true,
        "metricNames": [
            "gauge.hadoop.cluster.metrics.active_nodes",
            "gauge.hadoop.cluster.metrics.allocated_mb",
            "gauge.hadoop.cluster.metrics.allocated_virtual_cores",
            "gauge.hadoop.cluster.metrics.apps_completed",
            "gauge.hadoop.cluster.metrics.apps_failed",
            "gauge.hadoop.cluster.metrics.apps_running",
            "gauge.hadoop.cluster.metrics.apps_submitted",
            "gauge.hadoop.cluster.metrics.available_mb",
            "gauge.hadoop.cluster.metrics.available_virtual_cores",
            "gauge.hadoop.cluster.metrics.decommissioned_nodes",
            "gauge.hadoop.cluster.metrics.lost_nodes",
            "gauge.hadoop.cluster.metrics.rebooted_nodes",
            "gauge.hadoop.cluster.metrics.reserved_mb",
            "gauge.hadoop.cluster.metrics.reserved_virtual_cores",
            "gauge.hadoop.cluster.metrics.total_mb",
            "gauge.hadoop.cluster.metrics.total_virtual_cores",
            "gauge.hadoop.cluster.metrics.unhealthy_nodes",
            "gauge.hadoop.mapreduce.job.elapsedTime",
            "gauge.hadoop.mapreduce.job.failedMapAttempts",
            "gauge.hadoop.mapreduce.job.failedReduceAttempts",
            "gauge.hadoop.mapreduce.job.mapsTotal",
            "gauge.hadoop.mapreduce.job.successfulMapAttempts",
            "gauge.hadoop.mapreduce.job.successfulReduceAttempts",
            "gauge.hadoop.resource.manager.apps.allocatedMB",
            "gauge.hadoop.resource.manager.apps.allocatedVCores",
            "gauge.hadoop.resource.manager.apps.clusterUsagePercentage",
            "gauge.hadoop.resource.manager.apps.memorySeconds",
            "gauge.hadoop.resource.manager.apps.priority",
            "gauge.hadoop.resource.manager.apps.progress",
            "gauge.hadoop.resource.manager.apps.queueUsagePercentage",
            "gauge.hadoop.resource.manager.apps.runningContainers",
            "gauge.hadoop.resource.manager.apps.vcoreSeconds",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.usedCapacity"
        ]
    },
    {
        "monitorType": "collectd/rabbitmq",
        "negated": true,
        "metricNames": [
            "counter.exchange.message_stats.publish_in",
            "counter.queue.message_stats.deliver",
            "gauge.channel.number",
            "gauge.node.disk_free",
            "gauge.node.disk_free_limit",
            "gauge.node.fd_total",
            "gauge.node.fd_used",
            "gauge.node.io_read_avg_time",
            "gauge.node.io_sync_avg_time",
            "gauge.node.io_write_avg_time",
            "gauge.node.mem_limit",
            "gauge.node.mem_used",
            "gauge.node.uptime",
            "gauge.queue.consumers",
            "gauge.queue.memory",
            "gauge.queue.messages_ready"
        ]
    },
    {
        "monitorType": "collectd/vmem",
        "negated": true,
        "metricNames": [
            "vmpage_io.swap.in",
            "vmpage_io.swap.out"
        ]
    },
    {
        "monitorType": "collectd/kafka",
        "negated": true,
        "metricNames": [
            "counter.kafka-bytes-in",
            "counter.kafka-bytes-out",
            "counter.kafka-isr-expands",
            "counter.kafka-isr-shrinks",
            "counter.kafka-messages-in",
            "counter.kafka-unclean-elections-rate",
            "counter.kafka.fetch-consumer.total-time.count",
            "counter.kafka.produce.total-time.count",
            "counter.kafka.zk.request-latency.count",
            "gauge.kafka-active-controllers",
            "gauge.kafka-max-lag",
            "gauge.kafka-offline-partitions-count",
            "gauge.kafka-request-queue",
            "gauge.kafka-underreplicated-partitions",
            "gauge.kafka.consumer.bytes-consumed-rate",
            "gauge.kafka.consumer.fetch-rate",
            "gauge.kafka.consumer.fetch-size-avg",
            "gauge.kafka.consumer.records-consumed-rate",
            "gauge.kafka.consumer.records-lag-max",
            "gauge.kafka.fetch-consumer.total-time.99th",
            "gauge.kafka.fetch-consumer.total-time.median",
            "gauge.kafka.fetch-follower.total-time.99th",
            "gauge.kafka.fetch-follower.total-time.median",
            "gauge.kafka.produce.total-time.99th",
            "gauge.kafka.produce.total-time.median",
            "gauge.kafka.producer.byte-rate",
            "gauge.kafka.producer.compression-rate",
            "gauge.kafka.producer.io-wait-time-ns-avg",
            "gauge.kafka.producer.outgoing-byte-rate",
            "gauge.kafka.producer.record-error-rate",
            "gauge.kafka.producer.record-retry-rate",
            "gauge.kafka.producer.record-send-rate",
            "gauge.kafka.producer.request-latency-avg",
            "gauge.kafka.producer.request-rate",
            "gauge.kafka.producer.response-rate",
            "gauge.kafka.zk.request-latency.99th",
            "gauge.kafka.zk.request-latency.median",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.init",
            "jmx_memory.max",
            "jmx_memory.used",
            "message.age.maximum",
            "total_time_in_ms.collection_time"
        ]
    },
    {
        "monitorType": "collectd/kong",
        "negated": true,
        "metricNames": [
            "counter.kong.kong.latency",
            "counter.kong.requests.count",
            "counter.kong.requests.latency",
            "counter.kong.requests.size",
            "counter.kong.responses.count",
            "counter.kong.responses.size",
            "counter.kong.upstream.latency",
            "gauge.kong.connections.active",
            "gauge.kong.connections.reading",
            "gauge.kong.connections.waiting",
            "gauge.kong.connections.writing",
            "gauge.kong.database.reachable"
        ]
    },
    {
        "monitorType": "collectd/postgresql",
        "negated": true,
        "metricNames": [
            "pg_blks.heap_hit",
            "pg_blks.heap_read",
            "pg_blks.idx_hit",
            "pg_blks.idx_read",
            "pg_db_size",
            "pg_n_tup_c.del",
            "pg_n_tup_c.ins",
            "pg_n_tup_c.ins-*",
            "pg_n_tup_c.upd",
            "pg_n_tup_g.live",
            "pg_numbackends",
            "pg_scan.idx",
            "pg_scan.idx_tup_fetch",
            "pg_scan.seq",
            "pg_scan.seq_tup_read",
            "pg_xact.commit",
            "pg_xact.rollback"
        ]
    },
    {
        "monitorType": "collectd/activemq",
        "negated": true,
        "metricNames": [
            "counter.amq.TotalConnectionsCount",
            "gauge.amq.TotalConsumerCount",
            "gauge.amq.TotalEnqueueCount",
            "gauge.amq.TotalMessageCount",
            "gauge.amq.TotalProducerCount",
            "gauge.amq.queue.AverageEnqueueTime",
            "gauge.amq.queue.ConsumerCount",
            "gauge.amq.queue.DequeueCount",
            "gauge.amq.queue.EnqueueCount",
            "gauge.amq.queue.ExpiredCount",
            "gauge.amq.queue.InFlightCount",
            "gauge.amq.queue.ProducerCount",
            "gauge.amq.queue.QueueSize",
            "gauge.amq.topic.AverageEnqueueTime",
            "gauge.amq.topic.ConsumerCount",
            "gauge.amq.topic.EnqueueCount",
            "gauge.amq.topic.ExpiredCount",
            "gauge.amq.topic.InFlightCount",
            "gauge.amq.topic.ProducerCount",
            "gauge.amq.topic.QueueSize",
            "message.age.average",
            "message.age.maximum"
        ]
    },
    {
        "monitorType": "collectd/openstack",
        "negated": true,
        "metricNames": [
            "counter.openstack.nova.server.cpu*",
            "counter.openstack.nova.server.rx",
            "counter.openstack.nova.server.rx_packets",
            "counter.openstack.nova.server.tx",
            "counter.openstack.nova.server.tx_packets",
            "gauge.openstack.cinder.limit.maxTotalVolumeGigabytes",
            "gauge.openstack.cinder.limit.maxTotalVolumes",
            "gauge.openstack.cinder.limit.totalGigabytesUsed",
            "gauge.openstack.cinder.limit.totalVolumesUsed",
            "gauge.openstack.neutron.floatingip.count",
            "gauge.openstack.neutron.network.count",
            "gauge.openstack.neutron.router.count",
            "gauge.openstack.neutron.securitygroup.count",
            "gauge.openstack.neutron.subnet.count",
            "gauge.openstack.nova.hypervisor.disk_available_least",
            "gauge.openstack.nova.hypervisor.free_disk_gb",
            "gauge.openstack.nova.hypervisor.free_ram_mb",
            "gauge.openstack.nova.hypervisor.load_average_15m",
            "gauge.openstack.nova.hypervisor.load_average_1m",
            "gauge.openstack.nova.hypervisor.load_average_5m",
            "gauge.openstack.nova.hypervisor.local_gb",
            "gauge.openstack.nova.hypervisor.local_gb_used",
            "gauge.openstack.nova.hypervisor.memory_mb",
            "gauge.openstack.nova.hypervisor.memory_mb_used",
            "gauge.openstack.nova.hypervisor.running_vms",
            "gauge.openstack.nova.hypervisor.vcpus",
            "gauge.openstack.nova.hypervisor.vcpus_used",
            "gauge.openstack.nova.limit.maxSecurityGroups",
            "gauge.openstack.nova.limit.maxTotalCores",
            "gauge.openstack.nova.limit.maxTotalFloatingIps",
            "gauge.openstack.nova.limit.maxTotalInstances",
            "gauge.openstack.nova.limit.maxTotalRAMSize",
            "gauge.openstack.nova.limit.totalCoresUsed",
            "gauge.openstack.nova.limit.totalInstancesUsed",
            "gauge.openstack.nova.limit.totalRAMUsed",
            "gauge.openstack.nova.server.memory",
            "gauge.openstack.nova.server.memory-actual",
            "gauge.openstack.nova.server.memory-rss",
            "gauge.openstack.nova.server.rx_drop",
            "gauge.openstack.nova.server.tx_drop",
            "gauge.openstack.nova.server.vda_errors",
            "gauge.openstack.nova.server.vda_read",
            "gauge.openstack.nova.server.vda_read_req",
            "gauge.openstack.nova.server.vda_write",
            "gauge.openstack.nova.server.vda_write_req"
        ]
    }
]
