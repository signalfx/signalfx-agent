# Filtering

You may wish to filter out certain datapoints or properties to prevent them
from ever leaving the agent. Filtering can be useful to reduce clutter in
charts without having to resort to filtering in the UI.  If possible, it is
preferable to prevent the datapoints and properties you want to omit from being
generated by a monitor in the first place, as this will reduce CPU and memory
usage of the agent, but sometimes this is not feasible.

## Monitor-level filtering

It is usually best to apply datapoint filters at the monitor level where the
datapoints are being generated.  You can do this with the `datapointsToExclude`
option available on [every monitor
configuration](./monitor-config.md#common-configuration).  This option accepts
a list of filter items that can specify the `metricName(s)` and/or `dimensions`
to match on datapoints to determine whether to drop them.  For example:

```
monitors:
   # Prometheus node exporter scraper
 - type: promtheus-exporter
   host: 127.0.0.1
   port: 9090
   datapointsToExclude:
    # This filter causes only the 'free bytes' and 'readonly' filesystem
    # metrics to be sent, excluding all other metrics that start with
    # 'node_filesystem_'.
    - metricNames:
       - node_filesystem_*
       - '!node_filesystem_free_bytes'
       - '!node_filesystem_readonly'

    # This filter causes all network metrics, *except* for those about eth0, to
    # be dropped.
    - metricName: node_network_*
      dimensions:
        interface: [ '*', '!eth0' ]

    # This filter causes all datapoints that start with 'node_disk_' that have
    a 'device' dimension that starts with 'sr' to be dropped.
    - metricName: node_disk_*
      dimensions:
        device: sr*
```

The behavior is that datapoints are processed through each filter item in the
list under `datapointsToExclude` and if any *one* of those filters matches, the
datapoint is dropped (i.e. the filters are ORed together).  Within a single
item, for a datapoint to match, it must have a matching metric name (if
`metricName` or `metricNames` is provided) and any dimensions specified in the
filter must match dimensions on the datapoint.  There can be extra dimensions
on the datapoint that will not affect matching.

The negation of items in either `metricNames` or a `dimensions` map value list
item will serve to override (and thus reinclude) only other already excluded
items from that same list.  Thus, if you want to do "whitelisting" of metric
names or dimension values.hi, you can provide a list like `[ '*',
'!whitelisted1', '!whitelisted2' ]` to exclude everything but those two
metrics.  This, along with the regex and glob capabilities, is explained more
in [Overridable Filters](#overridable-filters).

If there is some monitor configuration option that already prevents the
datapoints from being generated in the first place, that is the most ideal,
since it reduces CPU consumption by the agent by avoiding the creation of the
datapoints in the first place.

## Global datapoint filtering

Filters can be specified with the `metricsToExclude` config at the top-level of
the agent config.  This parameter should be a list of filters that specify the
metric name and/or dimensions to match on.  These filters should be used
sparingly, as every single datapoint emitted by monitors must be processed by
these filters, resulting in higher CPU usage.

Metric names and dimension values can be either globbed (i.e. where `*` is a
wildcard for zero or more characters, and `?` is a wildcard for a single
character) or specified as a Go-compatible regular expression (the value must
be surrounded by `/` to be considered a regex).

You can limit the scope of a filter to a specific monitor type with the
`monitorType` option in the filter item.  This value matches the monitor type
used in the monitor config.  This is very useful when trying to filter on a
heavily overloaded dimension, such as the `plugin_instance` dimension that most
collectd-based monitors emit.

Sometimes it is easier to whitelist the metrics you want to allow through.
You can do this by setting the `negated` option to `true` on a filter item.
This makes all metric name and dimension matching negated so that only
datapoints with that name or dimension are allowed through.  You would also
use this option to specify custom metrics that you want to send to SignalFx.
The `monitorType` option is never negated, and always serves to scope a filter
item to the specified monitor type, if given. In the case where multiple filters
overlap, they will be combined by the agent. If metrics are matched by two filters
which have opposite negation, the agent will favor exclusion.

Examples:

```yaml
  # If a metric matches any one of these filters it will be excluded.
  metricsToExclude:
    # Excludes all metrics that start with 'container_spec_memory_'
    - metricName: container_spec_memory_*

    # Excludes multiple metric names in a single filter
    - metricNames:
      - container_start_time_seconds
      - container_tasks_state

    # Excludes networking metrics about flannel interfaces that match the
    # pattern (e.g. 'flannel.1', 'flannel.2', etc.)
    - metricName: pod_network_*
      dimensions:
        interface: /flannel\.\d/

    # This is a metric from collectd.  All instances of it will be suppressed.
    - metricName: vmpage_io.swap.in

    # This filter will only match against datapoints from the collectd/df
    # monitor
    - dimensions:
        plugin_instance: dm-*
      monitorType: collectd/df

    # This only allows cpu and memory metrics from the docker monitor to come
    # through.  Note that the monitorType is never negated, and metrics from
    # other monitors will not be excluded since this filter is scoped to a
    # single monitor.
    - metricNames:
      - cpu*
      - memory*
      monitorType: collectd/docker
      negated: true

    # This indicates that you want to monitor the custom metrics
    # gauge.cluster.status and gauge.thread_pool.active for the
    # elasticsearch monitor.
    - metricNames:
      - gauge.cluster.status
      - gauge.thread_pool.active
      monitorType: collectd/elasticsearch
      negated: true

    # This will be automatically merged with the above filter to produce one
    # whitelist filter on three metric names for elasticsearch
    - metricNames:
      - gauge.thread_pool.inactive
      monitorType: collectd/elasticsearch
      negated: true

    # This will override the above filter, exclusion is always favored
    - metricNames:
      - gauge.thread_pool.inactive
      monitorType: collectd/elasticsearch
```

### Inclusion filtering
Sometimes it is necessary to specify metrics that you want to include even when
they would be otherwise excluded by filters in `metricsToExclude`.  Therefore,
there is the `metricsToInclude` option that should be a list of the same type
of metric filters used in `metricsToExclude`.

The main difference between a filter in `metricsToExclude` that has `negated:
true` and a filter in `metricsToInclude` is that the filter in
`metricsToExclude` will actually exclude metrics that don't match the filter,
whereas the filter in `metricsToInclude` will never exclude anything, but only
override the exclusion in `metricsToExclude`.

For example:

```yaml
  metricsToExclude:
   - metricNames:
     - request_size
     - response_size
  metricsToInclude:
   # This allows through datapoints with the name `request_size` that have the
   # specified dimension but still excludes other datapoints without those
   # dimensions.  All `response_size` metrics are still excluded.
   - metricName: request_size
     dimensions:
       app: bigapp
```

This can be useful for overridding the built-in whitelist for metrics.



## Property filtering
Property filtering behaves very similar to datapoint filtering.
Filters can be specified with the `propertiesToExclude` config of the agent
config. This parameter should be a list of filters that specify which
properties to exclude by defining any or all of the following: `dimensionName`,
`dimensionValue`, `propertyName`, `propertyValues`. Each filter from the list
will be applied to all properties the agent emits, so be careful when scoping.

Properties and dimensions (both names and values) can be either
globbed (i.e. where `*` is a wildcard for zero or more characters, and `?` is
a wildcard for a single character) or specified as a Go-compatible regular
expression (the value must be surrounded by `/` to be considered a regex).

Sometimes it is easier to whitelist the properties you want to allow through,
and not allow any others.
You can do this by prefixing any config value with `!`, which will negate the
matching value. This can be applied to any of the config options.
See examples below.


Examples:
```yaml
  # If a property matches any one of these filters it will be excluded
  propertiesToExclude:
    # Exclude 'pod-template-hash' from syncing to any dimension
    - propertyName: pod-template-hash

    # Do not sync any properties to 'kubernetes_pod_uid'
    - dimensionName: kubernetes_pod_uid

    # Exclude 'pod-template-hash'  from syncing on dimension 'kubernetes_pod_uid'
    - propertyName: pod-template-hash
      dimensionName: kubernetes_pod_uid

    # Exclude all properties except 'pod-template-hash' on 'kubernetes_pod_uid'
    -  propertyName: "!pod-template-hash"
       dimensionName: kubernetes_pod_uid

    # Do not sync any property beginning with 'load_balancer' to 'kubernetes_pod_uid'
    - propertyName: "load_balancer*"
      dimensionName: kubernetes_pod_uid

    # Do not sync any property name 'pod-template-hash' beginning with value '123'
    # on a dimension name `kubernetes_pod_uid` with a dimension value starting
    # with 'abc'
    - propertyName: pod-template-hash
      propertyValue: "123*"
      dimensionName: kubernetes_pod_uid
      dimensionValue: "abc*"
```

## Overridable filters

Some config options for monitors and observers support comprehensive filtering
that accepts a list of strings that define the filter.  These config options
support string literals, globbed values, and regular expressions.  Filter items
can be prefixed by `!` to override previously excluded values (which can then
also be literal values, globbed values, or regular expressions).

Regular expressions are processed by the [Golang regexp
package](https://golang.org/pkg/regexp/syntax/), so the syntax can be anything
supported by that.  Regular expressions must be surrounded by `/` on both ends
of the string to be interpreted as a regexp. Negation (`!`) comes before the
first `/` since it is not part of the regexp pattern itself.

Globs can be anything with `*` (zero or more characters) or `?` (zero or one
character), along with a few other features.  The glob processor library used
is [demonstrated here](https://github.com/gobwas/glob#example).

Examples:

```yaml
 # Would match the values "a" and "b" and nothing else
 filter:
  - a
  - b

 # Would match all values except for "a"
 filter:
  - "*"
  - "!a"

 # Would match all values matching the pattern disk_* except for "disk_tmp"
 filter:
  - "/disk_.*/"
  - "!disk_tmp"

```
