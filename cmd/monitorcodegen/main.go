package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"text/template"

	"github.com/signalfx/signalfx-agent/internal/monitors"
	log "github.com/sirupsen/logrus"
)

const genMetadata = "genmetadata.go"

var tmpl = `// Code generated by monitor-code-gen. DO NOT EDIT.

package {{.goPackage}}

import (
{{if .metrics}}
	"github.com/signalfx/golib/datapoint"
{{- end}}
	"github.com/signalfx/signalfx-agent/internal/monitors"
)

{{if (len .monitors) eq 1 }}
const monitorType = "{{(index .monitors 0).MonitorType}}"
{{end}}

{{with .groupMetricsMap}}
const (
{{- range $group, $metrics := . }}
	{{(printf "group.%s" $group) | formatVariable}} = "{{$group}}"
{{- end}}
)
{{end}}

var groupSet = map[string]bool {
{{- range $group, $metrics := .groupMetricsMap}}
	{{(printf "group.%s" $group) | formatVariable}}: true,
{{- end}}
}

{{with .metrics}}
const (
{{- range .}}
	{{.Name | formatVariable}} = "{{.Name}}"
{{- with .Alias}}
	{{. | formatVariable}} = "{{.}}"
{{- end}}
{{- end}}
)
{{end}}

var metricSet = map[string]monitors.MetricInfo {
{{- range .metrics}}
	{{.Name | formatVariable}}: {Type: {{.Type | convertMetricType}}},
{{- end}}
}

var includedMetrics = map[string]bool {
{{- range .metrics}}
{{- if .Included}}
	{{.Name | formatVariable}}: true,
{{- with .Alias}}
	{{. | formatVariable}}: true,
{{- end}}
{{- end}}
{{- end}}
}

var groupMetricsMap = map[string][]string {
{{- range $group, $metrics := .groupMetricsMap}}
	{{(printf "group.%s" $group) | formatVariable}}: []string {
		{{- range $metrics}}
		{{. | formatVariable}},
		{{- end}}
	},
{{- end}}
}

{{range .monitors}}
var {{if gt (len $.monitors) 1 -}}
{{- (printf "%s.%s" .MonitorType "monitorMetadata") | formatVariable -}}
{{else -}}
monitorMetadata{{end}} = monitors.Metadata{
	MonitorType: "{{.MonitorType}}",
	IncludedMetrics: includedMetrics,
	Metrics: metricSet,
	MetricsExhaustive: {{.MetricsExhaustive}},
	Groups: groupSet,
	GroupMetricsMap: groupMetricsMap,
	SendAll: {{ .SendAll }},
}
{{end}}
`

// shouldRegenerate determines whether the metadata file needs regenerated based on its existence and timestamps.
func shouldRegenerate(pkg *monitors.PackageMetadata) (bool, error) {
	generatedMetadata := filepath.Join(pkg.PackagePath, genMetadata)

	var generatorStat os.FileInfo
	var statMetadataYaml os.FileInfo

	if path, err := os.Executable(); err != nil {
		return false, err
	} else if generatorStat, err = os.Stat(path); err != nil {
		return false, err
	} else if statMetadataYaml, err = os.Stat(pkg.Path); err != nil {
		return false, fmt.Errorf("unable to stat %s", pkg.Path)
	}

	statMetadataGenerated, err := os.Stat(generatedMetadata)

	if err != nil {
		// generatedMetadata.go does not exist.
		if os.IsNotExist(err) {
			return true, nil
		}
		return false, fmt.Errorf("unable to stat %s", generatedMetadata)
	}

	// There's an existing generatedMetadata.go so check timestamps.
	return statMetadataYaml.ModTime().After(statMetadataGenerated.ModTime()) ||
		generatorStat.ModTime().After(statMetadataGenerated.ModTime()), nil
}

func generate(force bool) error {
	pkgs, err := monitors.CollectMetadata("internal/monitors")

	if err != nil {
		return err
	}

	tmpl, err := template.New("").Option("missingkey=error").Funcs(template.FuncMap{
		"formatVariable": formatVariable,
		"convertMetricType": func(metricType string) (output string, err error) {
			switch metricType {
			case "gauge":
				return "datapoint.Gauge", nil
			case "counter":
				return "datapoint.Count", nil
			case "cumulative":
				return "datapoint.Counter", nil
			default:
				return "", fmt.Errorf("unknown metric type %s", metricType)
			}
		},
	}).Parse(tmpl)

	if err != nil {
		return err
	}

	for i := range pkgs {
		pkg := pkgs[i]
		if !force {
			if regenerate, err := shouldRegenerate(&pkg); err != nil {
				return err
			} else if !regenerate {
				continue
			}
		}

		// Go package name can be overridden but default to the directory name.
		var goPackage string
		if pkg.GoPackage != nil {
			goPackage = *pkg.GoPackage
		} else {
			goPackage = filepath.Base(pkg.PackagePath)
		}

		writer := &bytes.Buffer{}
		groupMetricsMap := map[string][]string{}
		metrics := map[string]monitors.MetricMetadata{}

		for _, mon := range pkg.Monitors {
			for _, metric := range mon.Metrics {
				if existingMetric, ok := metrics[metric.Name]; ok {
					if existingMetric.Type != metric.Type {
						return fmt.Errorf("existing metric %v does not have the same metric type as %v", existingMetric,
							metric)
					}
				} else {
					metrics[metric.Name] = metric
				}

				if metric.Group != nil {
					metrics := []string{metric.Name}
					if metric.Alias != "" {
						metrics = append(metrics, metric.Alias)
					}
					groupMetricsMap[*metric.Group] = append(groupMetricsMap[*metric.Group], metrics...)
				}
			}
		}

		if err := tmpl.Execute(writer, map[string]interface{}{
			"metrics":         metrics,
			"monitors":        pkg.Monitors,
			"goPackage":       goPackage,
			"groupMetricsMap": groupMetricsMap,
		}); err != nil {
			return fmt.Errorf("failed executing template for %s: %s", pkg.Path, err)
		}

		formatted, err := format.Source(writer.Bytes())
		if err != nil {
			return err
		}

		if err := ioutil.WriteFile(filepath.Join(pkg.PackagePath, genMetadata), formatted,
			0644); err != nil {
			return err
		}
	}

	return nil
}

func main() {
	flags := flag.NewFlagSet(os.Args[0], flag.ExitOnError)
	force := flags.Bool("force", false, "set to force generate files")
	_ = flags.Parse(os.Args[1:])

	if err := generate(*force); err != nil {
		log.Fatal(err)
	}
}
