{
  "GenericMonitorConfig": {
    "name": "MonitorConfig",
    "doc": "MonitorConfig is used to configure monitor instances.  One instance of MonitorConfig may be used to configure multiple monitor instances.  If a monitor's discovery rule does not match any discovered services, the monitor will not run.",
    "package": "internal/core/config",
    "fields": [
      {
        "yamlName": "type",
        "doc": "The type of the monitor",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "discoveryRule",
        "doc": "The rule used to match up this configuration with a discovered endpoint. If blank, the configuration will be run immediately when the agent is started.  If multiple endpoints match this rule, multiple instances of the monitor type will be created with the same configuration (except different host/port).",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "extraDimensions",
        "doc": "A set of extra dimensions (key:value pairs) to include on datapoints emitted by the monitor(s) created from this configuration. To specify metrics from this monitor should be high-resolution, add the dimension `sf_hires:1`",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "intervalSeconds",
        "doc": "The interval (in seconds) at which to emit datapoints from the monitor(s) created by this configuration.  If not set (or set to 0), the global agent intervalSeconds config option will be used instead.",
        "default": 0,
        "required": false,
        "type": "int",
        "elementKind": ""
      },
      {
        "yamlName": "solo",
        "doc": "If one or more configurations have this set to true, only those configurations will be considered -- useful for testing",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "metricsToExclude",
        "doc": "A list of metric filters",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against, OR'd together",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "disableHostDimensions",
        "doc": "Some monitors pull metrics from services not running on the same host and should not get the host-specific dimensions set on them (e.g. `host`, `AWSUniqueId`, etc).  Setting this to `true` causes those dimensions to be omitted.  You can disable this globally with the `disableHostDimensions` option on the top level of the config.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "disableEndpointDimensions",
        "doc": "This can be set to true if you don't want to include the dimensions that are specific to the endpoint that was discovered by an observer.  This is useful when you have an endpoint whose identity is not particularly important since it acts largely as a proxy or adapter for other metrics.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      }
    ]
  },
  "GenericObserverConfig": {
    "name": "ObserverConfig",
    "doc": "ObserverConfig holds the configuration for an observer",
    "package": "internal/core/config",
    "fields": [
      {
        "yamlName": "type",
        "doc": "The type of the observer",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      }
    ]
  },
  "Monitors": [
    {
      "name": "CHTTPConfig",
      "doc": " This monitor pulls metrics directly from cadvisor, which\nconventionally runs on port 4194, but can be configured to anything.  If you\nare running on Kubernetes, consider the [kubelet-stats](./kubelet-stats.md)\nmonitor because many K8s nodes do not expose cAdvisor on a network port,\neven though they are running it within Kubelet.\n\nIf you are running containers with Docker, there is a fair amount of\nduplication with the `collectd/docker` monitor in terms of the metrics sent\n(under distinct metric names) so you may want to consider not enabling the\nDocker monitor in a K8s environment, or else use filtering to whitelist only\ncertain metrics.  Note that this will cause the built-in Docker dashboards\nto be blank, but container metrics will be available on the Kubernetes\ndashboards instead.\n",
      "package": "internal/monitors/cadvisor",
      "fields": [
        {
          "yamlName": "cadvisorURL",
          "doc": "Where to find cAdvisor",
          "default": "http://localhost:4194",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "cadvisor",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": [
        {
          "name": "container_id",
          "description": "The ID of the running container"
        },
        {
          "name": "container_image",
          "description": "The container image name"
        },
        {
          "name": "container_name",
          "description": "The container's name as it appears in the pod spec, the same as container_spec_name but retained for backwards compatibility."
        },
        {
          "name": "container_spec_name",
          "description": "The container's name as it appears in the pod spec"
        },
        {
          "name": "kubernetes_namespace",
          "description": "The K8s namespace the container is part of"
        },
        {
          "name": "kubernetes_pod_name",
          "description": "The pod instance under which this container runs"
        },
        {
          "name": "kubernetes_pod_uid",
          "description": "The UID of the pod instance under which this container runs"
        }
      ],
      "metrics": [
        {
          "name": "container_cpu_cfs_periods",
          "type": "counter",
          "description": "Total number of elapsed CFS enforcement intervals"
        },
        {
          "name": "container_cpu_cfs_throttled_periods",
          "type": "counter",
          "description": "Total number of times tasks in the cgroup have been throttled"
        },
        {
          "name": "container_cpu_cfs_throttled_time",
          "type": "counter",
          "description": "Total time duration, in nanoseconds, for which tasks in the cgroup have been throttled"
        },
        {
          "name": "container_cpu_percent",
          "type": "counter",
          "description": "Cumulative cpu utilization as a percentage of the total host CPU available.  This metric is equivalent to `container_cpu_utilization` / \u003c# of CPUs/cores on host\u003e."
        },
        {
          "name": "container_cpu_system_seconds_total",
          "type": "counter",
          "description": "Cumulative system cpu time consumed in nanoseconds"
        },
        {
          "name": "container_cpu_usage_seconds_total",
          "type": "counter",
          "description": "Cumulative cpu time consumed per cpu in nanoseconds"
        },
        {
          "name": "container_cpu_user_seconds_total",
          "type": "counter",
          "description": "Cumulative user cpu time consumed in nanoseconds"
        },
        {
          "name": "container_cpu_utilization",
          "type": "counter",
          "description": "Cumulative cpu utilization in percentages.  This is equivalent to \"centicores\", or hundreths of CPU cores consumed.  This metric is **NOT** normalized by the total # of cores on the system."
        },
        {
          "name": "container_fs_io_current",
          "type": "gauge",
          "description": "Number of I/Os currently in progress"
        },
        {
          "name": "container_fs_io_time_seconds_total",
          "type": "counter",
          "description": "Cumulative count of seconds spent doing I/Os"
        },
        {
          "name": "container_fs_io_time_weighted_seconds_total",
          "type": "counter",
          "description": "Cumulative weighted I/O time in seconds"
        },
        {
          "name": "container_fs_limit_bytes",
          "type": "gauge",
          "description": "Number of bytes that the container may occupy on this filesystem"
        },
        {
          "name": "container_fs_read_seconds_total",
          "type": "counter",
          "description": "Cumulative count of seconds spent reading"
        },
        {
          "name": "container_fs_reads_merged_total",
          "type": "counter",
          "description": "Cumulative count of reads merged"
        },
        {
          "name": "container_fs_reads_total",
          "type": "counter",
          "description": "Cumulative count of reads completed"
        },
        {
          "name": "container_fs_sector_reads_total",
          "type": "counter",
          "description": "Cumulative count of sector reads completed"
        },
        {
          "name": "container_fs_sector_writes_total",
          "type": "counter",
          "description": "Cumulative count of sector writes completed"
        },
        {
          "name": "container_fs_usage_bytes",
          "type": "gauge",
          "description": "Number of bytes that are consumed by the container on this filesystem"
        },
        {
          "name": "container_fs_write_seconds_total",
          "type": "counter",
          "description": "Cumulative count of seconds spent writing"
        },
        {
          "name": "container_fs_writes_merged_total",
          "type": "counter",
          "description": "Cumulative count of writes merged"
        },
        {
          "name": "container_fs_writes_total",
          "type": "counter",
          "description": "Cumulative count of writes completed"
        },
        {
          "name": "container_last_seen",
          "type": "gauge",
          "description": "Last time a container was seen by the exporter"
        },
        {
          "name": "container_memory_failcnt",
          "type": "counter",
          "description": "Number of memory usage hits limits"
        },
        {
          "name": "container_memory_failures_total",
          "type": "counter",
          "description": "Cumulative count of memory allocation failures"
        },
        {
          "name": "container_memory_usage_bytes",
          "type": "gauge",
          "description": "Current memory usage in bytes"
        },
        {
          "name": "container_memory_working_set_bytes",
          "type": "gauge",
          "description": "Current working set in bytes"
        },
        {
          "name": "container_spec_cpu_period",
          "type": "gauge",
          "description": "The number of microseconds that the [CFS scheduler](https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) uses as a window when limiting container processes"
        },
        {
          "name": "container_spec_cpu_quota",
          "type": "gauge",
          "description": "In CPU quota for the CFS process scheduler. In K8s this is equal to the containers's CPU limit as a fraction of 1 core and multiplied by the `container_spec_cpu_period`.  So if the CPU limit is `500m` (500 millicores) for a container and the `container_spec_cpu_period` is set to 100,000, this value will be 50,000."
        },
        {
          "name": "container_spec_cpu_shares",
          "type": "gauge",
          "description": "CPU share of the container"
        },
        {
          "name": "container_spec_memory_limit_bytes",
          "type": "gauge",
          "description": "Memory limit for the container."
        },
        {
          "name": "container_spec_memory_swap_limit_bytes",
          "type": "gauge",
          "description": "Memory swap limit for the container."
        },
        {
          "name": "container_start_time_seconds",
          "type": "gauge",
          "description": "Start time of the container since unix epoch in seconds."
        },
        {
          "name": "container_tasks_state",
          "type": "gauge",
          "description": "Number of tasks in given state"
        },
        {
          "name": "machine_cpu_cores",
          "type": "gauge",
          "description": "Number of CPU cores on the node."
        },
        {
          "name": "machine_cpu_frequency_khz",
          "type": "gauge",
          "description": "Node's CPU frequency."
        },
        {
          "name": "machine_memory_bytes",
          "type": "gauge",
          "description": "Amount of memory installed on the node."
        },
        {
          "name": "pod_network_receive_bytes_total",
          "type": "counter",
          "description": "Cumulative count of bytes received"
        },
        {
          "name": "pod_network_receive_errors_total",
          "type": "counter",
          "description": "Cumulative count of errors encountered while receiving"
        },
        {
          "name": "pod_network_receive_packets_dropped_total",
          "type": "counter",
          "description": "Cumulative count of packets dropped while receiving"
        },
        {
          "name": "pod_network_receive_packets_total",
          "type": "counter",
          "description": "Cumulative count of packets received"
        },
        {
          "name": "pod_network_transmit_bytes_total",
          "type": "counter",
          "description": "Cumulative count of bytes transmitted"
        },
        {
          "name": "pod_network_transmit_errors_total",
          "type": "counter",
          "description": "Cumulative count of errors encountered while transmitting"
        },
        {
          "name": "pod_network_transmit_packets_dropped_total",
          "type": "counter",
          "description": "Cumulative count of packets dropped while transmitting"
        },
        {
          "name": "pod_network_transmit_packets_total",
          "type": "counter",
          "description": "Cumulative count of packets transmitted"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors Apache ActiveMQ via the collectd\nGenericJMX plugin.\n",
      "package": "internal/monitors/collectd/activemq",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "JMX RMI port on the host",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceName",
          "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceURL",
          "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
          "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "instancePrefix",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "customDimensions",
          "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToCollect",
          "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToOmit",
          "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeanDefinitions",
          "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "struct",
          "elementStruct": {
            "name": "MBean",
            "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
            "package": "internal/monitors/collectd/genericjmx",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instancePrefix",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instanceFrom",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "values",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "MBeanValue",
                  "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                  "package": "internal/monitors/collectd/genericjmx",
                  "fields": [
                    {
                      "yamlName": "type",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "table",
                      "doc": "",
                      "default": false,
                      "required": false,
                      "type": "bool",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instancePrefix",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instanceFrom",
                      "doc": "",
                      "default": null,
                      "required": false,
                      "type": "slice",
                      "elementKind": "string"
                    },
                    {
                      "yamlName": "attribute",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    }
                  ]
                }
              },
              {
                "yamlName": "dimensions",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              }
            ]
          }
        }
      ],
      "monitorType": "collectd/activemq",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.amq.TotalConnectionsCount",
          "type": "counter",
          "description": "Total connections count per broker"
        },
        {
          "name": "gauge.amq.TotalConsumerCount",
          "type": "gauge",
          "description": "Total number of consumers subscribed to destinations on the broker"
        },
        {
          "name": "gauge.amq.TotalDequeueCount",
          "type": "gauge",
          "description": "Total number of messages that have been acknowledged from the broker."
        },
        {
          "name": "gauge.amq.TotalEnqueueCount",
          "type": "gauge",
          "description": "Total number of messages that have been sent to the broker."
        },
        {
          "name": "gauge.amq.TotalMessageCount",
          "type": "gauge",
          "description": "Total number of unacknowledged messages on the broker"
        },
        {
          "name": "gauge.amq.TotalProducerCount",
          "type": "gauge",
          "description": "Total number of message producers active on destinations on the broker"
        },
        {
          "name": "gauge.amq.queue.AverageBlockedTime",
          "type": "gauge",
          "description": "Average time (ms) that messages have spent blocked by Flow Control."
        },
        {
          "name": "gauge.amq.queue.AverageEnqueueTime",
          "type": "gauge",
          "description": "Average time (ms) that messages have been held at this destination"
        },
        {
          "name": "gauge.amq.queue.AverageMessageSize",
          "type": "gauge",
          "description": "Average size of messages in this queue, in bytes."
        },
        {
          "name": "gauge.amq.queue.BlockedSends",
          "type": "gauge",
          "description": "Number of messages blocked by Flow Control."
        },
        {
          "name": "gauge.amq.queue.ConsumerCount",
          "type": "gauge",
          "description": "Number of consumers subscribed to this queue."
        },
        {
          "name": "gauge.amq.queue.DequeueCount",
          "type": "gauge",
          "description": "Number of messages that have been acknowledged and removed from the queue."
        },
        {
          "name": "gauge.amq.queue.EnqueueCount",
          "type": "gauge",
          "description": "Number of messages that have been sent to the queue."
        },
        {
          "name": "gauge.amq.queue.ExpiredCount",
          "type": "gauge",
          "description": "Number of messages that have expired from the queue."
        },
        {
          "name": "gauge.amq.queue.ForwardCount",
          "type": "gauge",
          "description": "Number of messages that have been forwarded from this queue to a networked broker."
        },
        {
          "name": "gauge.amq.queue.InFlightCount",
          "type": "gauge",
          "description": "The number of messages that have been dispatched to consumers, but not acknowledged."
        },
        {
          "name": "gauge.amq.queue.ProducerCount",
          "type": "gauge",
          "description": "Number of producers publishing to this queue"
        },
        {
          "name": "gauge.amq.queue.QueueSize",
          "type": "gauge",
          "description": "The number of messages in the queue that have yet to be consumed."
        },
        {
          "name": "gauge.amq.queue.TotalBlockedTime",
          "type": "gauge",
          "description": "The total time (ms) that messages have spent blocked by Flow Control."
        },
        {
          "name": "gauge.amq.topic.AverageBlockedTime",
          "type": "gauge",
          "description": "Average time (ms) that messages have been blocked by Flow Control."
        },
        {
          "name": "gauge.amq.topic.AverageEnqueueTime",
          "type": "gauge",
          "description": "Average time (ms) that messages have been held at this destination."
        },
        {
          "name": "gauge.amq.topic.AverageMessageSize",
          "type": "gauge",
          "description": "Average size of messages on this topic, in bytes."
        },
        {
          "name": "gauge.amq.topic.BlockedSends",
          "type": "gauge",
          "description": "Number of messages blocked by Flow Control"
        },
        {
          "name": "gauge.amq.topic.ConsumerCount",
          "type": "gauge",
          "description": "The number of consumers subscribed to this topic"
        },
        {
          "name": "gauge.amq.topic.DequeueCount",
          "type": "gauge",
          "description": "Number of messages that have been acknowledged and removed from the topic."
        },
        {
          "name": "gauge.amq.topic.EnqueueCount",
          "type": "gauge",
          "description": "The number of messages that have been sent to the topic."
        },
        {
          "name": "gauge.amq.topic.ExpiredCount",
          "type": "gauge",
          "description": "The number of messages that have expired from this topic."
        },
        {
          "name": "gauge.amq.topic.ForwardCount",
          "type": "gauge",
          "description": "The number of messages that have been forwarded from this topic to a networked broker."
        },
        {
          "name": "gauge.amq.topic.InFlightCount",
          "type": "gauge",
          "description": "The number of messages that have been dispatched to consumers, but have not yet been acknowledged."
        },
        {
          "name": "gauge.amq.topic.ProducerCount",
          "type": "gauge",
          "description": "Number of producers publishing to this topic."
        },
        {
          "name": "gauge.amq.topic.QueueSize",
          "type": "gauge",
          "description": "Number of messages in the topic that have yet to be consumed."
        },
        {
          "name": "gauge.amq.topic.TotalBlockedTime",
          "type": "gauge",
          "description": "The total time (ms) that messages have spent blocked by Flow Control"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors Apache webservice instances using\nthe information provided by `mod_status`.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-apache\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: collectd/apache\n   host: localhost\n   port: 80\n```\n\nIf `mod_status` is exposed on an endpoint other than `/mod_status`, you can\nuse the `url` config option to specify the path:\n\n```\nmonitors:\n - type: collectd/apache\n   host: localhost\n   port: 80\n   url: \"http://{{.Host}}:{{.Port}}/server-status?auto\"\n```\n",
      "package": "internal/monitors/collectd/apache",
      "fields": [
        {
          "yamlName": "host",
          "doc": "The hostname of the Apache server",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "The port number of the Apache server",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "This will be sent as the `plugin_instance` dimension and can be any name you like.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "url",
          "doc": "The URL, either a final url or a Go template that will be populated with the host and port values.",
          "default": "http://{{.Host}}:{{.Port}}/mod_status?auto",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/apache",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": [
        {
          "name": "plugin_instance",
          "description": "Set to whatever you set in the `name` config option."
        }
      ],
      "metrics": [
        {
          "name": "apache_bytes",
          "type": "cumulative",
          "description": "Bytes served by Apache"
        },
        {
          "name": "apache_connections",
          "type": "gauge",
          "description": "Connections served by Apache"
        },
        {
          "name": "apache_idle_workers",
          "type": "gauge",
          "description": "Apache workers that are idle"
        },
        {
          "name": "apache_requests",
          "type": "cumulative",
          "description": "Requests served by Apache"
        },
        {
          "name": "apache_scoreboard.closing",
          "type": "gauge",
          "description": "Number of workers in the process of closing connections"
        },
        {
          "name": "apache_scoreboard.dnslookup",
          "type": "gauge",
          "description": "Number of workers performing DNS lookup"
        },
        {
          "name": "apache_scoreboard.finishing",
          "type": "gauge",
          "description": "Number of workers that are finishing"
        },
        {
          "name": "apache_scoreboard.idle_cleanup",
          "type": "gauge",
          "description": "Number of idle threads ready for cleanup"
        },
        {
          "name": "apache_scoreboard.keepalive",
          "type": "gauge",
          "description": "Number of keep-alive connections"
        },
        {
          "name": "apache_scoreboard.logging",
          "type": "gauge",
          "description": "Number of workers writing to log file"
        },
        {
          "name": "apache_scoreboard.open",
          "type": "gauge",
          "description": "Number of worker thread slots that are open"
        },
        {
          "name": "apache_scoreboard.reading",
          "type": "gauge",
          "description": "Number of workers reading requests"
        },
        {
          "name": "apache_scoreboard.sending",
          "type": "gauge",
          "description": "Number of workers sending responses"
        },
        {
          "name": "apache_scoreboard.starting",
          "type": "gauge",
          "description": "Number of workers starting up"
        },
        {
          "name": "apache_scoreboard.waiting",
          "type": "gauge",
          "description": "Number of workers waiting for requests"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors Cassandra using the GenericJMX collectd\nplugin.\n",
      "package": "internal/monitors/collectd/cassandra",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "JMX RMI port on the host",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceName",
          "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceURL",
          "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
          "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "instancePrefix",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "customDimensions",
          "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToCollect",
          "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToOmit",
          "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeanDefinitions",
          "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "struct",
          "elementStruct": {
            "name": "MBean",
            "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
            "package": "internal/monitors/collectd/genericjmx",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instancePrefix",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instanceFrom",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "values",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "MBeanValue",
                  "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                  "package": "internal/monitors/collectd/genericjmx",
                  "fields": [
                    {
                      "yamlName": "type",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "table",
                      "doc": "",
                      "default": false,
                      "required": false,
                      "type": "bool",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instancePrefix",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instanceFrom",
                      "doc": "",
                      "default": null,
                      "required": false,
                      "type": "slice",
                      "elementKind": "string"
                    },
                    {
                      "yamlName": "attribute",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    }
                  ]
                }
              },
              {
                "yamlName": "dimensions",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              }
            ]
          }
        }
      ],
      "monitorType": "collectd/cassandra",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.cassandra.ClientRequest.RangeSlice.Latency.Count",
          "type": "cumulative",
          "description": "Count of range slice operations since server start"
        },
        {
          "name": "counter.cassandra.ClientRequest.RangeSlice.Timeouts.Count",
          "type": "cumulative",
          "description": "Count of range slice timeouts since server start"
        },
        {
          "name": "counter.cassandra.ClientRequest.RangeSlice.Unavailables.Count",
          "type": "cumulative",
          "description": "Count of range slice unavailables since server start"
        },
        {
          "name": "counter.cassandra.ClientRequest.Read.Latency.Count",
          "type": "cumulative",
          "description": "Count of read operations since server start"
        },
        {
          "name": "counter.cassandra.ClientRequest.Read.Timeouts.Count",
          "type": "cumulative",
          "description": "Count of read timeouts since server start"
        },
        {
          "name": "counter.cassandra.ClientRequest.Read.Unavailables.Count",
          "type": "cumulative",
          "description": "Count of read unavailables since server start"
        },
        {
          "name": "counter.cassandra.ClientRequest.Write.Latency.Count",
          "type": "cumulative",
          "description": "Count of write operations since server start"
        },
        {
          "name": "counter.cassandra.ClientRequest.Write.Timeouts.Count",
          "type": "cumulative",
          "description": "Count of write timeouts since server start"
        },
        {
          "name": "counter.cassandra.ClientRequest.Write.Unavailables.Count",
          "type": "cumulative",
          "description": "Count of write unavailables since server start"
        },
        {
          "name": "counter.cassandra.Compaction.TotalCompactionsCompleted.Count",
          "type": "cumulative",
          "description": "Number of compaction operations since node start"
        },
        {
          "name": "gauge.cassandra.ClientRequest.RangeSlice.Latency.50thPercentile",
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra range slice latency"
        },
        {
          "name": "gauge.cassandra.ClientRequest.RangeSlice.Latency.99thPercentile",
          "type": "gauge",
          "description": "99th percentile of Cassandra range slice latency"
        },
        {
          "name": "gauge.cassandra.ClientRequest.RangeSlice.Latency.Max",
          "type": "gauge",
          "description": "Maximum Cassandra range slice latency"
        },
        {
          "name": "gauge.cassandra.ClientRequest.Read.Latency.50thPercentile",
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra read latency"
        },
        {
          "name": "gauge.cassandra.ClientRequest.Read.Latency.99thPercentile",
          "type": "gauge",
          "description": "99th percentile of Cassandra read latency"
        },
        {
          "name": "gauge.cassandra.ClientRequest.Read.Latency.Max",
          "type": "gauge",
          "description": "Maximum Cassandra read latency"
        },
        {
          "name": "gauge.cassandra.ClientRequest.Write.Latency.50thPercentile",
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra write latency"
        },
        {
          "name": "gauge.cassandra.ClientRequest.Write.Latency.99thPercentile",
          "type": "gauge",
          "description": "99th percentile of Cassandra write latency"
        },
        {
          "name": "gauge.cassandra.ClientRequest.Write.Latency.Max",
          "type": "gauge",
          "description": "Maximum Cassandra write latency"
        },
        {
          "name": "gauge.cassandra.Compaction.PendingTasks.Value",
          "type": "gauge",
          "description": "Number of compaction operations waiting to run"
        },
        {
          "name": "gauge.cassandra.Storage.Load.Count",
          "type": "gauge",
          "description": "Storage used for Cassandra data in bytes"
        },
        {
          "name": "gauge.cassandra.Storage.TotalHints.Count",
          "type": "gauge",
          "description": "Total hints since node start"
        },
        {
          "name": "gauge.cassandra.Storage.TotalHintsInProgress.Count",
          "type": "gauge",
          "description": "Total pending hints"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Collectd NTP data from a chronyd instance\n\nSee https://collectd.org/documentation/manpages/collectd.conf.5.shtml#plugin_chrony\n",
      "package": "internal/monitors/collectd/chrony",
      "fields": [
        {
          "yamlName": "host",
          "doc": "The hostname of the chronyd instance",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "The UDP port number of the chronyd instance.  Defaults to 323 in collectd if unspecified.",
          "default": null,
          "required": false,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "timeout",
          "doc": "How long to wait for a response from chronyd before considering it down. Defaults to 2 seconds in the collectd plugin if not specified",
          "default": null,
          "required": false,
          "type": "uint",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/chrony",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors the Consul data store by using the\n[Consul collectd Python\nplugin](https://github.com/signalfx/collectd-consul), which collects metrics\nfrom Consul instances by hitting these endpoints:\n- [/agent/self](https://www.consul.io/api/agent.html#read-configuration)\n- [/agent/metrics](https://www.consul.io/api/agent.html#view-metrics)\n- [/catalog/nodes](https://www.consul.io/api/catalog.html#list-nodes)\n- [/catalog/node/:node](https://www.consul.io/api/catalog.html#list-services-for-node)\n- [/status/leader](https://www.consul.io/api/status.html#get-raft-leader)\n- [/status/peers](https://www.consul.io/api/status.html#list-raft-peers)\n- [/coordinate/datacenters](https://www.consul.io/api/coordinate.html#read-wan-coordinates)\n- [/coordinate/nodes](https://www.consul.io/api/coordinate.html#read-lan-coordinates)\n- [/health/state/any](https://www.consul.io/api/health.html#list-checks-in-state)\n",
      "package": "internal/monitors/collectd/consul",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "aclToken",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "useHTTPS",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "enhancedMetrics",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "caCertificate",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "clientCertificate",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "clientKey",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "signalFxAccessToken",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/consul",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": [
        {
          "name": "consul_mode",
          "description": "Whether this consul instance is running as a server or client"
        },
        {
          "name": "consul_node",
          "description": "The name of the consul node"
        },
        {
          "name": "datacenter",
          "description": "The name of the consul datacenter"
        }
      ],
      "metrics": [
        {
          "name": "consul.dns.stale_queries",
          "type": "gauge",
          "description": "Number of times an agent serves a DNS query with stale information"
        },
        {
          "name": "consul.memberlist.msg.suspect",
          "type": "gauge",
          "description": "Number of suspect messages received per interval"
        },
        {
          "name": "consul.serf.member.flap",
          "type": "gauge",
          "description": "Tracks flapping agents"
        },
        {
          "name": "gauge.consul.catalog.nodes.total",
          "type": "gauge",
          "description": "Number of nodes in the Consul datacenter"
        },
        {
          "name": "gauge.consul.catalog.nodes_by_service",
          "type": "gauge",
          "description": "Number of nodes providing a given service"
        },
        {
          "name": "gauge.consul.catalog.services.total",
          "type": "gauge",
          "description": "Total number of services registered with Consul in the given datacenter"
        },
        {
          "name": "gauge.consul.catalog.services_by_node",
          "type": "gauge",
          "description": "Number of services registered with a node"
        },
        {
          "name": "gauge.consul.consul.dns.domain_query.AGENT.avg",
          "type": "gauge",
          "description": "Average time to complete a forward DNS query"
        },
        {
          "name": "gauge.consul.consul.dns.domain_query.AGENT.max",
          "type": "gauge",
          "description": "Max time to complete a forward DNS query"
        },
        {
          "name": "gauge.consul.consul.dns.domain_query.AGENT.min",
          "type": "gauge",
          "description": "Min time to complete a forward DNS query"
        },
        {
          "name": "gauge.consul.consul.dns.ptr_query.AGENT.avg",
          "type": "gauge",
          "description": "Average time to complete a Reverse DNS query"
        },
        {
          "name": "gauge.consul.consul.dns.ptr_query.AGENT.max",
          "type": "gauge",
          "description": "Max time to complete a Reverse DNS query"
        },
        {
          "name": "gauge.consul.consul.dns.ptr_query.AGENT.min",
          "type": "gauge",
          "description": "Min time to complete a Reverse DNS query"
        },
        {
          "name": "gauge.consul.consul.leader.reconcile.avg",
          "type": "gauge",
          "description": "Leader time to reconcile the differences between Serf membership and Consul's store"
        },
        {
          "name": "gauge.consul.health.nodes.critical",
          "type": "gauge",
          "description": "Number of nodes for which health checks are reporting Critical state"
        },
        {
          "name": "gauge.consul.health.nodes.passing",
          "type": "gauge",
          "description": "Number of nodes for which health checks are reporting Passing state"
        },
        {
          "name": "gauge.consul.health.nodes.warning",
          "type": "gauge",
          "description": "Number of nodes for which health checks are reporting Warning state"
        },
        {
          "name": "gauge.consul.health.services.critical",
          "type": "gauge",
          "description": "Number of services for which health checks are reporting Critical state"
        },
        {
          "name": "gauge.consul.health.services.passing",
          "type": "gauge",
          "description": "Number of services for which health checks are reporting Passing state"
        },
        {
          "name": "gauge.consul.health.services.warning",
          "type": "gauge",
          "description": "Number of services for which health checks are reporting Warning state"
        },
        {
          "name": "gauge.consul.is_leader",
          "type": "gauge",
          "description": "Metric to map consul server's in leader or follower state"
        },
        {
          "name": "gauge.consul.network.dc.latency.avg",
          "type": "gauge",
          "description": "Average network latency between 2 datacenters"
        },
        {
          "name": "gauge.consul.network.dc.latency.max",
          "type": "gauge",
          "description": "Maximum network latency between 2 datacenters"
        },
        {
          "name": "gauge.consul.network.dc.latency.min",
          "type": "gauge",
          "description": "Minimum network latency between 2 datacenters"
        },
        {
          "name": "gauge.consul.network.node.latency.avg",
          "type": "gauge",
          "description": "Average network latency between given node and other nodes in the datacenter"
        },
        {
          "name": "gauge.consul.network.node.latency.max",
          "type": "gauge",
          "description": "Minimum network latency between given node and other nodes in the datacenter"
        },
        {
          "name": "gauge.consul.network.node.latency.min",
          "type": "gauge",
          "description": "Minimum network latency between given node and other nodes in the datacenter"
        },
        {
          "name": "gauge.consul.peers",
          "type": "gauge",
          "description": "Number of Raft peers in Consul datacenter"
        },
        {
          "name": "gauge.consul.raft.apply",
          "type": "gauge",
          "description": "Number of raft transactions"
        },
        {
          "name": "gauge.consul.raft.commitTime.avg",
          "type": "gauge",
          "description": "Average of the time it takes to commit an entry on the leader"
        },
        {
          "name": "gauge.consul.raft.commitTime.max",
          "type": "gauge",
          "description": "Max of the time it takes to commit an entry on the leader"
        },
        {
          "name": "gauge.consul.raft.commitTime.min",
          "type": "gauge",
          "description": "Minimum of the time it takes to commit an entry on the leader"
        },
        {
          "name": "gauge.consul.raft.leader.dispatchLog.avg",
          "type": "gauge",
          "description": "Average of the time it takes for the leader to write log entries to disk"
        },
        {
          "name": "gauge.consul.raft.leader.dispatchLog.max",
          "type": "gauge",
          "description": "Maximum of the time it takes for the leader to write log entries to disk"
        },
        {
          "name": "gauge.consul.raft.leader.dispatchLog.min",
          "type": "gauge",
          "description": "Minimum of the time it takes for the leader to write log entries to disk"
        },
        {
          "name": "gauge.consul.raft.leader.lastContact.avg",
          "type": "gauge",
          "description": "Mean of the time since the leader was last able to contact follower nodes"
        },
        {
          "name": "gauge.consul.raft.leader.lastContact.max",
          "type": "gauge",
          "description": "Max of the time since the leader was last able to contact follower nodes"
        },
        {
          "name": "gauge.consul.raft.leader.lastContact.min",
          "type": "gauge",
          "description": "Min of the time since the leader was last able to contact follower nodes"
        },
        {
          "name": "gauge.consul.raft.replication.appendEntries.rpc.AGENT.avg",
          "type": "gauge",
          "description": "Mean time taken to complete the AppendEntries RPC"
        },
        {
          "name": "gauge.consul.raft.replication.appendEntries.rpc.AGENT.max",
          "type": "gauge",
          "description": "Max time taken to complete the AppendEntries RPC"
        },
        {
          "name": "gauge.consul.raft.replication.appendEntries.rpc.AGENT.min",
          "type": "gauge",
          "description": "Min time taken to complete the AppendEntries RPC"
        },
        {
          "name": "gauge.consul.raft.state.candidate",
          "type": "gauge",
          "description": "Tracks the number of times given node enters the candidate state"
        },
        {
          "name": "gauge.consul.raft.state.leader",
          "type": "gauge",
          "description": "Tracks the number of leadership transitions per interval"
        },
        {
          "name": "gauge.consul.runtime.alloc_bytes",
          "type": "gauge",
          "description": "Number of bytes allocated to Consul process on the node"
        },
        {
          "name": "gauge.consul.runtime.heap_objects",
          "type": "gauge",
          "description": "Number of heap objects allocated to Consul"
        },
        {
          "name": "gauge.consul.runtime.num_goroutines",
          "type": "gauge",
          "description": "Number of GO routines run by Consul process"
        },
        {
          "name": "gauge.consul.serf.events",
          "type": "gauge",
          "description": "Number of serf events processed"
        },
        {
          "name": "gauge.consul.serf.member.join",
          "type": "gauge",
          "description": "Tracks successful node joins"
        },
        {
          "name": "gauge.consul.serf.member.left",
          "type": "gauge",
          "description": "Tracks successful node leaves"
        },
        {
          "name": "gauge.consul.serf.queue.Event.avg",
          "type": "gauge",
          "description": "Average number of serf events in queue yet to be processed"
        },
        {
          "name": "gauge.consul.serf.queue.Event.max",
          "type": "gauge",
          "description": "Maximum number of serf events in queue yet to be processed during the interval"
        },
        {
          "name": "gauge.consul.serf.queue.Event.min",
          "type": "gauge",
          "description": "Minimum number of serf events in queue yet to be processed during the interval"
        },
        {
          "name": "gauge.consul.serf.queue.Query.avg",
          "type": "gauge",
          "description": "Average number of serf queries in queue yet to be processed during the interval"
        },
        {
          "name": "gauge.consul.serf.queue.Query.max",
          "type": "gauge",
          "description": "Maximum number of serf queries in queue yet to be processed during the interval"
        },
        {
          "name": "gauge.consul.serf.queue.Query.min",
          "type": "gauge",
          "description": "Minimum number of serf queries in queue yet to be processed during the interval"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors couchbase by using the\n[couchbase collectd Python\nplugin](https://github.com/signalfx/collectd-couchbase), which collects\nmetrics from couchbase instances\n\nSample YAML configuration with custom query:\n\n```yaml\nmonitors:\n- type: collectd/couchbase\n  host: 127.0.0.1\n  port: 8091\n  collectTarget: \"NODE\"\n  clusterName: \"my-cluster\"\n  username: \"user\"\n  password: \"password\"\n```\n",
      "package": "internal/monitors/collectd/couchbase",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "collectTarget",
          "doc": "Define what this Module block will monitor: \"NODE\", for a Couchbase node, or \"BUCKET\" for a Couchbase bucket.",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "collectBucket",
          "doc": "If CollectTarget is \"BUCKET\", CollectBucket specifies the name of the bucket that this will monitor.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "clusterName",
          "doc": "Name of this Couchbase cluster. (**default**:\"default\")",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "collectMode",
          "doc": "Change to \"detailed\" to collect all available metrics from Couchbase stats API. Defaults to \"default\", collecting a curated set that works well with SignalFx. See [metric_info.py](https://github.com/signalfx/collectd-couchbase/blob/master/metric_info.py) for more information.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "Username to authenticate with",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "Password to authenticate with",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/couchbase",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "gauge.bucket.basic.dataUsed",
          "type": "gauge",
          "description": "Size of user data within buckets of the specified state that are resident in RAM (%)"
        },
        {
          "name": "gauge.bucket.basic.diskFetches",
          "type": "gauge",
          "description": "Number of disk fetches"
        },
        {
          "name": "gauge.bucket.basic.diskUsed",
          "type": "gauge",
          "description": "Amount of disk used (bytes)"
        },
        {
          "name": "gauge.bucket.basic.itemCount",
          "type": "gauge",
          "description": "Number of items associated with the bucket"
        },
        {
          "name": "gauge.bucket.basic.memUsed",
          "type": "gauge",
          "description": "Amount of memory used by the bucket (bytes)"
        },
        {
          "name": "gauge.bucket.basic.opsPerSec",
          "type": "gauge",
          "description": "Number of operations per second"
        },
        {
          "name": "gauge.bucket.basic.quotaPercentUsed",
          "type": "gauge",
          "description": "Percentage of RAM used (for active objects) against the configure bucket size (%)"
        },
        {
          "name": "gauge.bucket.op.cmd_get",
          "type": "gauge",
          "description": "requested objects"
        },
        {
          "name": "gauge.bucket.op.couch_docs_fragmentation",
          "type": "gauge",
          "description": "Percent fragmentation of documents in this bucket."
        },
        {
          "name": "gauge.bucket.op.couch_views_ops",
          "type": "gauge",
          "description": "view operations per second"
        },
        {
          "name": "gauge.bucket.op.curr_connections",
          "type": "gauge",
          "description": "open connection per bucket"
        },
        {
          "name": "gauge.bucket.op.curr_items",
          "type": "gauge",
          "description": "total number of stored items per bucket"
        },
        {
          "name": "gauge.bucket.op.disk_write_queue",
          "type": "gauge",
          "description": "number of items waiting to be written to disk"
        },
        {
          "name": "gauge.bucket.op.ep_bg_fetched",
          "type": "gauge",
          "description": "number of items fetched from disk"
        },
        {
          "name": "gauge.bucket.op.ep_cache_miss_rate",
          "type": "gauge",
          "description": "ratio of requested objects found in cache vs retrieved from disk"
        },
        {
          "name": "gauge.bucket.op.ep_diskqueue_drain",
          "type": "gauge",
          "description": "items removed from disk queue"
        },
        {
          "name": "gauge.bucket.op.ep_diskqueue_fill",
          "type": "gauge",
          "description": "enqueued items on disk queue"
        },
        {
          "name": "gauge.bucket.op.ep_mem_high_wat",
          "type": "gauge",
          "description": "memory high water mark - point at which active objects begin to be ejected from bucket"
        },
        {
          "name": "gauge.bucket.op.ep_mem_low_wat",
          "type": "gauge",
          "description": "memory low water mark"
        },
        {
          "name": "gauge.bucket.op.ep_num_value_ejects",
          "type": "gauge",
          "description": "number of objects ejected out of the bucket"
        },
        {
          "name": "gauge.bucket.op.ep_oom_errors",
          "type": "gauge",
          "description": "request rejected - bucket is at quota, panic"
        },
        {
          "name": "gauge.bucket.op.ep_queue_size",
          "type": "gauge",
          "description": "number of items queued for storage"
        },
        {
          "name": "gauge.bucket.op.ep_tmp_oom_errors",
          "type": "gauge",
          "description": "request rejected - couchbase is making room by ejecting objects, try again later"
        },
        {
          "name": "gauge.bucket.op.mem_used",
          "type": "gauge",
          "description": "memory used"
        },
        {
          "name": "gauge.bucket.op.ops",
          "type": "gauge",
          "description": "total of gets, sets, increment and decrement"
        },
        {
          "name": "gauge.bucket.op.vb_active_resident_items_ratio",
          "type": "gauge",
          "description": "ratio of items kept in memory vs stored on disk"
        },
        {
          "name": "gauge.bucket.quota.ram",
          "type": "gauge",
          "description": "Amount of RAM used by the bucket (bytes)."
        },
        {
          "name": "gauge.bucket.quota.rawRAM",
          "type": "gauge",
          "description": "Amount of raw RAM used by the bucket (bytes)."
        },
        {
          "name": "gauge.nodes.cmd_get",
          "type": "gauge",
          "description": "Number of get commands"
        },
        {
          "name": "gauge.nodes.couch_docs_actual_disk_size",
          "type": "gauge",
          "description": "Amount of disk space used by Couch docs.(bytes)"
        },
        {
          "name": "gauge.nodes.couch_docs_data_size",
          "type": "gauge",
          "description": "Data size of couch documents associated with a node (bytes)"
        },
        {
          "name": "gauge.nodes.couch_spatial_data_size",
          "type": "gauge",
          "description": "Size of object data for spatial views (bytes)"
        },
        {
          "name": "gauge.nodes.couch_spatial_disk_size",
          "type": "gauge",
          "description": "Amount of disk space occupied by spatial views, in bytes."
        },
        {
          "name": "gauge.nodes.couch_views_actual_disk_size",
          "type": "gauge",
          "description": "Amount of disk space occupied by Couch views (bytes)."
        },
        {
          "name": "gauge.nodes.couch_views_data_size",
          "type": "gauge",
          "description": "Size of object data for Couch views (bytes)."
        },
        {
          "name": "gauge.nodes.curr_items",
          "type": "gauge",
          "description": "Number of current items"
        },
        {
          "name": "gauge.nodes.curr_items_tot",
          "type": "gauge",
          "description": "Total number of items associated with node"
        },
        {
          "name": "gauge.nodes.ep_bg_fetched",
          "type": "gauge",
          "description": "Number of disk fetches performed since server was started"
        },
        {
          "name": "gauge.nodes.get_hits",
          "type": "gauge",
          "description": "Number of get hits"
        },
        {
          "name": "gauge.nodes.mcdMemoryAllocated",
          "type": "gauge",
          "description": "Amount of memcached memory allocated (bytes)."
        },
        {
          "name": "gauge.nodes.mcdMemoryReserved",
          "type": "gauge",
          "description": "Amount of memcached memory reserved (bytes)."
        },
        {
          "name": "gauge.nodes.mem_used",
          "type": "gauge",
          "description": "Memory used by the node (bytes)"
        },
        {
          "name": "gauge.nodes.memoryFree",
          "type": "gauge",
          "description": "Amount of memory free for the node (bytes)."
        },
        {
          "name": "gauge.nodes.memoryTotal",
          "type": "gauge",
          "description": "Total memory available to the node (bytes)."
        },
        {
          "name": "gauge.nodes.ops",
          "type": "gauge",
          "description": "Number of operations performed on Couchbase"
        },
        {
          "name": "gauge.nodes.system.cpu_utilization_rate",
          "type": "gauge",
          "description": "The CPU utilization rate (%)"
        },
        {
          "name": "gauge.nodes.system.mem_free",
          "type": "gauge",
          "description": "Free memory available to the node (bytes)"
        },
        {
          "name": "gauge.nodes.system.mem_total",
          "type": "gauge",
          "description": "Total memory available to the node (bytes)"
        },
        {
          "name": "gauge.nodes.system.swap_total",
          "type": "gauge",
          "description": "Total swap size allocated (bytes)"
        },
        {
          "name": "gauge.nodes.system.swap_used",
          "type": "gauge",
          "description": "Amount of swap space used (bytes)"
        },
        {
          "name": "gauge.nodes.vb_replica_curr_items",
          "type": "gauge",
          "description": "Number of items/documents that are replicas"
        },
        {
          "name": "gauge.storage.hdd.free",
          "type": "gauge",
          "description": "Free harddrive space in the cluster (bytes)"
        },
        {
          "name": "gauge.storage.hdd.quotaTotal",
          "type": "gauge",
          "description": "Harddrive quota total for the cluster (bytes)"
        },
        {
          "name": "gauge.storage.hdd.total",
          "type": "gauge",
          "description": "Total harddrive space available to cluster (bytes)"
        },
        {
          "name": "gauge.storage.hdd.used",
          "type": "gauge",
          "description": "Harddrive space used by the cluster (bytes)"
        },
        {
          "name": "gauge.storage.hdd.usedByData",
          "type": "gauge",
          "description": "Harddrive use by the data in the cluster(bytes)"
        },
        {
          "name": "gauge.storage.ram.quotaTotal",
          "type": "gauge",
          "description": "Ram quota total for the cluster (bytes)"
        },
        {
          "name": "gauge.storage.ram.quotaTotalPerNode",
          "type": "gauge",
          "description": "Ram quota total per node (bytes)"
        },
        {
          "name": "gauge.storage.ram.quotaUsed",
          "type": "gauge",
          "description": "Ram quota used by the cluster (bytes)"
        },
        {
          "name": "gauge.storage.ram.quotaUsedPerNode",
          "type": "gauge",
          "description": "Ram quota used per node (bytes)"
        },
        {
          "name": "gauge.storage.ram.total",
          "type": "gauge",
          "description": "Total ram available to cluster (bytes)"
        },
        {
          "name": "gauge.storage.ram.used",
          "type": "gauge",
          "description": "Ram used by the cluster (bytes)"
        },
        {
          "name": "gauge.storage.ram.usedByData",
          "type": "gauge",
          "description": "Ram used by the data in the cluster (bytes)"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor collects cpu usage data using the\ncollectd `cpu` plugin.  It aggregates the per-core CPU data into a single\nmetric and sends it to the SignalFx Metadata plugin in collectd, where the\nraw jiffy counts from the `cpu` plugin are converted to percent utilization\n(the `cpu.utilization` metric).\n\nSee https://collectd.org/wiki/index.php/Plugin:CPU\n",
      "package": "internal/monitors/collectd/cpu",
      "fields": [],
      "monitorType": "collectd/cpu",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "cpu.utilization",
          "type": "gauge",
          "description": "Percentage of total CPU used within the last metric interval cycle."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors the actual clock speed of each CPU on a\nhost.  Useful for systems that vary the clock speed to conserve energy.\n\nSee https://collectd.org/wiki/index.php/Plugin:CPUFreq\n",
      "package": "internal/monitors/collectd/cpufreq",
      "fields": [],
      "monitorType": "collectd/cpufreq",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "cpufreq.\u003cN\u003e",
          "type": "gauge",
          "description": "The processor frequency in Hertz for the \u003cN\u003eth processor on the system."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor lets you provide custom collectd\nconfiguration to be run by the managed collectd instance.  You can provide\nconfiguration for as many plugins as you want in a single instance of this\nmonitor configuration by either putting multiple `\u003cPlugin\u003e` blocks in a\nsingle `template` option, or specifying multiple `templates`.\n\nNote that a distinct instance of collectd is run for each instance of this\nmonitor, so it is more efficient to group plugin configurations into a\nsingle monitor configuration (either in one big `template` text blob, or\nsplit into multiple `templates`).  You should not group configurations if\nusing a discoveryRule since that would result in duplicate config for each\ninstance of the service endpoint discovered.\n\nYou can also use your own Python plugins in conjunction with the\n`ModulePath` option in\n[collectd-python](https://collectd.org/documentation/manpages/collectd-python.5.shtml).\nIf your Python plugin has dependencies of its own, you can specify the path\nto them by specifying multiple `ModulePath` options with those paths.\n\nHere is an example of a configuration with a custom Python plugin:\n\n```yaml\n  - type: collectd/custom\n    discoveryRule: container_image =~ \"myservice\"\n    template: |\n      LoadPlugin \"python\"\n      \u003cPlugin python\u003e\n        ModulePath \"/usr/lib/python2.7/dist-packages/health_checker\"\n        Import \"health_checker\"\n        \u003cModule health_checker\u003e\n          URL \"http://{{.Host}}:{{.Port}}\"\n          JSONKey \"isRunning\"\n          JSONVal \"1\"\n        \u003c/Module\u003e\n      \u003c/Plugin\u003e\n```\n\nWe have many collectd plugins included in the image that are not exposed as\nmonitors.  You can see the plugins in the `\u003cAGENT_BUNDLE\u003e/plugins/collectd`\ndirectory, where `\u003cAGENT_BUNDLE\u003e` is blank in the containerized version, and\nis normally `/usr/lib/signalfx-agent` in the non-containerized agent.\n",
      "package": "internal/monitors/collectd/custom",
      "fields": [
        {
          "yamlName": "host",
          "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Host}}`.  It will be set to the hostname or IP address of the discovered service. If you aren't using service discovery, you can just hardcode the host/port in the config template and ignore these fields.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Port}}`.  It will be set to the port of the discovered service, if it is a TCP/UDP endpoint.",
          "default": 0,
          "required": false,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Name}}`.  It will be set to the name that the observer creates for the endpoint upon discovery.  You can generally ignore this field.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "template",
          "doc": "A config template for collectd.  You can include as many plugin blocks as you want in this value.  It is rendered as a standard Go template, so be mindful of the delimiters `{{` and `}}`.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "templates",
          "doc": "A list of templates, but otherwise equivalent to the above `template` option.  This enables you to have a single directory with collectd configuration files and load them all by using a globbed remote config value:",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "collectdReadThreads",
          "doc": "The number of read threads to use in collectd.  Will default to the number of templates provided, capped at 10, but if you manually specify it there is no limit.",
          "default": 0,
          "required": false,
          "type": "int",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/custom",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Tracks free disk space on the host.\n",
      "package": "internal/monitors/collectd/df",
      "fields": [
        {
          "yamlName": "hostFSPath",
          "doc": "Path to the root of the host filesystem.  Useful when running in a container and the host filesystem is mounted in some subdirectory under /.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "ignoreSelected",
          "doc": "If true, the filesystems selected by `fsTypes` and `mountPoints` will be excluded and all others included.",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "fsTypes",
          "doc": "The filesystem types to include/exclude.",
          "default": [
            "aufs",
            "overlay",
            "tmpfs",
            "proc",
            "sysfs",
            "nsfs",
            "cgroup",
            "devpts",
            "selinuxfs",
            "devtmpfs",
            "debugfs",
            "mqueue",
            "hugetlbfs",
            "securityfs",
            "pstore",
            "binfmt_misc",
            "autofs"
          ],
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mountPoints",
          "doc": "The mount paths to include/exclude, is interpreted as a regex if surrounded by `/`.  Note that you need to include the full path as the agent will see it, irrespective of the hostFSPath option.",
          "default": [
            "/^/var/lib/docker/containers/",
            "/^/var/lib/rkt/pods/",
            "/^/net//",
            "/^/smb//"
          ],
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "reportByDevice",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "reportInodes",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/df",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "df_complex.free",
          "type": "gauge",
          "description": "Free disk space in bytes"
        },
        {
          "name": "df_complex.reserved",
          "type": "gauge",
          "description": "Reserved disk space in bytes"
        },
        {
          "name": "df_complex.used",
          "type": "gauge",
          "description": "Used disk space in bytes"
        },
        {
          "name": "df_inodes.free",
          "type": "gauge",
          "description": "Number of inodes that are free."
        },
        {
          "name": "df_inodes.reserved",
          "type": "gauge",
          "description": "Number of inodes reserved for the super user."
        },
        {
          "name": "df_inodes.used",
          "type": "gauge",
          "description": "Number of inodes that are used."
        },
        {
          "name": "percent_bytes.free",
          "type": "gauge",
          "description": "Free disk space on the file system, expressed as a percentage."
        },
        {
          "name": "percent_bytes.reserved",
          "type": "gauge",
          "description": "Reserved disk space on the filesystem, expressed as a percentage."
        },
        {
          "name": "percent_bytes.used",
          "type": "gauge",
          "description": "Used disk space on the file system, expressed as a percentage."
        },
        {
          "name": "percent_inodes.free",
          "type": "gauge",
          "description": "Free inodes on the file system, expressed as a percentage."
        },
        {
          "name": "percent_inodes.reserved",
          "type": "gauge",
          "description": "Reserved inodes on the file system, expressed as a percentage."
        },
        {
          "name": "percent_inodes.used",
          "type": "gauge",
          "description": "Used inodes on the file system, expressed as a percentage."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor collects information about the usage of\nphysical disks and logical disks (partitions).\n\nSee https://collectd.org/wiki/index.php/Plugin:Disk.\n",
      "package": "internal/monitors/collectd/disk",
      "fields": [
        {
          "yamlName": "disks",
          "doc": "Which devices to include/exclude",
          "default": [
            "/^loop[0-9]+$/",
            "/^dm-[0-9]+$/"
          ],
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "ignoreSelected",
          "doc": "If true, the disks selected by `disks` will be excluded and all others included.",
          "default": true,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/disk",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "disk_merged.read",
          "type": "cumulative",
          "description": "The number of disk reads merged into single physical disk access operations."
        },
        {
          "name": "disk_merged.write",
          "type": "cumulative",
          "description": "The number of disk writes merged into single physical disk access operations."
        },
        {
          "name": "disk_octets.read",
          "type": "cumulative",
          "description": "The number of bytes (octets) read from a disk."
        },
        {
          "name": "disk_octets.write",
          "type": "cumulative",
          "description": "The number of bytes (octets) written to a disk."
        },
        {
          "name": "disk_ops.read",
          "type": "cumulative",
          "description": "The number of disk read operations."
        },
        {
          "name": "disk_ops.write",
          "type": "cumulative",
          "description": "The number of disk write operations."
        },
        {
          "name": "disk_time.read",
          "type": "cumulative",
          "description": "The average amount of time it took to do a read operation."
        },
        {
          "name": "disk_time.write",
          "type": "cumulative",
          "description": "The average amount of time it took to do a write operation."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Pulls container stats from the Docker Engine.  We\nstrongly recommend using the\n[docker-container-stats](./docker-container-stats.md) monitor instead, as it\nwill scale to large number of containers much better.\n\nSee https://github.com/signalfx/docker-collectd-plugin.\n",
      "package": "internal/monitors/collectd/docker",
      "fields": [
        {
          "yamlName": "dimensions",
          "doc": "A set of dimensions to add to container metrics (see https://github.com/signalfx/docker-collectd-plugin#extracting-additional-dimensions).",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "dockerURL",
          "doc": "URL of the Docker engine, can be a unix socket path.",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "excludedImages",
          "doc": "",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "excludedNames",
          "doc": "",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "excludedLabels",
          "doc": "",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "collectNetworkStats",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/docker",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors ElasticSearch instances.\n\nSee https://github.com/signalfx/collectd-elasticsearch and\nhttps://github.com/signalfx/integrations/tree/master/collectd-elasticsearch\n",
      "package": "internal/monitors/collectd/elasticsearch",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "additionalMetrics",
          "doc": "AdditionalMetrics to report on",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "detailedMetrics",
          "doc": "DetailedMetrics turns on additional metric time series",
          "default": true,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "enableClusterHealth",
          "doc": "EnableClusterHealth enables reporting on the cluster health",
          "default": true,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "enableIndexStats",
          "doc": "EnableIndexStats reports metrics about indexes",
          "default": true,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "indexes",
          "doc": "Indexes to report on",
          "default": [
            "_all"
          ],
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "indexInterval",
          "doc": "IndexInterval is an interval in seconds at which the plugin will report index stats. It must be greater than or equal, and divisible by the Interval configuration",
          "default": 300,
          "required": false,
          "type": "uint",
          "elementKind": ""
        },
        {
          "yamlName": "indexStatsMasterOnly",
          "doc": "IndexStatsMasterOnly sends index stats from the master only",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "indexSummaryOnly",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "Password used to access elasticsearch stats api",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "protocol",
          "doc": "Protocol used to connect: http or https",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "threadPools",
          "doc": "ThreadPools to report on",
          "default": [
            "search",
            "index"
          ],
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "username",
          "doc": "Username used to access elasticsearch stats api",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "version",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/elasticsearch",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.indices.get.total",
          "type": "counter",
          "description": "The total number of get requests since node startup"
        },
        {
          "name": "counter.indices.indexing.index-total",
          "type": "counter",
          "description": "The total number of index requests since node startup"
        },
        {
          "name": "counter.indices.merges.total",
          "type": "counter",
          "description": "Total number of merges since node startup"
        },
        {
          "name": "counter.indices.search.query-time",
          "type": "counter",
          "description": "Total time spent in search queries (milliseconds)"
        },
        {
          "name": "counter.indices.search.query-total",
          "type": "counter",
          "description": "The total number of search requests since node startup"
        },
        {
          "name": "counter.indices.total.indexing.index-total",
          "type": "counter",
          "description": "The total number of index requests per cluster"
        },
        {
          "name": "counter.indices.total.merges.total",
          "type": "counter",
          "description": "Total number of merges per cluster"
        },
        {
          "name": "counter.indices.total.search.query-total",
          "type": "counter",
          "description": "The total number of search requests per cluster"
        },
        {
          "name": "counter.jvm.gc.time",
          "type": "counter",
          "description": "Total garbage collection time (milliseconds)"
        },
        {
          "name": "counter.thread_pool.bulk.rejected",
          "type": "counter",
          "description": "Number of rejected bulk requests"
        },
        {
          "name": "counter.thread_pool.flush.rejected",
          "type": "counter",
          "description": "Number of rejected flush requests"
        },
        {
          "name": "counter.thread_pool.generic.rejected",
          "type": "counter",
          "description": "Number of rejected generic requests"
        },
        {
          "name": "counter.thread_pool.get.rejected",
          "type": "counter",
          "description": "Number of rejected get requests"
        },
        {
          "name": "counter.thread_pool.index.rejected",
          "type": "counter",
          "description": "Number of rejected index requests"
        },
        {
          "name": "counter.thread_pool.merge.rejected",
          "type": "counter",
          "description": "Number of rejected merge requests"
        },
        {
          "name": "counter.thread_pool.optimize.rejected",
          "type": "counter",
          "description": "Number of rejected optimize requests"
        },
        {
          "name": "counter.thread_pool.refresh.rejected",
          "type": "counter",
          "description": "Number of rejected refresh requests"
        },
        {
          "name": "counter.thread_pool.rejected",
          "type": "counter",
          "description": "Number of rejected thread pool requests"
        },
        {
          "name": "counter.thread_pool.search.rejected",
          "type": "counter",
          "description": "Number of rejected search requests"
        },
        {
          "name": "counter.thread_pool.snapshot.rejected",
          "type": "counter",
          "description": "Number of rejected snapshot requests"
        },
        {
          "name": "gauge.cluster.active-primary-shards",
          "type": "gauge",
          "description": "The number of active primary shards"
        },
        {
          "name": "gauge.cluster.active-shards",
          "type": "gauge",
          "description": "The number of active shards"
        },
        {
          "name": "gauge.cluster.initializing-shards",
          "type": "gauge",
          "description": "The number of currently initializing shards"
        },
        {
          "name": "gauge.cluster.number-of-data_nodes",
          "type": "gauge",
          "description": "The current number of data nodes in the cluster"
        },
        {
          "name": "gauge.cluster.number-of-nodes",
          "type": "gauge",
          "description": "Total number of nodes in the cluster"
        },
        {
          "name": "gauge.cluster.relocating-shards",
          "type": "gauge",
          "description": "The number of shards that are currently being relocated"
        },
        {
          "name": "gauge.cluster.status",
          "type": "gauge",
          "description": "The health status of the cluster"
        },
        {
          "name": "gauge.cluster.unassigned-shards",
          "type": "gauge",
          "description": "The number of shards that are currently unassigned"
        },
        {
          "name": "gauge.indices.cache.field.size",
          "type": "gauge",
          "description": "Field data size (bytes)"
        },
        {
          "name": "gauge.indices.cache.filter.size",
          "type": "gauge",
          "description": "Filter cache size (bytes)"
        },
        {
          "name": "gauge.indices.docs.count",
          "type": "gauge",
          "description": "Number of documents on this node"
        },
        {
          "name": "gauge.indices.docs.deleted",
          "type": "gauge",
          "description": "Number of deleted documents on this node"
        },
        {
          "name": "gauge.indices.merges.current",
          "type": "gauge",
          "description": "Number of active merges"
        },
        {
          "name": "gauge.indices.segments.count",
          "type": "gauge",
          "description": "Number of segments on this node"
        },
        {
          "name": "gauge.indices.total.docs.count",
          "type": "gauge",
          "description": "Number of documents in the cluster"
        },
        {
          "name": "gauge.indices.total.fielddata.memory-size",
          "type": "gauge",
          "description": "Field data size (bytes)"
        },
        {
          "name": "gauge.indices.total.filter-cache.memory-size",
          "type": "gauge",
          "description": "Filter cache size (bytes)"
        },
        {
          "name": "gauge.jvm.mem.heap-committed",
          "type": "gauge",
          "description": "Total heap committed by the process (bytes)"
        },
        {
          "name": "gauge.jvm.mem.heap-used",
          "type": "gauge",
          "description": "Total heap used (bytes)"
        },
        {
          "name": "gauge.process.open_file_descriptors",
          "type": "gauge",
          "description": "Number of currently open file descriptors"
        },
        {
          "name": "gauge.thread_pool.active",
          "type": "counter",
          "description": "Number of active threads"
        },
        {
          "name": "gauge.thread_pool.largest",
          "type": "counter",
          "description": "Highest active threads in thread pool"
        },
        {
          "name": "gauge.thread_pool.queue",
          "type": "counter",
          "description": "Number of Tasks in thread pool"
        },
        {
          "name": "gauge.thread_pool.threads",
          "type": "counter",
          "description": "Number of Threads in thread pool"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors an etcd key/value store.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-etcd and\nhttps://github.com/signalfx/collectd-etcd\n",
      "package": "internal/monitors/collectd/etcd",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "clusterName",
          "doc": "An arbitrary name of the etcd cluster to make it easier to group together and identify instances.",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "sslKeyFile",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "sslCertificate",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "sslCACerts",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "skipSSLValidation",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "enhancedMetrics",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/etcd",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.etcd.leader.counts.fail",
          "type": "counter",
          "description": "Total number of failed rpc requests to with a follower"
        },
        {
          "name": "counter.etcd.leader.counts.success",
          "type": "counter",
          "description": "Total number of successful rpc requests to with a follower"
        },
        {
          "name": "counter.etcd.self.recvappendreq.cnt",
          "type": "counter",
          "description": "Total number of append requests received by a member"
        },
        {
          "name": "counter.etcd.self.sendappendreq.cnt",
          "type": "counter",
          "description": "Total number of append requests sent by a member"
        },
        {
          "name": "counter.etcd.store.compareanddelete.fail",
          "type": "counter",
          "description": "Total number of failed compare-and-delete operations"
        },
        {
          "name": "counter.etcd.store.compareanddelete.success",
          "type": "counter",
          "description": "Total number of successful compare-and-delete operations"
        },
        {
          "name": "counter.etcd.store.compareandswap.fail",
          "type": "counter",
          "description": "Total number of failed compare-and-swap operations"
        },
        {
          "name": "counter.etcd.store.compareandswap.success",
          "type": "counter",
          "description": "Total number of successful compare-and-swap operations"
        },
        {
          "name": "counter.etcd.store.create.fail",
          "type": "counter",
          "description": "Total number of failed create operations"
        },
        {
          "name": "counter.etcd.store.create.success",
          "type": "counter",
          "description": "Total number of successful create operations"
        },
        {
          "name": "counter.etcd.store.delete.fail",
          "type": "counter",
          "description": "Total number of failed delete operations"
        },
        {
          "name": "counter.etcd.store.delete.success",
          "type": "counter",
          "description": "Total number of successful delete operations"
        },
        {
          "name": "counter.etcd.store.expire.count",
          "type": "counter",
          "description": "Total number of items expired due to TTL"
        },
        {
          "name": "counter.etcd.store.gets.fail",
          "type": "counter",
          "description": "Total number of failed get operations"
        },
        {
          "name": "counter.etcd.store.gets.success",
          "type": "counter",
          "description": "Total number of successful get operations"
        },
        {
          "name": "counter.etcd.store.sets.fail",
          "type": "counter",
          "description": "Total number of failed set operations"
        },
        {
          "name": "counter.etcd.store.sets.success",
          "type": "counter",
          "description": "Total number of successful set operations"
        },
        {
          "name": "counter.etcd.store.update.fail",
          "type": "counter",
          "description": "Total number of failed update operations"
        },
        {
          "name": "counter.etcd.store.update.success",
          "type": "counter",
          "description": "Total number of successful update operations"
        },
        {
          "name": "gauge.etcd.leader.latency.average",
          "type": "gauge",
          "description": "Average latency of a follower with respect to the leader"
        },
        {
          "name": "gauge.etcd.leader.latency.current",
          "type": "gauge",
          "description": "Current latency of a follower with respect to the leader"
        },
        {
          "name": "gauge.etcd.leader.latency.max",
          "type": "gauge",
          "description": "Max latency of a follower with respect to the leader"
        },
        {
          "name": "gauge.etcd.leader.latency.min",
          "type": "gauge",
          "description": "Min latency of a follower with respect to the leader"
        },
        {
          "name": "gauge.etcd.leader.latency.stddev",
          "type": "gauge",
          "description": "Std dev latency of a follower with respect to the leader"
        },
        {
          "name": "gauge.etcd.self.recvbandwidth.rate",
          "type": "gauge",
          "description": "Bandwidth rate of a follower"
        },
        {
          "name": "gauge.etcd.self.recvpkg.rate",
          "type": "gauge",
          "description": "Rate at which a follower receives packages"
        },
        {
          "name": "gauge.etcd.self.sendbandwidth.rate",
          "type": "gauge",
          "description": "Bandwidth rate of a leader"
        },
        {
          "name": "gauge.etcd.self.sendpkg.rate",
          "type": "gauge",
          "description": "Rate at which a leader sends packages"
        },
        {
          "name": "gauge.etcd.store.watchers",
          "type": "gauge",
          "description": "Number of watchers"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors Java services that expose metrics on\nJMX using collectd's GenericJMX plugin.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-genericjmx\nand https://collectd.org/documentation/manpages/collectd-java.5.shtml\n\nExample (gets the thread count from a standard JMX MBean available on all\nJava JMX-enabled apps):\n\n```yaml\n\nmonitors:\n - type: collectd/genericjmx\n   host: my-java-app\n   port: 7099\n   mBeanDefinitions:\n     threading:\n       objectName: java.lang:type=Threading\n       values:\n       - type: gauge\n         table: false\n         instancePrefix: jvm.threads.count\n         attribute: ThreadCount\n```\n",
      "package": "internal/monitors/collectd/genericjmx",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "JMX RMI port on the host",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceName",
          "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceURL",
          "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
          "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "instancePrefix",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "customDimensions",
          "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToCollect",
          "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToOmit",
          "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeanDefinitions",
          "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "struct",
          "elementStruct": {
            "name": "MBean",
            "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
            "package": "internal/monitors/collectd/genericjmx",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instancePrefix",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instanceFrom",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "values",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "MBeanValue",
                  "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                  "package": "internal/monitors/collectd/genericjmx",
                  "fields": [
                    {
                      "yamlName": "type",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "table",
                      "doc": "",
                      "default": false,
                      "required": false,
                      "type": "bool",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instancePrefix",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instanceFrom",
                      "doc": "",
                      "default": null,
                      "required": false,
                      "type": "slice",
                      "elementKind": "string"
                    },
                    {
                      "yamlName": "attribute",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    }
                  ]
                }
              },
              {
                "yamlName": "dimensions",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              }
            ]
          }
        }
      ],
      "monitorType": "collectd/genericjmx",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Collects metrics about a Hadoop cluster using the\n[collectd Hadoop Python plugin](https://github.com/signalfx/collectd-hadoop).\nAlso see\nhttps://github.com/signalfx/integrations/tree/master/collectd-hadoop.\n\nThe `collectd/hadoop` monitor will collect metrics from the Resource Manager\nREST API for the following:\n- Cluster Metrics\n- Cluster Scheduler\n- Cluster Applications\n- Cluster Nodes\n- MapReduce Jobs\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/hadoop\n  host: 127.0.0.1\n  port: 8088\n```\n\nIf a remote JMX port is exposed in the hadoop cluster, then\nyou may also configure the [collectd/hadoopjmx](https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/collectd/hadoopjmx)\nmonitor to collect additional metrics about the hadoop cluster.\n",
      "package": "internal/monitors/collectd/hadoop",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Resource Manager Hostname",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "Resource Manager Port",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "verbose",
          "doc": "Log verbose information about the plugin",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/hadoop",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Collects metrics about a Hadoop cluster using\nusing collectd's GenericJMX plugin.\n\nAlso see\nhttps://github.com/signalfx/integrations/tree/master/collectd-hadoop.\n\n\u003eTo enable JMX in Hadoop, add the following JVM options to hadoop-env.sh and yarn-env.sh respectively\n\n**hadoop-env.sh:**\n```\nexport HADOOP_NAMENODE_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5677 $HADOOP_NAMENODE_OPTS\"\nexport HADOOP_DATANODE_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5679 $HADOOP_DATANODE_OPTS\"\n```\n\n**yarn-env.sh:**\n```\nexport YARN_NODEMANAGER_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5678 $YARN_NODEMANAGER_OPTS\"\nexport YARN_NODEMANAGER_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5678 $YARN_NODEMANAGER_OPTS\"\n```\n\nThis monitor has a set of built in MBeans configured for:\n- [Name Nodes](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/hadoopjmx/nameNodeMBeans.go)\n- [Resource Manager](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/hadoopjmx/resourceManagerMBeans.go)\n- [Node Manager](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/hadoopjmx/nodeManagerMBeans.go)\n- [Data Nodes](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/hadoopjmx/dataNodeMBeans.go)\n\nSample YAML configuration:\n\n\tName Node\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5677\n  nodeType: nameNode\n```\n\n\tResource Manager\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5680\n  nodeType: resourceManager\n```\n\n\tNode Manager\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 8002\n  nodeType: nodeManager\n```\n\n\tData Node\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5679\n  nodeType: dataNode\n```\n\nYou may also configure the [collectd/hadoop](https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/collectd/hadoop)\nmonitor to collect additional metrics about the hadoop cluster from the REST API\n",
      "package": "internal/monitors/collectd/hadoopjmx",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "JMX RMI port on the host",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceName",
          "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceURL",
          "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
          "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "instancePrefix",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "customDimensions",
          "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToCollect",
          "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToOmit",
          "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeanDefinitions",
          "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "struct",
          "elementStruct": {
            "name": "MBean",
            "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
            "package": "internal/monitors/collectd/genericjmx",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instancePrefix",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instanceFrom",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "values",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "MBeanValue",
                  "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                  "package": "internal/monitors/collectd/genericjmx",
                  "fields": [
                    {
                      "yamlName": "type",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "table",
                      "doc": "",
                      "default": false,
                      "required": false,
                      "type": "bool",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instancePrefix",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instanceFrom",
                      "doc": "",
                      "default": null,
                      "required": false,
                      "type": "slice",
                      "elementKind": "string"
                    },
                    {
                      "yamlName": "attribute",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    }
                  ]
                }
              },
              {
                "yamlName": "dimensions",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              }
            ]
          }
        },
        {
          "yamlName": "nodeType",
          "doc": "Hadoop Node Type",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/hadoopjmx",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors an HAProxy instance.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-haproxy.\n",
      "package": "internal/monitors/collectd/haproxy",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": 0,
          "required": false,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "proxiesToMonitor",
          "doc": "",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "excludedMetrics",
          "doc": "",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "enhancedMetrics",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/haproxy",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.connection_total",
          "type": "counter",
          "description": "Cumulative number of connections (frontend). This corresponds to HAProxy's \"conn_tot\" metric."
        },
        {
          "name": "counter.server_selected_total",
          "type": "counter",
          "description": "Number of times a server was selected, either for new sessions or when re-dispatching. This corresponds to HAProxy's \"lbtot\" metric."
        },
        {
          "name": "derive.bytes_in",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `bin` metric -  Bytes in"
        },
        {
          "name": "derive.bytes_out",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `bout` metric -  Bytes out"
        },
        {
          "name": "derive.cli_abrt",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `cli_abrt` metric -  Number of data transfers aborted by the client"
        },
        {
          "name": "derive.comp_byp",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_byp` metric -  Number of bytes that bypassed the HTTP compressor (CPU/BW limit)"
        },
        {
          "name": "derive.comp_in",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_in` metric -  Number of HTTP response bytes fed to the compressor"
        },
        {
          "name": "derive.comp_out",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_out` metric -  Number of HTTP response bytes emitted by the compressor"
        },
        {
          "name": "derive.comp_rsp",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_rsp` metric -  Number of HTTP responses that were compressed"
        },
        {
          "name": "derive.compress_bps_in",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CompressBpsIn` metric."
        },
        {
          "name": "derive.compress_bps_out",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CompressBpsOut` metric."
        },
        {
          "name": "derive.connections",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumConns` metric. Cumulative number of connections."
        },
        {
          "name": "derive.denied_request",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `dreq` metric -  Requests denied because of security concerns. - For tcp this is because of a matched tcp-request content rule."
        },
        {
          "name": "derive.denied_response",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `dresp` metric -  Responses denied because of security concerns. - For http this is because of a matched http-request rule, or"
        },
        {
          "name": "derive.downtime",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `downtime` metric -  Total downtime (in seconds). The value for the backend is the downtime for the whole backend, not the sum of the server downtime."
        },
        {
          "name": "derive.error_connection",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `econ` metric -  Number of requests that encountered an error trying to connect to a backend server. The backend stat is the sum of the stat"
        },
        {
          "name": "derive.error_request",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `ereq` metric -  Request errors."
        },
        {
          "name": "derive.error_response",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `eresp` metric -  Response errors. srv_abrt will be counted here also. Responses denied because of security concerns."
        },
        {
          "name": "derive.failed_checks",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `chkfail` metric -  Number of failed checks. (Only counts checks failed when the server is up.)"
        },
        {
          "name": "derive.redispatched",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `wredis` metric -  Number of times a request was redispatched to another server. The server value counts the number of times that server was"
        },
        {
          "name": "derive.request_total",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `req_tot` metric -  Total number of HTTP requests received"
        },
        {
          "name": "derive.requests",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumReq` metric."
        },
        {
          "name": "derive.response_1xx",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_1xx` metric -  Http responses with 1xx code"
        },
        {
          "name": "derive.response_2xx",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_2xx` metric -  Http responses with 2xx code"
        },
        {
          "name": "derive.response_3xx",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_3xx` metric -  Http responses with 3xx code"
        },
        {
          "name": "derive.response_4xx",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_4xx` metric -  Http responses with 4xx code"
        },
        {
          "name": "derive.response_5xx",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_5xx` metric -  Http responses with 5xx code"
        },
        {
          "name": "derive.response_other",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_other` metric -  Http responses with other codes (protocol error)"
        },
        {
          "name": "derive.retries",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `wretr` metric -  Number of times a connection to a server was retried."
        },
        {
          "name": "derive.session_total",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `stot` metric -  Cumulative number of connections"
        },
        {
          "name": "derive.srv_abrt",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `srv_abrt` metric -  Number of data transfers aborted by the server (inc. in eresp)"
        },
        {
          "name": "derive.ssl_cache_lookups",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `SslCacheLookups` metric."
        },
        {
          "name": "derive.ssl_cache_misses",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `SslCacheMisses` metric."
        },
        {
          "name": "derive.ssl_connections",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumSslConns` metric."
        },
        {
          "name": "derive.uptime_seconds",
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `Uptime_sec` metric."
        },
        {
          "name": "gauge.active_servers",
          "type": "gauge",
          "description": "Number of active servers. This corresponds to HAProxy's \"act\" metric."
        },
        {
          "name": "gauge.backup_servers",
          "type": "gauge",
          "description": "Number of backup servers. This corresponds to HAProxy's \"bck\" metric."
        },
        {
          "name": "gauge.check_duration",
          "type": "gauge",
          "description": "Time in ms took to finish to last health check. This corresponds to HAProxy's \"check_duration\" metric."
        },
        {
          "name": "gauge.connection_rate",
          "type": "gauge",
          "description": "Number of connections over the last elapsed second (frontend). This corresponds to HAProxy's \"conn_rate\" metric."
        },
        {
          "name": "gauge.connection_rate_max",
          "type": "gauge",
          "description": "Highest known connection rate. This corresponds to HAProxy's \"conn_rate_max\" metric."
        },
        {
          "name": "gauge.current_connections",
          "type": "gauge",
          "description": "Current number of connections. Corresponds to HAProxy's `CurrConns` metric."
        },
        {
          "name": "gauge.current_ssl_connections",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `CurrSslConns` metric."
        },
        {
          "name": "gauge.denied_tcp_connections",
          "type": "gauge",
          "description": "Requests denied by 'tcp-request connection' rules. This corresponds to HAProxy's \"dcon\" metric."
        },
        {
          "name": "gauge.denied_tcp_sessions",
          "type": "gauge",
          "description": "Requests denied by 'tcp-request session' rules. This corresponds to HAProxy's \"dses\" metric."
        },
        {
          "name": "gauge.idle_pct",
          "type": "gauge",
          "description": "Corresponds to HAProxy's \"Idle_pct\" metric. Ratio of system polling time versus total time."
        },
        {
          "name": "gauge.intercepted_requests",
          "type": "gauge",
          "description": "Cumulative number of intercepted requests, corresponds to HAProxys metric 'intercepted'"
        },
        {
          "name": "gauge.last_session",
          "type": "gauge",
          "description": "Number of seconds since last session was assigned to server/backend. This corresponds to HAProxy's \"lastsess\" metric."
        },
        {
          "name": "gauge.max_connection_rate",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxConnRate` metric."
        },
        {
          "name": "gauge.max_connections",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxConn` metric."
        },
        {
          "name": "gauge.max_pipes",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxPipes` metric."
        },
        {
          "name": "gauge.max_session_rate",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxSessRate` metric."
        },
        {
          "name": "gauge.max_ssl_connections",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxSslConns` metric."
        },
        {
          "name": "gauge.pipes_free",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `PipesFree` metric."
        },
        {
          "name": "gauge.pipes_used",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `PipesUsed` metric."
        },
        {
          "name": "gauge.queue_current",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `qcur` metric -  Current queued requests. For the backend this reports the number queued without a server assigned."
        },
        {
          "name": "gauge.queue_limit",
          "type": "gauge",
          "description": "Configured max queue for the server, 0 being no limit. Corresponds to HAProxy's \"qlimit\" metric."
        },
        {
          "name": "gauge.queue_max",
          "type": "gauge",
          "description": "Max number of queued requests, queue_current, corresponds to HAProxy's 'qmax' metric."
        },
        {
          "name": "gauge.request_rate",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `req_rate` metric -  HTTP requests per second over last elapsed second"
        },
        {
          "name": "gauge.request_rate_max",
          "type": "gauge",
          "description": "Max number of HTTP requests per second observed. Corresponds to HAProxy's \"req_rate_max\" metric."
        },
        {
          "name": "gauge.run_queue",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `Run_queue` metric."
        },
        {
          "name": "gauge.session_current",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `scur` metric -  Current sessions"
        },
        {
          "name": "gauge.session_rate",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `rate` metric -  Number of sessions per second over last elapsed second"
        },
        {
          "name": "gauge.session_rate_limit",
          "type": "gauge",
          "description": "Configured limit on number of new sessions per second. Corresponds to HAProxy's \"rate_lim\" metric."
        },
        {
          "name": "gauge.session_rate_max",
          "type": "gauge",
          "description": "Max number of new sessions per second"
        },
        {
          "name": "gauge.session_time_average",
          "type": "gauge",
          "description": "Average total session time in ms over the last 1024 requests. Corresponds to HAProxy's \"ttime\" metric."
        },
        {
          "name": "gauge.ssl_backend_key_rate",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslBackendKeyRate` metric."
        },
        {
          "name": "gauge.ssl_frontend_key_rate",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslFrontendKeyRate` metric."
        },
        {
          "name": "gauge.ssl_rate",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslRate` metric."
        },
        {
          "name": "gauge.tasks",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `Tasks` metric."
        },
        {
          "name": "gauge.throttle",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `throttle` metric -  Current throttle percentage for the server, when slowstart is active, or no value if not in slowstart."
        },
        {
          "name": "gauge.zlib_mem_usage",
          "type": "gauge",
          "description": "Corresponds to HAProxy's `ZlibMemUsage` metric."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " A simple Collectd Python-based monitor\nthat hits an endpoint and checks if the configured JSON value is returned in\nthe response body.\n",
      "package": "internal/monitors/collectd/healthchecker",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "path",
          "doc": "The HTTP path that contains a JSON document to verify",
          "default": "/",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "jsonKey",
          "doc": "If `jsonKey` and `jsonVal` are given, the given endpoint will be interpreted as a JSON document and will be expected to contain the given key and value for the service to be considered healthy.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "jsonVal",
          "doc": "This can be either a string or numeric type",
          "default": null,
          "required": false,
          "type": "interface",
          "elementKind": ""
        },
        {
          "yamlName": "useHTTPS",
          "doc": "If true, the endpoint will be connected to on HTTPS instead of plain HTTP.  It is invalid to specify this if `tcpCheck` is true.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "skipSecurity",
          "doc": "If true, and `useHTTPS` is true, the server's SSL/TLS cert will not be verified.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "tcpCheck",
          "doc": "If true, the plugin will verify that it can connect to the given host/port value. JSON checking is not supported.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/health-checker",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Collectd stats about network interfaces on the\nsystem by using the [collectd interface\nplugin](https://collectd.org/wiki/index.php/Plugin:Interface).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-interface)\nfor more information.\n",
      "package": "internal/monitors/collectd/netinterface",
      "fields": [],
      "monitorType": "collectd/interface",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "if_errors.rx",
          "type": "cumulative",
          "description": "Count of receive errors on the interface"
        },
        {
          "name": "if_errors.tx",
          "type": "cumulative",
          "description": "Count of transmit errors on the interface"
        },
        {
          "name": "if_octets.rx",
          "type": "cumulative",
          "description": "Count of bytes (octets) received on the interface"
        },
        {
          "name": "if_octets.tx",
          "type": "cumulative",
          "description": "Count of bytes (octets) transmitted by the interface"
        },
        {
          "name": "if_packets.rx",
          "type": "cumulative",
          "description": "Count of packets received on the interface"
        },
        {
          "name": "if_packets.tx",
          "type": "cumulative",
          "description": "Count of packets transmitted by the interface"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors jenkins by using the\n[jenkins collectd Python\nplugin](https://github.com/signalfx/collectd-jenkins), which collects\nmetrics from jenkins instances\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n```\n\nSample YAML configuration with specific enhanced metrics included\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n  includeMetrics:\n  - \"vm.daemon.count\"\n  - \"vm.terminated.count\"\n```\n\nSample YAML configuration with all enhanced metrics included\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n  enhancedMetrics: true\n```\n",
      "package": "internal/monitors/collectd/jenkins",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "metricsKey",
          "doc": "Key required for collecting metrics.  The access key located at `Manage Jenkins \u003e Configure System \u003e Metrics \u003e ADD.` If empty, click `Generate`.",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "enhancedMetrics",
          "doc": "Whether to enable enhanced metrics",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "includeMetrics",
          "doc": "Used to enable individual enhanced metrics when `enhancedMetrics` is false",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "username",
          "doc": "User with security access to jenkins",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "apiToken",
          "doc": "API Token of the user",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "sslKeyFile",
          "doc": "Path to the keyfile",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "sslCertificate",
          "doc": "Path to the certificate",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "sslCACerts",
          "doc": "Path to the ca file",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/jenkins",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "gauge.jenkins.job.duration",
          "type": "gauge",
          "description": "Time taken to complete the job in ms."
        },
        {
          "name": "gauge.jenkins.node.executor.count.value",
          "type": "gauge",
          "description": "Total Number of executors in an instance"
        },
        {
          "name": "gauge.jenkins.node.executor.in-use.value",
          "type": "gauge",
          "description": "Total number of executors being used in an instance"
        },
        {
          "name": "gauge.jenkins.node.health-check.score",
          "type": "gauge",
          "description": "Mean health score of an instance"
        },
        {
          "name": "gauge.jenkins.node.health.disk.space",
          "type": "gauge",
          "description": "Binary value of disk space health"
        },
        {
          "name": "gauge.jenkins.node.health.plugins",
          "type": "gauge",
          "description": "Boolean value indicating state of plugins"
        },
        {
          "name": "gauge.jenkins.node.health.temporary.space",
          "type": "gauge",
          "description": "Binary value of temporary space health"
        },
        {
          "name": "gauge.jenkins.node.health.thread-deadlock",
          "type": "gauge",
          "description": "Boolean value indicating a deadlock"
        },
        {
          "name": "gauge.jenkins.node.online.status",
          "type": "gauge",
          "description": "Boolean value of instance is reachable or not"
        },
        {
          "name": "gauge.jenkins.node.queue.size.value",
          "type": "gauge",
          "description": "Total number pending jobs in queue"
        },
        {
          "name": "gauge.jenkins.node.slave.online.status",
          "type": "gauge",
          "description": "Boolean value for slave is reachable or not"
        },
        {
          "name": "gauge.jenkins.node.vm.memory.heap.usage",
          "type": "gauge",
          "description": "Percent utilization of the heap memory"
        },
        {
          "name": "gauge.jenkins.node.vm.memory.non-heap.used",
          "type": "gauge",
          "description": "Total amount of non-heap memory used"
        },
        {
          "name": "gauge.jenkins.node.vm.memory.total.used",
          "type": "gauge",
          "description": "Total Memory used by instance"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors a Kafka instance using collectd's\nGenericJMX plugin.\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/kafka/mbeans.go)\nfor which it pulls metrics from Kafka's JMX endpoint.\n\nNote that this monitor supports Kafka v0.8.2.x and above. For Kafka v1.x.x and above,\napart from the list of default metrics, kafka.server:type=ZooKeeperClientMetrics,name=ZooKeeperRequestLatencyMs\nis a good metric to monitor since it gives an understanding of how long brokers wait for\nrequests to Zookeeper to be completed. Since Zookeeper is an integral part of a Kafka cluster,\nmonitoring it using the [Zookeeper\nmonitor] (https://docs.signalfx.com/en/latest/integrations/agent/monitors/collectd-zookeeper.html)\nis recommended. It is also a good idea to monitor disk utilization and network metrics of\nthe underlying host.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-kafka.\n",
      "package": "internal/monitors/collectd/kafka",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "JMX RMI port on the host",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceName",
          "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceURL",
          "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
          "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "instancePrefix",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "customDimensions",
          "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToCollect",
          "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToOmit",
          "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeanDefinitions",
          "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "struct",
          "elementStruct": {
            "name": "MBean",
            "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
            "package": "internal/monitors/collectd/genericjmx",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instancePrefix",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instanceFrom",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "values",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "MBeanValue",
                  "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                  "package": "internal/monitors/collectd/genericjmx",
                  "fields": [
                    {
                      "yamlName": "type",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "table",
                      "doc": "",
                      "default": false,
                      "required": false,
                      "type": "bool",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instancePrefix",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instanceFrom",
                      "doc": "",
                      "default": null,
                      "required": false,
                      "type": "slice",
                      "elementKind": "string"
                    },
                    {
                      "yamlName": "attribute",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    }
                  ]
                }
              },
              {
                "yamlName": "dimensions",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              }
            ]
          }
        },
        {
          "yamlName": "clusterName",
          "doc": "Cluster name to which the broker belongs",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/kafka",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.kafka-all-bytes-in",
          "type": "cumulative",
          "description": "Number of bytes received per second across all topics"
        },
        {
          "name": "counter.kafka-all-bytes-out",
          "type": "cumulative",
          "description": "Number of bytes transmitted per second across all topics"
        },
        {
          "name": "counter.kafka-log-flushes",
          "type": "cumulative",
          "description": "Number of log flushes per second"
        },
        {
          "name": "counter.kafka-messages-in",
          "type": "cumulative",
          "description": "Number of messages received per second across all topics"
        },
        {
          "name": "counter.kafka.fetch-consumer.total-time.count",
          "type": "cumulative",
          "description": "Number of fetch requests from consumers per second across all partitions"
        },
        {
          "name": "counter.kafka.fetch-follower.total-time.count",
          "type": "cumulative",
          "description": "Number of fetch requests from followers per second across all partitions"
        },
        {
          "name": "counter.kafka.produce.total-time.99th",
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process produce requests"
        },
        {
          "name": "counter.kafka.produce.total-time.count",
          "type": "cumulative",
          "description": "Number of producer requests"
        },
        {
          "name": "counter.kafka.produce.total-time.median",
          "type": "gauge",
          "description": "Median time it takes to process a produce request"
        },
        {
          "name": "gauge.kafka-active-controllers",
          "type": "gauge",
          "description": "Specifies if the broker an active controller"
        },
        {
          "name": "gauge.kafka-log-flush-time-ms",
          "type": "gauge",
          "description": "Average number of milliseconds to flush a log"
        },
        {
          "name": "gauge.kafka-log-flush-time-ms-p95",
          "type": "gauge",
          "description": "95th percentile of log flush time in milliseconds"
        },
        {
          "name": "gauge.kafka-request-queue",
          "type": "gauge",
          "description": "Number of requests in the request queue across all partitions on the broker"
        },
        {
          "name": "gauge.kafka-underreplicated-partitions",
          "type": "gauge",
          "description": "Number of underreplicated partitions across all topics on the broker"
        },
        {
          "name": "gauge.kafka.fetch-consumer.total-time.99th",
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process fetch requests from consumers"
        },
        {
          "name": "gauge.kafka.fetch-consumer.total-time.median",
          "type": "gauge",
          "description": "Median time it takes to process a fetch request from consumers"
        },
        {
          "name": "gauge.kafka.fetch-follower.total-time.99th",
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process fetch requests from followers"
        },
        {
          "name": "gauge.kafka.fetch-follower.total-time.median",
          "type": "gauge",
          "description": "Median time it takes to process a fetch request from follower"
        },
        {
          "name": "kafka-isr-expands",
          "type": "cumulative",
          "description": "When a broker is brought up after a failure, it starts catching up by reading from the leader. Once it is caught up, it gets added back to the ISR."
        },
        {
          "name": "kafka-isr-shrinks",
          "type": "cumulative",
          "description": "When a broker goes down, ISR for some of partitions will shrink. When that broker is up again, ISR will be expanded once the replicas are fully caught up. Other than that, the expected value for both ISR shrink rate and expansion rate is 0."
        },
        {
          "name": "kafka-leader-election-rate",
          "type": "cumulative",
          "description": "Number of leader elections"
        },
        {
          "name": "kafka-max-lag",
          "type": "gauge",
          "description": "Maximum lag in messages between the follower and leader replicas"
        },
        {
          "name": "kafka-offline-partitions-count",
          "type": "gauge",
          "description": "Number of partitions that don’t have an active leader and are hence not writable or readable"
        },
        {
          "name": "kafka-unclean-elections",
          "type": "cumulative",
          "description": "Number of unclean leader elections. This happens when a leader goes down and an out-of-sync replica is chosen to be the leader"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors a Java based Kafka consumer using GenericJMX.\n\nSee the [integration documentation](https://github.com/signalfx/integrations/tree/master/collectd-kafka)\nfor more information.\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/kafkaconsumer/mbeans.go)\nfor which it pulls metrics from the Kafka consumer's JMX endpoint.\n\nSample YAML configuration:\n```yaml\nmonitors:\n  - type: collectd/kafka_consumer\n    host: localhost\n    port: 9099\n    mBeansToOmit:\n      - fetch-size-avg-per-topic\n```\n\nNote that this monitor requires Kafka v0.9.0.0 or above and collects metrics from the new consumer API.\nAlso, per-topic metrics that are collected by default are not available through the new consumer API in\nv0.9.0.0 which can cause the logs to flood with warnings related to the MBean not being found.\nUse the `mBeansToOmit` config option in such cases. The above example configuration will not attempt to\ncollect the MBean referenced by `fetch-size-avg-per-topic`. Here is a\n[list](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/kafkaconsumer/mbeans.go)\nof metrics collected by default\n",
      "package": "internal/monitors/collectd/kafkaconsumer",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "JMX RMI port on the host",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceName",
          "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceURL",
          "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
          "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "instancePrefix",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "customDimensions",
          "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToCollect",
          "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToOmit",
          "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeanDefinitions",
          "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "struct",
          "elementStruct": {
            "name": "MBean",
            "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
            "package": "internal/monitors/collectd/genericjmx",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instancePrefix",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instanceFrom",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "values",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "MBeanValue",
                  "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                  "package": "internal/monitors/collectd/genericjmx",
                  "fields": [
                    {
                      "yamlName": "type",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "table",
                      "doc": "",
                      "default": false,
                      "required": false,
                      "type": "bool",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instancePrefix",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instanceFrom",
                      "doc": "",
                      "default": null,
                      "required": false,
                      "type": "slice",
                      "elementKind": "string"
                    },
                    {
                      "yamlName": "attribute",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    }
                  ]
                }
              },
              {
                "yamlName": "dimensions",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              }
            ]
          }
        }
      ],
      "monitorType": "collectd/kafka_consumer",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "kafka.consumer.bytes-consumed-rate",
          "type": "gauge",
          "description": "Average number of bytes consumed per second. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter."
        },
        {
          "name": "kafka.consumer.fetch-rate",
          "type": "gauge",
          "description": "Number of records consumed per second."
        },
        {
          "name": "kafka.consumer.fetch-size-avg",
          "type": "gauge",
          "description": "Average number of bytes fetched per request. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter."
        },
        {
          "name": "kafka.consumer.records-consumed-rate",
          "type": "gauge",
          "description": "Average number of records consumed per second. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter."
        },
        {
          "name": "kafka.consumer.records-lag-max",
          "type": "gauge",
          "description": "Maximum lag in of records for any partition in this window. An increasing value over time is your best indication that the consumer group is not keeping up with the producers."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors a Java based Kafka producer using GenericJMX.\n\nSee the [integration documentation](https://github.com/signalfx/integrations/tree/master/collectd-kafka)\nfor more information.\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/kafkaproducer/mbeans.go)\nfor which it pulls metrics from the Kafka producer's JMX endpoint.\n\nSample YAML configuration:\n```yaml\nmonitors:\n  - type: collectd/kafka_producer\n    host: localhost\n    port: 8099\n```\n\nNote that this monitor requires Kafka v0.9.0.0 or above and collects metrics from the new producer API.\n",
      "package": "internal/monitors/collectd/kafkaproducer",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "JMX RMI port on the host",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceName",
          "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceURL",
          "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
          "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "instancePrefix",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "customDimensions",
          "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToCollect",
          "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeansToOmit",
          "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "mBeanDefinitions",
          "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "struct",
          "elementStruct": {
            "name": "MBean",
            "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
            "package": "internal/monitors/collectd/genericjmx",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instancePrefix",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "instanceFrom",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "values",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "MBeanValue",
                  "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                  "package": "internal/monitors/collectd/genericjmx",
                  "fields": [
                    {
                      "yamlName": "type",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "table",
                      "doc": "",
                      "default": false,
                      "required": false,
                      "type": "bool",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instancePrefix",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instanceFrom",
                      "doc": "",
                      "default": null,
                      "required": false,
                      "type": "slice",
                      "elementKind": "string"
                    },
                    {
                      "yamlName": "attribute",
                      "doc": "",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    }
                  ]
                }
              },
              {
                "yamlName": "dimensions",
                "doc": "",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              }
            ]
          }
        }
      ],
      "monitorType": "collectd/kafka_producer",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "kafka.producer.byte-rate",
          "type": "gauge",
          "description": "Average number of bytes sent per second for a topic. This metric has client-id and topic dimensions."
        },
        {
          "name": "kafka.producer.compression-rate",
          "type": "gauge",
          "description": "Average compression rate of record batches for a topic. This metric has client-id and topic dimensions."
        },
        {
          "name": "kafka.producer.io-wait-time-ns-avg",
          "type": "gauge",
          "description": "Average length of time the I/O thread spent waiting for a socket ready for reads or writes in nanoseconds. This metric has client-id dimension."
        },
        {
          "name": "kafka.producer.outgoing-byte-rate",
          "type": "gauge",
          "description": "Average number of outgoing bytes sent per second to all servers. This metric has client-id dimension."
        },
        {
          "name": "kafka.producer.record-error-rate",
          "type": "gauge",
          "description": "Average per-second number of record sends that resulted in errors for a topic. This metric has client-id and topic dimensions."
        },
        {
          "name": "kafka.producer.record-retry-rate",
          "type": "gauge",
          "description": "Average per-second number of retried record sends for a topic. This metric has client-id and topic dimensions."
        },
        {
          "name": "kafka.producer.record-send-rate",
          "type": "gauge",
          "description": "Average number of records sent per second for a topic. This metric has client-id and topic dimensions."
        },
        {
          "name": "kafka.producer.request-latency-avg",
          "type": "gauge",
          "description": "Average request latency in ms. Time it takes on average for the producer to get responses from the broker. This metric has client-id dimension."
        },
        {
          "name": "kafka.producer.request-rate",
          "type": "gauge",
          "description": "Average number of requests sent per second. This metric has client-id dimension."
        },
        {
          "name": "kafka.producer.response-rate",
          "type": "gauge",
          "description": "Average number of responses received per second. This metric has client-id dimension."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors a Kong instance using [collectd-kong](https://github.com/signalfx/collectd-kong).\n\nSee the [integration documentation](https://github.com/signalfx/integrations/tree/master/collectd-kong)\nfor more information.\n\nThe `metrics` field below is populated with a set of metrics that are\ndescribed at https://github.com/signalfx/collectd-kong/blob/master/README.md.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n  - type: collectd/kong\n    host: 127.0.0.1\n    port: 8001\n    metrics:\n      - metric: request_latency\n        report: true\n      - metric: connections_accepted\n        report: false\n```\n\nSample YAML configuration with custom /signalfx route and white and blacklists\n\n```yaml\nmonitors:\n  - type: collectd/kong\n    host: 127.0.0.1\n    port: 8443\n    url: https://127.0.0.1:8443/routed_signalfx\n    authHeader:\n      header: Authorization\n      value: HeaderValue\n    metrics:\n      - metric: request_latency\n        report: true\n    reportStatusCodeGroups: true\n    statusCodes:\n      - 202\n      - 403\n      - 405\n      - 419\n      - \"5*\"\n    serviceNamesBlacklist:\n      - \"*SomeService*\"\n```\n",
      "package": "internal/monitors/collectd/kong",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Kong host to connect with (used for autodiscovery and URL)",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "Port for kong-plugin-signalfx hosting server (used for autodiscovery and URL)",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "Registration name when using multiple instances in Smart Agent",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "url",
          "doc": "kong-plugin-signalfx metric plugin",
          "default": "http://{{.Host}}:{{.Port}}/signalfx",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "authHeader",
          "doc": "Header and its value to use for requests to SFx metric endpoint",
          "default": null,
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "Header",
            "doc": "Header defines name/value pair for AuthHeader option",
            "package": "internal/monitors/collectd/kong",
            "fields": [
              {
                "yamlName": "header",
                "doc": "Name of header to include with GET",
                "default": null,
                "required": true,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "value",
                "doc": "Value of header",
                "default": null,
                "required": true,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "verifyCerts",
          "doc": "Whether to verify certificates when using ssl/tls",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "caBundle",
          "doc": "CA Bundle file or directory",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "clientCert",
          "doc": "Client certificate file (with or without included key)",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "clientCertKey",
          "doc": "Client cert key if not bundled with clientCert",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "verbose",
          "doc": "Whether to use debug logging for collectd-kong",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "metrics",
          "doc": "List of metric names and report flags. See monitor description for more details.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "Metric",
            "doc": "Metric is for use with `Metric \"metric_name\" bool` collectd plugin format",
            "package": "internal/monitors/collectd/kong",
            "fields": [
              {
                "yamlName": "metric",
                "doc": "Name of metric, per collectd-kong",
                "default": null,
                "required": true,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "report",
                "doc": "Whether to report this metric",
                "default": null,
                "required": true,
                "type": "bool",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "reportApiIds",
          "doc": "Report metrics for distinct API IDs where applicable",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "reportApiNames",
          "doc": "Report metrics for distinct API names where applicable",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "reportServiceIds",
          "doc": "Report metrics for distinct Service IDs where applicable",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "reportServiceNames",
          "doc": "Report metrics for distinct Service names where applicable",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "reportRouteIds",
          "doc": "Report metrics for distinct Route IDs where applicable",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "reportHttpMethods",
          "doc": "Report metrics for distinct HTTP methods where applicable",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "reportStatusCodeGroups",
          "doc": "Report metrics for distinct HTTP status code groups (eg. \"5xx\") where applicable",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "reportStatusCodes",
          "doc": "Report metrics for distinct HTTP status codes where applicable (mutually exclusive with ReportStatusCodeGroups)",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "apiIds",
          "doc": "List of API ID patterns to report distinct metrics for, if reportApiIds is false",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "apiIdsBlacklist",
          "doc": "List of API ID patterns to not report distinct metrics for, if reportApiIds is true or apiIds are specified",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "apiNames",
          "doc": "List of API name patterns to report distinct metrics for, if reportApiNames is false",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "apiNamesBlacklist",
          "doc": "List of API name patterns to not report distinct metrics for, if reportApiNames is true or apiNames are specified",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "serviceIds",
          "doc": "List of Service ID patterns to report distinct metrics for, if reportServiceIds is false",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "serviceIdsBlacklist",
          "doc": "List of Service ID patterns to not report distinct metrics for, if reportServiceIds is true or serviceIds are specified",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "serviceNames",
          "doc": "List of Service name patterns to report distinct metrics for, if reportServiceNames is false",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "serviceNamesBlacklist",
          "doc": "List of Service name patterns to not report distinct metrics for, if reportServiceNames is true or serviceNames are specified",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "routeIds",
          "doc": "List of Route ID patterns to report distinct metrics for, if reportRouteIds is false",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "routeIdsBlacklist",
          "doc": "List of Route ID patterns to not report distinct metrics for, if reportRouteIds is true or routeIds are specified",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "httpMethods",
          "doc": "List of HTTP method patterns to report distinct metrics for, if reportHttpMethods is false",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "httpMethodsBlacklist",
          "doc": "List of HTTP method patterns to not report distinct metrics for, if reportHttpMethods is true or httpMethods are specified",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "statusCodes",
          "doc": "List of HTTP status code patterns to report distinct metrics for, if reportStatusCodes is false",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "statusCodesBlacklist",
          "doc": "List of HTTP status code patterns to not report distinct metrics for, if reportStatusCodes is true or statusCodes are specified",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        }
      ],
      "monitorType": "collectd/kong",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.kong.connections.accepted",
          "type": "cumulative",
          "description": "Total number of all accepted connections."
        },
        {
          "name": "counter.kong.connections.handled",
          "type": "cumulative",
          "description": "Total number of all handled connections (accounting for resource limits)."
        },
        {
          "name": "counter.kong.kong.latency",
          "type": "cumulative",
          "description": "Time spent in Kong request handling and balancer (ms)."
        },
        {
          "name": "counter.kong.requests.count",
          "type": "cumulative",
          "description": "Total number of all requests made to Kong API and proxy server."
        },
        {
          "name": "counter.kong.requests.latency",
          "type": "cumulative",
          "description": "Time elapsed between the first bytes being read from each client request and the log writes after the last bytes were sent to the clients (ms)."
        },
        {
          "name": "counter.kong.requests.size",
          "type": "cumulative",
          "description": "Total bytes received/proxied from client requests."
        },
        {
          "name": "counter.kong.responses.count",
          "type": "cumulative",
          "description": "Total number of responses provided to clients."
        },
        {
          "name": "counter.kong.responses.size",
          "type": "cumulative",
          "description": "Total bytes sent/proxied to clients."
        },
        {
          "name": "counter.kong.upstream.latency",
          "type": "cumulative",
          "description": "Time spent waiting for upstream response (ms)."
        },
        {
          "name": "gauge.kong.connections.active",
          "type": "gauge",
          "description": "The current number of active client connections (includes waiting)."
        },
        {
          "name": "gauge.kong.connections.reading",
          "type": "gauge",
          "description": "The current number of connections where nginx is reading the request header."
        },
        {
          "name": "gauge.kong.connections.waiting",
          "type": "gauge",
          "description": "The current number of idle client connections waiting for a request."
        },
        {
          "name": "gauge.kong.connections.writing",
          "type": "gauge",
          "description": "The current number of connections where nginx is writing the response back to the client."
        },
        {
          "name": "gauge.kong.database.reachable",
          "type": "gauge",
          "description": "kong.dao:db.reachable() at time of metric query"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors process load on the host using the collectd\n[Load plugin](https://collectd.org/wiki/index.php/Plugin:Load).\n",
      "package": "internal/monitors/collectd/load",
      "fields": [],
      "monitorType": "collectd/load",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "load.longterm",
          "type": "gauge",
          "description": "Average CPU load per core over the last 15 minutes"
        },
        {
          "name": "load.midterm",
          "type": "gauge",
          "description": "Average CPU load per core over the last five minutes"
        },
        {
          "name": "load.shortterm",
          "type": "gauge",
          "description": "Average CPU load per core over the last one minute"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors a Mesos Marathon instance using the\n[collectd Marathon Python plugin](https://github.com/signalfx/collectd-marathon).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-marathon)\nfor more information on configuration.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n  - type: collectd/marathon\n    host: 127.0.0.1\n    port: 8080\n    scheme: http\n```\n\nSample YAML configuration for DC/OS:\n\n```yaml\nmonitors:\n  - type: collectd/marathon\n    host: 127.0.0.1\n    port: 8080\n    scheme: https\n    dcosAuthURL: https://leader.mesos/acs/api/v1/auth/login\n```\n",
      "package": "internal/monitors/collectd/marathon",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "Username used to authenticate with Marathon.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "Password used to authenticate with Marathon.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "scheme",
          "doc": "Set to either `http` or `https`.",
          "default": "http",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "dcosAuthURL",
          "doc": "The dcos authentication URL which the plugin uses to get authentication tokens from. Set scheme to \"https\" if operating DC/OS in strict mode and dcosAuthURL to \"https://leader.mesos/acs/api/v1/auth/login\" (which is the default DNS entry provided by DC/OS)",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/marathon",
      "acceptsEndpoints": true,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "gauge.marathon-api-metric",
          "type": "gauge",
          "description": "Metrics reported by the Marathon Metrics API"
        },
        {
          "name": "gauge.marathon.app.cpu.allocated",
          "type": "gauge",
          "description": "Number of CPUs allocated to an application"
        },
        {
          "name": "gauge.marathon.app.cpu.allocated.per.instance",
          "type": "gauge",
          "description": "Configured number of CPUs allocated to each application instance"
        },
        {
          "name": "gauge.marathon.app.delayed",
          "type": "gauge",
          "description": "Indicates if the application is delayed or not"
        },
        {
          "name": "gauge.marathon.app.deployments.total",
          "type": "gauge",
          "description": "Number of application deployments"
        },
        {
          "name": "gauge.marathon.app.disk.allocated",
          "type": "gauge",
          "description": "Storage allocated to a Marathon application"
        },
        {
          "name": "gauge.marathon.app.disk.allocated.per.instance",
          "type": "gauge",
          "description": "Configured storage allocated each to application instance"
        },
        {
          "name": "gauge.marathon.app.gpu.allocated",
          "type": "gauge",
          "description": "GPU Allocated to a Marathon application"
        },
        {
          "name": "gauge.marathon.app.gpu.allocated.per.instance",
          "type": "gauge",
          "description": "Configured number of GPUs allocated to each application instance"
        },
        {
          "name": "gauge.marathon.app.instances.total",
          "type": "gauge",
          "description": "Number of application instances"
        },
        {
          "name": "gauge.marathon.app.memory.allocated",
          "type": "gauge",
          "description": "Memory Allocated to a Marathon application"
        },
        {
          "name": "gauge.marathon.app.memory.allocated.per.instance",
          "type": "gauge",
          "description": "Configured amount of memory allocated to each application instance"
        },
        {
          "name": "gauge.marathon.app.tasks.running",
          "type": "gauge",
          "description": "Number tasks running for an application"
        },
        {
          "name": "gauge.marathon.app.tasks.staged",
          "type": "gauge",
          "description": "Number tasks staged for an application"
        },
        {
          "name": "gauge.marathon.app.tasks.unhealthy",
          "type": "gauge",
          "description": "Number unhealthy tasks for an application"
        },
        {
          "name": "gauge.marathon.task.healthchecks.failing.total",
          "type": "gauge",
          "description": "The number of failing health checks for a task"
        },
        {
          "name": "gauge.marathon.task.healthchecks.passing.total",
          "type": "gauge",
          "description": "The number of passing health checks for a task"
        },
        {
          "name": "gauge.marathon.task.staged.time.elapsed",
          "type": "gauge",
          "description": "The amount of time the task spent in staging"
        },
        {
          "name": "gauge.marathon.task.start.time.elapsed",
          "type": "gauge",
          "description": "Time elapsed since the task started"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors an instance of memcached using the\n[collectd memcached\nplugin](https://collectd.org/wiki/index.php/Plugin:memcached).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-memcached)\nfor more information.\n",
      "package": "internal/monitors/collectd/memcached",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "reportHost",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/memcached",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "df.cache.free",
          "type": "gauge",
          "description": "Unused storage bytes"
        },
        {
          "name": "df.cache.used",
          "type": "gauge",
          "description": "Current number of bytes used to store items"
        },
        {
          "name": "memcached_command.flush",
          "type": "cumulative",
          "description": "Number of flush requests"
        },
        {
          "name": "memcached_command.get",
          "type": "cumulative",
          "description": "Number of retrieval requests"
        },
        {
          "name": "memcached_command.set",
          "type": "cumulative",
          "description": "Number of storage requests"
        },
        {
          "name": "memcached_command.touch",
          "type": "cumulative",
          "description": "Number of touch requests"
        },
        {
          "name": "memcached_connections.current",
          "type": "gauge",
          "description": "Current number of open connections"
        },
        {
          "name": "memcached_connections.listen_disabled",
          "type": "gauge",
          "description": "Number of times connection limit has been exceeded"
        },
        {
          "name": "memcached_items.current",
          "type": "gauge",
          "description": "Current number of items stored by this instance"
        },
        {
          "name": "memcached_octets.rx",
          "type": "cumulative",
          "description": "Total network bytes read by this server"
        },
        {
          "name": "memcached_octets.tx",
          "type": "cumulative",
          "description": "Total network bytes written by this server"
        },
        {
          "name": "memcached_ops.decr_hits",
          "type": "cumulative",
          "description": "Number of successful Decr requests"
        },
        {
          "name": "memcached_ops.decr_misses",
          "type": "cumulative",
          "description": "Number of decr requests against missing keys"
        },
        {
          "name": "memcached_ops.evictions",
          "type": "cumulative",
          "description": "Number of valid items removed from cache"
        },
        {
          "name": "memcached_ops.hits",
          "type": "cumulative",
          "description": "Number of keys that have been requested and found present"
        },
        {
          "name": "memcached_ops.incr_hits",
          "type": "cumulative",
          "description": "Number of successful incr requests"
        },
        {
          "name": "memcached_ops.incr_misses",
          "type": "cumulative",
          "description": "Number of incr requests against missing keys"
        },
        {
          "name": "memcached_ops.misses",
          "type": "cumulative",
          "description": "Number of items that have been requested and not found"
        },
        {
          "name": "ps_count.threads",
          "type": "gauge",
          "description": "Number of worker threads requested"
        },
        {
          "name": "ps_cputime.syst",
          "type": "cumulative",
          "description": "Total system time for this instance"
        },
        {
          "name": "ps_cputime.user",
          "type": "cumulative",
          "description": "Total user time for this instance"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Sends memory usage stats for the underlying host.\nSee https://collectd.org/wiki/index.php/Plugin:Memory\n",
      "package": "internal/monitors/collectd/memory",
      "fields": [],
      "monitorType": "collectd/memory",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "memory.buffered",
          "type": "gauge",
          "description": "Bytes of memory used for buffering I/O"
        },
        {
          "name": "memory.cached",
          "type": "gauge",
          "description": "Bytes of memory used for disk caching"
        },
        {
          "name": "memory.free",
          "type": "gauge",
          "description": "Bytes of memory available for use"
        },
        {
          "name": "memory.slab_recl",
          "type": "gauge",
          "description": "Bytes of memory, used for SLAB-allocation of kernel objects, that can be reclaimed."
        },
        {
          "name": "memory.slab_unrecl",
          "type": "gauge",
          "description": "Bytes of memory, used for SLAB-allocation of kernel objects, that can't be reclaimed"
        },
        {
          "name": "memory.used",
          "type": "gauge",
          "description": "Bytes of memory in use by the system."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors an instance of MongoDB using the\n[collectd MongoDB Python plugin](https://github.com/signalfx/collectd-mongodb).\n\nAlso see https://github.com/signalfx/integrations/tree/master/collectd-mongodb.\n",
      "package": "internal/monitors/collectd/mongodb",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "databases",
          "doc": "",
          "default": null,
          "required": true,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "useTLS",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "caCerts",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "tlsClientCert",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "tlsClientKey",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "tlsClientKeyPassPhrase",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/mongodb",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": [
        {
          "name": "plugin_instance",
          "description": "Port number of the MongoDB instance"
        }
      ],
      "metrics": [
        {
          "name": "counter.backgroundFlushing.flushes",
          "type": "gauge",
          "description": "Number of times the database has been flushed"
        },
        {
          "name": "counter.collection.commandsCount",
          "type": "counter",
          "description": "Number of commands issued for a collection"
        },
        {
          "name": "counter.collection.commandsTime",
          "type": "counter",
          "description": "Time spent in microseconds processing commands issued for a collection"
        },
        {
          "name": "counter.collection.getmoreCount",
          "type": "counter",
          "description": "Number of getMore requests issued for a collection"
        },
        {
          "name": "counter.collection.getmoreTime",
          "type": "counter",
          "description": "Time spent in microseconds processing getMore requests for a collection"
        },
        {
          "name": "counter.collection.index.accesses.ops",
          "type": "counter",
          "description": "Number of times an index has been used (only on Mongo 3.2+)"
        },
        {
          "name": "counter.collection.insertCount",
          "type": "counter",
          "description": "Number of inserts issued for a collection"
        },
        {
          "name": "counter.collection.insertTime",
          "type": "counter",
          "description": "Time spent in microseconds processing insert requests for a collection"
        },
        {
          "name": "counter.collection.queriesCount",
          "type": "counter",
          "description": "Number of queries issued for a collection"
        },
        {
          "name": "counter.collection.queriesTime",
          "type": "counter",
          "description": "Time spent in microseconds processing query requests for a collection"
        },
        {
          "name": "counter.collection.readLockCount",
          "type": "counter",
          "description": "Number of read locks issued for a collection"
        },
        {
          "name": "counter.collection.readLockTime",
          "type": "counter",
          "description": "Time spent in microseconds processing read locks for a collection"
        },
        {
          "name": "counter.collection.removeCount",
          "type": "counter",
          "description": "Number of remove requests issued for a collection"
        },
        {
          "name": "counter.collection.removeTime",
          "type": "counter",
          "description": "Time spent in microseconds processing remove requests for a collection"
        },
        {
          "name": "counter.collection.totalCount",
          "type": "counter",
          "description": "Total number of operations issued for a collection"
        },
        {
          "name": "counter.collection.totalTime",
          "type": "counter",
          "description": "Time spent in microseconds processing all operations for a collection"
        },
        {
          "name": "counter.collection.updateCount",
          "type": "counter",
          "description": "Number of update requests issued for a collection"
        },
        {
          "name": "counter.collection.updateTime",
          "type": "counter",
          "description": "Time spent in microseconds processing update requests for a collection"
        },
        {
          "name": "counter.collection.writeLockCount",
          "type": "counter",
          "description": "Number of write locks issued for a collection"
        },
        {
          "name": "counter.collection.writeLockTime",
          "type": "counter",
          "description": "Time spent in microseconds processing write locks for a collection"
        },
        {
          "name": "counter.extra_info.page_faults",
          "type": "gauge",
          "description": "Mongod page faults"
        },
        {
          "name": "counter.network.bytesIn",
          "type": "gauge",
          "description": "Network bytes received by the database server"
        },
        {
          "name": "counter.network.bytesOut",
          "type": "gauge",
          "description": "Network bytes sent by the database server"
        },
        {
          "name": "counter.network.numRequests",
          "type": "cumulative",
          "description": "Requests received by the server"
        },
        {
          "name": "counter.opcounters.delete",
          "type": "cumulative",
          "description": "Number of deletes per second"
        },
        {
          "name": "counter.opcounters.insert",
          "type": "cumulative",
          "description": "Number of inserts per second"
        },
        {
          "name": "counter.opcounters.query",
          "type": "cumulative",
          "description": "Number of queries per second"
        },
        {
          "name": "counter.opcounters.update",
          "type": "cumulative",
          "description": "Number of updates per second"
        },
        {
          "name": "gauge.backgroundFlushing.average_ms",
          "type": "gauge",
          "description": "Average time (ms) to write data to disk"
        },
        {
          "name": "gauge.backgroundFlushing.last_ms",
          "type": "gauge",
          "description": "Most recent time (ms) spent writing data to disk"
        },
        {
          "name": "gauge.collection.avgObjSize",
          "type": "gauge",
          "description": "Mean object/document size of a collection"
        },
        {
          "name": "gauge.collection.count",
          "type": "gauge",
          "description": "Number of objects/documents in a collection"
        },
        {
          "name": "gauge.collection.indexSize",
          "type": "gauge",
          "description": "Size of a particular index on a collection"
        },
        {
          "name": "gauge.collection.max",
          "type": "gauge",
          "description": "Maximum number of documents in a capped collection"
        },
        {
          "name": "gauge.collection.maxSize",
          "type": "gauge",
          "description": "Maximum disk usage of a capped collection"
        },
        {
          "name": "gauge.collection.size",
          "type": "gauge",
          "description": "Size of a collection in bytes, not including indexes"
        },
        {
          "name": "gauge.collection.storageSize",
          "type": "gauge",
          "description": "Size of the collection on disk in bytes, never decreases."
        },
        {
          "name": "gauge.collections",
          "type": "gauge",
          "description": "Number of collections"
        },
        {
          "name": "gauge.connections.available",
          "type": "gauge",
          "description": "Number of available incoming connections"
        },
        {
          "name": "gauge.connections.current",
          "type": "gauge",
          "description": "Number of current client connections"
        },
        {
          "name": "gauge.dataSize",
          "type": "gauge",
          "description": "Total size of data, in bytes"
        },
        {
          "name": "gauge.extra_info.heap_usage_bytes",
          "type": "gauge",
          "description": "Heap size used by the mongod process, in bytes"
        },
        {
          "name": "gauge.globalLock.activeClients.readers",
          "type": "gauge",
          "description": "Number of active client connections performing reads"
        },
        {
          "name": "gauge.globalLock.activeClients.total",
          "type": "gauge",
          "description": "Total number of active client connections"
        },
        {
          "name": "gauge.globalLock.activeClients.writers",
          "type": "gauge",
          "description": "Number of active client connections performing writes"
        },
        {
          "name": "gauge.globalLock.currentQueue.readers",
          "type": "gauge",
          "description": "Read operations currently in queue"
        },
        {
          "name": "gauge.globalLock.currentQueue.total",
          "type": "gauge",
          "description": "Total operations currently in queue"
        },
        {
          "name": "gauge.globalLock.currentQueue.writers",
          "type": "gauge",
          "description": "Write operations currently in queue"
        },
        {
          "name": "gauge.indexSize",
          "type": "gauge",
          "description": "Total size of indexes, in bytes"
        },
        {
          "name": "gauge.indexes",
          "type": "gauge",
          "description": "Number of indexes across all collections"
        },
        {
          "name": "gauge.mem.mapped",
          "type": "gauge",
          "description": "Mongodb mapped memory usage, in MB"
        },
        {
          "name": "gauge.mem.resident",
          "type": "gauge",
          "description": "Mongodb resident memory usage, in MB"
        },
        {
          "name": "gauge.mem.virtual",
          "type": "gauge",
          "description": "Mongodb virtual memory usage, in MB"
        },
        {
          "name": "gauge.objects",
          "type": "gauge",
          "description": "Number of documents across all collections"
        },
        {
          "name": "gauge.storageSize",
          "type": "gauge",
          "description": "Total bytes allocated to collections for document storage"
        },
        {
          "name": "gauge.uptime",
          "type": "counter",
          "description": "Uptime of this server in milliseconds"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors a MySQL database server using collectd's\n[MySQL plugin](https://collectd.org/wiki/index.php/Plugin:MySQL).\n\nOn Unix, MySQL programs treat the host name `localhost` specially, in a way\nthat is likely different from what is expected compared to other\nnetwork-based programs. For connections to `localhost`, MySQL programs\nattempt to connect to the local server by using a Unix socket file. To ensure\nthat the client makes a TCP/IP connection to the local server specify a host\nname value of `127.0.0.1`, or the IP address or name of the local server.\n\nYou have to specify each database you want to monitor individually under the\n`databases` key.  If you have a common authentication to all databases being\nmonitored, you can specify that in the top-level `username`/`password`\noptions, otherwise they can be specified at the database level.\n\n**Note:** The MySQL monitor supports MySQL versions 5.x or later.\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: collectd/mysql\n   host: 127.0.0.1\n   port: 3306\n   databases:\n     - name: dbname\n     - name: securedb\n       username: admin\n       password: s3cr3t\n   username: dbuser\n   password: passwd\n```\n",
      "package": "internal/monitors/collectd/mysql",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "databases",
          "doc": "A list of databases along with optional authentication credentials.",
          "default": null,
          "required": true,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "Database",
            "doc": "Database configures a particular MySQL database",
            "package": "internal/monitors/collectd/mysql",
            "fields": [
              {
                "yamlName": "name",
                "doc": "",
                "default": null,
                "required": true,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "username",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "password",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "username",
          "doc": "These credentials serve as defaults for all databases if not overridden",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "reportHost",
          "doc": "A SignalFx extension to the plugin that allows us to disable the normal behavior of the MySQL collectd plugin where the `host` dimension is set to the hostname of the MySQL database server.  When `false` (the recommended and default setting), the globally configured `hostname` config is used instead.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/mysql",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "cache_result.qcache-hits",
          "type": "cumulative",
          "description": "The number of hits on MySQL query cache."
        },
        {
          "name": "cache_result.qcache-inserts",
          "type": "cumulative",
          "description": "The number of inserts into MySQL query cache."
        },
        {
          "name": "cache_results.cache_size",
          "type": "gauge",
          "description": "MySQL Qcache Size"
        },
        {
          "name": "cache_results.qcache-not_cached",
          "type": "cumulative",
          "description": "The number of MySQL queries that were not cacheable or not cached."
        },
        {
          "name": "cache_results.qcache-prunes",
          "type": "cumulative",
          "description": "The number of queries that were pruned from query cache because of low-memory condition."
        },
        {
          "name": "cache_size.qcache",
          "type": "gauge",
          "description": "The number of queries in MySQL query cache."
        },
        {
          "name": "mysql_commands.admin_commands",
          "type": "counter",
          "description": "The number of MySQL ADMIN commands executed"
        },
        {
          "name": "mysql_commands.alter_db",
          "type": "counter",
          "description": "The number of MySQL ALTER DB commands executed"
        },
        {
          "name": "mysql_commands.alter_db_upgrade",
          "type": "counter",
          "description": "The number of MySQL ALTER DB UPGRADE commands executed"
        },
        {
          "name": "mysql_commands.alter_event",
          "type": "counter",
          "description": "The number of MySQL ALTER EVENT commands executed"
        },
        {
          "name": "mysql_commands.alter_function",
          "type": "counter",
          "description": "The number of MySQL ALTER FUNCTION commands executed"
        },
        {
          "name": "mysql_commands.alter_procedure",
          "type": "counter",
          "description": "The number of MySQL ALTER PROCEDURE commands executed"
        },
        {
          "name": "mysql_commands.alter_server",
          "type": "counter",
          "description": "The number of MySQL ALTER SERVER commands executed"
        },
        {
          "name": "mysql_commands.alter_table",
          "type": "counter",
          "description": "The number of MySQL ALTER TABLE commands executed"
        },
        {
          "name": "mysql_commands.alter_tablespace",
          "type": "counter",
          "description": "The number of MySQL ALTER TABLESPACE commands executed"
        },
        {
          "name": "mysql_commands.alter_user",
          "type": "counter",
          "description": "The number of MySQL ALTER USER commands executed"
        },
        {
          "name": "mysql_commands.analyze",
          "type": "counter",
          "description": "The number of MySQL ANALYZE commands executed"
        },
        {
          "name": "mysql_commands.assign_to_keycache",
          "type": "counter",
          "description": "The number of MySQL ASSIGN TO KEYCACHE commands executed"
        },
        {
          "name": "mysql_commands.begin",
          "type": "counter",
          "description": "The number of MySQL BEGIN commands executed"
        },
        {
          "name": "mysql_commands.binlog",
          "type": "counter",
          "description": "The number of MySQL BINLOG commands executed"
        },
        {
          "name": "mysql_commands.call_procedure",
          "type": "counter",
          "description": "The number of MySQL CALL PROCEDURE commands executed"
        },
        {
          "name": "mysql_commands.change_db",
          "type": "counter",
          "description": "The number of MySQL CHANGE DB commands executed"
        },
        {
          "name": "mysql_commands.change_master",
          "type": "counter",
          "description": "The number of MySQL CHANGE MASTER commands executed"
        },
        {
          "name": "mysql_commands.check",
          "type": "counter",
          "description": "The number of MySQL CHECK commands executed"
        },
        {
          "name": "mysql_commands.checksum",
          "type": "counter",
          "description": "The number of MySQL CHECKSUM commands executed"
        },
        {
          "name": "mysql_commands.commit",
          "type": "counter",
          "description": "The number of MySQL COMMIT commands executed"
        },
        {
          "name": "mysql_commands.create_db",
          "type": "counter",
          "description": "The number of MySQL CREATE DB commands executed"
        },
        {
          "name": "mysql_commands.create_event",
          "type": "counter",
          "description": "The number of MySQL CREATE EVENT commands executed"
        },
        {
          "name": "mysql_commands.create_function",
          "type": "counter",
          "description": "The number of MySQL CREATE FUNCTION commands executed"
        },
        {
          "name": "mysql_commands.create_index",
          "type": "counter",
          "description": "The number of MySQL CREATE INDEX commands executed"
        },
        {
          "name": "mysql_commands.create_procedure",
          "type": "counter",
          "description": "The number of MySQL CREATE PROCEDURE commands executed"
        },
        {
          "name": "mysql_commands.create_server",
          "type": "counter",
          "description": "The number of MySQL CREATE SERVER commands executed"
        },
        {
          "name": "mysql_commands.create_table",
          "type": "counter",
          "description": "The number of MySQL CREATE TABLE commands executed"
        },
        {
          "name": "mysql_commands.create_trigger",
          "type": "counter",
          "description": "The number of MySQL CREATE TRIGGER commands executed"
        },
        {
          "name": "mysql_commands.create_udf",
          "type": "counter",
          "description": "The number of MySQL CREATE UDF commands executed"
        },
        {
          "name": "mysql_commands.create_user",
          "type": "counter",
          "description": "The number of MySQL CREATE USER commands executed"
        },
        {
          "name": "mysql_commands.create_view",
          "type": "counter",
          "description": "The number of MySQL CREATE VIEW commands executed"
        },
        {
          "name": "mysql_commands.dealloc_sql",
          "type": "counter",
          "description": "The number of MySQL DEALLOC SQL commands executed"
        },
        {
          "name": "mysql_commands.delete",
          "type": "counter",
          "description": "The number of MySQL DELETE commands executed"
        },
        {
          "name": "mysql_commands.delete_multi",
          "type": "counter",
          "description": "The number of MySQL DELETE MULTI commands executed"
        },
        {
          "name": "mysql_commands.do",
          "type": "counter",
          "description": "The number of MySQL DO commands executed"
        },
        {
          "name": "mysql_commands.drop_db",
          "type": "counter",
          "description": "The number of MySQL DROP DB commands executed"
        },
        {
          "name": "mysql_commands.drop_event",
          "type": "counter",
          "description": "The number of MySQL DROP EVENT commands executed"
        },
        {
          "name": "mysql_commands.drop_function",
          "type": "counter",
          "description": "The number of MySQL DROP FUNCTION commands executed"
        },
        {
          "name": "mysql_commands.drop_index",
          "type": "counter",
          "description": "The number of MySQL DROP INDEX commands executed"
        },
        {
          "name": "mysql_commands.drop_procedure",
          "type": "counter",
          "description": "The number of MySQL DROP PROCEDURE commands executed"
        },
        {
          "name": "mysql_commands.drop_server",
          "type": "counter",
          "description": "The number of MySQL DROP SERVER commands executed"
        },
        {
          "name": "mysql_commands.drop_table",
          "type": "counter",
          "description": "The number of MySQL DROP TABLE commands executed"
        },
        {
          "name": "mysql_commands.drop_trigger",
          "type": "counter",
          "description": "The number of MySQL DROP TRIGGER commands executed"
        },
        {
          "name": "mysql_commands.drop_user",
          "type": "counter",
          "description": "The number of MySQL DROP USER commands executed"
        },
        {
          "name": "mysql_commands.drop_view",
          "type": "counter",
          "description": "The number of MySQL DROP VIEW commands executed"
        },
        {
          "name": "mysql_commands.empty_query",
          "type": "counter",
          "description": "The number of MySQL EMPTY QUERY commands executed"
        },
        {
          "name": "mysql_commands.execute_sql",
          "type": "counter",
          "description": "The number of MySQL EXECUTE SQL commands executed"
        },
        {
          "name": "mysql_commands.flush",
          "type": "counter",
          "description": "The number of MySQL FLUSH commands executed"
        },
        {
          "name": "mysql_commands.get_diagnostics",
          "type": "counter",
          "description": "The number of MySQL GET DIAGNOSTICS commands executed"
        },
        {
          "name": "mysql_commands.grant",
          "type": "counter",
          "description": "The number of MySQL GRANT commands executed"
        },
        {
          "name": "mysql_commands.ha_close",
          "type": "counter",
          "description": "The number of MySQL HA CLOSE commands executed"
        },
        {
          "name": "mysql_commands.ha_open",
          "type": "counter",
          "description": "The number of MySQL HA OPEN commands executed"
        },
        {
          "name": "mysql_commands.ha_read",
          "type": "counter",
          "description": "The number of MySQL HA READ commands executed"
        },
        {
          "name": "mysql_commands.help",
          "type": "counter",
          "description": "The number of MySQL HELP commands executed"
        },
        {
          "name": "mysql_commands.insert",
          "type": "counter",
          "description": "The number of MySQL INSERT commands executed"
        },
        {
          "name": "mysql_commands.insert_select",
          "type": "counter",
          "description": "The number of MySQL INSERT SELECT commands executed"
        },
        {
          "name": "mysql_commands.install_plugin",
          "type": "counter",
          "description": "The number of MySQL INSTALL PLUGIN commands executed"
        },
        {
          "name": "mysql_commands.kill",
          "type": "counter",
          "description": "The number of MySQL KILL commands executed"
        },
        {
          "name": "mysql_commands.load",
          "type": "counter",
          "description": "The number of MySQL LOAD commands executed"
        },
        {
          "name": "mysql_commands.lock_tables",
          "type": "counter",
          "description": "The number of MySQL LOCK TABLES commands executed"
        },
        {
          "name": "mysql_commands.optimize",
          "type": "counter",
          "description": "The number of MySQL OPTIMIZE commands executed"
        },
        {
          "name": "mysql_commands.preload_keys",
          "type": "counter",
          "description": "The number of MySQL PRELOAD KEYS commands executed"
        },
        {
          "name": "mysql_commands.prepare_sql",
          "type": "counter",
          "description": "The number of MySQL PREPARE SQL commands executed"
        },
        {
          "name": "mysql_commands.purge",
          "type": "counter",
          "description": "The number of MySQL PURGE commands executed"
        },
        {
          "name": "mysql_commands.purge_before_date",
          "type": "counter",
          "description": "The number of MySQL PURGE BEFORE DATE commands executed"
        },
        {
          "name": "mysql_commands.release_savepoint",
          "type": "counter",
          "description": "The number of MySQL RELEASE SAVEPOINT commands executed"
        },
        {
          "name": "mysql_commands.rename_table",
          "type": "counter",
          "description": "The number of MySQL RENAME TABLE commands executed"
        },
        {
          "name": "mysql_commands.rename_user",
          "type": "counter",
          "description": "The number of MySQL RENAME USER commands executed"
        },
        {
          "name": "mysql_commands.repair",
          "type": "counter",
          "description": "The number of MySQL REPAIR commands executed"
        },
        {
          "name": "mysql_commands.replace",
          "type": "counter",
          "description": "The number of MySQL REPLACE commands executed"
        },
        {
          "name": "mysql_commands.replace_select",
          "type": "counter",
          "description": "The number of MySQL REPLACE SELECT commands executed"
        },
        {
          "name": "mysql_commands.reset",
          "type": "counter",
          "description": "The number of MySQL RESET commands executed"
        },
        {
          "name": "mysql_commands.resignal",
          "type": "counter",
          "description": "The number of MySQL RESIGNAL commands executed"
        },
        {
          "name": "mysql_commands.revoke",
          "type": "counter",
          "description": "The number of MySQL REVOKE commands executed"
        },
        {
          "name": "mysql_commands.revoke_all",
          "type": "counter",
          "description": "The number of MySQL REVOKE ALL commands executed"
        },
        {
          "name": "mysql_commands.rollback",
          "type": "counter",
          "description": "The number of MySQL ROLLBACK commands executed"
        },
        {
          "name": "mysql_commands.rollback_to_savepoint",
          "type": "counter",
          "description": "The number of MySQL ROLLBACK TO SAVEPOINT commands executed"
        },
        {
          "name": "mysql_commands.savepoint",
          "type": "counter",
          "description": "The number of MySQL SAVEPOINT commands executed"
        },
        {
          "name": "mysql_commands.select",
          "type": "counter",
          "description": "The number of MySQL SELECT commands executed"
        },
        {
          "name": "mysql_commands.set_option",
          "type": "counter",
          "description": "The number of MySQL SET OPTION commands executed"
        },
        {
          "name": "mysql_commands.show_binlog_events",
          "type": "counter",
          "description": "The number of MySQL SHOW BINLOG EVENTS commands executed"
        },
        {
          "name": "mysql_commands.show_binlogs",
          "type": "counter",
          "description": "The number of MySQL SHOW BINLOGS commands executed"
        },
        {
          "name": "mysql_commands.show_charsets",
          "type": "counter",
          "description": "The number of MySQL SHOW CHARSETS commands executed"
        },
        {
          "name": "mysql_commands.show_collations",
          "type": "counter",
          "description": "The number of MySQL SHOW COLLATIONS commands executed"
        },
        {
          "name": "mysql_commands.show_create_db",
          "type": "counter",
          "description": "The number of MySQL SHOW CREATE DB commands executed"
        },
        {
          "name": "mysql_commands.show_create_event",
          "type": "counter",
          "description": "The number of MySQL SHOW CREATE EVENT commands executed"
        },
        {
          "name": "mysql_commands.show_create_func",
          "type": "counter",
          "description": "The number of MySQL SHOW CREATE FUNC commands executed"
        },
        {
          "name": "mysql_commands.show_create_proc",
          "type": "counter",
          "description": "The number of MySQL SHOW CREATE PROC commands executed"
        },
        {
          "name": "mysql_commands.show_create_table",
          "type": "counter",
          "description": "The number of MySQL SHOW CREATE TABLE commands executed"
        },
        {
          "name": "mysql_commands.show_create_trigger",
          "type": "counter",
          "description": "The number of MySQL SHOW CREATE TRIGGER commands executed"
        },
        {
          "name": "mysql_commands.show_databases",
          "type": "counter",
          "description": "The number of MySQL SHOW DATABASES commands executed"
        },
        {
          "name": "mysql_commands.show_engine_logs",
          "type": "counter",
          "description": "The number of MySQL SHOW ENGINE LOGS commands executed"
        },
        {
          "name": "mysql_commands.show_engine_mutex",
          "type": "counter",
          "description": "The number of MySQL SHOW ENGINE MUTEX commands executed"
        },
        {
          "name": "mysql_commands.show_engine_status",
          "type": "counter",
          "description": "The number of MySQL SHOW ENGINE STATUS commands executed"
        },
        {
          "name": "mysql_commands.show_errors",
          "type": "counter",
          "description": "The number of MySQL SHOW ERRORS commands executed"
        },
        {
          "name": "mysql_commands.show_events",
          "type": "counter",
          "description": "The number of MySQL SHOW EVENTS commands executed"
        },
        {
          "name": "mysql_commands.show_fields",
          "type": "counter",
          "description": "The number of MySQL SHOW FIELDS commands executed"
        },
        {
          "name": "mysql_commands.show_function_code",
          "type": "counter",
          "description": "The number of MySQL SHOW FUNCTION CODE commands executed"
        },
        {
          "name": "mysql_commands.show_function_status",
          "type": "counter",
          "description": "The number of MySQL SHOW FUNCTION STATUS commands executed"
        },
        {
          "name": "mysql_commands.show_grants",
          "type": "counter",
          "description": "The number of MySQL SHOW GRANTS commands executed"
        },
        {
          "name": "mysql_commands.show_keys",
          "type": "counter",
          "description": "The number of MySQL SHOW KEYS commands executed"
        },
        {
          "name": "mysql_commands.show_master_status",
          "type": "counter",
          "description": "The number of MySQL SHOW MASTER STATUS commands executed"
        },
        {
          "name": "mysql_commands.show_open_tables",
          "type": "counter",
          "description": "The number of MySQL SHOW OPEN TABLES commands executed"
        },
        {
          "name": "mysql_commands.show_plugins",
          "type": "counter",
          "description": "The number of MySQL SHOW PLUGINS commands executed"
        },
        {
          "name": "mysql_commands.show_privileges",
          "type": "counter",
          "description": "The number of MySQL SHOW PRIVILEGES commands executed"
        },
        {
          "name": "mysql_commands.show_procedure_code",
          "type": "counter",
          "description": "The number of MySQL SHOW PROCEDURE CODE commands executed"
        },
        {
          "name": "mysql_commands.show_procedure_status",
          "type": "counter",
          "description": "The number of MySQL SHOW PROCEDURE STATUS commands executed"
        },
        {
          "name": "mysql_commands.show_processlist",
          "type": "counter",
          "description": "The number of MySQL SHOW PROCESSLIST commands executed"
        },
        {
          "name": "mysql_commands.show_profile",
          "type": "counter",
          "description": "The number of MySQL SHOW PROFILE commands executed"
        },
        {
          "name": "mysql_commands.show_profiles",
          "type": "counter",
          "description": "The number of MySQL SHOW PROFILES commands executed"
        },
        {
          "name": "mysql_commands.show_relaylog_events",
          "type": "counter",
          "description": "The number of MySQL SHOW RELAYLOG EVENTS commands executed"
        },
        {
          "name": "mysql_commands.show_slave_hosts",
          "type": "counter",
          "description": "The number of MySQL SHOW SLAVE HOSTS commands executed"
        },
        {
          "name": "mysql_commands.show_slave_status",
          "type": "counter",
          "description": "The number of MySQL SHOW SLAVE STATUS commands executed"
        },
        {
          "name": "mysql_commands.show_status",
          "type": "counter",
          "description": "The number of MySQL SHOW STATUS commands executed"
        },
        {
          "name": "mysql_commands.show_storage_engines",
          "type": "counter",
          "description": "The number of MySQL SHOW STORAGE ENGINES commands executed"
        },
        {
          "name": "mysql_commands.show_table_status",
          "type": "counter",
          "description": "The number of MySQL SHOW TABLE STATUS commands executed"
        },
        {
          "name": "mysql_commands.show_tables",
          "type": "counter",
          "description": "The number of MySQL SHOW TABLES commands executed"
        },
        {
          "name": "mysql_commands.show_triggers",
          "type": "counter",
          "description": "The number of MySQL SHOW TRIGGERS commands executed"
        },
        {
          "name": "mysql_commands.show_variables",
          "type": "counter",
          "description": "The number of MySQL SHOW VARIABLES commands executed"
        },
        {
          "name": "mysql_commands.show_warnings",
          "type": "counter",
          "description": "The number of MySQL SHOW WARNINGS commands executed"
        },
        {
          "name": "mysql_commands.signal",
          "type": "counter",
          "description": "The number of MySQL SIGNAL commands executed"
        },
        {
          "name": "mysql_commands.slave_start",
          "type": "counter",
          "description": "The number of MySQL SLAVE START commands executed"
        },
        {
          "name": "mysql_commands.slave_stop",
          "type": "counter",
          "description": "The number of MySQL SLAVE STOP commands executed"
        },
        {
          "name": "mysql_commands.truncate",
          "type": "counter",
          "description": "The number of MySQL TRUNCATE commands executed"
        },
        {
          "name": "mysql_commands.uninstall_plugin",
          "type": "counter",
          "description": "The number of MySQL UNINSTALL PLUGIN commands executed"
        },
        {
          "name": "mysql_commands.unlock_tables",
          "type": "counter",
          "description": "The number of MySQL UNLOCK TABLES commands executed"
        },
        {
          "name": "mysql_commands.update",
          "type": "counter",
          "description": "The number of MySQL UPDATE commands executed"
        },
        {
          "name": "mysql_commands.update_multi",
          "type": "counter",
          "description": "The number of MySQL UPDATE MULTI commands executed"
        },
        {
          "name": "mysql_commands.xa_commit",
          "type": "counter",
          "description": "The number of MySQL XA COMMIT commands executed"
        },
        {
          "name": "mysql_commands.xa_end",
          "type": "counter",
          "description": "The number of MySQL XA END commands executed"
        },
        {
          "name": "mysql_commands.xa_prepare",
          "type": "counter",
          "description": "The number of MySQL XA PREPARE commands executed"
        },
        {
          "name": "mysql_commands.xa_recover",
          "type": "counter",
          "description": "The number of MySQL XA RECOVER commands executed"
        },
        {
          "name": "mysql_commands.xa_rollback",
          "type": "counter",
          "description": "The number of MySQL XA ROLLBACK commands executed"
        },
        {
          "name": "mysql_commands.xa_start",
          "type": "counter",
          "description": "The number of MySQL XA START commands executed"
        },
        {
          "name": "mysql_handler.commit",
          "type": "counter",
          "description": "The number of internal COMMIT statements."
        },
        {
          "name": "mysql_handler.delete",
          "type": "counter",
          "description": "The number of times rows have been deleted from tables."
        },
        {
          "name": "mysql_handler.prepare",
          "type": "counter",
          "description": "The number of times \"Prepare\" phase was executed in the two-phase commit operations."
        },
        {
          "name": "mysql_handler.read_first",
          "type": "counter",
          "description": "The number of times the first entry in an index was read."
        },
        {
          "name": "mysql_handler.read_key",
          "type": "counter",
          "description": "The number of times a row was read based on a key."
        },
        {
          "name": "mysql_handler.read_next",
          "type": "counter",
          "description": "The number of requests to read the next row in key order."
        },
        {
          "name": "mysql_handler.read_prev",
          "type": "counter",
          "description": "The number of requests to read the previous row in key order."
        },
        {
          "name": "mysql_handler.read_rnd",
          "type": "counter",
          "description": "The number of requests that read a random fixed position in the data file."
        },
        {
          "name": "mysql_handler.read_rnd_next",
          "type": "counter",
          "description": "The number of requests for the next row in the data file."
        },
        {
          "name": "mysql_handler.rollback",
          "type": "counter",
          "description": "The number of requests for a rollback operation on the storage engine."
        },
        {
          "name": "mysql_handler.savepoint",
          "type": "counter",
          "description": "The number of requests to place a savepoint on the storage engine.  This can be used to roll back later."
        },
        {
          "name": "mysql_handler.savepoint_rollback",
          "type": "counter",
          "description": "The number of requests to roll back to a savepoint."
        },
        {
          "name": "mysql_handler.update",
          "type": "counter",
          "description": "The number of requests to update a row in a table."
        },
        {
          "name": "mysql_handler.write",
          "type": "counter",
          "description": "The number of requests to insert a row in a table."
        },
        {
          "name": "mysql_locks.immediate",
          "type": "counter",
          "description": "The number of MySQL table locks which were granted immediately."
        },
        {
          "name": "mysql_locks.waited",
          "type": "counter",
          "description": "The number of MySQL table locks which had to wait before being granted."
        },
        {
          "name": "mysql_octets.rx",
          "type": "cumulative",
          "description": "The number of bytes received by MySQL server from all clients."
        },
        {
          "name": "mysql_octets.tx",
          "type": "cumulative",
          "description": "The number of bytes sent by MySQL server to all clients."
        },
        {
          "name": "mysql_select.full_join",
          "type": "counter",
          "description": "The number of joins that perform full table scans."
        },
        {
          "name": "mysql_select.full_range_join",
          "type": "counter",
          "description": "The number of joins that used a range search on a reference table."
        },
        {
          "name": "mysql_select.range",
          "type": "counter",
          "description": "The number of joins that used a range on the first table."
        },
        {
          "name": "mysql_select.range_check",
          "type": "counter",
          "description": "The number of joins without keys that check for key usage after each row."
        },
        {
          "name": "mysql_sort.merge_passes",
          "type": "counter",
          "description": "The number of merge passes done by the sorting algorithm."
        },
        {
          "name": "mysql_sort.range",
          "type": "counter",
          "description": "The number of sorts that were done using ranges."
        },
        {
          "name": "mysql_sort.rows",
          "type": "counter",
          "description": "The number of rows that were sorted."
        },
        {
          "name": "mysql_sort.scan",
          "type": "counter",
          "description": "The number of sorts that were done by scanning the table."
        },
        {
          "name": "threads.cached",
          "type": "gauge",
          "description": "The number of threads cached by MySQL for re-use on a new client connection.  A MySQL thread corresponds to a single MySQL connection."
        },
        {
          "name": "threads.connected",
          "type": "gauge",
          "description": "The number of currently open MySQL connections.  A MySQL thread corresponds to a single MySQL connection."
        },
        {
          "name": "threads.running",
          "type": "gauge",
          "description": "The number of MySQL threads that are processing a query.  A MySQL thread corresponds to a single MySQL connection."
        },
        {
          "name": "total_threads.created",
          "type": "cumulative",
          "description": "The total number of threads created by MySQL for client connections.  A MySQL thread corresponds to a single MySQL connection."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors an nginx instance using our fork of the\ncollectd nginx plugin based on the [collectd nginx\nplugin](https://collectd.org/wiki/index.php/Plugin:nginx).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-nginx)\nfor more information.\n",
      "package": "internal/monitors/collectd/nginx",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "url",
          "doc": "The full URL of the status endpoint; can be a template",
          "default": "http://{{.Host}}:{{.Port}}/nginx_status",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "timeout",
          "doc": "",
          "default": 0,
          "required": false,
          "type": "int",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/nginx",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "connections.accepted",
          "type": "cumulative",
          "description": "Connections accepted by Nginx Web Server"
        },
        {
          "name": "connections.handled",
          "type": "cumulative",
          "description": "Connections handled by Nginx Web Server"
        },
        {
          "name": "nginx_connections.active",
          "type": "gauge",
          "description": "Connections active in Nginx Web Server"
        },
        {
          "name": "nginx_connections.reading",
          "type": "gauge",
          "description": "Connections being read by Nginx Web Server"
        },
        {
          "name": "nginx_connections.waiting",
          "type": "gauge",
          "description": "Connections waited on by Nginx Web Server"
        },
        {
          "name": "nginx_connections.writing",
          "type": "gauge",
          "description": "Connections being written by Nginx Web Server"
        },
        {
          "name": "nginx_requests",
          "type": "cumulative",
          "description": "Requests handled by Nginx Web Server"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors Openstack by using the\n[Openstack collectd Python\nplugin](https://github.com/signalfx/collectd-openstack), which collects metrics\nfrom Openstack instances\n\n```yaml\nmonitors:\n- type: collectd/openstack\n  authURL: \"http://192.168.11.111/identity/v3\"\n  username: \"admin\"\n  password: \"secret\"\n```\n",
      "package": "internal/monitors/collectd/openstack",
      "fields": [
        {
          "yamlName": "authURL",
          "doc": "Keystone authentication URL/endpoint for the OpenStack cloud",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "Username to authenticate with keystone identity",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "Password to authenticate with keystone identity",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "projectName",
          "doc": "Specify the name of Project to be monitored (**default**:\"demo\")",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "projectDomainID",
          "doc": "The project domain (**default**:\"default\")",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "userDomainID",
          "doc": "The user domain id (**default**:\"default\")",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/openstack",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.openstack.nova.server.cpu_time",
          "type": "counter",
          "description": "Virtual CPU time consumed in nanoseconds"
        },
        {
          "name": "counter.openstack.nova.server.rx",
          "type": "counter",
          "description": "Size of network packet received in bytes"
        },
        {
          "name": "counter.openstack.nova.server.rx_packets",
          "type": "counter",
          "description": "Received packets at an instance"
        },
        {
          "name": "counter.openstack.nova.server.tx",
          "type": "counter",
          "description": "Size of network packet transmitted in bytes"
        },
        {
          "name": "counter.openstack.nova.server.tx_packets",
          "type": "counter",
          "description": "Transmitted packets at an instance"
        },
        {
          "name": "gauge.openstack.cinder.limit.maxTotalVolumeGigabytes",
          "type": "gauge",
          "description": "Total available block storage at cinder component for project"
        },
        {
          "name": "gauge.openstack.cinder.limit.maxTotalVolumes",
          "type": "gauge",
          "description": "Maximum volume resources available at cinder component for project"
        },
        {
          "name": "gauge.openstack.cinder.limit.totalGigabytesUsed",
          "type": "gauge",
          "description": "Total block storage used at cinder component for project"
        },
        {
          "name": "gauge.openstack.cinder.limit.totalVolumesUsed",
          "type": "gauge",
          "description": "Volume resources used at cinder component for project"
        },
        {
          "name": "gauge.openstack.neutron.floatingip.count",
          "type": "gauge",
          "description": "Overall floating IPs used across projects"
        },
        {
          "name": "gauge.openstack.neutron.network.count",
          "type": "gauge",
          "description": "Overall Network resources used across projects"
        },
        {
          "name": "gauge.openstack.neutron.router.count",
          "type": "gauge",
          "description": "Overall router resources used across projects"
        },
        {
          "name": "gauge.openstack.neutron.securitygroup.count",
          "type": "gauge",
          "description": "Overall securitygroup resources used across projects"
        },
        {
          "name": "gauge.openstack.neutron.subnet.count",
          "type": "gauge",
          "description": "Overall subnet resources used in all projects"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.disk_available_least",
          "type": "gauge",
          "description": "Minimum free disk space available in Gigabyte"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.free_disk_gb",
          "type": "gauge",
          "description": "Maximum free disk space available in Gigabyte"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.load_average",
          "type": "gauge",
          "description": "Average CPU load on the hypervisor"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.local_gb",
          "type": "gauge",
          "description": "Maximum available local disk space in Gigabyte"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.local_gb_used",
          "type": "gauge",
          "description": "Total disk space used in Gigabyte"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.memory_mb",
          "type": "gauge",
          "description": "Maximum available memory in MB at hypervisor"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.memory_mb_used",
          "type": "gauge",
          "description": "Total memory used in MB at hypervisor"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.running_vms",
          "type": "gauge",
          "description": "Total running VMs at hypervisor"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.vcpus",
          "type": "gauge",
          "description": "Available physical cores at hypervisor"
        },
        {
          "name": "gauge.openstack.nova.hypervisor.vcpus_used",
          "type": "gauge",
          "description": "Used virtual CPUs used"
        },
        {
          "name": "gauge.openstack.nova.limit.maxSecurityGroups",
          "type": "gauge",
          "description": "Maximum available security groups for project"
        },
        {
          "name": "gauge.openstack.nova.limit.maxTotalCores",
          "type": "gauge",
          "description": "Maximum available VCPUs in project"
        },
        {
          "name": "gauge.openstack.nova.limit.maxTotalFloatingIps",
          "type": "gauge",
          "description": "Maximum available floating IPs for project"
        },
        {
          "name": "gauge.openstack.nova.limit.maxTotalInstances",
          "type": "gauge",
          "description": "Maximum available instances in project"
        },
        {
          "name": "gauge.openstack.nova.limit.maxTotalRAMSize",
          "type": "gauge",
          "description": "Maximum available RAM size for project"
        },
        {
          "name": "gauge.openstack.nova.limit.totalCoresUsed",
          "type": "gauge",
          "description": "Total cores used in the project"
        },
        {
          "name": "gauge.openstack.nova.limit.totalInstancesUsed",
          "type": "gauge",
          "description": "Total instances used in the project"
        },
        {
          "name": "gauge.openstack.nova.limit.totalRAMUsed",
          "type": "gauge",
          "description": "Total RAM used in the project"
        },
        {
          "name": "gauge.openstack.nova.server.memory",
          "type": "gauge",
          "description": "Memory provisioned at an instance"
        },
        {
          "name": "gauge.openstack.nova.server.memory-actual",
          "type": "gauge",
          "description": "Actual memory used at an instance"
        },
        {
          "name": "gauge.openstack.nova.server.memory-rss",
          "type": "gauge",
          "description": "Memory used not including disk pages at an instance"
        },
        {
          "name": "gauge.openstack.nova.server.vda_read",
          "type": "gauge",
          "description": "Size of virtual disk read requests in bytes"
        },
        {
          "name": "gauge.openstack.nova.server.vda_read_req",
          "type": "gauge",
          "description": "Virtual disk read requests from an instance"
        },
        {
          "name": "gauge.openstack.nova.server.vda_write",
          "type": "gauge",
          "description": "Size of virtual disk write requests in bytes"
        },
        {
          "name": "gauge.openstack.nova.server.vda_write_req",
          "type": "gauge",
          "description": "Virtual disk write requests from an instance"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors a PostgreSQL database server using collectd's\n[PostgreSQL plugin](https://collectd.org/wiki/index.php/Plugin:PostgreSQL).\n\nYou have to specify each database you want to monitor individually under the\n`databases` key.  If you have a common authentication to all databases being\nmonitored, you can specify that in the top-level `username`/`password`\noptions, otherwise they can be specified at the database level.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/postgresql\n  host: 127.0.0.1\n  port: 5432\n  username: \"username1\"\n  password: \"password1\"\n  databases:\n  - name: \"testdb\"\n    username: \"test_user\"\n    password: \"test_pwd\"\n```\n\nSample YAML configuration with custom query:\n\n```yaml\nmonitors:\n- type: collectd/postgresql\n  host: 127.0.0.1\n  port: 5432\n  username: \"username1\"\n  password: \"password1\"\n  queries:\n  - name: \"exampleQuery\"\n    params:\n    - \"hostname\"\n    statement: \"Select * From test Where host = $1;\"\n    results:\n    - type: \"gauge\"\n      valuesFrom:\n      - \"test\"\n databases:\n - name: \"test\"\n   username: \"username2\"\n   password: \"password2\"\n   queries:\n   - \"exampleQuery\"\n```\n",
      "package": "internal/monitors/collectd/postgresql",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "databases",
          "doc": "A list of databases along with optional authentication credentials.",
          "default": null,
          "required": true,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "Database",
            "doc": "Database configures a particular PostgreSQL database",
            "package": "internal/monitors/collectd/postgresql",
            "fields": [
              {
                "yamlName": "name",
                "doc": "The name of the database",
                "default": null,
                "required": true,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "username",
                "doc": "Username used to access the database",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "password",
                "doc": "Password used to access the database",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "interval",
                "doc": "Interval to query the database in seconds",
                "default": 0,
                "required": false,
                "type": "int",
                "elementKind": ""
              },
              {
                "yamlName": "expireDelay",
                "doc": "Skip expired values in query output",
                "default": 0,
                "required": false,
                "type": "int",
                "elementKind": ""
              },
              {
                "yamlName": "sslMode",
                "doc": "Specify whether to use an ssl connection with PostgreSQL. (prefer(default), disable, allow, require)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "krbSrvName",
                "doc": "Specify the Kerberos service name used to authenticate with kerberos 5 or GSSAPI",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "queries",
                "doc": "Queries used to generate metrics.  If no queries are specified, the default set will be used [`custom_deadlocks`, `backends`, `transactions`, `queries`, `queries_by_table`, `query_plans`, `table_states`, `query_plans_by_table`, `table_states_by_table`, `disk_io`, `disk_io_by_table`, `disk_usage`]",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              }
            ]
          }
        },
        {
          "yamlName": "queries",
          "doc": "PostgreSQL queries and metric mappings",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "Query",
            "doc": "Query adds a new query for retrieving metrics",
            "package": "internal/monitors/collectd/postgresql",
            "fields": [
              {
                "yamlName": "name",
                "doc": "Name used to refer to the query in the database block",
                "default": null,
                "required": true,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "statement",
                "doc": "Statement is a SQL statement to execute",
                "default": null,
                "required": true,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "results",
                "doc": "Result blocks that define mappings of SQL query results to metrics",
                "default": null,
                "required": true,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "Result",
                  "doc": "Result maps values from a query to a metric",
                  "package": "internal/monitors/collectd/postgresql",
                  "fields": [
                    {
                      "yamlName": "type",
                      "doc": "Type defines a metric type",
                      "default": null,
                      "required": true,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "valuesFrom",
                      "doc": "Specifies columns in the SQL result to use as the metric value.  The number of columns must match the expected number of values for the metric type.",
                      "default": null,
                      "required": true,
                      "type": "slice",
                      "elementKind": "string"
                    },
                    {
                      "yamlName": "instancePrefix",
                      "doc": "A prefix for the type instance",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "instancesFrom",
                      "doc": "Specifies columns in the SQL result to uses for the type instance.  Multiple columns are joined with a hyphen \"-\".",
                      "default": null,
                      "required": false,
                      "type": "slice",
                      "elementKind": "string"
                    }
                  ]
                }
              },
              {
                "yamlName": "params",
                "doc": "Parameters used to fill in $1,$2,$... tokens in the SQL statement.  Acceptable values are hostname, database, instance, username, interval",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "pluginInstanceFrom",
                "doc": "Specifies the column that should be used to populate plugin instance",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "minVersion",
                "doc": "The minimum version of PostgreSQL that the query is compatible with.  The version must be specified as a two decimal digit. Ex. 7.2.3 -\u003e 70203",
                "default": 0,
                "required": false,
                "type": "int",
                "elementKind": ""
              },
              {
                "yamlName": "maxVersion",
                "doc": "The maximum version of PostgreSQL that the query is compatible with.  The version must be specified as a two decimal digit. Ex. 7.2.3 -\u003e 70203",
                "default": 0,
                "required": false,
                "type": "int",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "username",
          "doc": "A username that serves as a default for all databases if not overridden",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "A password that serves as a default for all databases if not overridden",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "reportHost",
          "doc": "A SignalFx extension to the plugin that allows us to disable the normal behavior of the PostgreSQL collectd plugin where the `host` dimension is set to the hostname of the PostgreSQL database server.  When `false` (the recommended and default setting), the globally configured `hostname` config is used instead.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/postgresql",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "pg_blks.heap_hit",
          "type": "gauge",
          "description": "Number of buffer hits"
        },
        {
          "name": "pg_blks.heap_read",
          "type": "gauge",
          "description": "Number of disk blocks read"
        },
        {
          "name": "pg_blks.idx_hit",
          "type": "gauge",
          "description": "Number of index buffer hits"
        },
        {
          "name": "pg_blks.idx_read",
          "type": "gauge",
          "description": "Number of index blocks read"
        },
        {
          "name": "pg_blks.tidx_hit",
          "type": "gauge",
          "description": "Number of TOAST index buffer hits"
        },
        {
          "name": "pg_blks.tidx_read",
          "type": "gauge",
          "description": "Number of TOAST index blocks read"
        },
        {
          "name": "pg_blks.toast_hit",
          "type": "gauge",
          "description": "Number of TOAST buffer hits"
        },
        {
          "name": "pg_blks.toast_read",
          "type": "gauge",
          "description": "Number of disk blocks read"
        },
        {
          "name": "pg_db_size",
          "type": "gauge",
          "description": "Size of the database on disk, in bytes"
        },
        {
          "name": "pg_n_tup_c.del",
          "type": "gauge",
          "description": "Number of delete operations"
        },
        {
          "name": "pg_n_tup_c.hot_upd",
          "type": "gauge",
          "description": "Number of update operations not requiring index update"
        },
        {
          "name": "pg_n_tup_c.ins",
          "type": "gauge",
          "description": "Number of insert operations"
        },
        {
          "name": "pg_n_tup_c.upd",
          "type": "gauge",
          "description": "Number of update operations"
        },
        {
          "name": "pg_n_tup_g.dead",
          "type": "gauge",
          "description": "Number of dead rows in the database"
        },
        {
          "name": "pg_n_tup_g.live",
          "type": "gauge",
          "description": "Number of live rows in the database"
        },
        {
          "name": "pg_numbackends",
          "type": "gauge",
          "description": "Number of server processes"
        },
        {
          "name": "pg_scan.idx",
          "type": "gauge",
          "description": "Number of index scans"
        },
        {
          "name": "pg_scan.idx_tup_fetch",
          "type": "gauge",
          "description": "Number of rows read from index scans"
        },
        {
          "name": "pg_scan.seq",
          "type": "gauge",
          "description": "Number of sequential scans"
        },
        {
          "name": "pg_scan.seq_tup_read",
          "type": "gauge",
          "description": "Number of rows read from sequential scans"
        },
        {
          "name": "pg_xact.commit",
          "type": "gauge",
          "description": "Number of commits"
        },
        {
          "name": "pg_xact.num_deadlocks",
          "type": "gauge",
          "description": "Number of deadlocks detected by the database"
        },
        {
          "name": "pg_xact.rollback",
          "type": "gauge",
          "description": "Number of rollbacks"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Gathers information about processes running on\nthe host.  See\nhttps://collectd.org/documentation/manpages/collectd.conf.5.shtml#plugin_processes\nand https://collectd.org/wiki/index.php/Plugin:Processes for more\ninformation on the configuration options.\n\nExample:\n\n```yaml\n  - type: collectd/processes\n    processes:\n      - mysql\n      - myapp\n    processMatch:\n      docker: \"docker.*\"\n    collectContextSwitch: true\n```\n\nThe above config will send process metrics for processes named *mysql* and\n*myapp*, along with additional metrics on the number of context switches the\nprocess has made.  Also, all processes that start with `docker` will have\ntheir process metrics aggregated together and sent with a `plugin_instance`\nvalue of `docker`.\n",
      "package": "internal/monitors/collectd/processes",
      "fields": [
        {
          "yamlName": "processes",
          "doc": "A list of process names to match",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "processMatch",
          "doc": "A map with keys specifying the `plugin_instance` value to be sent for the values which are regexes that match process names.  See example in description.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "collectContextSwitch",
          "doc": "Collect metrics on the number of context switches made by the process",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "procFSPath",
          "doc": "The path to the proc filesystem -- useful to override if the agent is running in a container.",
          "default": "/proc",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/processes",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Gathers metrics about the network protocol\nstacks running on the system by using the [collectd protocols\nplugin](https://collectd.org/wiki/index.php/Plugin:Protocols).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-protocols)\nfor more information.\n",
      "package": "internal/monitors/collectd/protocols",
      "fields": [],
      "monitorType": "collectd/protocols",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "protocol_counter.ActiveOpens",
          "type": "cumulative",
          "description": "The number of times TCP connections transitioned from the CLOSED state to the SYN-SENT state."
        },
        {
          "name": "protocol_counter.CurrEstab",
          "type": "cumulative",
          "description": "The number of TCP connections currently in either ESTABLISHED or CLOSE-WAIT state."
        },
        {
          "name": "protocol_counter.DelayedACKs",
          "type": "cumulative",
          "description": "The number of acknowledgements delayed by TCP Delayed Acknowledgement"
        },
        {
          "name": "protocol_counter.InDestUnreachs",
          "type": "cumulative",
          "description": "The number of ICMP Destination Unreachable messages received"
        },
        {
          "name": "protocol_counter.PassiveOpens",
          "type": "cumulative",
          "description": "The number of times that a server opened a connection, due to receiving a TCP SYN packet."
        },
        {
          "name": "protocol_counter.RetransSegs",
          "type": "cumulative",
          "description": "The total number of segments retransmitted"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor runs arbitrary collectd Python\nplugins directly, apart from collectd.  It implements a mock collectd Python\ninterface that supports most, but not all, of the real collectd.\n",
      "package": "internal/monitors/collectd/python",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host will be filled in by auto-discovery if this monitor has a discovery rule.  It can then be used under pluginConfig by the template `{{.Host}}`",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "Port will be filled in by auto-discovery if this monitor has a discovery rule.  It can then be used under pluginConfig by the template `{{.Port}}`",
          "default": 0,
          "required": false,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "moduleName",
          "doc": "Corresponds to the ModuleName option in collectd-python",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "modulePaths",
          "doc": "Corresponds to a set of ModulePath options in collectd-python",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "pluginConfig",
          "doc": "This is a yaml form of the collectd config.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "interface"
        },
        {
          "yamlName": "typesDBPaths",
          "doc": "A set of paths to [types.db files](https://collectd.org/documentation/manpages/types.db.5.shtml) that are needed by your plugin.  If not specified, the runner will use the global collectd types.db file.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        }
      ],
      "monitorType": "collectd/python",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors an instance of RabbitMQ using the\n[collectd RabbitMQ Python\nPlugin](https://github.com/signalfx/collectd-rabbitmq).\n\nSee the [integration\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-rabbitmq)\nfor more information.\n\n**Note that you must individually enable each of the five `collect*` options\nto get metrics pertaining to those facets of a RabbitMQ instance.  If none\nof them are enabled, no metrics will be sent.**\n",
      "package": "internal/monitors/collectd/rabbitmq",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "brokerName",
          "doc": "The name of the particular RabbitMQ instance.  Can be a Go template using other config options. This will be used as the `plugin_instance` dimension.",
          "default": "{{.host}}-{{.port}}",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "collectChannels",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "collectConnections",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "collectExchanges",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "collectNodes",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "collectQueues",
          "doc": "",
          "default": null,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "httpTimeout",
          "doc": "",
          "default": null,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "verbosityLevel",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "username",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/rabbitmq",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.channel.message_stats.ack",
          "type": "counter",
          "description": "The number of acknowledged messages"
        },
        {
          "name": "counter.channel.message_stats.confirm",
          "type": "counter",
          "description": "Count of messages confirmed."
        },
        {
          "name": "counter.channel.message_stats.deliver",
          "type": "counter",
          "description": "Count of messages delivered in acknowledgement mode to consumers."
        },
        {
          "name": "counter.channel.message_stats.deliver_get",
          "type": "counter",
          "description": "Count of all messages delivered on the channel"
        },
        {
          "name": "counter.channel.message_stats.publish",
          "type": "counter",
          "description": "Count of messages published."
        },
        {
          "name": "counter.connection.channel_max",
          "type": "counter",
          "description": "The maximum number of channels on the connection"
        },
        {
          "name": "counter.connection.recv_cnt",
          "type": "counter",
          "description": "Number of packets received on the connection"
        },
        {
          "name": "counter.connection.recv_oct",
          "type": "counter",
          "description": "Number of octets received on the connection"
        },
        {
          "name": "counter.connection.send_cnt",
          "type": "counter",
          "description": "Number of packets sent by the connection"
        },
        {
          "name": "counter.connection.send_oct",
          "type": "counter",
          "description": "Number of octets sent by the connection"
        },
        {
          "name": "counter.exchange.message_stats.confirm",
          "type": "counter",
          "description": "Count of messages confirmed."
        },
        {
          "name": "counter.exchange.message_stats.publish_in",
          "type": "counter",
          "description": "Count of messages published \"in\" to an exchange, i.e. not taking account of routing."
        },
        {
          "name": "counter.exchange.message_stats.publish_out",
          "type": "counter",
          "description": "Count of messages published \"out\" of an exchange, i.e. taking account of routing."
        },
        {
          "name": "counter.node.io_read_bytes",
          "type": "counter",
          "description": "Total number of bytes read from disk by the persister."
        },
        {
          "name": "counter.node.io_read_count",
          "type": "counter",
          "description": "Total number of read operations by the persister."
        },
        {
          "name": "counter.node.mnesia_disk_tx_count",
          "type": "counter",
          "description": "Number of Mnesia transactions which have been performed that required writes to disk."
        },
        {
          "name": "counter.node.mnesia_ram_tx_count",
          "type": "counter",
          "description": "Number of Mnesia transactions which have been performed that did not require writes to disk."
        },
        {
          "name": "counter.queue.disk_reads",
          "type": "counter",
          "description": "Total number of times messages have been read from disk by this queue since it started."
        },
        {
          "name": "counter.queue.disk_writes",
          "type": "counter",
          "description": "Total number of times messages have been written to disk by this queue since it started."
        },
        {
          "name": "counter.queue.message_stats.ack",
          "type": "counter",
          "description": "Number of acknowledged messages processed by the queue"
        },
        {
          "name": "counter.queue.message_stats.deliver",
          "type": "counter",
          "description": "Count of messages delivered in acknowledgement mode to consumers."
        },
        {
          "name": "counter.queue.message_stats.deliver_get",
          "type": "counter",
          "description": "Count of all messages delivered on the queue"
        },
        {
          "name": "counter.queue.message_stats.publish",
          "type": "counter",
          "description": "Count of messages published."
        },
        {
          "name": "gauge.channel.connection_details.peer_port",
          "type": "gauge",
          "description": "The peer port number of the channel"
        },
        {
          "name": "gauge.channel.consumer_count",
          "type": "gauge",
          "description": "The number of consumers the channel has"
        },
        {
          "name": "gauge.channel.global_prefetch_count",
          "type": "gauge",
          "description": "QoS prefetch limit for the entire channel, 0 if unlimited."
        },
        {
          "name": "gauge.channel.message_stats.ack_details.rate",
          "type": "gauge",
          "description": "How much the channel message ack count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.channel.message_stats.confirm_details.rate",
          "type": "gauge",
          "description": "How much the channel message confirm count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.channel.message_stats.deliver_details.rate",
          "type": "gauge",
          "description": "How much the channel deliver count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.channel.message_stats.deliver_get_details.rate",
          "type": "gauge",
          "description": "How much the channel message count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.channel.message_stats.publish_details.rate",
          "type": "gauge",
          "description": "How much the channel message publish count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.channel.messages_unacknowledged",
          "type": "gauge",
          "description": "Number of messages delivered via this channel but not yet acknowledged."
        },
        {
          "name": "gauge.channel.messages_uncommitted",
          "type": "gauge",
          "description": "Number of messages received in an as yet uncommitted transaction."
        },
        {
          "name": "gauge.channel.messages_unconfirmed",
          "type": "gauge",
          "description": "Number of published messages not yet confirmed. On channels not in confirm mode, this remains 0."
        },
        {
          "name": "gauge.channel.number",
          "type": "gauge",
          "description": "The number of the channel, which uniquely identifies it within a connection."
        },
        {
          "name": "gauge.channel.prefetch_count",
          "type": "gauge",
          "description": "QoS prefetch limit for new consumers, 0 if unlimited."
        },
        {
          "name": "gauge.connection.channels",
          "type": "gauge",
          "description": "The current number of channels on the connection"
        },
        {
          "name": "gauge.connection.connected_at",
          "type": "gauge",
          "description": "The integer timestamp of the most recent time the connection was established"
        },
        {
          "name": "gauge.connection.frame_max",
          "type": "gauge",
          "description": "Maximum permissible size of a frame (in bytes) to negotiate with clients."
        },
        {
          "name": "gauge.connection.peer_port",
          "type": "gauge",
          "description": "The peer port of the connection"
        },
        {
          "name": "gauge.connection.port",
          "type": "gauge",
          "description": "The port the connection is established on"
        },
        {
          "name": "gauge.connection.recv_oct_details.rate",
          "type": "gauge",
          "description": "How much the connection's octets received count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.connection.send_oct_details.rate",
          "type": "gauge",
          "description": "How much the connection's octets sent count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.connection.send_pend",
          "type": "gauge",
          "description": "The number of messages in the send queue of the connection"
        },
        {
          "name": "gauge.connection.timeout",
          "type": "gauge",
          "description": "The current timeout setting (in seconds) of the connection"
        },
        {
          "name": "gauge.exchange.message_stats.confirm_details.rate",
          "type": "gauge",
          "description": "How much the message confirm count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.exchange.message_stats.publish_in_details.rate",
          "type": "gauge",
          "description": "How much the exchange publish-in count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.exchange.message_stats.publish_out_details.rate",
          "type": "gauge",
          "description": "How much the exchange publish-out count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.disk_free",
          "type": "gauge",
          "description": "Disk free space (in bytes) on the node"
        },
        {
          "name": "gauge.node.disk_free_details.rate",
          "type": "gauge",
          "description": "How much the disk free space has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.disk_free_limit",
          "type": "gauge",
          "description": "Point (in bytes) at which the disk alarm will go off."
        },
        {
          "name": "gauge.node.fd_total",
          "type": "gauge",
          "description": "Total number of file descriptors available."
        },
        {
          "name": "gauge.node.fd_used",
          "type": "gauge",
          "description": "Number of used file descriptors."
        },
        {
          "name": "gauge.node.fd_used_details.rate",
          "type": "gauge",
          "description": "How much the number of used file descriptors has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.io_read_avg_time",
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each disk read operation in the last statistics interval."
        },
        {
          "name": "gauge.node.io_read_avg_time_details.rate",
          "type": "gauge",
          "description": "How much the I/O read average time has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.io_read_bytes_details.rate",
          "type": "gauge",
          "description": "How much the number of bytes read from disk has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.io_read_count_details.rate",
          "type": "gauge",
          "description": "How much the number of read operations has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.io_sync_avg_time",
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each fsync() operation in the last statistics interval."
        },
        {
          "name": "gauge.node.io_sync_avg_time_details.rate",
          "type": "gauge",
          "description": "How much the average I/O sync time has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.io_write_avg_time",
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each disk write operation in the last statistics interval."
        },
        {
          "name": "gauge.node.io_write_avg_time_details.rate",
          "type": "gauge",
          "description": "How much the I/O write time has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.mem_limit",
          "type": "gauge",
          "description": "Point (in bytes) at which the memory alarm will go off."
        },
        {
          "name": "gauge.node.mem_used",
          "type": "gauge",
          "description": "Memory used in bytes."
        },
        {
          "name": "gauge.node.mem_used_details.rate",
          "type": "gauge",
          "description": "How much the count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.mnesia_disk_tx_count_details.rate",
          "type": "gauge",
          "description": "How much the Mnesia disk transaction count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.mnesia_ram_tx_count_details.rate",
          "type": "gauge",
          "description": "How much the RAM-only Mnesia transaction count has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.net_ticktime",
          "type": "gauge",
          "description": "Current kernel net_ticktime setting for the node."
        },
        {
          "name": "gauge.node.proc_total",
          "type": "gauge",
          "description": "The maximum number of Erlang processes that can run in an Erlang VM."
        },
        {
          "name": "gauge.node.proc_used",
          "type": "gauge",
          "description": "Number of Erlang processes currently running in use."
        },
        {
          "name": "gauge.node.proc_used_details.rate",
          "type": "gauge",
          "description": "How much the number of erlang processes in use has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.processors",
          "type": "gauge",
          "description": "Number of cores detected and usable by Erlang."
        },
        {
          "name": "gauge.node.run_queue",
          "type": "gauge",
          "description": "Average number of Erlang processes waiting to run."
        },
        {
          "name": "gauge.node.sockets_total",
          "type": "gauge",
          "description": "Number of file descriptors available for use as sockets."
        },
        {
          "name": "gauge.node.sockets_used",
          "type": "gauge",
          "description": "Number of file descriptors used as sockets."
        },
        {
          "name": "gauge.node.sockets_used_details.rate",
          "type": "gauge",
          "description": "How much the number of sockets used has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.node.uptime",
          "type": "gauge",
          "description": "Time since the Erlang VM started, in milliseconds."
        },
        {
          "name": "gauge.queue.backing_queue_status.avg_ack_egress_rate",
          "type": "gauge",
          "description": "Rate at which unacknowledged message records leave RAM, e.g. because acks arrive or unacked messages are paged out"
        },
        {
          "name": "gauge.queue.backing_queue_status.avg_ack_ingress_rate",
          "type": "gauge",
          "description": "Rate at which unacknowledged message records enter RAM, e.g. because messages are delivered requiring acknowledgement"
        },
        {
          "name": "gauge.queue.backing_queue_status.avg_egress_rate",
          "type": "gauge",
          "description": "Average egress (outbound) rate, not including messages that are sent straight through to auto-acking consumers."
        },
        {
          "name": "gauge.queue.backing_queue_status.avg_ingress_rate",
          "type": "gauge",
          "description": "Average ingress (inbound) rate, not including messages that are sent straight through to auto-acking consumers."
        },
        {
          "name": "gauge.queue.backing_queue_status.len",
          "type": "gauge",
          "description": "Total backing queue length, in messages"
        },
        {
          "name": "gauge.queue.backing_queue_status.next_seq_id",
          "type": "gauge",
          "description": "The next sequence ID to be used in the backing queue"
        },
        {
          "name": "gauge.queue.backing_queue_status.q1",
          "type": "gauge",
          "description": "Number of messages in backing queue q1"
        },
        {
          "name": "gauge.queue.backing_queue_status.q2",
          "type": "gauge",
          "description": "Number of messages in backing queue q2"
        },
        {
          "name": "gauge.queue.backing_queue_status.q3",
          "type": "gauge",
          "description": "Number of messages in backing queue q3"
        },
        {
          "name": "gauge.queue.backing_queue_status.q4",
          "type": "gauge",
          "description": "Number of messages in backing queue q4"
        },
        {
          "name": "gauge.queue.consumer_utilisation",
          "type": "gauge",
          "description": "Fraction of the time (between 0.0 and 1.0) that the queue is able to immediately deliver messages to consumers."
        },
        {
          "name": "gauge.queue.consumers",
          "type": "gauge",
          "description": "Number of consumers of the queue"
        },
        {
          "name": "gauge.queue.memory",
          "type": "gauge",
          "description": "Bytes of memory consumed by the Erlang process associated with the queue, including stack, heap and internal structures."
        },
        {
          "name": "gauge.queue.message_bytes",
          "type": "gauge",
          "description": "Sum of the size of all message bodies in the queue. This does not include the message properties (including headers) or any overhead."
        },
        {
          "name": "gauge.queue.message_bytes_persistent",
          "type": "gauge",
          "description": "Total number of persistent messages in the queue (will always be 0 for transient queues)."
        },
        {
          "name": "gauge.queue.message_bytes_ram",
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages which are in RAM."
        },
        {
          "name": "gauge.queue.message_bytes_ready",
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages ready to be delivered to clients."
        },
        {
          "name": "gauge.queue.message_bytes_unacknowledged",
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages delivered to clients but not yet acknowledged."
        },
        {
          "name": "gauge.queue.message_stats.ack_details.rate",
          "type": "gauge",
          "description": "How much the number of acknowledged messages has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.queue.message_stats.deliver_details.rate",
          "type": "gauge",
          "description": "How much the count of messages delivered has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.queue.message_stats.deliver_get_details.rate",
          "type": "gauge",
          "description": "How much the count of all messages delivered has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.queue.message_stats.publish_details.rate",
          "type": "gauge",
          "description": "How much the count of messages published has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.queue.messages",
          "type": "gauge",
          "description": "Sum of ready and unacknowledged messages (queue depth)."
        },
        {
          "name": "gauge.queue.messages_details.rate",
          "type": "gauge",
          "description": "How much the queue depth has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.queue.messages_persistent",
          "type": "gauge",
          "description": "Total number of persistent messages in the queue (will always be 0 for transient queues)."
        },
        {
          "name": "gauge.queue.messages_ram",
          "type": "gauge",
          "description": "Total number of messages which are resident in RAM."
        },
        {
          "name": "gauge.queue.messages_ready",
          "type": "gauge",
          "description": "Number of messages ready to be delivered to clients."
        },
        {
          "name": "gauge.queue.messages_ready_details.rate",
          "type": "gauge",
          "description": "How much the count of messages ready has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.queue.messages_ready_ram",
          "type": "gauge",
          "description": "Number of messages from messages_ready which are resident in RAM."
        },
        {
          "name": "gauge.queue.messages_unacknowledged",
          "type": "gauge",
          "description": "Number of messages delivered to clients but not yet acknowledged."
        },
        {
          "name": "gauge.queue.messages_unacknowledged_details.rate",
          "type": "gauge",
          "description": "How much the count of unacknowledged messages has changed per second in the most recent sampling interval."
        },
        {
          "name": "gauge.queue.messages_unacknowledged_ram",
          "type": "gauge",
          "description": "Number of messages from messages_unacknowledged which are resident in RAM."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors a redis instance using the [collectd\nPython Redis plugin](https://github.com/signalfx/redis-collectd-plugin).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-redis)\nfor more information.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/redis\n  host: 127.0.0.1\n  port: 9100\n```\n\nSample YAML configuration with list lengths:\n\n```yaml\nmonitors:\n- type: collectd/redis\n  host: 127.0.0.1\n  port: 9100\n  sendListLengths:\n  - databaseIndex: 0\n    keyPattern: 'mylist*'\n```\n",
      "package": "internal/monitors/collectd/redis",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "The name for the node is a canonical identifier which is used as plugin instance. It is limited to 64 characters in length.  (**default**: \"{host}:{port}\")",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "auth",
          "doc": "Password to use for authentication.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "sendListLengths",
          "doc": "Specify a pattern of keys to lists for which to send their length as a metric. See below for more details.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "ListLength",
            "doc": "ListLength defines a database index and key pattern for sending list lengths",
            "package": "internal/monitors/collectd/redis",
            "fields": [
              {
                "yamlName": "databaseIndex",
                "doc": "The database index.",
                "default": null,
                "required": true,
                "type": "uint16",
                "elementKind": ""
              },
              {
                "yamlName": "keyPattern",
                "doc": "Can be a globbed pattern (only * is supported), in which case all keys matching that glob will be processed.  The pattern should be placed in single quotes (').  Ex. `'mylist*'`",
                "default": null,
                "required": true,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "monitorType": "collectd/redis",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "bytes.used_memory",
          "type": "gauge",
          "description": "Number of bytes allocated by Redis"
        },
        {
          "name": "bytes.used_memory_lua",
          "type": "gauge",
          "description": "Number of bytes used by the Lua engine"
        },
        {
          "name": "bytes.used_memory_peak",
          "type": "gauge",
          "description": "Peak Number of bytes allocated by Redis"
        },
        {
          "name": "bytes.used_memory_rss",
          "type": "gauge",
          "description": "Number of bytes allocated by Redis as seen by the OS"
        },
        {
          "name": "counter.commands_processed",
          "type": "cumulative",
          "description": "Total number of commands processed by the server"
        },
        {
          "name": "counter.connections_received",
          "type": "cumulative",
          "description": "Total number of connections accepted by the server"
        },
        {
          "name": "counter.evicted_keys",
          "type": "cumulative",
          "description": "Number of evicted keys due to maxmemory limit"
        },
        {
          "name": "counter.expired_keys",
          "type": "cumulative",
          "description": "Total number of key expiration events"
        },
        {
          "name": "counter.lru_clock",
          "type": "cumulative",
          "description": "Clock incrementing every minute, for LRU management"
        },
        {
          "name": "counter.rejected_connections",
          "type": "cumulative",
          "description": "Number of connections rejected because of maxclients limit"
        },
        {
          "name": "counter.total_net_input_bytes",
          "type": "cumulative",
          "description": "Total number of bytes inputted"
        },
        {
          "name": "counter.total_net_output_bytes",
          "type": "cumulative",
          "description": "Total number of bytes outputted"
        },
        {
          "name": "counter.used_cpu_sys",
          "type": "cumulative",
          "description": "System CPU consumed by the Redis server"
        },
        {
          "name": "counter.used_cpu_sys_children",
          "type": "cumulative",
          "description": "System CPU consumed by the background processes"
        },
        {
          "name": "counter.used_cpu_user",
          "type": "cumulative",
          "description": "User CPU consumed by the Redis server"
        },
        {
          "name": "counter.used_cpu_user_children",
          "type": "cumulative",
          "description": "User CPU consumed by the background processes"
        },
        {
          "name": "derive.keyspace_hits",
          "type": "cumulative",
          "description": "Number of successful lookup of keys in the main dictionary"
        },
        {
          "name": "derive.keyspace_misses",
          "type": "cumulative",
          "description": "Number of failed lookup of keys in the main dictionary"
        },
        {
          "name": "gauge.blocked_clients",
          "type": "gauge",
          "description": "Number of clients pending on a blocking call"
        },
        {
          "name": "gauge.changes_since_last_save",
          "type": "gauge",
          "description": "Number of changes since the last dump"
        },
        {
          "name": "gauge.client_biggest_input_buf",
          "type": "gauge",
          "description": "Biggest input buffer among current client connections"
        },
        {
          "name": "gauge.client_longest_output_list",
          "type": "gauge",
          "description": "Longest output list among current client connections"
        },
        {
          "name": "gauge.connected_clients",
          "type": "gauge",
          "description": "Number of client connections (excluding connections from slaves)"
        },
        {
          "name": "gauge.connected_slaves",
          "type": "gauge",
          "description": "Number of connected slaves"
        },
        {
          "name": "gauge.db0_avg_ttl",
          "type": "gauge",
          "description": "The average time to live for all keys in redis"
        },
        {
          "name": "gauge.db0_expires",
          "type": "gauge",
          "description": "The total number of keys in redis that will expire"
        },
        {
          "name": "gauge.db0_keys",
          "type": "gauge",
          "description": "The total number of keys stored in redis"
        },
        {
          "name": "gauge.instantaneous_ops_per_sec",
          "type": "gauge",
          "description": "Number of commands processed per second"
        },
        {
          "name": "gauge.key_llen",
          "type": "gauge",
          "description": "Length of an list key"
        },
        {
          "name": "gauge.latest_fork_usec",
          "type": "gauge",
          "description": "Duration of the latest fork operation in microseconds"
        },
        {
          "name": "gauge.master_last_io_seconds_ago",
          "type": "gauge",
          "description": "Number of seconds since the last interaction with master"
        },
        {
          "name": "gauge.master_repl_offset",
          "type": "gauge",
          "description": "Master replication offset"
        },
        {
          "name": "gauge.mem_fragmentation_ratio",
          "type": "gauge",
          "description": "Ratio between used_memory_rss and used_memory"
        },
        {
          "name": "gauge.rdb_bgsave_in_progress",
          "type": "gauge",
          "description": "Flag indicating a RDB save is on-going"
        },
        {
          "name": "gauge.repl_backlog_first_byte_offset",
          "type": "gauge",
          "description": "Slave replication backlog offset"
        },
        {
          "name": "gauge.slave_repl_offset",
          "type": "gauge",
          "description": "Slave replication offset"
        },
        {
          "name": "gauge.uptime_in_days",
          "type": "gauge",
          "description": "Number of days up"
        },
        {
          "name": "gauge.uptime_in_seconds",
          "type": "gauge",
          "description": "Number of seconds up"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Collectd Python plugin that aggregates\nvarious metrics from other collectd plugins.  It also sends host metadata to\nSignalFx through specially formatted events, and sends active process\n(\"top\") lists on a periodic basis.\n\nSee [Python plugin code](https://github.com/signalfx/collectd-signalfx/) and\n[Integrations docs](https://github.com/signalfx/integrations/tree/master/signalfx-metadata).\n",
      "package": "internal/monitors/collectd/metadata",
      "fields": [
        {
          "yamlName": "writeServerURL",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "procFSPath",
          "doc": "The path to the proc filesystem. Useful to override in containerized environments.",
          "default": "/proc",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "etcPath",
          "doc": "The path to the main host config dir. Useful to override in containerized environments.",
          "default": "/etc",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "persistencePath",
          "doc": "A directory where the metadata plugin can persist the history of successful host metadata syncs so that host metadata is not sent redundantly.",
          "default": "/var/run/signalfx-agent",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "omitProcessInfo",
          "doc": "If true, process \"top\" information will not be sent.  This can be useful if you have an extremely high number of processes and performance of the plugin is poor.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "dogStatsDPort",
          "doc": "Set this to a non-zero value to enable the DogStatsD listener as part of this monitor.  The listener will accept metrics on the DogStatsD format, and sends them as SignalFx datapoints to our backend.  Setting to a value setting the `DogStatsDPort` to `0` will result in a random port assignment. **Note: The listener emits directly to SignalFx and will not be subject to filters configured with the SignalFx Smart Agent.  Internal stats about the SignalFx Smart Agent will not reflect datapoints set through the DogStatsD listener**",
          "default": null,
          "required": false,
          "type": "uint",
          "elementKind": ""
        },
        {
          "yamlName": "token",
          "doc": "This is only required when running the DogStatsD listener.  Set this to your SignalFx access token.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "dogStatsDIP",
          "doc": "Optionally override the default ip that the DogStatsD listener listens on.  (**default**: \"0.0.0.0\")",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "ingestEndpoint",
          "doc": "This is optional only used when running the DogStatsD listener. By default the DogStatsD listener will emit to SignalFx Ingest. (**default**: \"https://ingest.signalfx.com\")",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "verbose",
          "doc": "Set this to enable verbose logging from the monitor",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/signalfx-metadata",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "cpu.utilization",
          "type": "gauge",
          "description": "Percent of CPU used on this host."
        },
        {
          "name": "cpu.utilization_per_core",
          "type": "gauge",
          "description": "Percent of CPU used on each core."
        },
        {
          "name": "disk.summary_utilization",
          "type": "gauge",
          "description": "Percent of disk space utilized on all volumes on this host."
        },
        {
          "name": "disk.utilization",
          "type": "gauge",
          "description": "Percent of disk used on this volume."
        },
        {
          "name": "disk_ops.total",
          "type": "cumulative",
          "description": "Total number of disk read and write operations on this host."
        },
        {
          "name": "memory.utilization",
          "type": "gauge",
          "description": "Percent of memory in use on this host."
        },
        {
          "name": "network.total",
          "type": "cumulative",
          "description": "Total amount of inbound and outbound network traffic on this host, in bytes."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Collects metrics about a Spark cluster using the\n[collectd Spark Python plugin](https://github.com/signalfx/collectd-spark).\nAlso see\nhttps://github.com/signalfx/integrations/tree/master/collectd-spark.\n\nYou have to specify distinct monitor configurations and discovery rules for\nmaster and worker processes.  For the master configuration, set `isMaster`\nto true.\n\nWe only support HTTP endpoints for now.\n\nWhen running Spark on Apache Hadoop / Yarn, this integration is only capable\nof reporting application metrics from the master node.  Please use the\ncollectd/hadoop monitor to report on the health of the cluster.\n\nAn example configuration for monitoring applications on Yarn\n```yaml\nmonitors:\n  - type: collectd/spark\n    host: 000.000.000.000\n    port: 8088\n    clusterType: Yarn\n    isMaster: true\n    collectApplicationMetrics: true\n```\n",
      "package": "internal/monitors/collectd/spark",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "isMaster",
          "doc": "Set to `true` when monitoring a master Spark node",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "clusterType",
          "doc": "Should be one of `Standalone` or `Mesos` or `Yarn`.  Cluster metrics will not be collected on Yarn.  Please use the collectd/hadoop monitor to gain insights to your cluster's health.",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "collectApplicationMetrics",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "enhancedMetrics",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/spark",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.HiveExternalCatalog.counter.HiveClientCalls",
          "type": "counter",
          "description": "Total number of client calls sent to Hive for query processing"
        },
        {
          "name": "counter.HiveExternalCatalog.fileCacheHits",
          "type": "counter",
          "description": "Total number of file level cache hits occurred"
        },
        {
          "name": "counter.HiveExternalCatalog.filesDiscovered",
          "type": "counter",
          "description": "Total number of files discovered"
        },
        {
          "name": "counter.HiveExternalCatalog.parallelListingJobCount",
          "type": "counter",
          "description": "Total number of Hive-specific jobs running in parallel"
        },
        {
          "name": "counter.HiveExternalCatalog.partitionsFetched",
          "type": "counter",
          "description": "Total number of partitions fetched"
        },
        {
          "name": "counter.spark.driver.completed_tasks",
          "type": "counter",
          "description": "Total number of completed tasks in driver mapped to a particular application"
        },
        {
          "name": "counter.spark.driver.disk_used",
          "type": "counter",
          "description": "Amount of disk used by driver mapped to a particular application"
        },
        {
          "name": "counter.spark.driver.failed_tasks",
          "type": "counter",
          "description": "Total number of failed tasks in driver mapped to a particular application"
        },
        {
          "name": "counter.spark.driver.memory_used",
          "type": "counter",
          "description": "Amount of memory used by driver mapped to a particular application"
        },
        {
          "name": "counter.spark.driver.total_duration",
          "type": "counter",
          "description": "Fraction of time spent by driver mapped to a particular application"
        },
        {
          "name": "counter.spark.driver.total_input_bytes",
          "type": "counter",
          "description": "Number of input bytes in driver mapped to a particular application"
        },
        {
          "name": "counter.spark.driver.total_shuffle_read",
          "type": "counter",
          "description": "Size read during a shuffle in driver mapped to a particular application"
        },
        {
          "name": "counter.spark.driver.total_shuffle_write",
          "type": "counter",
          "description": "Size written to during a shuffle in driver mapped to a particular application"
        },
        {
          "name": "counter.spark.driver.total_tasks",
          "type": "counter",
          "description": "Total number of tasks in driver mapped to a particular application"
        },
        {
          "name": "counter.spark.executor.completed_tasks",
          "type": "counter",
          "description": "Completed tasks across executors working for a particular application"
        },
        {
          "name": "counter.spark.executor.disk_used",
          "type": "counter",
          "description": "Amount of disk used across executors working for a particular application"
        },
        {
          "name": "counter.spark.executor.failed_tasks",
          "type": "counter",
          "description": "Failed tasks across executors working for a particular application"
        },
        {
          "name": "counter.spark.executor.memory_used",
          "type": "counter",
          "description": "Amount of memory used across executors working for a particular application"
        },
        {
          "name": "counter.spark.executor.total_duration",
          "type": "counter",
          "description": "Fraction of time spent across executors working for a particular application"
        },
        {
          "name": "counter.spark.executor.total_input_bytes",
          "type": "counter",
          "description": "Number of input bytes across executors working for a particular application"
        },
        {
          "name": "counter.spark.executor.total_shuffle_read",
          "type": "counter",
          "description": "Size read during a shuffle in a particular application's executors"
        },
        {
          "name": "counter.spark.executor.total_shuffle_write",
          "type": "counter",
          "description": "Size written to during a shuffle in a particular application's executors"
        },
        {
          "name": "counter.spark.executor.total_tasks",
          "type": "counter",
          "description": "Total tasks across executors working for a particular application"
        },
        {
          "name": "counter.spark.streaming.num_processed_records",
          "type": "counter",
          "description": "Number of processed records in a streaming application"
        },
        {
          "name": "counter.spark.streaming.num_received_records",
          "type": "counter",
          "description": "Number of received records in a streaming application"
        },
        {
          "name": "counter.spark.streaming.num_total_completed_batches",
          "type": "counter",
          "description": "Number of batches completed in a streaming application"
        },
        {
          "name": "gauge.jvm.MarkSweepCompact.count",
          "type": "gauge",
          "description": "Garbage collection count"
        },
        {
          "name": "gauge.jvm.MarkSweepCompact.time",
          "type": "gauge",
          "description": "Garbage collection time"
        },
        {
          "name": "gauge.jvm.heap.committed",
          "type": "gauge",
          "description": "Amount of committed heap memory (in MB)"
        },
        {
          "name": "gauge.jvm.heap.used",
          "type": "gauge",
          "description": "Amount of used heap memory (in MB)"
        },
        {
          "name": "gauge.jvm.non-heap.committed",
          "type": "gauge",
          "description": "Amount of committed non-heap memory (in MB)"
        },
        {
          "name": "gauge.jvm.non-heap.used",
          "type": "gauge",
          "description": "Amount of used non-heap memory (in MB)"
        },
        {
          "name": "gauge.jvm.pools.Code-Cache.committed",
          "type": "gauge",
          "description": "Amount of memory committed for compilation and storage of native code"
        },
        {
          "name": "gauge.jvm.pools.Code-Cache.used",
          "type": "gauge",
          "description": "Amount of memory used to compile and store native code"
        },
        {
          "name": "gauge.jvm.pools.Compressed-Class-Space.committed",
          "type": "gauge",
          "description": "Amount of memory committed for compressing a class object"
        },
        {
          "name": "gauge.jvm.pools.Compressed-Class-Space.used",
          "type": "gauge",
          "description": "Amount of memory used to compress a class object"
        },
        {
          "name": "gauge.jvm.pools.Eden-Space.committed",
          "type": "gauge",
          "description": "Amount of memory committed for the initial allocation of objects"
        },
        {
          "name": "gauge.jvm.pools.Eden-Space.used",
          "type": "gauge",
          "description": "Amount of memory used for the initial allocation of objects"
        },
        {
          "name": "gauge.jvm.pools.Metaspace.committed",
          "type": "gauge",
          "description": "Amount of memory committed for storing classes and classloaders"
        },
        {
          "name": "gauge.jvm.pools.Metaspace.used",
          "type": "gauge",
          "description": "Amount of memory used to store classes and classloaders"
        },
        {
          "name": "gauge.jvm.pools.Survivor-Space.committed",
          "type": "gauge",
          "description": "Amount of memory committed specifically for objects that have survived GC of the Eden Space"
        },
        {
          "name": "gauge.jvm.pools.Survivor-Space.used",
          "type": "gauge",
          "description": "Amount of memory used for objects that have survived GC of the Eden Space"
        },
        {
          "name": "gauge.jvm.pools.Tenured-Gen.committed",
          "type": "gauge",
          "description": "Amount of memory committed to store objects that have lived in the survivor space for a given period of time"
        },
        {
          "name": "gauge.jvm.pools.Tenured-Gen.used",
          "type": "gauge",
          "description": "Amount of memory used for objects that have lived in the survivor space for a given period of time"
        },
        {
          "name": "gauge.jvm.total.committed",
          "type": "gauge",
          "description": "Amount of committed JVM memory (in MB)"
        },
        {
          "name": "gauge.jvm.total.used",
          "type": "gauge",
          "description": "Amount of used JVM memory (in MB)"
        },
        {
          "name": "gauge.master.aliveWorkers",
          "type": "gauge",
          "description": "Total functioning workers"
        },
        {
          "name": "gauge.master.apps",
          "type": "gauge",
          "description": "Total number of active applications in the spark cluster"
        },
        {
          "name": "gauge.master.waitingApps",
          "type": "gauge",
          "description": "Total number of waiting applications in the spark cluster"
        },
        {
          "name": "gauge.master.workers",
          "type": "gauge",
          "description": "Total number of workers in spark cluster"
        },
        {
          "name": "gauge.spark.driver.active_tasks",
          "type": "gauge",
          "description": "Total number of active tasks in driver mapped to a particular application"
        },
        {
          "name": "gauge.spark.driver.max_memory",
          "type": "gauge",
          "description": "Maximum memory used by driver mapped to a particular application"
        },
        {
          "name": "gauge.spark.driver.rdd_blocks",
          "type": "gauge",
          "description": "Number of RDD blocks in the driver mapped to a particular application"
        },
        {
          "name": "gauge.spark.executor.active_tasks",
          "type": "gauge",
          "description": "Total number of active tasks across all executors working for a particular application"
        },
        {
          "name": "gauge.spark.executor.count",
          "type": "gauge",
          "description": "Total number of executors performing for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.executor.max_memory",
          "type": "gauge",
          "description": "Max memory across all executors working for a particular application"
        },
        {
          "name": "gauge.spark.executor.rdd_blocks",
          "type": "gauge",
          "description": "Number of RDD blocks across all executors working for a particular application"
        },
        {
          "name": "gauge.spark.job.num_active_stages",
          "type": "gauge",
          "description": "Total number of active stages for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.job.num_active_tasks",
          "type": "gauge",
          "description": "Total number of active tasks for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.job.num_completed_stages",
          "type": "gauge",
          "description": "Total number of completed stages for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.job.num_completed_tasks",
          "type": "gauge",
          "description": "Total number of completed tasks for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.job.num_failed_stages",
          "type": "gauge",
          "description": "Total number of failed stages for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.job.num_failed_tasks",
          "type": "gauge",
          "description": "Total number of failed tasks for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.job.num_skipped_stages",
          "type": "gauge",
          "description": "Total number of skipped stages for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.job.num_skipped_tasks",
          "type": "gauge",
          "description": "Total number of skipped tasks for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.job.num_tasks",
          "type": "gauge",
          "description": "Total number of tasks for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.num_active_stages",
          "type": "gauge",
          "description": "Total number of active stages for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.num_running_jobs",
          "type": "gauge",
          "description": "Total number of running jobs for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.stage.disk_bytes_spilled",
          "type": "gauge",
          "description": "Actual size written to disk for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.stage.executor_run_time",
          "type": "gauge",
          "description": "Fraction of time spent by (and averaged across) executors for a particular application"
        },
        {
          "name": "gauge.spark.stage.input_bytes",
          "type": "gauge",
          "description": "Input size for a particular application"
        },
        {
          "name": "gauge.spark.stage.input_records",
          "type": "gauge",
          "description": "Input records received for a particular application"
        },
        {
          "name": "gauge.spark.stage.memory_bytes_spilled",
          "type": "gauge",
          "description": "Size spilled to disk from memory for an active application in the spark cluster"
        },
        {
          "name": "gauge.spark.stage.output_bytes",
          "type": "gauge",
          "description": "Output size for a particular application"
        },
        {
          "name": "gauge.spark.stage.output_records",
          "type": "gauge",
          "description": "Output records written to for a particular application"
        },
        {
          "name": "gauge.spark.stage.shuffle_read_bytes",
          "type": "gauge",
          "description": "Read size during shuffle phase for a particular application"
        },
        {
          "name": "gauge.spark.stage.shuffle_read_records",
          "type": "gauge",
          "description": "Number of records read during shuffle phase for a particular application"
        },
        {
          "name": "gauge.spark.stage.shuffle_write_bytes",
          "type": "gauge",
          "description": "Size written during shuffle phase for a particular application"
        },
        {
          "name": "gauge.spark.stage.shuffle_write_records",
          "type": "gauge",
          "description": "Number of records written to during shuffle phase for a particular application"
        },
        {
          "name": "gauge.spark.streaming.avg_input_rate",
          "type": "gauge",
          "description": "Average input rate of records across retained batches in a streaming application"
        },
        {
          "name": "gauge.spark.streaming.avg_processing_time",
          "type": "gauge",
          "description": "Average processing time in a streaming application"
        },
        {
          "name": "gauge.spark.streaming.avg_scheduling_delay",
          "type": "gauge",
          "description": "Average scheduling delay in a streaming application"
        },
        {
          "name": "gauge.spark.streaming.avg_total_delay",
          "type": "gauge",
          "description": "Average total delay in a streaming application"
        },
        {
          "name": "gauge.spark.streaming.num_active_batches",
          "type": "gauge",
          "description": "Number of active batches in a streaming application"
        },
        {
          "name": "gauge.spark.streaming.num_inactive_receivers",
          "type": "gauge",
          "description": "Number of inactive receivers in a streaming application"
        },
        {
          "name": "gauge.worker.coresFree",
          "type": "gauge",
          "description": "Total cores free for a particular worker process"
        },
        {
          "name": "gauge.worker.coresUsed",
          "type": "gauge",
          "description": "Total cores used by a particular worker process"
        },
        {
          "name": "gauge.worker.executors",
          "type": "gauge",
          "description": "Total number of executors for a particular worker process"
        },
        {
          "name": "gauge.worker.memFree_MB",
          "type": "gauge",
          "description": "Total memory free for a particular worker process"
        },
        {
          "name": "gauge.worker.memUsed_MB",
          "type": "gauge",
          "description": "Memory used by a particular worker process"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " The StatsD plugin for collectd listens for StatsD\nevents, aggregates them and transmits them according to collectd's\nconfiguration. Use this plugin to send data from StatsD to SignalFx [statsd\nplugin](https://collectd.org/wiki/index.php/Plugin:StatsD).\n\nSignalFx supports `Counter`, `Timer` and `Gauge` types which are dispatched\nas the collectd types - `derive`, `latency` and `gauge` respectively.\nIn SignalFx, for a statsd metric, its collectd type is attached as a\nprefix to the metric name. As an example, if you send in the gauge -\n\n```\n$ echo \"statsd.test:1|g\" | nc -w 1 -u 127.0.0.1 8125\n```\n\nThis will be reported to SignalFx as \"gauge.statsd.test\"\n\n### USAGE\n\n#### Adding dimensions to StatsD metrics\n\nAdd dimensions to your metrics by adding key-value pairs to your StatsD\nmetric names as follows:\n\n```\n$ echo \"statsd.[foo=bar,dim=val]test:1|g\" | nc -w 1 -u 127.0.0.1 8125\n```\n\nThis creates a metric called `statsd.test` of type gauge, with dimensions\n`foo=bar` and `dim=val`.\n\n#### Delete[Type]s boolean setting\n\nThese options control what happens if metrics are not updated in an\ninterval. If set to False, the default, metrics are dispatched unchanged,\ni.e. the rate of counters and size of sets will be zero, timers report NaN\nand gauges are unchanged. If set to True, the such metrics are not\ndispatched and removed from the internal cache.\n\nSignalFx's default configuration for this plugin sets all `Delete[Type]s`\nconfiguration options to `True`. We strongly recommend this in order to\nensure that metrics that have stopped reporting are not reported as 0 in\nperpetuity. Setting these parameters to `False` results in collectd's memory\nusage increasing over time, as the set of metrics reported from StatsD grows\nindefinitely. This is especially important in environments that are\nlong-running or whose metrics change frequently.\n\n#### CounterSum boolean setting\n\nWhen enabled, creates a count metric which reports the change since the last\nread. This option primarily exists for compatibility with the statsd\nimplementation by Etsy.\n\nIf you are only looking at the counts generated by each reporting interval,\nequivalent to\n[Counters](https://docs.signalfx.com/en/latest/concepts/metric-types.html?highlight=Counters)\nin SignalFx then we'd recommend that you set CounterSum to `True`. It will\nsend in an additional counter metric with a prefix of `count`.\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: collectd/statsd\n   listenAddress: \"0.0.0.0\"\n   listenPort: 8125\n   deleteSets: true\n   timerPercentile: 90.0\n```\n",
      "package": "internal/monitors/collectd/statsd",
      "fields": [
        {
          "yamlName": "listenAddress",
          "doc": "The host/address on which to bind the UDP listener that accepts statsd datagrams",
          "default": "localhost",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "listenPort",
          "doc": "The port on which to listen for statsd messages",
          "default": 8125,
          "required": false,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "deleteSets",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "deleteCounters",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "deleteTimers",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "deleteGauges",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "timerPercentile",
          "doc": "",
          "default": 0,
          "required": false,
          "type": "float64",
          "elementKind": ""
        },
        {
          "yamlName": "timerUpper",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "timerSum",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "timerLower",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "counterSum",
          "doc": "",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/statsd",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Sends a single metric of the total number of\nseconds the host has been up, using the [collectd uptime\nplugin](https://collectd.org/wiki/index.php/Plugin:Uptime).\n",
      "package": "internal/monitors/collectd/uptime",
      "fields": [],
      "monitorType": "collectd/uptime",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "uptime",
          "type": "gauge",
          "description": "Seconds since system boot"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Collects information about the virtual memory\nsubsystem of the kernel using the [collectd vmem\nplugin](https://collectd.org/wiki/index.php/Plugin:vmem).  There is no\nconfiguration available for this plugin.\n",
      "package": "internal/monitors/collectd/vmem",
      "fields": [],
      "monitorType": "collectd/vmem",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": [
        {
          "name": "vmpage_faults.majflt",
          "type": "cumulative",
          "description": "Number of major page faults on the system"
        },
        {
          "name": "vmpage_faults.minflt",
          "type": "cumulative",
          "description": "Number of minor page faults on the system"
        },
        {
          "name": "vmpage_io.memory.in",
          "type": "cumulative",
          "description": "Page Ins for Memory"
        },
        {
          "name": "vmpage_io.memory.out",
          "type": "cumulative",
          "description": "Page Outs for Memory"
        },
        {
          "name": "vmpage_io.swap.in",
          "type": "cumulative",
          "description": "Page Ins for Swap"
        },
        {
          "name": "vmpage_io.swap.out",
          "type": "cumulative",
          "description": "Page Outs for Swap"
        },
        {
          "name": "vmpage_number.free_pages",
          "type": "cumulative",
          "description": "Number of free memory pages"
        },
        {
          "name": "vmpage_number.mapped",
          "type": "cumulative",
          "description": "Number of mapped pages"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Monitors an Apache Zookeeper instance.\n\nSee the [Python plugin\nsource](https://github.com/signalfx/collectd-zookeeper) and the\n[integrations repo\npage](https://github.com/signalfx/integrations/tree/master/collectd-zookeeper)\nfor more information.\n",
      "package": "internal/monitors/collectd/zookeeper",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "collectd/zookeeper",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "counter.zk_packets_received",
          "type": "cumulative",
          "description": "Count of the number of ZooKeeper packets received by a server"
        },
        {
          "name": "counter.zk_packets_sent",
          "type": "cumulative",
          "description": "Count of the number of ZooKeeper packets sent from a server"
        },
        {
          "name": "gauge.zk_approximate_data_size",
          "type": "gauge",
          "description": "Size of data in bytes that a ZooKeeper server has in its data tree"
        },
        {
          "name": "gauge.zk_avg_latency",
          "type": "gauge",
          "description": "Average time in milliseconds for requests to be processed"
        },
        {
          "name": "gauge.zk_ephemerals_count",
          "type": "gauge",
          "description": "Number of ephemeral nodes that a ZooKeeper server has in its data tree"
        },
        {
          "name": "gauge.zk_max_file_descriptor_count",
          "type": "gauge",
          "description": "Maximum number of file descriptors that a ZooKeeper server can open"
        },
        {
          "name": "gauge.zk_max_latency",
          "type": "gauge",
          "description": "Maximum time in milliseconds for a request to be processed"
        },
        {
          "name": "gauge.zk_min_latency",
          "type": "gauge",
          "description": "Minimum time in milliseconds for a request to be processed"
        },
        {
          "name": "gauge.zk_num_alive_connections",
          "type": "gauge",
          "description": "Number of active clients connected to a ZooKeeper server"
        },
        {
          "name": "gauge.zk_open_file_descriptor_count",
          "type": "gauge",
          "description": "Number of file descriptors that a ZooKeeper server has open"
        },
        {
          "name": "gauge.zk_outstanding_requests",
          "type": "gauge",
          "description": "Number of currently executing requests"
        },
        {
          "name": "gauge.zk_watch_count",
          "type": "gauge",
          "description": "Number of watches placed on Z-Nodes on a ZooKeeper server"
        },
        {
          "name": "gauge.zk_znode_count",
          "type": "gauge",
          "description": "Number of z-nodes that a ZooKeeper server has in its data tree"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor reads container stats from a\nDocker API server.  It is meant as a metric-compatible replacement of our\n[docker-collectd](https://github.com/signalfx/docker-collectd-plugin)\nplugin, which scales rather poorly against a large number of containers.\n\nThis currently does not support CPU share/quota metrics.\n\nIf you are running the agent directly on a host (outside of a container\nitself) and you are using the default Docker UNIX socket URL, you will\nprobably need to add the `signalfx-agent` user to the `docker` group in\norder to have permission to access the Docker API via the socket.\n\nRequires Docker API version 1.22+.\n",
      "package": "internal/monitors/docker",
      "fields": [
        {
          "yamlName": "dockerURL",
          "doc": "The URL of the docker server",
          "default": "unix:///var/run/docker.sock",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "timeoutSeconds",
          "doc": "The maximum amount of time to wait for docker API requests",
          "default": 5,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "labelsToDimensions",
          "doc": "A mapping of container label names to dimension names. The corresponding label values will become the dimension value for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "excludedImages",
          "doc": "A list of filters of images to exclude.  Supports literals, globs, and regex.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        }
      ],
      "monitorType": "docker-container-stats",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "blkio.io_service_bytes_recursive.async",
          "type": "cumulative",
          "description": "Volume, in bytes, of asynchronous block I/O"
        },
        {
          "name": "blkio.io_service_bytes_recursive.read",
          "type": "cumulative",
          "description": "Volume, in bytes, of reads from block devices"
        },
        {
          "name": "blkio.io_service_bytes_recursive.sync",
          "type": "cumulative",
          "description": "Volume, in bytes, of synchronous block I/O"
        },
        {
          "name": "blkio.io_service_bytes_recursive.total",
          "type": "cumulative",
          "description": "Total volume, in bytes, of all block I/O"
        },
        {
          "name": "blkio.io_service_bytes_recursive.write",
          "type": "cumulative",
          "description": "Volume, in bytes, of writes to block devices"
        },
        {
          "name": "blkio.io_serviced_recursive.async",
          "type": "cumulative",
          "description": "Number of asynchronous block I/O requests"
        },
        {
          "name": "blkio.io_serviced_recursive.read",
          "type": "cumulative",
          "description": "Number of reads requests from block devices"
        },
        {
          "name": "blkio.io_serviced_recursive.sync",
          "type": "cumulative",
          "description": "Number of synchronous block I/O requests"
        },
        {
          "name": "blkio.io_serviced_recursive.total",
          "type": "cumulative",
          "description": "Total number of block I/O requests"
        },
        {
          "name": "blkio.io_serviced_recursive.write",
          "type": "cumulative",
          "description": "Number of write requests to block devices"
        },
        {
          "name": "cpu.percent",
          "type": "gauge",
          "description": "Percentage of host CPU resources used by the container"
        },
        {
          "name": "cpu.percpu.usage",
          "type": "cumulative",
          "description": "Jiffies of CPU time spent by the container, per CPU core"
        },
        {
          "name": "cpu.percpu.usage",
          "type": "cumulative",
          "description": "Jiffies of CPU time spent by the container, per CPU core"
        },
        {
          "name": "cpu.throttling_data.periods",
          "type": "cumulative",
          "description": "Number of periods"
        },
        {
          "name": "cpu.throttling_data.throttled_periods",
          "type": "cumulative",
          "description": "Number of periods throttled"
        },
        {
          "name": "cpu.throttling_data.throttled_time",
          "type": "cumulative",
          "description": "Throttling time in nano seconds"
        },
        {
          "name": "cpu.usage.kernelmode",
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in kernel mode by the container"
        },
        {
          "name": "cpu.usage.system",
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the system"
        },
        {
          "name": "cpu.usage.total",
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the container"
        },
        {
          "name": "cpu.usage.usermode",
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in user mode by the container"
        },
        {
          "name": "memory.stats.swap",
          "type": "gauge",
          "description": "Bytes of swap memory used by container"
        },
        {
          "name": "memory.usage.limit",
          "type": "gauge",
          "description": "Memory usage limit of the container, in bytes"
        },
        {
          "name": "memory.usage.max",
          "type": "gauge",
          "description": "Maximum measured memory usage of the container, in bytes"
        },
        {
          "name": "memory.usage.total",
          "type": "gauge",
          "description": "Bytes of memory used by the container"
        },
        {
          "name": "network.usage.rx_bytes",
          "type": "cumulative",
          "description": "Bytes received by the container via its network interface"
        },
        {
          "name": "network.usage.rx_dropped",
          "type": "cumulative",
          "description": "Number of inbound network packets dropped by the container"
        },
        {
          "name": "network.usage.rx_errors",
          "type": "cumulative",
          "description": "Errors receiving network packets"
        },
        {
          "name": "network.usage.rx_packets",
          "type": "cumulative",
          "description": "Network packets received by the container via its network interface"
        },
        {
          "name": "network.usage.tx_bytes",
          "type": "cumulative",
          "description": "Bytes sent by the container via its network interface"
        },
        {
          "name": "network.usage.tx_dropped",
          "type": "cumulative",
          "description": "Number of outbound network packets dropped by the container"
        },
        {
          "name": "network.usage.tx_errors",
          "type": "cumulative",
          "description": "Errors sending network packets"
        },
        {
          "name": "network.usage.tx_packets",
          "type": "cumulative",
          "description": "Network packets sent by the container via its network interface"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor collects metadata properties about a\nhost.  It is required for some views in SignalFx to operate.\n\n```yaml\nmonitors:\n  - type: host-metadata\n```\n\nIn containerized environments host `/etc` and `/proc` may not be located\ndirectly under the root path.  You can specify the path to `proc` and `etc`\nusing the monitor configurations `procFSPath` and `etcPath`\n\n```yaml\nmonitors:\n  - type: host-metadata\n    procFSPath: \"/hostfs/proc\"\n    etcPath: \"/hostfs/etc\"\n```\n\nMetadata updates occur on a sparse interval of approximately\n1m, 1m, 1h, 1d and continues repeating once per day.\nSetting the `Interval` configuration for this monitor will not affect the\nsparse interval on which metadata is collected.\n",
      "package": "internal/monitors/metadata/hostmetadata",
      "fields": [
        {
          "yamlName": "procFSPath",
          "doc": "The path to the proc filesystem. Useful to override in containerized environments.",
          "default": "/proc",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "etcPath",
          "doc": "The path to the main host config dir. Useful to override in containerized environments.",
          "default": "/etc",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "host-metadata",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": [
        {
          "name": "collectd",
          "description": "The version of collectd in the signalfx-agent"
        },
        {
          "name": "kernel_name",
          "description": "The name of the host kernel."
        },
        {
          "name": "kernel_release",
          "description": "The release of the host kernel."
        },
        {
          "name": "kernel_version",
          "description": "The version of the host kernel."
        },
        {
          "name": "os_version",
          "description": "The version of the os on the host."
        },
        {
          "name": "signalfx_agent",
          "description": "The version of the signalfx-agent"
        }
      ],
      "metrics": [
        {
          "name": "sfxagent.hostmetadata",
          "type": "gauge",
          "description": "The time the hostmetadata monitor has been running in seconds.  It includes dimensional metadata about the host and agent."
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Emits metrics about the internal state of the\nagent.  Useful for debugging performance issues with the agent and to ensure\nthe agent isn't overloaded.\n\n```yaml\nmonitors:\n  - type: internal-metrics\n```\n",
      "package": "internal/monitors/internalmetrics",
      "fields": [],
      "monitorType": "internal-metrics",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": [
        {
          "name": "sfxagent.active_monitors",
          "type": "gauge",
          "description": "The total number of monitor instances actively working"
        },
        {
          "name": "sfxagent.active_observers",
          "type": "gauge",
          "description": "The number of observers configured and running"
        },
        {
          "name": "sfxagent.configured_monitors",
          "type": "gauge",
          "description": "The total number of monitor configurations"
        },
        {
          "name": "sfxagent.datapoint_requests_active",
          "type": "gauge",
          "description": "The total number of outstanding requests to ingest currently active."
        },
        {
          "name": "sfxagent.datapoints_buffered",
          "type": "gauge",
          "description": "The total number of datapoints that have been emitted by monitors but have yet to be processed by the writer"
        },
        {
          "name": "sfxagent.datapoints_in_flight",
          "type": "gauge",
          "description": "The total number of datapoints that have been accepted by the writer but still lack confirmation from ingest that they have been received."
        },
        {
          "name": "sfxagent.datapoints_sent",
          "type": "cumulative",
          "description": "The total number of datapoints sent by the agent since it last started"
        },
        {
          "name": "sfxagent.discovered_endpoints",
          "type": "gauge",
          "description": "The number of discovered service endpoints.  This includes endpoints that do not have any matching monitor configuration discovery rule."
        },
        {
          "name": "sfxagent.events_buffered",
          "type": "gauge",
          "description": "The total number of events that have been emitted by monitors but have yet to be sent to SignalFx"
        },
        {
          "name": "sfxagent.events_sent",
          "type": "cumulative",
          "description": "The total number of events sent by the agent since it last started"
        },
        {
          "name": "sfxagent.go_frees",
          "type": "cumulative",
          "description": "Total number of heap objects freed throughout the lifetime of the agent"
        },
        {
          "name": "sfxagent.go_heap_alloc",
          "type": "gauge",
          "description": "Bytes of live heap memory (memory that has been allocated but not freed)"
        },
        {
          "name": "sfxagent.go_heap_idle",
          "type": "gauge",
          "description": "Bytes of memory that consist of idle spans (that is, completely empty spans of memory)"
        },
        {
          "name": "sfxagent.go_heap_inuse",
          "type": "gauge",
          "description": "Size in bytes of in use spans"
        },
        {
          "name": "sfxagent.go_heap_released",
          "type": "gauge",
          "description": "Bytes of memory that have been returned to the OS.  This is quite often 0.  `sfxagent.go_heap_idle - sfxagent.go_heap_release` is the memory that Go is retaining for future heap allocations."
        },
        {
          "name": "sfxagent.go_heap_sys",
          "type": "gauge",
          "description": "Virtual memory size in bytes of the agent.  This will generally reflect the largest heap size the agent has ever had in its lifetime."
        },
        {
          "name": "sfxagent.go_mallocs",
          "type": "cumulative",
          "description": "Total number of heap objects allocated throughout the lifetime of the agent"
        },
        {
          "name": "sfxagent.go_next_gc",
          "type": "gauge",
          "description": "The target heap size -- GC tries to keep the heap smaller than this"
        },
        {
          "name": "sfxagent.go_num_gc",
          "type": "gauge",
          "description": "The number of GC cycles that have happened in the agent since it started"
        },
        {
          "name": "sfxagent.go_stack_inuse",
          "type": "gauge",
          "description": "Size in bytes of spans that have at least one goroutine stack in them"
        },
        {
          "name": "sfxagent.go_total_alloc",
          "type": "cumulative",
          "description": "Total number of bytes allocated to the heap throughout the lifetime of the agent"
        },
        {
          "name": "sfxgent.go_num_goroutine",
          "type": "gauge",
          "description": "Number of goroutines in the agent"
        }
      ],
      "properties": null
    },
    {
      "name": "KubeletStatsConfig",
      "doc": " This monitor pulls cadvisor metrics through a\nKubernetes kubelet instance via the `/stats/container` endpoint.\n",
      "package": "internal/monitors/cadvisor",
      "fields": [
        {
          "yamlName": "kubeletAPI",
          "doc": "Kubelet client configuration",
          "default": null,
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains config specific to the KubeletAPI",
            "package": "internal/core/common/kubelet",
            "fields": [
              {
                "yamlName": "url",
                "doc": "URL of the Kubelet instance.  This will default to `https://\u003ccurrent node hostname\u003e:10250` if not provided.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "authType",
                "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                "default": "none",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verification of the Kubelet's TLS cert",
                "default": true,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "logResponses",
                "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "monitorType": "kubelet-stats",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": [
        {
          "name": "container_id",
          "description": "The ID of the running container"
        },
        {
          "name": "container_image",
          "description": "The container image name"
        },
        {
          "name": "container_name",
          "description": "The container's name as it appears in the pod spec, the same as container_spec_name but retained for backwards compatibility."
        },
        {
          "name": "container_spec_name",
          "description": "The container's name as it appears in the pod spec"
        },
        {
          "name": "kubernetes_namespace",
          "description": "The K8s namespace the container is part of"
        },
        {
          "name": "kubernetes_pod_name",
          "description": "The pod instance under which this container runs"
        },
        {
          "name": "kubernetes_pod_uid",
          "description": "The UID of the pod instance under which this container runs"
        }
      ],
      "metrics": [
        {
          "name": "container_cpu_cfs_periods",
          "type": "counter",
          "description": "Total number of elapsed CFS enforcement intervals"
        },
        {
          "name": "container_cpu_cfs_throttled_periods",
          "type": "counter",
          "description": "Total number of times tasks in the cgroup have been throttled"
        },
        {
          "name": "container_cpu_cfs_throttled_time",
          "type": "counter",
          "description": "Total time duration, in nanoseconds, for which tasks in the cgroup have been throttled"
        },
        {
          "name": "container_cpu_percent",
          "type": "counter",
          "description": "Cumulative cpu utilization as a percentage of the total host CPU available.  This metric is equivalent to `container_cpu_utilization` / \u003c# of CPUs/cores on host\u003e."
        },
        {
          "name": "container_cpu_system_seconds_total",
          "type": "counter",
          "description": "Cumulative system cpu time consumed in nanoseconds"
        },
        {
          "name": "container_cpu_usage_seconds_total",
          "type": "counter",
          "description": "Cumulative cpu time consumed per cpu in nanoseconds"
        },
        {
          "name": "container_cpu_user_seconds_total",
          "type": "counter",
          "description": "Cumulative user cpu time consumed in nanoseconds"
        },
        {
          "name": "container_cpu_utilization",
          "type": "counter",
          "description": "Cumulative cpu utilization in percentages.  This is equivalent to \"centicores\", or hundreths of CPU cores consumed.  This metric is **NOT** normalized by the total # of cores on the system."
        },
        {
          "name": "container_fs_io_current",
          "type": "gauge",
          "description": "Number of I/Os currently in progress"
        },
        {
          "name": "container_fs_io_time_seconds_total",
          "type": "counter",
          "description": "Cumulative count of seconds spent doing I/Os"
        },
        {
          "name": "container_fs_io_time_weighted_seconds_total",
          "type": "counter",
          "description": "Cumulative weighted I/O time in seconds"
        },
        {
          "name": "container_fs_limit_bytes",
          "type": "gauge",
          "description": "Number of bytes that the container may occupy on this filesystem"
        },
        {
          "name": "container_fs_read_seconds_total",
          "type": "counter",
          "description": "Cumulative count of seconds spent reading"
        },
        {
          "name": "container_fs_reads_merged_total",
          "type": "counter",
          "description": "Cumulative count of reads merged"
        },
        {
          "name": "container_fs_reads_total",
          "type": "counter",
          "description": "Cumulative count of reads completed"
        },
        {
          "name": "container_fs_sector_reads_total",
          "type": "counter",
          "description": "Cumulative count of sector reads completed"
        },
        {
          "name": "container_fs_sector_writes_total",
          "type": "counter",
          "description": "Cumulative count of sector writes completed"
        },
        {
          "name": "container_fs_usage_bytes",
          "type": "gauge",
          "description": "Number of bytes that are consumed by the container on this filesystem"
        },
        {
          "name": "container_fs_write_seconds_total",
          "type": "counter",
          "description": "Cumulative count of seconds spent writing"
        },
        {
          "name": "container_fs_writes_merged_total",
          "type": "counter",
          "description": "Cumulative count of writes merged"
        },
        {
          "name": "container_fs_writes_total",
          "type": "counter",
          "description": "Cumulative count of writes completed"
        },
        {
          "name": "container_last_seen",
          "type": "gauge",
          "description": "Last time a container was seen by the exporter"
        },
        {
          "name": "container_memory_failcnt",
          "type": "counter",
          "description": "Number of memory usage hits limits"
        },
        {
          "name": "container_memory_failures_total",
          "type": "counter",
          "description": "Cumulative count of memory allocation failures"
        },
        {
          "name": "container_memory_usage_bytes",
          "type": "gauge",
          "description": "Current memory usage in bytes"
        },
        {
          "name": "container_memory_working_set_bytes",
          "type": "gauge",
          "description": "Current working set in bytes"
        },
        {
          "name": "container_spec_cpu_period",
          "type": "gauge",
          "description": "The number of microseconds that the [CFS scheduler](https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) uses as a window when limiting container processes"
        },
        {
          "name": "container_spec_cpu_quota",
          "type": "gauge",
          "description": "In CPU quota for the CFS process scheduler. In K8s this is equal to the containers's CPU limit as a fraction of 1 core and multiplied by the `container_spec_cpu_period`.  So if the CPU limit is `500m` (500 millicores) for a container and the `container_spec_cpu_period` is set to 100,000, this value will be 50,000."
        },
        {
          "name": "container_spec_cpu_shares",
          "type": "gauge",
          "description": "CPU share of the container"
        },
        {
          "name": "container_spec_memory_limit_bytes",
          "type": "gauge",
          "description": "Memory limit for the container."
        },
        {
          "name": "container_spec_memory_swap_limit_bytes",
          "type": "gauge",
          "description": "Memory swap limit for the container."
        },
        {
          "name": "container_start_time_seconds",
          "type": "gauge",
          "description": "Start time of the container since unix epoch in seconds."
        },
        {
          "name": "container_tasks_state",
          "type": "gauge",
          "description": "Number of tasks in given state"
        },
        {
          "name": "machine_cpu_cores",
          "type": "gauge",
          "description": "Number of CPU cores on the node."
        },
        {
          "name": "machine_cpu_frequency_khz",
          "type": "gauge",
          "description": "Node's CPU frequency."
        },
        {
          "name": "machine_memory_bytes",
          "type": "gauge",
          "description": "Amount of memory installed on the node."
        },
        {
          "name": "pod_network_receive_bytes_total",
          "type": "counter",
          "description": "Cumulative count of bytes received"
        },
        {
          "name": "pod_network_receive_errors_total",
          "type": "counter",
          "description": "Cumulative count of errors encountered while receiving"
        },
        {
          "name": "pod_network_receive_packets_dropped_total",
          "type": "counter",
          "description": "Cumulative count of packets dropped while receiving"
        },
        {
          "name": "pod_network_receive_packets_total",
          "type": "counter",
          "description": "Cumulative count of packets received"
        },
        {
          "name": "pod_network_transmit_bytes_total",
          "type": "counter",
          "description": "Cumulative count of bytes transmitted"
        },
        {
          "name": "pod_network_transmit_errors_total",
          "type": "counter",
          "description": "Cumulative count of errors encountered while transmitting"
        },
        {
          "name": "pod_network_transmit_packets_dropped_total",
          "type": "counter",
          "description": "Cumulative count of packets dropped while transmitting"
        },
        {
          "name": "pod_network_transmit_packets_total",
          "type": "counter",
          "description": "Cumulative count of packets transmitted"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Collects cluster-level metrics from the\nKubernetes API server.  It uses the _watch_ functionality of the K8s API\nto listen for updates about the cluster and maintains a cache of metrics\nthat get sent on a regular interval.\n\nSince the agent is generally running in multiple places in a K8s cluster and\nsince it is generally more convenient to share the same configuration across\nall agent instances, this monitor by default makes use of a leader election\nprocess to ensure that it is the only agent sending metrics in a cluster.\nAll of the agents running in the same namespace that have this monitor\nconfigured will decide amongst themselves which should send metrics for this\nmonitor, and the rest will stand by ready to activate if the leader agent\ndies.  You can override leader election by setting the config option\n`alwaysClusterReporter` to true, which will make the monitor always report\nmetrics.\n\nThis monitor is similar to\n[kube-state-metrics](https://github.com/kubernetes/kube-state-metrics), and\nsends many of the same metrics, but in a way that is less verbose and better\nfitted for the SignalFx backend.\n",
      "package": "internal/monitors/kubernetes/cluster",
      "fields": [
        {
          "yamlName": "alwaysClusterReporter",
          "doc": "If `true`, leader election is skipped and metrics are always reported.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "useNodeName",
          "doc": "If set to true, the Kubernetes node name will be used as the dimension to which to sync properties about each respective node.  This is necessary if your cluster's machines do not have unique machine-id values, as can happen when machine images are improperly cloned.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "kubernetesAPI",
          "doc": "Config for the K8s API client",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains options relevant to connecting to the K8s API",
            "package": "internal/core/common/kubernetes",
            "fields": [
              {
                "yamlName": "authType",
                "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), or `serviceAccount` (to use the standard service account token provided to the agent pod).",
                "default": "serviceAccount",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "monitorType": "kubernetes-cluster",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": [
        {
          "name": "kubernetes_name",
          "description": "The name of the resource that the metric describes"
        },
        {
          "name": "kubernetes_namespace",
          "description": "The namespace of the resource that the metric describes"
        },
        {
          "name": "kubernetes_node",
          "description": "The name of the node, as defined by the `name` field of the node resource."
        },
        {
          "name": "kubernetes_pod_uid",
          "description": "The UID of the pod that the metric describes"
        },
        {
          "name": "machine_id",
          "description": "The machine ID from /etc/machine-id.  This should be unique across all nodes in your cluster, but some cluster deployment tools don't guarantee this.  This will not be sent if the `useNodeName` config option is set to true."
        },
        {
          "name": "metric_source",
          "description": "This is always set to `kubernetes`"
        },
        {
          "name": "quota_name",
          "description": "The name of the k8s ResourceQuota object that the quota is part of"
        },
        {
          "name": "resource",
          "description": "The k8s resource that the quota applies to"
        }
      ],
      "metrics": [
        {
          "name": "kubernetes.container_ready",
          "type": "gauge",
          "description": "Whether a container has passed its readiness probe (0 for no, 1 for yes)"
        },
        {
          "name": "kubernetes.container_restart_count",
          "type": "gauge",
          "description": "How many times the container has restarted in the recent past.  This value is pulled directly from [the K8s API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#containerstatus-v1-core) and the value can go indefinitely high and be reset to 0 at any time depending on how your [kubelet is configured to prune dead containers](https://kubernetes.io/docs/concepts/cluster-administration/kubelet-garbage-collection/). It is best to not depend too much on the exact value but rather look at it as either `== 0`, in which case you can conclude there were no restarts in the recent past, or `\u003e 0`, in which case you can conclude there were restarts in the recent past, and not try and analyze the value beyond that."
        },
        {
          "name": "kubernetes.daemon_set.current_scheduled",
          "type": "gauge",
          "description": "The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod"
        },
        {
          "name": "kubernetes.daemon_set.desired_scheduled",
          "type": "gauge",
          "description": "The total number of nodes that should be running the daemon pod (including nodes currently running the daemon pod)"
        },
        {
          "name": "kubernetes.daemon_set.misscheduled",
          "type": "gauge",
          "description": "The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod"
        },
        {
          "name": "kubernetes.daemon_set.ready",
          "type": "gauge",
          "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready"
        },
        {
          "name": "kubernetes.deployment.available",
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this deployment."
        },
        {
          "name": "kubernetes.deployment.desired",
          "type": "gauge",
          "description": "Number of desired pods in this deployment"
        },
        {
          "name": "kubernetes.namespace_phase",
          "type": "gauge",
          "description": "The current phase of namespaces (`1` for _active_ and `0` for _terminating_)"
        },
        {
          "name": "kubernetes.node_ready",
          "type": "gauge",
          "description": "Whether this node is ready (1), not ready (0) or in an unknown state (-1)"
        },
        {
          "name": "kubernetes.pod_phase",
          "type": "gauge",
          "description": "Current phase of the pod (1 - Pending, 2 - Running, 3 - Succeeded, 4 - Failed, 5 - Unknown)"
        },
        {
          "name": "kubernetes.replica_set.available",
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replica set"
        },
        {
          "name": "kubernetes.replica_set.desired",
          "type": "gauge",
          "description": "Number of desired pods in this replica set"
        },
        {
          "name": "kubernetes.replication_controller.available",
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replication controller."
        },
        {
          "name": "kubernetes.replication_controller.desired",
          "type": "gauge",
          "description": "Number of desired pods"
        },
        {
          "name": "kubernetes.resource_quota_hard",
          "type": "gauge",
          "description": "The upper limit for a particular resource in a specific namespace.  Will only be sent if a quota is specified.  CPU requests/limits will be sent as millicores."
        },
        {
          "name": "kubernetes.resource_quota_used",
          "type": "gauge",
          "description": "The usage for a particular resource in a specific namespace.  Will only be sent if a quota is specified.  CPU requests/limits will be sent as millicores."
        }
      ],
      "properties": [
        {
          "name": "\u003cnode label\u003e",
          "dimension": "machine_id/kubernetes_node",
          "description": "All non-blank labels on a given node will be synced as properties to the `machine_id` or `kubernetes_node` dimension value for that node.  Which dimension gets the properties is determined by the `useNodeName` config option.  Any blank values will be synced as tags on that same dimension."
        },
        {
          "name": "\u003cpod label\u003e",
          "dimension": "kubernetes_pod_uid",
          "description": "Any labels with non-blank values on the pod will be synced as properties to the `kubernetes_pod_uid` dimension. Any blank labels will be synced as tags on that same dimension."
        }
      ]
    },
    {
      "name": "Config",
      "doc": " This monitor sends Kubernetes events as SignalFx\nevents.  Upon startup, it will send all of the events that K8s has that are\nstill persisted and then send any new events that come in.  The various\nagents perform leader election amongs themselves to decide which instance\nwill send events, unless the `alwaysClusterReporter` config option is set to\ntrue.\n\nYou can see the types of events happening in your cluster with `kubectl get\nevents -o yaml --all-namespaces`.\n",
      "package": "internal/monitors/kubernetes/events",
      "fields": [
        {
          "yamlName": "kubernetesAPI",
          "doc": "Configuration of the Kubernetes API client",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains options relevant to connecting to the K8s API",
            "package": "internal/core/common/kubernetes",
            "fields": [
              {
                "yamlName": "authType",
                "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), or `serviceAccount` (to use the standard service account token provided to the agent pod).",
                "default": "serviceAccount",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "whitelistedEvents",
          "doc": "A list of event types to send events for.  Only events matching these items will be sent.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "EventInclusionSpec",
            "doc": "EventInclusionSpec specifies a type of event to send",
            "package": "internal/monitors/kubernetes/events",
            "fields": [
              {
                "yamlName": "reason",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "involvedObjectKind",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "alwaysClusterReporter",
          "doc": "Whether to always send events from this agent instance or to do leader election to only send from one agent instance.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "kubernetes-events",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor sends usage stats about volumes\nmounted to Kubernetes pods (e.g. free space/inodes).  This information is\ngotten from the Kubelet /stats/summary endpoint.  The normal `collectd/df`\nmonitor generally will not report Persistent Volume usage metrics because\nthose volumes are not seen by the agent since they can be mounted\ndynamically and older versions of K8s don't support mount propagation of\nthose mounts to the agent container.\n\nDimensions that identify the underlying volume source will be added for\n`awsElasticBlockStore` and `glusterfs` volumes.  Support for more can be\neasily added as needed.\n",
      "package": "internal/monitors/kubernetes/volumes",
      "fields": [
        {
          "yamlName": "kubeletAPI",
          "doc": "Kubelet kubeletClient configuration",
          "default": null,
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains config specific to the KubeletAPI",
            "package": "internal/core/common/kubelet",
            "fields": [
              {
                "yamlName": "url",
                "doc": "URL of the Kubelet instance.  This will default to `https://\u003ccurrent node hostname\u003e:10250` if not provided.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "authType",
                "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                "default": "none",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verification of the Kubelet's TLS cert",
                "default": true,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "logResponses",
                "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "kubernetesAPI",
          "doc": "Configuration of the Kubernetes API kubeletClient",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains options relevant to connecting to the K8s API",
            "package": "internal/core/common/kubernetes",
            "fields": [
              {
                "yamlName": "authType",
                "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), or `serviceAccount` (to use the standard service account token provided to the agent pod).",
                "default": "serviceAccount",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "monitorType": "kubernetes-volumes",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": [
        {
          "name": "VolumeId",
          "description": "(*EBS volumes only*) The EBS volume id of the underlying volume source"
        },
        {
          "name": "endpoints_name",
          "description": "(*GlusterFS volumes only*) The endpoint name used for the GlusterFS volume"
        },
        {
          "name": "glusterfs_path",
          "description": "(*GlusterFS volumes only*) The GlusterFS volume path"
        },
        {
          "name": "kubernetes_namespace",
          "description": "The namespace of the pod that has this volume"
        },
        {
          "name": "kubernetes_pod_name",
          "description": "The name of the pod that has this volume"
        },
        {
          "name": "kubernetes_pod_uid",
          "description": "The UID of the pod that has this volume"
        },
        {
          "name": "partition",
          "description": "(*EBS volumes only*) The partition number of the underlying EBS volume (`0` indicates the entire disk)"
        },
        {
          "name": "volume",
          "description": "The volume name as given in the pod spec under `volumes`"
        },
        {
          "name": "volume_type",
          "description": "The type of the underlying volume -- this will be the key used in the k8s volume config spec (e.g. awsElasticBlockStore, etc.)"
        }
      ],
      "metrics": [
        {
          "name": "kubernetes.volume_available_bytes",
          "type": "gauge",
          "description": "The number of available bytes in the volume"
        },
        {
          "name": "kubernetes.volume_capacity_bytes",
          "type": "gauge",
          "description": "The total capacity in bytes of the volume"
        }
      ],
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor reports processlist information for Windows\nHosts.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: processlist\n```\n",
      "package": "internal/monitors/processlist",
      "fields": [],
      "monitorType": "processlist",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor reads metrics from a [Prometheus\nexporter](https://prometheus.io/docs/instrumenting/exporters/) endpoint.\n\nAll metric types are supported.  See\nhttps://prometheus.io/docs/concepts/metric_types/ for a description of the\nPrometheus metric types.  The conversion happens as follows:\n\n - Gauges are converted directly to SignalFx gauges\n - Counters are converted directly to SignalFx cumulative counters\n - Untyped metrics are converted directly to SignalFx gauges\n - Summary metrics are converted to three distinct metrics, where\n   `\u003cbasename\u003e` is the root name of the metric:\n   - The total count gets converted to a cumulative counter called `\u003cbasename\u003e_count`\n   - The total sum gets converted to a cumulative counter called `\u003cbasename\u003e`\n   - Each quantile value is converted to a gauge called\n     `\u003cbasename\u003e_quantile` and will include a dimension called `quantile` that\n     specifies the quantile.\n - Histogram metrics are converted to three distinct metrics, where\n   `\u003cbasename\u003e` is the root name of the metric:\n   - The total count gets converted to a cumulative counter called `\u003cbasename\u003e_count`\n   - The total sum gets converted to a cumulative counter called `\u003cbasename\u003e`\n   - Each histogram bucket is converted to a cumulative counter called\n     `\u003cbasename\u003e_bucket` and will include a dimension called `upper_bound` that\n     specifies the maximum value in that bucket.  This metric specifies the\n     number of events with a value that is less than or equal to the upper\n     bound.\n\nAll Prometheus labels will be converted directly to SignalFx dimensions.\n\nThis supports service discovery so you can set a discovery rule such as:\n\n`port \u003e= 9100 \u0026\u0026 port \u003c= 9500 \u0026\u0026 containerImage =~ \"exporter\"`\n\nassuming you are running exporters in container images that have the word\n\"exporter\" in them and fall within the standard exporter port range.  In\nK8s, you could also try matching on the container port name as defined in\nthe pod spec, which is the `name` variable in discovery rules for the\n`k8s-api` observer.\n\nFiltering can be very useful here since exporters tend to be fairly verbose.\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: prometheus-exporter\n   discoveryRule: port \u003e= 9100 \u0026\u0026 port \u003c= 9500 \u0026\u0026 container_image =~ \"exporter\"\n   extraDimensions:\n     metric_source: prometheus\n   host: 127.0.0.1\n   port: 9100\n```\n",
      "package": "internal/monitors/prometheus",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host of the exporter",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "Port of the exporter",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "useHTTPS",
          "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "skipVerify",
          "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "metricPath",
          "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
          "default": "/metrics",
          "required": false,
          "type": "string",
          "elementKind": ""
        }
      ],
      "monitorType": "prometheus-exporter",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor reports metrics about processes.\nThis monitor is based on the Telegraf procstat plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/procstat).\n\nPlease note that the Smart Agent only supports the `native` pid finder and the options\n`cgroup` and `systemd unit` are not supported at this time.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/procstat\n   exe: \"signalfx-agent*\"\n```\n",
      "package": "internal/monitors/telegraf/monitors/procstat",
      "fields": [
        {
          "yamlName": "procFSPath",
          "doc": "The path to the proc filesystem. Useful to override in containerized environments.",
          "default": "/proc",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "exe",
          "doc": "The name of an executable to monitor.  (ie: `exe: \"signalfx-agent*\"`)",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "pattern",
          "doc": "Pattern to match against.  On Windows the pattern should be in the form of a WMI query. (ie: `pattern: \"%signalfx-agent%\"`)",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "user",
          "doc": "Username to match against",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "pidFile",
          "doc": "Path to Pid file to monitor.  (ie: `pidFile: \"/var/run/signalfx-agent.pid\"`)",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "processName",
          "doc": "Used to override the process name dimension",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "prefix",
          "doc": "Prefix to be added to each dimension",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "pidTag",
          "doc": "Whether to add PID as a dimension instead of part of the metric name",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "telegraf/procstat",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor reports metrics from snmp agents.\nThis monitor is based on the Telegraf SNMP plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/snmp).\n\n**NOTE:** This snmp monitor does not currently support MIB look ups because of a dependency on `net-snmp`\nand specifically the commands `snmptranslate` and `snmptable`.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/snmp\n   agents:\n     - \"127.0.0.1:161\"\n   version: 2\n   community: \"public\"\n   fields:\n     - name: \"uptime\"\n       oid: \".1.3.6.1.2.1.1.3.0\"\n```\n\nUsing a discovery rule to discover and configure for a specific snmp agent\n```yaml\nmonitors:\n - type: telegraf/snmp\n   discoveryRule: container_name =~ \"snmp\" \u0026\u0026 port == 161\n   version: 2\n   community: \"public\"\n   fields:\n     - name: \"uptime\"\n       oid: \".1.3.6.1.2.1.1.3.0\"\n```\n",
      "package": "internal/monitors/telegraf/monitors/telegrafsnmp",
      "fields": [
        {
          "yamlName": "host",
          "doc": "Host and port will be concatenated and appended to the list of SNMP agents to connect to.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "Port and Host will be concatenated and appended to the list of SNMP agents to connect to.",
          "default": 0,
          "required": false,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "agents",
          "doc": "SNMP agent address and ports to query for information.  An example address is `0.0.0.0:5555` If an address is supplied with out a port, the default port `161` will be used.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "retries",
          "doc": "The number of times to retry.",
          "default": 0,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "community",
          "doc": "The SNMP community to use.",
          "default": "public",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "maxRepetitions",
          "doc": "Maximum number of iterations for reqpeating variables",
          "default": 50,
          "required": false,
          "type": "uint8",
          "elementKind": ""
        },
        {
          "yamlName": "contextName",
          "doc": "SNMP v3 context name to use with requests",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "secLevel",
          "doc": "Security level to use for SNMP v3 messages: `noAuthNoPriv` `authNoPriv`, `authPriv`.",
          "default": "noAuthNoPriv",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "secName",
          "doc": "Name to used to authenticate with SNMP v3 requests.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "authProtocol",
          "doc": "Protocol to used to authenticate SNMP v3 requests: `\"MD5\"`, `\"SHA\"`, and `\"\"` (default).",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "authPassword",
          "doc": "Password used to authenticate SNMP v3 requests.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "privProtocol",
          "doc": "Protocol used for encrypted SNMP v3 messages: `DES`, `AES`, `\"\"` (default).",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "privPassword",
          "doc": "Password used to encrypt SNMP v3 messages.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "engineID",
          "doc": "The SNMP v3 engine ID.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "engineBoots",
          "doc": "The SNMP v3 engine boots.",
          "default": 0,
          "required": false,
          "type": "uint32",
          "elementKind": ""
        },
        {
          "yamlName": "engineTime",
          "doc": "The SNMP v3 engine time.",
          "default": 0,
          "required": false,
          "type": "uint32",
          "elementKind": ""
        },
        {
          "yamlName": "name",
          "doc": "The top-level measurement name",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "fields",
          "doc": "The top-level SNMP fields",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "Field",
            "doc": "Field represents an SNMP field",
            "package": "internal/monitors/telegraf/monitors/telegrafsnmp",
            "fields": [
              {
                "yamlName": "name",
                "doc": "Name of the field.  The OID will be used if no value is supplied.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "oid",
                "doc": "The OID to fetch.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "oidIndexSuffix",
                "doc": "The sub-identifier to strip off when matching indexes to other fields.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "oidIndexLength",
                "doc": "The index length after the table OID.  The index will be truncated after this length in order to remove length index suffixes or non-fixed values.",
                "default": 0,
                "required": false,
                "type": "int",
                "elementKind": ""
              },
              {
                "yamlName": "isTag",
                "doc": "Whether to output the field as a tag.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "conversion",
                "doc": "Controls the type conversion applied to the value: `\"float(X)\"`, `\"float\"`, `\"int\"`, `\"hwaddr\"`, `\"ipaddr\"` or `\"\"` (default).",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "tables",
          "doc": "SNMP Tables",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "Table",
            "doc": "Table represents an SNMP table",
            "package": "internal/monitors/telegraf/monitors/telegrafsnmp",
            "fields": [
              {
                "yamlName": "name",
                "doc": "Metric name.  If not supplied the OID will be used.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "inheritTags",
                "doc": "Top level tags to inherit.",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "indexAsTag",
                "doc": "Add a tag for the table index for each row.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "field",
                "doc": "Specifies the ags and values to look up.",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "struct",
                "elementStruct": {
                  "name": "Field",
                  "doc": "Field represents an SNMP field",
                  "package": "internal/monitors/telegraf/monitors/telegrafsnmp",
                  "fields": [
                    {
                      "yamlName": "name",
                      "doc": "Name of the field.  The OID will be used if no value is supplied.",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "oid",
                      "doc": "The OID to fetch.",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "oidIndexSuffix",
                      "doc": "The sub-identifier to strip off when matching indexes to other fields.",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "oidIndexLength",
                      "doc": "The index length after the table OID.  The index will be truncated after this length in order to remove length index suffixes or non-fixed values.",
                      "default": 0,
                      "required": false,
                      "type": "int",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "isTag",
                      "doc": "Whether to output the field as a tag.",
                      "default": false,
                      "required": false,
                      "type": "bool",
                      "elementKind": ""
                    },
                    {
                      "yamlName": "conversion",
                      "doc": "Controls the type conversion applied to the value: `\"float(X)\"`, `\"float\"`, `\"int\"`, `\"hwaddr\"`, `\"ipaddr\"` or `\"\"` (default).",
                      "default": "",
                      "required": false,
                      "type": "string",
                      "elementKind": ""
                    }
                  ]
                }
              },
              {
                "yamlName": "oid",
                "doc": "The OID to fetch.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "monitorType": "telegraf/snmp",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor reports metrics about microsoft sql servers.\nThis monitor is based on the telegraf sqlserver plugin.  More information about the telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/sqlserver).\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/sqlserver\n   host: hostname\n   port: 1433\n   userID: sa\n   password: P@ssw0rd!\n   appName: signalfxagent\n   azureDB: true\n   excludeQuery:\n    - PerformanceCounters\n    # - WaitStatsCategorized\n    # - DatabaseIO\n    # - DatabaseProperties\n    # - CPUHistory\n    # - DatabaseSize\n    # - DatabaseStats\n    # - MemoryClerk\n    # - VolumeSpace\n    # - PerformanceMetrics\n```\n",
      "package": "internal/monitors/telegraf/monitors/mssqlserver",
      "fields": [
        {
          "yamlName": "host",
          "doc": "",
          "default": null,
          "required": true,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "port",
          "doc": "",
          "default": null,
          "required": true,
          "type": "uint16",
          "elementKind": ""
        },
        {
          "yamlName": "userID",
          "doc": "UserID used to access the SQL Server instance.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "password",
          "doc": "Password used to access the SQL Server instance.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "appName",
          "doc": "The app name used by the monitor when connecting to the SQLServer.",
          "default": "signalfxagent",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "queryVersion",
          "doc": "The version of queries to use when accessing the cluster Please refer to the telegraf [documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/sqlserver) for more information.",
          "default": 2,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "azureDB",
          "doc": "Whether the database is an azure database or not.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "excludedQueries",
          "doc": "Queries to exclude possible values are `PerformanceCounters`, `WaitStatsCategorized`, `DatabaseIO`, `DatabaseProperties`, `CPUHistory`, `DatabaseSize`, `DatabaseStats`, `MemoryClerk` `VolumeSpace`, `PerformanceMetrics`.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "log",
          "doc": "Log level to use when accessing the database",
          "default": 1,
          "required": false,
          "type": "uint",
          "elementKind": ""
        }
      ],
      "monitorType": "telegraf/sqlserver",
      "acceptsEndpoints": true,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor acts as a Telegraf StatsD listener for receiving telegrafstatsd metrics.\nThis monitor is based on the Telegraf Statsd input plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/statsd).\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/statsd\n   protocol: udp\n   serviceAddress: \":8125\"\n   parseDataDogTags: true\n```\n\n```yaml\nmonitors:\n - type: telegraf/statsd\n   protocol: udp\n   serviceAddress: \"127.0.0.1:0\"\n   parseDataDogTags: true\n   metricSeparator: '.'\n```\n",
      "package": "internal/monitors/telegraf/monitors/telegrafstatsd",
      "fields": [
        {
          "yamlName": "protocol",
          "doc": "Protocol to use with the listener: `tcp`, `udp4`, `udp6`, or `udp`.",
          "default": "udp",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serviceAddress",
          "doc": "The address and port to serve from",
          "default": ":8125",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "maxTCPConnections",
          "doc": "Maximum number of tcp connections allowed.",
          "default": 250,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "TCPKeepAlive",
          "doc": "Indicates whether to keep the tcp connection alive.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "deleteGauges",
          "doc": "Whether to clear the gauge cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
          "default": true,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "deleteCounters",
          "doc": "Whether to clear the counter cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
          "default": true,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "deleteSets",
          "doc": "Whether to clear the sets cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
          "default": true,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "deleteTimings",
          "doc": "Whether to clear the timings cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
          "default": true,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "percentiles",
          "doc": "The percentiles that are collected for timing and histogram stats.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "int"
        },
        {
          "yamlName": "allowedPendingMessages",
          "doc": "Number of messages allowed to queue up between each collection interval. Packets will be dropped until the next collection interval if this buffer fills up.",
          "default": 10000,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "percentileLimit",
          "doc": "The maximum number of histogram values to track each measurement when calculating percentiles. Increasing the limit will increase memory consumption but will also improve accuracy.",
          "default": 1000,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "metricSeparator",
          "doc": "The separator used to separate parts of a metric name",
          "default": "_",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "templates",
          "doc": "Templates that transform telegrafstatsd metrics into influx tags and measurements. Please refer to the Telegraf (documentation)[https://github.com/influxdata/telegraf/tree/master/plugins/inputs/statsd#statsd-bucket---influxdb-line-protocol-templates] for more information on templates.",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "parseDataDogTags",
          "doc": "Indicates whether to parse dogstatsd tags",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "telegraf/statsd",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor is based on the Telegraf tail plugin.  The monitor tails files and\nnamed pipes.  The Telegraf parser configured with this monitor extracts metrics in different\n(formats)[https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md]\nfrom the tailed output. More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/tail).\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/tail\n   files:\n    - '/logs/**.log'       # find all .log files in /logs\n    - '/logs/*/*.log'      # find all .log files who are contained in a directory under /logs/\n    - '/var/log/agent.log' # tail the specified log file\n   watchMethod: inotify    # specify the file watch method (\"ionotify\" or \"poll\")\n```\n\nSample YAML configuration that specifies a parser:\n\n```yaml\nmonitors:\n - type: telegraf/tail\n   files:\n    - '/logs/**.log'       # find all .log files in /logs\n    - '/logs/*/*.log'      # find all .log files who are contained in a directory under /logs/\n    - '/var/log/agent.log' # tail the specified log file\n   watchMethod: inotify    # specify the file watch method (\"inotify\" or \"poll\")\n   telegrafParser:         # specify a parser\n     dataFormat: \"influx\"  # set the parser's dataFormat\n```\n",
      "package": "internal/monitors/telegraf/monitors/tail",
      "fields": [
        {
          "yamlName": "files",
          "doc": "Paths to files to be tailed",
          "default": null,
          "required": true,
          "type": "slice",
          "elementKind": "string"
        },
        {
          "yamlName": "watchMethod",
          "doc": "Method for watching changes to files (\"ionotify\" or \"poll\")",
          "default": "poll",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "pipe",
          "doc": "Indicates if the file is a named pipe",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "fromBeginning",
          "doc": "Whether to start tailing from the beginning of the file",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "telegrafParser",
          "doc": "telegrafParser is a nested object that defines configurations for a Telegraf parser. Please refer to the Telegraf (documentation)[https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md] for more information on Telegraf parsers.",
          "default": null,
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "Config",
            "doc": "Config implements Telegraf parsers.Config, but with SignalFx Smart Agent struct tags and a methods for returning a Telegraf parsers.Config struct and a Telegraf parsers.Parser. Please refer to Telegraf's (documentation)[https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md#influx] for more information about the different parsers and their specific configurations",
            "package": "internal/monitors/telegraf/common/parser",
            "fields": [
              {
                "yamlName": "dataFormat",
                "doc": "dataFormat specifies a data format to parse: `json`, `value`, `influx`, `graphite`, `value`, `nagios`, `collectd`, `dropwizard`, `wavefront`, `grok`, `csv`, or `logfmt`.",
                "default": "influx",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "defaultTags",
                "doc": "defaultTags are tags that will be added to all metrics. (`json`, `value`, `graphite`, `collectd`, `dropwizard`, `wavefront`, `grok`, `csv` and `logfmt` only)",
                "default": null,
                "required": false,
                "type": "map",
                "elementKind": "string"
              },
              {
                "yamlName": "metricName",
                "doc": "metricName applies to (`json` and `value`). This will be the name of the measurement.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "dataType",
                "doc": "dataType specifies the value type to parse the value to: `integer`, `float`, `long`, `string`, or `boolean`. (`value` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "JSONTagKeys",
                "doc": "A list of tag names to fetch from JSON data. (`json` only)",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "JSONStringFields",
                "doc": "A list of fields in JSON to extract and use as string fields. (json only)",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "JSONNameKey",
                "doc": "A path used to extract the metric name in JSON data.  (`json` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "JSONQuery",
                "doc": "A gjson path for json parser. (`json` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "JSONTimeKey",
                "doc": "The name of the timestamp key. (`json` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "JSONTimeFormat",
                "doc": "Specifies the timestamp format. (`json` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "separator",
                "doc": "Separator for Graphite data. (`graphite` only).",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "templates",
                "doc": "A list of templates for Graphite data. (`graphite` only).",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "collectdAuthFile",
                "doc": "The path to the collectd authentication file (`collectd` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "collectdSecurityLevel",
                "doc": "Specifies the security level: `none` (default), `sign`, or `encrypt`. (`collectd only`)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "collectdTypesDB",
                "doc": "A list of paths to collectd TypesDB files. (`collectd` only)",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "collectdSplit",
                "doc": "Indicates whether to separate or join multivalue metrics. (`collectd` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "dropwizardMetricRegistryPath",
                "doc": "An optional gjson path used to locate a metric registry inside of JSON data. The default behavior is to consider the entire JSON document. (`dropwizard` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "dropwizardTimePath",
                "doc": "An optional gjson path used to identify the drop wizard metric timestamp. (`dropwizard` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "dropwizardTimeFormat",
                "doc": "The format used for parsing the drop wizard metric timestamp. The default format is time.RFC3339. (`dropwizard` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "dropwizardTagsPath",
                "doc": "An optional gjson path used to locate drop wizard tags. (`dropwizard` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "dropwizardTagPathsMap",
                "doc": "A map of gjson tag names and gjson paths used to extract tag values from the JSON document. This is only used if `dropwizardTagsPath` is not specified. (`dropwizard` only)",
                "default": null,
                "required": false,
                "type": "map",
                "elementKind": "string"
              },
              {
                "yamlName": "grokPatterns",
                "doc": "A list of patterns to match. (`grok` only)",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "grokNamedPatterns",
                "doc": "A list of named grok patterns to match.  (`grok` only)",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "grokCustomPatterns",
                "doc": "Custom grok patterns. (`grok` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "grokCustomPatternFiles",
                "doc": "List of paths to custom grok pattern files. (`grok` only)",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "grokTimezone",
                "doc": "Specifies the timezone.  The default is UTC time.  Other options are `Local` for the local time on the machine, `UTC`, and `Canada/Eastern` (unix style timezones).  (`grok` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "CSVDelimiter",
                "doc": "The delimiter used between fields in the csv. (`csv` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "CSVComment",
                "doc": "The character used to mark rows as comments. (`csv` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "CSVTrimSpace",
                "doc": "Indicates whether to trim leading white from fields. (`csv` only)",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "CSVColumnNames",
                "doc": "List of custom column names.  All columns must have names.  Unnamed columns are ignored. This configuration must be set when `CSVHeaderRowCount` is 0. (`csv` only)",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "CSVTagColumns",
                "doc": "List of columns that should be added as tags.  Unspecified columns will be added as fields. (`csv` only)",
                "default": null,
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "CSVMeasurementColumn",
                "doc": "The name of the column to extract the metric name from (`csv` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "CSVTimestampColumn",
                "doc": "The name of the column to extract the metric timestamp from. `CSVTimestampFormat` must be set when using this option.  (`csv` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "CSVTimestampFormat",
                "doc": "The format to use for extracting timestamps. (`csv` only)",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "CSVHeaderRowCount",
                "doc": "The number of rows that are headers.  By default no rows are treated as headers.  (`csv` only)",
                "default": 0,
                "required": false,
                "type": "int",
                "elementKind": ""
              },
              {
                "yamlName": "CSVSkipRows",
                "doc": "The number of rows to ignore before looking for headers. (`csv` only)",
                "default": 0,
                "required": false,
                "type": "int",
                "elementKind": ""
              },
              {
                "yamlName": "CSVSkipColumns",
                "doc": "The number of columns to ignore before parsing data on a given row. (`csv` only)",
                "default": 0,
                "required": false,
                "type": "int",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "monitorType": "telegraf/tail",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor reads Windows performance\ncounters\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/win_perf_counters\n   printValid: true\n   objects:\n    - objectName: \"Processor\"\n      instances:\n       - \"*\"\n      counters:\n       - \"% Idle Time\"\n       - \"% Interrupt Time\"\n       - \"% Privileged Time\"\n       - \"% User Time\"\n       - \"% Processor Time\"\n      includeTotal: true\n      measurement: \"win_cpu\"\n```\n",
      "package": "internal/monitors/telegraf/monitors/winperfcounters",
      "fields": [
        {
          "yamlName": "objects",
          "doc": "",
          "default": "",
          "required": false,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "Perfcounterobj",
            "doc": "Perfcounterobj represents a perfcounter object to monitor",
            "package": "internal/monitors/telegraf/monitors/winperfcounters",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "counters",
                "doc": "",
                "default": "",
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "instances",
                "doc": "",
                "default": "",
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "measurement",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "warnOnMissing",
                "doc": "",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "failOnMissing",
                "doc": "",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "includeTotal",
                "doc": "",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "counterRefreshInterval",
          "doc": "number of nanoseconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration",
          "default": 60,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "useWildCardExpansion",
          "doc": "if `true`, instance indexes will be included in instance names, and wildcards will be expanded and localized (if applicable).  If `false`, non partial wildcards will be expanded and instance names will not include instance indexes.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "printValid",
          "doc": "print out the configurations that match available performance counters",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "telegraf/win_perf_counters",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " Runs an HTTP server that listens for trace spans\nand forwards them to SignalFx (or the configured ingest host in the `writer`\nsection of the agent config).  This supports the same span formats that our\ningest server supports and at the same path (`/v1/trace`).  By default, the\nserver listens on localhost port 9080 but can be configured to anything.\n",
      "package": "internal/monitors/traceforwarder",
      "fields": [
        {
          "yamlName": "listenAddress",
          "doc": "The host:port on which to listen for spans.  This server accepts spans in all of the formats that we support on our regular ingest server.  The HTTP path used is irrelevant and will be ignored.",
          "default": "127.0.0.1:9080",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "serverTimeout",
          "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
          "default": "5s",
          "required": false,
          "type": "int64",
          "elementKind": ""
        },
        {
          "yamlName": "sendInternalMetrics",
          "doc": "Whether to send internal metrics about the HTTP listener",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "trace-forwarder",
      "acceptsEndpoints": false,
      "singleInstance": true,
      "dimensions": null,
      "metrics": null,
      "properties": null
    },
    {
      "name": "Config",
      "doc": " This monitor reads Windows performance\ncounters\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/win_perf_counters\n   printValid: true\n   objects:\n    - objectName: \"Processor\"\n      instances:\n       - \"*\"\n      counters:\n       - \"% Idle Time\"\n       - \"% Interrupt Time\"\n       - \"% Privileged Time\"\n       - \"% User Time\"\n       - \"% Processor Time\"\n      includeTotal: true\n      measurement: \"win_cpu\"\n```\n",
      "package": "internal/monitors/telegraf/monitors/winperfcounters",
      "fields": [
        {
          "yamlName": "objects",
          "doc": "",
          "default": "",
          "required": false,
          "type": "slice",
          "elementKind": "struct",
          "elementStruct": {
            "name": "Perfcounterobj",
            "doc": "Perfcounterobj represents a perfcounter object to monitor",
            "package": "internal/monitors/telegraf/monitors/winperfcounters",
            "fields": [
              {
                "yamlName": "objectName",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "counters",
                "doc": "",
                "default": "",
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "instances",
                "doc": "",
                "default": "",
                "required": false,
                "type": "slice",
                "elementKind": "string"
              },
              {
                "yamlName": "measurement",
                "doc": "",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "warnOnMissing",
                "doc": "",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "failOnMissing",
                "doc": "",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "includeTotal",
                "doc": "",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "counterRefreshInterval",
          "doc": "number of nanoseconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration",
          "default": 60,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "useWildCardExpansion",
          "doc": "if `true`, instance indexes will be included in instance names, and wildcards will be expanded and localized (if applicable).  If `false`, non partial wildcards will be expanded and instance names will not include instance indexes.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "printValid",
          "doc": "print out the configurations that match available performance counters",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "monitorType": "telegraf/win_perf_counters",
      "acceptsEndpoints": false,
      "singleInstance": false,
      "dimensions": null,
      "metrics": null,
      "properties": null
    }
  ],
  "Observers": [
    {
      "name": "Config",
      "doc": " Queries the Docker Engine API for running containers.  If\nyou are using Kubernetes, you should use the [k8s-api\nobserver](./k8s-api.md) instead of this.\n\nNote that you will need permissions to access the Docker engine API.  For a\nDocker domain socket URL, this means that the agent needs to have read\npermissions on the socket.  We don't currently support authentication for\nHTTP URLs.\n\n## Configuration from Labels\nYou can configure monitors by putting special labels on your Docker\ncontainers.  You can either specify all of the configuration in container\nlabels, or you can use the more traditional agent configuration with\ndiscovery rules and specify configuration overrides with labels.\n\nThe config labels are of the form `agent.signalfx.com.config.\u003cport\nnumber\u003e.\u003cconfig_key\u003e: \u003cconfig value\u003e`.  The `\u003cconfig value\u003e` must be a\nstring in a container label, but it will be deserialized as a YAML value to\nthe most appropriate type when consumed by the agent.  For example, if you\nhave a Redis container and want to monitor it at a higher frequency than\nother Redis containers, you could have an agent config that looks like the\nfollowing:\n\n```\nobservers:\n - type: docker\nmonitors:\n - type: collectd/redis\n   discoveryRule: container_image =~ \"redis\" \u0026\u0026 port == 6379\n   auth: mypassword\n   intervalSeconds: 10\n```\n\nAnd then launch the Redis container with the label:\n\n`agent.signalfx.com.config.6379.intervalSeconds`: `1`\n\nThis would cause the config value for `intervalSeconds` to be overwritten to\nthe more frequent 1 second interval.\n\nYou can also specify the monitor configuration entirely with Docker labels\nand completely omit monitor config from the agent config.  With the agent\nconfig:\n\n```\nobservers:\n - type: docker\n```\n\nYou can then launch a Redis container with the following labels:\n\n - `agent.signalfx.com.monitorType.6379`: `collectd/redis`\n - `agent.signalfx.com.config.6379.auth`: `mypassword`\n\nWhich would configure a Redis monitor with the given authentication\nconfiguration.  No Redis configuration is required in the agent config file.\n\nThe distinction is that the `monitorType` label was added to the Docker\ncontainer.  If a `monitorType` label is present, **no discovery rules will\nbe considered for this endpoint**, and thus, no agent configuration can be\nused anyway.\n\n### Multiple Monitors per Port\nIf you want to configure multiple monitors per port, you can specify the\nport name in the form `\u003cport number\u003e-\u003cport name\u003e` instead of just the port\nnumber.  For example, if you had two different Prometheus exporters running\non the same port, but on different paths in a given container, you could\nprovide labels like the following:\n\n```\n - `agent.signalfx.com.monitorType.8080-app`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.monitorType.8080-goruntime`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n```\n\nThe name that is given to the port will populate the `name` field of the\ndiscovered endpoint and can be used in discovery rules as such.  For\nexample, with the following agent config:\n\n```\nobservers:\n - type: docker\nmonitors:\n - type: prometheus-exporter\n   discoveryRule: name == \"app\" \u0026\u0026 port == 8080\n   intervalSeconds: 1\n```\n\nAnd given docker labels as follows (remember that discovery rules are\nirrelevant to endpoints that specify `monitorType` labels):\n\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n\nWould result in the `app` endpoint getting an interval of 1 second and the\n`goruntime` endpoint getting the default interval of the agent.\n",
      "package": "internal/observers/docker",
      "fields": [
        {
          "yamlName": "dockerURL",
          "doc": "",
          "default": "unix:///var/run/docker.sock",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "labelsToDimensions",
          "doc": "A mapping of container label names to dimension names that will get applied to the metrics of all discovered services. The corresponding label values will become the dimension value for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "useHostnameIfPresent",
          "doc": "If true, the \"Config.Hostname\" field (if present) of the docker container will be used as the discovered host that is used to configure monitors.  If false or if no hostname is configured, the field `NetworkSettings.IPAddress` is used instead.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "observerType": "docker",
      "dimensions": [
        {
          "name": "container_name",
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        },
        {
          "name": "container_image",
          "description": "The image name (including tags) of the running container"
        }
      ],
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Looks at the current host for listening network endpoints.\nIt uses the `/proc` filesystem and requires the `SYS_PTRACE` and\n`DAC_READ_SEARCH` capabilities so that it can determine what processes own\nthe listening sockets.\n\nIt will look for all listening sockets on TCP and UDP over IPv4 and IPv6.\n",
      "package": "internal/observers/host",
      "fields": [],
      "observerType": "host",
      "dimensions": [
        {
          "name": "pid",
          "description": "The PID of the process that owns the listening endpoint"
        }
      ],
      "endpointVariables": [
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Discovers services running in a Kubernetes cluster by\nquerying the Kubernetes API server.  This observer is designed to only\ndiscover pod endpoints exposed on the same node that the agent is running,\nso that the monitoring of services does not generate cross-node traffic.  To\nknow which node the agent is running on, you should set an environment\nvariable called `MY_NODE_NAME` using the downward API `spec.nodeName` value\nin the pod spec.  Our provided K8s DaemonSet resource does this already and\nprovides an example.\n\nNote that this observer discovers exposed ports on pod containers, not K8s\nEndpoint resources, so don't let the terminology of agent \"endpoints\"\nconfuse you.\n",
      "package": "internal/observers/kubernetes",
      "fields": [
        {
          "yamlName": "kubernetesAPI",
          "doc": "Configuration for the K8s API client",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains options relevant to connecting to the K8s API",
            "package": "internal/core/common/kubernetes",
            "fields": [
              {
                "yamlName": "authType",
                "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), or `serviceAccount` (to use the standard service account token provided to the agent pod).",
                "default": "serviceAccount",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "observerType": "k8s-api",
      "dimensions": [
        {
          "name": "container_spec_name",
          "description": "The short name of the container in the pod spec, **NOT** the running container's name in the Docker engine"
        },
        {
          "name": "kubernetes_namespace",
          "description": "The namespace that the discovered service endpoint is running in."
        },
        {
          "name": "kubernetes_pod_name",
          "description": "The name of the running pod that is exposing the discovered endpoint"
        },
        {
          "name": "kubernetes_pod_uid",
          "description": "The UID of the pod that is exposing the discovered endpoint"
        },
        {
          "name": "container_name",
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        },
        {
          "name": "container_image",
          "description": "The image name (including tags) of the running container"
        }
      ],
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Discovers service endpoints running on the same node\nas the agent by querying the local kubelet instance.  It is generally\nrecommended to use the [k8s-api](./k8s-api.md) observer because\nauthentication to the local kubelet can be more difficult to setup, and also\nthe kubelet API is technically not documented for public consumption, so\nthis observer may break more easily in future K8s versions.\n",
      "package": "internal/observers/kubelet",
      "fields": [
        {
          "yamlName": "pollIntervalSeconds",
          "doc": "How often to poll the Kubelet instance for pod information",
          "default": 10,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "kubeletAPI",
          "doc": "Config for the Kubelet HTTP client",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains config specific to the KubeletAPI",
            "package": "internal/core/common/kubelet",
            "fields": [
              {
                "yamlName": "url",
                "doc": "URL of the Kubelet instance.  This will default to `https://\u003ccurrent node hostname\u003e:10250` if not provided.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "authType",
                "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                "default": "none",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verification of the Kubelet's TLS cert",
                "default": true,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "logResponses",
                "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "observerType": "k8s-kubelet",
      "dimensions": [
        {
          "name": "container_spec_name",
          "description": "The short name of the container in the pod spec, **NOT** the running container's name in the Docker engine"
        },
        {
          "name": "kubernetes_namespace",
          "description": "The namespace that the discovered service endpoint is running in."
        },
        {
          "name": "kubernetes_pod_name",
          "description": "The name of the running pod that is exposing the discovered endpoint"
        },
        {
          "name": "kubernetes_pod_uid",
          "description": "The UID of the pod that is exposing the discovered endpoint"
        },
        {
          "name": "container_name",
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        },
        {
          "name": "container_image",
          "description": "The image name (including tags) of the running container"
        }
      ],
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    }
  ],
  "SourceConfig": {
    "name": "SourceConfig",
    "doc": "SourceConfig represents configuration for various config sources that we support.",
    "package": "internal/core/config/sources",
    "fields": [
      {
        "yamlName": "watch",
        "doc": "Whether to watch config sources for changes.  If this is `true` and any of the config changes (either the main agent.yaml, or remote config values), the agent will dynamically reconfigure itself with minimal disruption.  This is generally better than restarting the agent on config changes since that can result in larger gaps in metric data.  The main disadvantage of watching is slightly greater network and compute resource usage. This option itself ironically enough is not subject to watching and changing it to false after the agent was started with it true will require an agent restart.",
        "default": true,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "file",
        "doc": "Configuration for other file sources",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for the file-based config source",
          "package": "internal/core/config/sources/file",
          "fields": [
            {
              "yamlName": "pollRateSeconds",
              "doc": "How often to poll files (in seconds) to test for changes.  There are so many edge cases that break inotify that it is more robust to simply poll files than rely on that. This option is not subject to watching and changes to it will require an agent restart.",
              "default": 5,
              "required": false,
              "type": "int",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "zookeeper",
        "doc": "Configuration for a Zookeeper remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config is used to configure the Zookeeper client",
          "package": "internal/core/config/sources/zookeeper",
          "fields": [
            {
              "yamlName": "endpoints",
              "doc": "A list of Zookeeper servers to use for the client",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "timeoutSeconds",
              "doc": "Client timeout",
              "default": 10,
              "required": false,
              "type": "uint",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "etcd2",
        "doc": "Configuration for an Etcd 2 remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for an Etcd2 source",
          "package": "internal/core/config/sources/etcd2",
          "fields": [
            {
              "yamlName": "endpoints",
              "doc": "A list of Etcd2 servers to use",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "username",
              "doc": "An optional username to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "password",
              "doc": "An optional password to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "consul",
        "doc": "Configuration for a Consul remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for the consul client",
          "package": "internal/core/config/sources/consul",
          "fields": [
            {
              "yamlName": "endpoint",
              "doc": "A Consul server URL",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "username",
              "doc": "An optional username to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "password",
              "doc": "An optional password to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "token",
              "doc": "An authentication token, if needed",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "datacenter",
              "doc": "The Consul datacenter to use",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      }
    ]
  },
  "TopConfig": {
    "name": "Config",
    "doc": "Config is the top level config struct for configurations that are common to all platoforms",
    "package": "internal/core/config",
    "fields": [
      {
        "yamlName": "signalFxAccessToken",
        "doc": "The access token for the org that should receive the metrics emitted by the agent.",
        "default": null,
        "required": true,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "ingestUrl",
        "doc": "The URL of SignalFx ingest server.  Should be overridden if using the Metric Proxy.  If you want to send trace spans to a different location, set the `traceEndpointUrl` option.",
        "default": "https://ingest.signalfx.com",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "traceEndpointUrl",
        "doc": "The full URL (including path) to the trace ingest server.  If this is not set, all trace spans will be sent to the `ingestUrl` configured above.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "apiUrl",
        "doc": "The SignalFx API base URL",
        "default": "https://api.signalfx.com",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "hostname",
        "doc": "The hostname that will be reported as the `host` dimension. If blank, this will be auto-determined by the agent based on a reverse lookup of the machine's IP address.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "useFullyQualifiedHost",
        "doc": "If true (the default), and the `hostname` option is not set, the hostname will be determined by doing a reverse DNS query on the IP address that is returned by querying for the bare hostname.  This is useful in cases where the hostname reported by the kernel is a short name.",
        "default": null,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "disableHostDimensions",
        "doc": "Our standard agent model is to collect metrics for services running on the same host as the agent.  Therefore, host-specific dimensions (e.g. `host`, `AWSUniqueId`, etc) are automatically added to every datapoint that is emitted from the agent by default.  Set this to true if you are using the agent primarily to monitor things on other hosts.  You can set this option at the monitor level as well.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "intervalSeconds",
        "doc": "How often to send metrics to SignalFx.  Monitors can override this individually.",
        "default": 10,
        "required": false,
        "type": "int",
        "elementKind": ""
      },
      {
        "yamlName": "globalDimensions",
        "doc": "Dimensions (key:value pairs) that will be added to every datapoint emitted by the agent. To specify that all metrics should be high-resolution, add the dimension `sf_hires:1`",
        "default": "",
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "sendMachineID",
        "doc": "Whether to send the machine-id dimension on all host-specific datapoints generated by the agent.  This dimension is derived from the Linux machine-id value.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "observers",
        "doc": "A list of observers to use (see observer config)",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "ObserverConfig",
          "doc": "ObserverConfig holds the configuration for an observer",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "type",
              "doc": "The type of the observer",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "monitors",
        "doc": "A list of monitors to use (see monitor config)",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MonitorConfig",
          "doc": "MonitorConfig is used to configure monitor instances.  One instance of MonitorConfig may be used to configure multiple monitor instances.  If a monitor's discovery rule does not match any discovered services, the monitor will not run.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "type",
              "doc": "The type of the monitor",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "discoveryRule",
              "doc": "The rule used to match up this configuration with a discovered endpoint. If blank, the configuration will be run immediately when the agent is started.  If multiple endpoints match this rule, multiple instances of the monitor type will be created with the same configuration (except different host/port).",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "extraDimensions",
              "doc": "A set of extra dimensions (key:value pairs) to include on datapoints emitted by the monitor(s) created from this configuration. To specify metrics from this monitor should be high-resolution, add the dimension `sf_hires:1`",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "intervalSeconds",
              "doc": "The interval (in seconds) at which to emit datapoints from the monitor(s) created by this configuration.  If not set (or set to 0), the global agent intervalSeconds config option will be used instead.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "solo",
              "doc": "If one or more configurations have this set to true, only those configurations will be considered -- useful for testing",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "metricsToExclude",
              "doc": "A list of metric filters",
              "default": "",
              "required": false,
              "type": "slice",
              "elementKind": "struct",
              "elementStruct": {
                "name": "MetricFilter",
                "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
                "package": "internal/core/config",
                "fields": [
                  {
                    "yamlName": "dimensions",
                    "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.",
                    "default": "",
                    "required": false,
                    "type": "map",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "metricNames",
                    "doc": "A list of metric names to match against, OR'd together",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "metricName",
                    "doc": "A single metric name to match against",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "monitorType",
                    "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "negated",
                    "doc": "Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
                    "default": false,
                    "required": false,
                    "type": "bool",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "disableHostDimensions",
              "doc": "Some monitors pull metrics from services not running on the same host and should not get the host-specific dimensions set on them (e.g. `host`, `AWSUniqueId`, etc).  Setting this to `true` causes those dimensions to be omitted.  You can disable this globally with the `disableHostDimensions` option on the top level of the config.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "disableEndpointDimensions",
              "doc": "This can be set to true if you don't want to include the dimensions that are specific to the endpoint that was discovered by an observer.  This is useful when you have an endpoint whose identity is not particularly important since it acts largely as a proxy or adapter for other metrics.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "writer",
        "doc": "Configuration of the datapoint/event writer",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "WriterConfig",
          "doc": "WriterConfig holds configuration for the datapoint writer.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "datapointMaxBatchSize",
              "doc": "The maximum number of datapoints to include in a batch before sending the batch to the ingest server.  Smaller batch sizes than this will be sent if datapoints originate in smaller chunks.",
              "default": 1000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "traceSpanMaxBatchSize",
              "doc": "The analogue of `datapointMaxBatchSize` for trace spans.",
              "default": 1000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "datapointMaxRequests",
              "doc": "Deprecated: use `maxRequests` instead.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "maxRequests",
              "doc": "The maximum number of concurrent requests to make to a single ingest server with datapoints/events/trace spans.  This number multipled by `datapointMaxBatchSize` is more or less the maximum number of datapoints that can be \"in-flight\" at any given time.",
              "default": 10,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "eventSendIntervalSeconds",
              "doc": "The agent does not send events immediately upon a monitor generating them, but buffers them and sends them in batches.  The lower this number, the less delay for events to appear in SignalFx.",
              "default": 1,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesMaxRequests",
              "doc": "The analogue of `maxRequests` for dimension property requests.",
              "default": 10,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesHistorySize",
              "doc": "Properties that are synced to SignalFx are cached to prevent duplicate requests from being sent, causing unnecessary load on our backend.",
              "default": 1000,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "logDatapoints",
              "doc": "If the log level is set to `debug` and this is true, all datapoints generated by the agent will be logged.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logEvents",
              "doc": "The analogue of `logDatapoints` for events.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logTraceSpans",
              "doc": "The analogue of `logDatapoints` for trace spans.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "sendTraceHostCorrelationMetrics",
              "doc": "Whether to send host correlation metrics to correlation traced services with the underlying host",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "staleServiceTimeout",
              "doc": "How long to wait after a trace span's service name is last seen to continue sending the correlation datapoints for that service.  This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration.  This option is irrelvant if `sendTraceHostCorrelationMetrics` is false.",
              "default": "5m",
              "required": false,
              "type": "int64",
              "elementKind": ""
            },
            {
              "yamlName": "traceHostCorrelationMetricsInterval",
              "doc": "How frequently to send host correlation metrics that are generated from the service name seen in trace spans sent through or by the agent.  This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration.  This option is irrelvant if `sendTraceHostCorrelationMetrics` is false.",
              "default": "1m",
              "required": false,
              "type": "int64",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "logging",
        "doc": "Log configuration",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "LogConfig",
          "doc": "LogConfig contains configuration related to logging",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "level",
              "doc": "Valid levels include `debug`, `info`, `warn`, `error`.  Note that `debug` logging may leak sensitive configuration (e.g. passwords) to the agent output.",
              "default": "info",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "collectd",
        "doc": "Configuration of the managed collectd subprocess",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "CollectdConfig",
          "doc": "CollectdConfig high-level configurations",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "disableCollectd",
              "doc": "If you won't be using any collectd monitors, this can be set to true to prevent collectd from pre-initializing",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "timeout",
              "doc": "How many read intervals before abandoning a metric. Doesn't affect much in normal usage. See [Timeout](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#timeout_iterations).",
              "default": 40,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "readThreads",
              "doc": "Number of threads dedicated to executing read callbacks. See [ReadThreads](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#readthreads_num)",
              "default": 5,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeThreads",
              "doc": "Number of threads dedicated to writing value lists to write callbacks. This should be much less than readThreads because writing is batched in the write_http plugin that writes back to the agent. See [WriteThreads](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writethreads_num).",
              "default": 2,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeQueueLimitHigh",
              "doc": "The maximum numbers of values in the queue to be written back to the agent from collectd.  Since the values are written to a local socket that the agent exposes, there should be almost no queuing and the default should be more than sufficient. See [WriteQueueLimitHigh](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writequeuelimithigh_highnum)",
              "default": 500000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeQueueLimitLow",
              "doc": "The lowest number of values in the collectd queue before which metrics begin being randomly dropped.  See [WriteQueueLimitLow](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writequeuelimitlow_lownum)",
              "default": 400000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "logLevel",
              "doc": "Collectd's log level -- info, notice, warning, or err",
              "default": "notice",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "intervalSeconds",
              "doc": "A default read interval for collectd plugins.  If zero or undefined, will default to the global agent interval.  Some collectd python monitors do not support overridding the interval at the monitor level, but this setting will apply to them.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeServerIPAddr",
              "doc": "The local IP address of the server that the agent exposes to which collectd will send metrics.  This defaults to an arbitrary address in the localhost subnet, but can be overridden if needed.",
              "default": "127.9.8.7",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "writeServerPort",
              "doc": "The port of the agent's collectd metric sink server.  If set to zero (the default) it will allow the OS to assign it a free port.",
              "default": 0,
              "required": false,
              "type": "uint16",
              "elementKind": ""
            },
            {
              "yamlName": "configDir",
              "doc": "This is where the agent will write the collectd config files that it manages.  If you have secrets in those files, consider setting this to a path on a tmpfs mount.  The files in this directory should be considered transient -- there is no value in editing them by hand.  If you want to add your own collectd config, see the collectd/custom monitor.",
              "default": "/var/run/signalfx-agent/collectd",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "metricsToExclude",
        "doc": "A list of metric filters",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against, OR'd together",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "pythonEnabled",
        "doc": "(**NOT FUNCTIONAL**) Whether to enable the Python sub-agent (\"neopy\") that can directly use DataDog and Collectd Python plugins.  This is not the same as Collectd's Python plugin, which is always enabled.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "diagnosticsNamedPipePath",
        "doc": "The path where the agent will create a named pipe and serve diagnostic output (windows only)",
        "default": "\\\\.\\pipe\\signalfx-agent-diagnostics",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "diagnosticsSocketPath",
        "doc": "The path where the agent will create UNIX socket and serve diagnostic output (linux only)",
        "default": "/var/run/signalfx-agent/diagnostics.sock",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "internalMetricsNamedPipePath",
        "doc": "The path where the agent will create a named pipe that serves internal metrics (used by the internal-metrics monitor) (windows only)",
        "default": "\\\\.\\pipe\\signalfx-agent-internal-metrics",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "internalMetricsSocketPath",
        "doc": "The path where the agent will create a socket that serves internal metrics (used by the internal-metrics monitor) (linux only)",
        "default": "/var/run/signalfx-agent/internal-metrics.sock",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "profiling",
        "doc": "Enables Go pprof endpoint on port 6060 that serves profiling data for development",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "bundleDir",
        "doc": "Path to the directory holding the agent dependencies.  This will normally be derived automatically. Overrides the envvar SIGNALFX_BUNDLE_DIR if set.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "scratch",
        "doc": "This exists purely to give the user a place to put common yaml values to reference in other parts of the config file.",
        "default": null,
        "required": false,
        "type": "interface",
        "elementKind": ""
      },
      {
        "yamlName": "configSources",
        "doc": "Configuration of remote config stores",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "SourceConfig",
          "doc": "SourceConfig represents configuration for various config sources that we support.",
          "package": "internal/core/config/sources",
          "fields": [
            {
              "yamlName": "watch",
              "doc": "Whether to watch config sources for changes.  If this is `true` and any of the config changes (either the main agent.yaml, or remote config values), the agent will dynamically reconfigure itself with minimal disruption.  This is generally better than restarting the agent on config changes since that can result in larger gaps in metric data.  The main disadvantage of watching is slightly greater network and compute resource usage. This option itself ironically enough is not subject to watching and changing it to false after the agent was started with it true will require an agent restart.",
              "default": true,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "file",
              "doc": "Configuration for other file sources",
              "default": "",
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for the file-based config source",
                "package": "internal/core/config/sources/file",
                "fields": [
                  {
                    "yamlName": "pollRateSeconds",
                    "doc": "How often to poll files (in seconds) to test for changes.  There are so many edge cases that break inotify that it is more robust to simply poll files than rely on that. This option is not subject to watching and changes to it will require an agent restart.",
                    "default": 5,
                    "required": false,
                    "type": "int",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "zookeeper",
              "doc": "Configuration for a Zookeeper remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config is used to configure the Zookeeper client",
                "package": "internal/core/config/sources/zookeeper",
                "fields": [
                  {
                    "yamlName": "endpoints",
                    "doc": "A list of Zookeeper servers to use for the client",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "timeoutSeconds",
                    "doc": "Client timeout",
                    "default": 10,
                    "required": false,
                    "type": "uint",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "etcd2",
              "doc": "Configuration for an Etcd 2 remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for an Etcd2 source",
                "package": "internal/core/config/sources/etcd2",
                "fields": [
                  {
                    "yamlName": "endpoints",
                    "doc": "A list of Etcd2 servers to use",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "username",
                    "doc": "An optional username to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "password",
                    "doc": "An optional password to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "consul",
              "doc": "Configuration for a Consul remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for the consul client",
                "package": "internal/core/config/sources/consul",
                "fields": [
                  {
                    "yamlName": "endpoint",
                    "doc": "A Consul server URL",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "username",
                    "doc": "An optional username to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "password",
                    "doc": "An optional password to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "token",
                    "doc": "An authentication token, if needed",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "datacenter",
                    "doc": "The Consul datacenter to use",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            }
          ]
        }
      }
    ]
  }
}