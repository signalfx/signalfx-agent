#!/usr/bin/env python3

# Syncs all the relevant docs/metadata from the agent to the integrations repo.

import os
import re
import sys
import yaml
from nltk.tokenize import sent_tokenize
from pathlib import Path

try:
    import nltk
except ImportError:
    print("You must install the nltk library with 'pip3 install nltk==3.4.3'", file=sys.stderr)
    sys.exit(1)

nltk.download("punkt")

SCRIPT_DIR = Path(__file__).parent.resolve()
AGENT_ROOT = SCRIPT_DIR / "../.."
AGENT_DOCS = AGENT_ROOT / "docs"

INTEGRATIONS_REPO = Path(os.environ.get("INTEGRATIONS_REPO") or (AGENT_ROOT / "../integrations")).resolve()
INTEGRATIONS_REPO_SMART_AGENT_DIR = INTEGRATIONS_REPO / "signalfx-agent"

AUTO_GENERATION_TEMPLATE = """
<!--- Generated by to-integrations-repo script in Smart Agent repo, DO NOT MODIFY HERE --->
"""

AGENT_MONITOR_BLURB = """
### INSTALLATION

This integration is part of the [SignalFx Smart Agent](https://github.com/signalfx/integrations/tree/master/signalfx-agent)[](sfx_link:signalfx-agent)
as the `{monitor_type}` monitor. You should first deploy the Smart Agent to the
same host as the service you want to monitor, and then continue with the
configuration instructions below.

"""

# Key is of the form <monitor/package/path:monitorType>, value is the
# integration directory in the integrations repo where metrics should go (not
# including the `docs/` path suffix).
MONITORS_TO_INTEGRATIONS_DIR = {
    ("internal/monitors/collectd/activemq", "collectd/activemq"): "activemq",
    ("internal/monitors/collectd/apache", "collectd/apache"): "apache",
    ("internal/monitors/elasticsearch", "elasticsearch"): "elasticsearch",
    ("internal/monitors/collectd/cpu", "collectd/cpu"): "collectd-cpu",
    ("internal/monitors/collectd/cassandra", "collectd/cassandra"): "cassandra",
    ("internal/monitors/collectd/consul", "collectd/consul"): "consul",
    ("internal/monitors/collectd/couchbase", "collectd/couchbase"): "couchbase",
    ("internal/monitors/collectd/etcd", "collectd/etcd"): "etcd",
    ("internal/monitors/docker", "docker-container-stats"): "docker",
    ("internal/monitors/gitlab", "gitlab"): "gitlab",
    ("internal/monitors/collectd/hadoop", "collectd/hadoop"): "hadoop",
    ("internal/monitors/collectd/haproxy", "collectd/haproxy"): "haproxy",
    ("internal/monitors/collectd/genericjmx", "collectd/genericjmx"): "java",
    ("internal/monitors/collectd/jenkins", "collectd/jenkins"): "jenkins",
    ("internal/monitors/collectd/kafka", "collectd/kafka"): "kafka",
    ("internal/monitors/collectd/kong", "collectd/kong"): "kong",
    ("internal/monitors/collectd/memcached", "collectd/memcached"): "memcached",
    ("internal/monitors/collectd/mongodb", "collectd/mongodb"): "mongodb",
    ("internal/monitors/collectd/mysql", "collectd/mysql"): "mysql",
    ("internal/monitors/collectd/nginx", "collectd/nginx"): "nginx",
    ("internal/monitors/collectd/openstack", "collectd/openstack"): "openstack",
    ("internal/monitors/postgresql", "postgresql"): "postgresql",
    ("internal/monitors/collectd/rabbitmq", "collectd/rabbitmq"): "rabbitmq",
    ("internal/monitors/collectd/redis", "collectd/redis"): "redis",
    ("internal/monitors/collectd/solr", "collectd/solr"): "solr",
    ("internal/monitors/statsd", "statsd"): "statsd",
    ("internal/monitors/collectd/spark", "collectd/spark"): "spark",
    ("internal/monitors/collectd/zookeeper", "collectd/zookeeper"): "zookeeper",
}


def sync_metrics(package_path, monitor_type, integrations_dir):
    for mon in yaml.safe_load((AGENT_ROOT / package_path / "metadata.yaml").read_bytes())["monitors"]:
        if mon.get("monitorType") == monitor_type:
            print(f"Syncing metrics for {monitor_type}")
            metric_yaml = generate_metric_yaml(mon)
            out_path = INTEGRATIONS_REPO / integrations_dir / "metrics.yaml"
            out_path.write_text(metric_yaml)
            break
    else:
        raise ValueError(f"monitor type {monitor_type} not found in {package_path}")


def generate_metric_yaml(mon):
    metrics = {}
    for name, metric in mon.get("metrics", {}).items():
        custom = mon.get("sendAll", False) or not metric.get("default", False)
        desc_sentences = sent_tokenize(metric.get("description", ""))
        metrics[name] = {
            "title": name,
            "brief": desc_sentences[0].rstrip(".").strip() if desc_sentences else "",
            "metric_type": metric["type"],
            "description": metric.get("description", "").strip(),
            "custom": custom,
        }

    out = "# This file was generated in the Smart Agent repo and copied here, DO NOT EDIT HERE.\n"
    # Add a blank line in between each metric descriptor.
    for name, met in sorted(metrics.items(), key=lambda t: t[0]):
        out += yaml.dump({name: met})
        out += "\n"
    return out


def sync_docs(monitor_type, integrations_dir):
    monitor_doc_path = AGENT_ROOT / f"docs/monitors/{monitor_type.replace('/', '-')}.md"
    assert monitor_doc_path.is_file(), monitor_doc_path

    target_path = INTEGRATIONS_REPO / integrations_dir / "SMART_AGENT_MONITOR.md"
    target_path.write_text(
        fixup_overview_header(
            fixup_relative_monitor_paths(
                AUTO_GENERATION_TEMPLATE + AGENT_MONITOR_BLURB.format(
                    monitor_type=monitor_type) + monitor_doc_path.read_text()),
            monitor_type=monitor_type,
        )
    )


RELATIVE_LINK_PATTERN = re.compile(r"(\[.*?\])\((\.\.?/.+?)\)", flags=re.DOTALL)


def fixup_relative_paths(absolute_path, content):
    """
    Only works for links within the specified absolute path
    """
    return RELATIVE_LINK_PATTERN.sub(absolute_path, content)


def fixup_relative_monitor_paths(content):
    """
    Replaces relative links within the scope of monitor docs with respective github links
    """
    return fixup_relative_paths(
        r"\1(https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/\2)", content
    )


def fixup_relative_agent_doc_paths(content):
    """
    Replaces relative links within the scope of agent docs with respective product-docs links
    """
    return fixup_relative_paths(
        r"\1(https://docs.signalfx.com/en/latest/integrations/agent/\2)", content
    )


OVERVIEW_REPLACEMENT = """
## Description

**This integration primarily consists of the Smart Agent monitor `{monitor_type}`.
Below is an overview of that monitor.**

### Smart Agent Monitor
"""


def fixup_overview_header(content, monitor_type):
    return content.replace("## Overview", OVERVIEW_REPLACEMENT.format(monitor_type=monitor_type))


# names of directories and files that need to be eventually surfaced in product-docs. make use of
# this map to process and sync only required docs to the integrations repo. Note that all files from
# directories specified will be synced to the integrations repo. The below dictionary is populated from
# https://github.com/signalfx/signalfx-agent/tree/master/docs/
REQUIRED_AGENT_DOCS = {
    'directories': [
        'monitors',
        'observers',
    ],
    'md_files': [
        'quick-install',
        'advanced-install-options',
        'config-schema',
        'observer-config',
        'monitor-config',
        'auto-discovery',
        'filtering',
        'remote-config',
        'windows',
        'faq',
        'legacy-filtering',
    ]
}

AGENT_README_HEADER = """
# ![](https://github.com/signalfx/integrations/blob/master/signalfx-agent/img/integration_smartagent.png) SignalFx Smart Agent

"""

MARKDOWN_LINK_PATTERN = re.compile(r"(\(https://docs.signalfx.com/en/latest/integrations/agent/.+?\.)md(.*?\))")
MARKDOWN_SUBSECTION_LINK_PATTERN = re.compile(r"(\[.*?\]\(\.\.?/.+?\.)md(\#.+?\))", flags=re.DOTALL)
SFX_APP_LINK_PATTERN = re.compile('\[\]\(sfx_link:.+?\)')


def convert_markdowns_to_htmls(content):
    return re.sub(MARKDOWN_LINK_PATTERN, r"\1html\2", content)


def convert_markdown_subsections_to_htmls(content):
    return re.sub(MARKDOWN_SUBSECTION_LINK_PATTERN, r"\1html\2", content)


def fixup_headers_in_agent_readme(content):
    # This is a hack in place for the README to surfaced in desired
    # manner on the tile, so that the magic comment has an invisible
    # header to use
    content = content.replace("# Quick Install", "## <!-- -->")
    content = content.replace(" - [Concepts](#concepts)", "")
    content = content.replace(" - [Installation](#installation)", "")
    content = content.replace("## Concepts", "### Concepts")
    content = content.replace("### Monitors", "#### Monitors")
    content = content.replace("### Observers", "#### Observers")
    content = content.replace("### Writer", "#### Writer")

    return content


def remove_sfx_app_links(content):
    return re.sub(SFX_APP_LINK_PATTERN, r"", content)


def fixup_moved_links(content):
    content = content.replace("(./observer-config.md)", "(./observers/_observer-config.md)")
    content = content.replace("(./monitor-config.md)", "(./monitors/_monitor-config.md)")

    return content


def sync_agent_quick_install():
    """
    Construct README for SignalFx Agent from quick-install.md file here:
    https://github.com/signalfx/signalfx-agent/tree/master/docs
    """

    target_path = INTEGRATIONS_REPO_SMART_AGENT_DIR / "README.md"
    smart_agent_quick_install_path = AGENT_DOCS / "quick-install.md"

    print("Constructing Agent README")

    target_path.write_text(convert_markdown_subsections_to_htmls(convert_markdowns_to_htmls(
        fixup_relative_agent_doc_paths(AUTO_GENERATION_TEMPLATE + AGENT_README_HEADER + fixup_headers_in_agent_readme(
            fixup_moved_links(smart_agent_quick_install_path.read_text()))))))


PRODUCT_DOCS_REPO = "agent_docs"


def sync_agent_docs():
    """
    Sync Agent docs from here:
    https://github.com/signalfx/signalfx-agent/tree/master/docs
    """
    target_dir_parent_path = INTEGRATIONS_REPO_SMART_AGENT_DIR / PRODUCT_DOCS_REPO
    target_dir_parent_path.mkdir(parents=True, exist_ok=True)

    for dir in REQUIRED_AGENT_DOCS['directories']:
        full_dir_path = AGENT_DOCS / dir
        assert full_dir_path.is_dir(), full_dir_path

        target_dir_path = target_dir_parent_path / dir
        target_dir_path.mkdir(parents=True, exist_ok=True)
        assert target_dir_path.is_dir(), target_dir_path

        for full_file_path in full_dir_path.iterdir():
            sync_markdown_files(full_file_path)

    for file in REQUIRED_AGENT_DOCS['md_files']:
        full_file_path = AGENT_DOCS / ("%s.md" % file)
        sync_markdown_files(full_file_path)


def sync_markdown_files(source_file_path):
    assert source_file_path.is_file(), source_file_path

    relative_path = source_file_path.relative_to(AGENT_DOCS)
    target_path = INTEGRATIONS_REPO_SMART_AGENT_DIR / PRODUCT_DOCS_REPO / relative_path

    print(f"Syncing Agent docs: {str(relative_path)}")

    target_path.write_text(
        remove_sfx_app_links(
            convert_markdown_subsections_to_htmls(AUTO_GENERATION_TEMPLATE + source_file_path.read_text())
        )
    )


def sync_agent_metrics():
    """
    Sync Agent internal metrics from here:
    https://github.com/signalfx/signalfx-agent/blob/master/internal/monitors/internalmetrics/metadata.yaml
    """

    sync_metrics("internal/monitors/internalmetrics", "internal-metrics", "signalfx-agent")


def run():
    mon_type_filters = None
    if len(sys.argv) > 1:
        mon_type_filters = sys.argv[1:]

    if not INTEGRATIONS_REPO:
        print("INTEGRATIONS_REPO envvar should be set")
        sys.exit(1)

    for (package_path, monitor_type), integrations_dir in MONITORS_TO_INTEGRATIONS_DIR.items():
        if mon_type_filters and monitor_type not in mon_type_filters:
            continue
        sync_metrics(package_path, monitor_type, integrations_dir)
        sync_docs(monitor_type, integrations_dir)

    sync_agent_quick_install()
    sync_agent_docs()
    sync_agent_metrics()


if __name__ == "__main__":
    run()
