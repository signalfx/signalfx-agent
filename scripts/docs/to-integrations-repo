#!/usr/bin/env python3

# Syncs all the relevant docs/metadata from the agent to the integrations repo.

import os
import re
import sys
import yaml
from nltk.tokenize import sent_tokenize
from pathlib import Path

try:
    import nltk
except ImportError:
    print("You must install the nltk library with 'pip3 install nltk==3.4.3'", file=sys.stderr)
    sys.exit(1)

nltk.download("punkt")

SCRIPT_DIR = Path(__file__).parent.resolve()
AGENT_ROOT = SCRIPT_DIR / "../.."
AGENT_DOCS = AGENT_ROOT / "docs"

INTEGRATIONS_REPO = Path(os.environ.get("INTEGRATIONS_REPO") or (AGENT_ROOT / "../integrations")).resolve()
INTEGRATIONS_REPO_SMART_AGENT_DIR = INTEGRATIONS_REPO / "signalfx-agent"

AUTO_GENERATION_TEMPLATE = """
<!--- Generated by to-integrations-repo script in Smart Agent repo, DO NOT MODIFY HERE --->
"""

AGENT_MONITOR_BLURB = """
### INSTALLATION

This integration is part of the [SignalFx Smart Agent](https://github.com/signalfx/integrations/tree/master/signalfx-agent)[](sfx_link:signalfx-agent)
as the `{monitor_type}` monitor. You should first deploy the Smart Agent to the
same host as the service you want to monitor, and then continue with the
configuration instructions below.

"""

# Key is  the integration directory where metrics should go (not
# # including the `docs/` path suffix) and value is of the
# form <monitor/package/path:monitorType>
MONITORS_TO_INTEGRATIONS_DIR = {
    "activemq": [("internal/monitors/collectd/activemq", "collectd/activemq")],
    "apache": [("internal/monitors/collectd/apache", "collectd/apache")],
    "elasticsearch": [("internal/monitors/elasticsearch", "elasticsearch")],
    "collectd-cpu": [("internal/monitors/collectd/cpu", "collectd/cpu")],
    "cassandra": [("internal/monitors/collectd/cassandra", "collectd/cassandra")],
    "consul": [("internal/monitors/collectd/consul", "collectd/consul")],
    "couchbase": [("internal/monitors/collectd/couchbase", "collectd/couchbase")],
    "etcd": [("internal/monitors/collectd/etcd", "collectd/etcd")],
    "docker": [("internal/monitors/docker", "docker-container-stats")],
    "gitlab": [("internal/monitors/gitlab", "gitlab")],
    "hadoop": [("internal/monitors/collectd/hadoop", "collectd/hadoop")],
    "haproxy": [("internal/monitors/collectd/haproxy", "collectd/haproxy")],
    "java": [("internal/monitors/collectd/genericjmx", "collectd/genericjmx")],
    "jenkins": [("internal/monitors/collectd/jenkins", "collectd/jenkins")],
    "kafka": [("internal/monitors/collectd/kafka", "collectd/kafka")],
    "kong": [("internal/monitors/collectd/kong", "collectd/kong")],
    "memcached": [("internal/monitors/collectd/memcached", "collectd/memcached")],
    "mongodb": [("internal/monitors/collectd/mongodb", "collectd/mongodb")],
    "mysql": [("internal/monitors/collectd/mysql", "collectd/mysql")],
    "nginx": [("internal/monitors/collectd/nginx", "collectd/nginx")],
    "openstack": [("internal/monitors/collectd/openstack", "collectd/openstack")],
    "postgresql": [("internal/monitors/postgresql", "postgresql")],
    "rabbitmq": [("internal/monitors/collectd/rabbitmq", "collectd/rabbitmq")],
    "redis": [("internal/monitors/collectd/redis", "collectd/redis")],
    "solr": [("internal/monitors/collectd/solr", "collectd/solr")],
    "statsd": [("internal/monitors/statsd", "statsd")],
    "spark": [("internal/monitors/collectd/spark", "collectd/spark")],
    "zookeeper": [("internal/monitors/collectd/zookeeper", "collectd/zookeeper")],
    "logstash": [
        ("internal/monitors/logstash/logstash", "logstash"),
        ("internal/monitors/logstash/tcp", "logstash-tcp"),
    ],
}


def sync_metrics(package_path, monitor_type):
    for mon in yaml.safe_load((AGENT_ROOT / package_path / "metadata.yaml").read_bytes())["monitors"]:
        if mon.get("monitorType") == monitor_type:
            print(f"Syncing metrics for {monitor_type}")
            return generate_metric_yaml(mon)
    else:
        raise ValueError(f"monitor type {monitor_type} not found in {package_path}")


def write_metrics(package_path, monitor_type, integrations_dir):
    metric_yaml = sync_metrics(package_path, monitor_type)
    out_path = INTEGRATIONS_REPO / integrations_dir / "metrics.yaml"
    out_path.write_text(metric_yaml, encoding="utf-8")


def generate_metric_yaml(mon):
    metrics = {}
    for name, metric in mon.get("metrics", {}).items():
        custom = mon.get("sendAll", False) or not metric.get("default", False)
        desc_sentences = sent_tokenize(metric.get("description", ""))
        metrics[name] = {
            "title": name,
            "brief": desc_sentences[0].rstrip(".").strip() if desc_sentences else "",
            "metric_type": metric["type"],
            "description": metric.get("description", "").strip(),
            "custom": custom,
        }

    out = "# This file was generated in the Smart Agent repo and copied here, DO NOT EDIT HERE.\n"
    # Add a blank line in between each metric descriptor.
    for name, met in sorted(metrics.items(), key=lambda t: t[0]):
        out += yaml.dump({name: met})
        out += "\n"
    return out


def sync_docs(monitor_type):
    monitor_doc_path = AGENT_ROOT / f"docs/monitors/{monitor_type.replace('/', '-')}.md"
    assert monitor_doc_path.is_file(), monitor_doc_path

    return fixup_overview_header(
        fixup_relative_monitor_paths(
            AUTO_GENERATION_TEMPLATE
            + AGENT_MONITOR_BLURB.format(monitor_type=monitor_type)
            + monitor_doc_path.read_text(encoding="utf-8")
        ),
        monitor_type=monitor_type,
    )


def write_docs(monitor_type, integrations_dir):
    target_path = INTEGRATIONS_REPO / integrations_dir / "SMART_AGENT_MONITOR.md"
    target_path.write_text(sync_docs(monitor_type), encoding="utf-8")


RELATIVE_LINK_PATTERN = re.compile(r"(\[.*?\])\((\.\.?/.+?)\)", flags=re.DOTALL)


def fixup_relative_paths(absolute_path, content):
    """
    Only works for links within the specified absolute path
    """
    return RELATIVE_LINK_PATTERN.sub(absolute_path, content)


def fixup_relative_monitor_paths(content):
    """
    Replaces relative links within the scope of monitor docs with respective github links
    """
    return fixup_relative_paths(r"\1(https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/\2)", content)


def fixup_relative_agent_doc_paths(content):
    """
    Replaces relative links within the scope of agent docs with respective product-docs links
    """
    return fixup_relative_paths(r"\1(https://docs.signalfx.com/en/latest/integrations/agent/\2)", content)


OVERVIEW_REPLACEMENT = """
## Description

**This integration primarily consists of the Smart Agent monitor `{monitor_type}`.
Below is an overview of that monitor.**

### Smart Agent Monitor
"""


def fixup_overview_header(content, monitor_type):
    return content.replace("## Overview", OVERVIEW_REPLACEMENT.format(monitor_type=monitor_type))


# names of directories and files that need to be eventually surfaced in product-docs. make use of
# this map to process and sync only required docs to the integrations repo. Note that all files from
# directories specified will be synced to the integrations repo. The below dictionary is populated from
# https://github.com/signalfx/signalfx-agent/tree/master/docs/
REQUIRED_AGENT_DOCS = {
    "directories": ["monitors", "observers"],
    "md_files": [
        "quick-install",
        "advanced-install-options",
        "config-schema",
        "observer-config",
        "monitor-config",
        "auto-discovery",
        "filtering",
        "remote-config",
        "windows",
        "faq",
        "legacy-filtering",
    ],
}

AGENT_README_HEADER = """
# ![](https://github.com/signalfx/integrations/blob/master/signalfx-agent/img/integration_smartagent.png) SignalFx Smart Agent

"""

MARKDOWN_LINK_PATTERN = re.compile(r"(\(https://docs.signalfx.com/en/latest/integrations/agent/.+?\.)md(.*?\))")
MARKDOWN_SUBSECTION_LINK_PATTERN = re.compile(r"(\[.*?\]\(\.\.?/.+?\.)md(\#.+?\))", flags=re.DOTALL)
SFX_APP_LINK_PATTERN = re.compile("\[\]\(sfx_link:.+?\)")


def convert_markdowns_to_htmls(content):
    return re.sub(MARKDOWN_LINK_PATTERN, r"\1html\2", content)


def convert_markdown_subsections_to_htmls(content):
    return re.sub(MARKDOWN_SUBSECTION_LINK_PATTERN, r"\1html\2", content)


def fixup_headers_in_agent_readme(content):
    # This is a hack in place for the README to surfaced in desired
    # manner on the tile, so that the magic comment has an invisible
    # header to use
    content = content.replace("# Quick Install", "## <!-- -->")
    content = content.replace(" - [Concepts](#concepts)", "")
    content = content.replace(" - [Installation](#installation)", "")
    content = content.replace("## Concepts", "### Concepts")
    content = content.replace("### Monitors", "#### Monitors")
    content = content.replace("### Observers", "#### Observers")
    content = content.replace("### Writer", "#### Writer")

    return content


def remove_sfx_app_links(content):
    return re.sub(SFX_APP_LINK_PATTERN, r"", content)


def fixup_moved_links(content):
    content = content.replace("(./observer-config.md)", "(./observers/_observer-config.md)")
    content = content.replace("(./monitor-config.md)", "(./monitors/_monitor-config.md)")

    return content


def sync_agent_quick_install():
    """
    Construct README for SignalFx Agent from quick-install.md file here:
    https://github.com/signalfx/signalfx-agent/tree/master/docs
    """

    target_path = INTEGRATIONS_REPO_SMART_AGENT_DIR / "README.md"
    smart_agent_quick_install_path = AGENT_DOCS / "quick-install.md"

    print("Constructing Agent README")

    target_path.write_text(
        convert_markdown_subsections_to_htmls(
            convert_markdowns_to_htmls(
                fixup_relative_agent_doc_paths(
                    AUTO_GENERATION_TEMPLATE
                    + AGENT_README_HEADER
                    + fixup_headers_in_agent_readme(
                        fixup_moved_links(smart_agent_quick_install_path.read_text(encoding="utf-8"))
                    )
                )
            )
        ),
        encoding="utf-8",
    )


PRODUCT_DOCS_REPO = "agent_docs"


def sync_agent_docs():
    """
    Sync Agent docs from here:
    https://github.com/signalfx/signalfx-agent/tree/master/docs
    """
    target_dir_parent_path = INTEGRATIONS_REPO_SMART_AGENT_DIR / PRODUCT_DOCS_REPO
    target_dir_parent_path.mkdir(parents=True, exist_ok=True)

    for dir in REQUIRED_AGENT_DOCS["directories"]:
        full_dir_path = AGENT_DOCS / dir
        assert full_dir_path.is_dir(), full_dir_path

        target_dir_path = target_dir_parent_path / dir
        target_dir_path.mkdir(parents=True, exist_ok=True)
        assert target_dir_path.is_dir(), target_dir_path

        for full_file_path in full_dir_path.iterdir():
            sync_markdown_files(full_file_path)

    for file in REQUIRED_AGENT_DOCS["md_files"]:
        full_file_path = AGENT_DOCS / ("%s.md" % file)
        sync_markdown_files(full_file_path)


def sync_markdown_files(source_file_path):
    assert source_file_path.is_file(), source_file_path

    relative_path = source_file_path.relative_to(AGENT_DOCS)
    target_path = INTEGRATIONS_REPO_SMART_AGENT_DIR / PRODUCT_DOCS_REPO / relative_path

    print(f"Syncing Agent docs: {str(relative_path)}")

    target_path.write_text(
        remove_sfx_app_links(
            convert_markdown_subsections_to_htmls(
                AUTO_GENERATION_TEMPLATE + source_file_path.read_text(encoding="utf-8")
            )
        ),
        encoding="utf-8",
    )


def sync_agent_metrics():
    """
    Sync Agent internal metrics from here:
    https://github.com/signalfx/signalfx-agent/blob/master/internal/monitors/internalmetrics/metadata.yaml
    """

    write_metrics("internal/monitors/internalmetrics", "internal-metrics", "signalfx-agent")


def run():
    mon_type_filters = None
    if len(sys.argv) > 1:
        mon_type_filters = sys.argv[1:]

    if not INTEGRATIONS_REPO:
        print("INTEGRATIONS_REPO envvar should be set")
        sys.exit(1)

    for integrations_dir, monitors_info in MONITORS_TO_INTEGRATIONS_DIR.items():
        if len(monitors_info) == 1:
            package_path, monitor_type = monitors_info[0]
            if mon_type_filters and monitor_type not in mon_type_filters:
                continue
            write_metrics(package_path, monitor_type, integrations_dir)
            write_docs(monitor_type, integrations_dir)
        else:  # case where multiple agent monitors need to show in a single integrations tile
            for (package_path, monitor_type) in monitors_info:
                pass

    sync_agent_quick_install()
    sync_agent_docs()
    sync_agent_metrics()


if __name__ == "__main__":
    run()
