{
  "GenericMonitorConfig": {
    "name": "MonitorConfig",
    "doc": "MonitorConfig is used to configure monitor instances.  One instance of MonitorConfig may be used to configure multiple monitor instances.  If a monitor's discovery rule does not match any discovered services, the monitor will not run.",
    "package": "pkg/core/config",
    "fields": [
      {
        "yamlName": "type",
        "doc": "The type of the monitor",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "discoveryRule",
        "doc": "The rule used to match up this configuration with a discovered endpoint. If blank, the configuration will be run immediately when the agent is started.  If multiple endpoints match this rule, multiple instances of the monitor type will be created with the same configuration (except different host/port).",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "validateDiscoveryRule",
        "doc": "If true, a warning will be emitted if a discovery rule contains variables that will never possibly match a rule.  If using multiple observers, it is convenient to set this to false to suppress spurious errors.  The top-level setting `validateDiscoveryRules` acts as a default if this isn't set.",
        "default": "false",
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "extraDimensions",
        "doc": "A set of extra dimensions (key:value pairs) to include on datapoints emitted by the monitor(s) created from this configuration. To specify metrics from this monitor should be high-resolution, add the dimension `sf_hires: 1`",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "extraDimensionsFromEndpoint",
        "doc": "A mapping of extra dimension names to a [discovery rule expression](https://docs.signalfx.com/en/latest/integrations/agent/auto-discovery.html) that is used to derive the value of the dimension.  For example, to use a certain container label as a dimension, you could use something like this in your monitor config block: `extraDimensionsFromEndpoint: {env: 'Get(container_labels, \"myapp.com/environment\")'}`",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "configEndpointMappings",
        "doc": "A set of mappings from a configuration option on this monitor to attributes of a discovered endpoint.  The keys are the config option on this monitor and the value can be any valid expression used in discovery rules.",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "intervalSeconds",
        "doc": "The interval (in seconds) at which to emit datapoints from the monitor(s) created by this configuration.  If not set (or set to 0), the global agent intervalSeconds config option will be used instead.",
        "default": 0,
        "required": false,
        "type": "int",
        "elementKind": ""
      },
      {
        "yamlName": "solo",
        "doc": "If one or more configurations have this set to true, only those configurations will be considered. This setting can be useful for testing.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "metricsToExclude",
        "doc": "DEPRECATED in favor of the `datapointsToExclude` option.  That option handles negation of filter items differently.",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "interface"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "datapointsToExclude",
        "doc": "A list of datapoint filters.  These filters allow you to comprehensively define which datapoints to exclude by metric name or dimension set, as well as the ability to define overrides to re-include metrics excluded by previous patterns within the same filter item.  See [monitor filtering](./filtering.md#additional-monitor-level-filtering) for examples and more information.",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "interface"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "disableHostDimensions",
        "doc": "Some monitors pull metrics from services not running on the same host and should not get the host-specific dimensions set on them (e.g. `host`, `AWSUniqueId`, etc).  Setting this to `true` causes those dimensions to be omitted.  You can disable this globally with the `disableHostDimensions` option on the top level of the config.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "disableEndpointDimensions",
        "doc": "This can be set to true if you don't want to include the dimensions that are specific to the endpoint that was discovered by an observer.  This is useful when you have an endpoint whose identity is not particularly important since it acts largely as a proxy or adapter for other metrics.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "dimensionTransformations",
        "doc": "A map from dimension names emitted by the monitor to the desired dimension name that will be emitted in the datapoint that goes to SignalFx.  This can be useful if you have custom metrics from your applications and want to make the dimensions from a monitor match those. Also can be useful when scraping free-form metrics, say with the `prometheus-exporter` monitor.  Right now, only static key/value transformations are supported.  Note that filtering by dimensions will be done on the *original* dimension name and not the new name. Note that it is possible to remove unwanted dimensions via this configuration, by making the desired dimension name an empty string.",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "extraMetrics",
        "doc": "Extra metrics to enable besides the default included ones.  This is an [overridable filter](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filtering).",
        "default": null,
        "required": false,
        "type": "slice",
        "elementKind": "string"
      },
      {
        "yamlName": "extraGroups",
        "doc": "Extra metric groups to enable in addition to the metrics that are emitted by default.  A metric group is simply a collection of metrics, and they are defined in each monitor's documentation.",
        "default": null,
        "required": false,
        "type": "slice",
        "elementKind": "string"
      }
    ]
  },
  "GenericObserverConfig": {
    "name": "ObserverConfig",
    "doc": "ObserverConfig holds the configuration for an observer",
    "package": "pkg/core/config",
    "fields": [
      {
        "yamlName": "type",
        "doc": "The type of the observer",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      }
    ]
  },
  "Monitors": [
    {
      "monitorType": "appmesh",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor starts a StatsD monitor to listen to StatsD metrics emitted\nby AWS AppMesh Envoy Proxy.\n\nTo report AppMesh Envoy metrics, you need to enable Envoy StatsD sink on AppMesh\nand deploy the agent as a sidecar in the services that need to be monitored.\n\n\nSample Envoy StatsD configuration:\n\n```yaml\nstats_sinks:\n -\n  name: \"envoy.statsd\"\n  config:\n   address:\n    socket_address:\n     address: \"127.0.0.1\"\n     port_value: 8125\n     protocol: \"UDP\"\n   prefix: statsd.appmesh\n```\nPlease remember to provide the prefix to the agent monitor configuration.\n\nSee [Envoy API reference](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/stats.proto#envoy-api-msg-config-metrics-v2-statsdsink) for more info\n\nSample SignalFx SmartAgent configuration:\n\n```yaml\nmonitors:\n - type: appmesh\n   listenAddress: 0.0.0.0\n   listenPort: 8125\n   metricPrefix: statsd.appmesh\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "circuit_breakers.\u003cpriority\u003e.cx_open",
            "circuit_breakers.\u003cpriority\u003e.cx_pool_open",
            "circuit_breakers.\u003cpriority\u003e.remaining_cx",
            "circuit_breakers.\u003cpriority\u003e.remaining_pending",
            "circuit_breakers.\u003cpriority\u003e.remaining_retries",
            "circuit_breakers.\u003cpriority\u003e.remaining_rq",
            "circuit_breakers.\u003cpriority\u003e.rq_open",
            "circuit_breakers.\u003cpriority\u003e.rq_pending_open",
            "circuit_breakers.\u003cpriority\u003e.rq_retry_open",
            "external.upstream_rq_\u003c_\u003e",
            "external.upstream_rq_\u003c_xx\u003e",
            "external.upstream_rq_completed",
            "external.upstream_rq_time",
            "internal.upstream_rq_\u003c_\u003e",
            "internal.upstream_rq_\u003c_xx\u003e",
            "internal.upstream_rq_completed",
            "internal.upstream_rq_time",
            "membership_change",
            "membership_degraded",
            "membership_healthy",
            "membership_total",
            "upstream_cx_active",
            "upstream_cx_close_notify",
            "upstream_cx_connect_attempts_exceeded",
            "upstream_cx_connect_fail",
            "upstream_cx_connect_ms",
            "upstream_cx_connect_timeout",
            "upstream_cx_destroy",
            "upstream_cx_destroy_local",
            "upstream_cx_destroy_local_with_active_rq",
            "upstream_cx_destroy_remote",
            "upstream_cx_destroy_remote_with_active_rq",
            "upstream_cx_destroy_with_active_rq",
            "upstream_cx_http1_total",
            "upstream_cx_http2_total",
            "upstream_cx_idle_timeout",
            "upstream_cx_length_ms",
            "upstream_cx_max_requests",
            "upstream_cx_none_healthy",
            "upstream_cx_overflow",
            "upstream_cx_pool_overflow",
            "upstream_cx_protocol_error",
            "upstream_cx_rx_bytes_buffered",
            "upstream_cx_rx_bytes_total",
            "upstream_cx_total",
            "upstream_cx_tx_bytes_buffered",
            "upstream_cx_tx_bytes_total",
            "upstream_rq_2xx",
            "upstream_rq_3xx",
            "upstream_rq_4xx",
            "upstream_rq_5xx",
            "upstream_rq_\u003c___\u003e",
            "upstream_rq_active",
            "upstream_rq_cancelled",
            "upstream_rq_completed",
            "upstream_rq_maintenance_mode",
            "upstream_rq_pending_active",
            "upstream_rq_pending_failure_eject",
            "upstream_rq_pending_overflow",
            "upstream_rq_pending_total",
            "upstream_rq_per_try_timeout",
            "upstream_rq_retry",
            "upstream_rq_retry_overflow",
            "upstream_rq_retry_success",
            "upstream_rq_rx_reset",
            "upstream_rq_time",
            "upstream_rq_timeout",
            "upstream_rq_total",
            "upstream_rq_tx_reset"
          ]
        }
      },
      "metrics": {
        "circuit_breakers.\u003cpriority\u003e.cx_open": {
          "type": "gauge",
          "description": "Whether the connection circuit breaker is closed (0) or open (1)",
          "group": null,
          "default": false
        },
        "circuit_breakers.\u003cpriority\u003e.cx_pool_open": {
          "type": "gauge",
          "description": "Whether the connection pool circuit breaker is closed (0) or open (1)",
          "group": null,
          "default": false
        },
        "circuit_breakers.\u003cpriority\u003e.remaining_cx": {
          "type": "gauge",
          "description": "Number of remaining connections until the circuit breaker opens",
          "group": null,
          "default": false
        },
        "circuit_breakers.\u003cpriority\u003e.remaining_pending": {
          "type": "gauge",
          "description": "Number of remaining pending requests until the circuit breaker opens",
          "group": null,
          "default": false
        },
        "circuit_breakers.\u003cpriority\u003e.remaining_retries": {
          "type": "gauge",
          "description": "Number of remaining retries until the circuit breaker opens",
          "group": null,
          "default": false
        },
        "circuit_breakers.\u003cpriority\u003e.remaining_rq": {
          "type": "gauge",
          "description": "Number of remaining requests until the circuit breaker opens",
          "group": null,
          "default": false
        },
        "circuit_breakers.\u003cpriority\u003e.rq_open": {
          "type": "gauge",
          "description": "Whether the requests circuit breaker is closed (0) or open (1)",
          "group": null,
          "default": false
        },
        "circuit_breakers.\u003cpriority\u003e.rq_pending_open": {
          "type": "gauge",
          "description": "Whether the pending requests circuit breaker is closed (0) or open (1)",
          "group": null,
          "default": false
        },
        "circuit_breakers.\u003cpriority\u003e.rq_retry_open": {
          "type": "gauge",
          "description": "Whether the retry circuit breaker is closed (0) or open (1)",
          "group": null,
          "default": false
        },
        "external.upstream_rq_\u003c_\u003e": {
          "type": "cumulative",
          "description": "External origin specific HTTP response codes",
          "group": null,
          "default": false
        },
        "external.upstream_rq_\u003c_xx\u003e": {
          "type": "cumulative",
          "description": "External origin aggregate HTTP response codes",
          "group": null,
          "default": false
        },
        "external.upstream_rq_completed": {
          "type": "cumulative",
          "description": "Total external origin requests completed",
          "group": null,
          "default": false
        },
        "external.upstream_rq_time": {
          "type": "gauge",
          "description": "External origin request time milliseconds",
          "group": null,
          "default": false
        },
        "internal.upstream_rq_\u003c_\u003e": {
          "type": "cumulative",
          "description": "Internal origin specific HTTP response codes",
          "group": null,
          "default": false
        },
        "internal.upstream_rq_\u003c_xx\u003e": {
          "type": "cumulative",
          "description": "Internal origin aggregate HTTP response codes",
          "group": null,
          "default": false
        },
        "internal.upstream_rq_completed": {
          "type": "cumulative",
          "description": "Total internal origin requests completed",
          "group": null,
          "default": false
        },
        "internal.upstream_rq_time": {
          "type": "gauge",
          "description": "Internal origin request time milliseconds",
          "group": null,
          "default": false
        },
        "membership_change": {
          "type": "cumulative",
          "description": "Total cluster membership changes",
          "group": null,
          "default": false
        },
        "membership_degraded": {
          "type": "gauge",
          "description": "Current cluster degraded total",
          "group": null,
          "default": false
        },
        "membership_healthy": {
          "type": "gauge",
          "description": "Current cluster healthy total (inclusive of both health checking and outlier detection)",
          "group": null,
          "default": true
        },
        "membership_total": {
          "type": "gauge",
          "description": "Current cluster membership total",
          "group": null,
          "default": true
        },
        "upstream_cx_active": {
          "type": "gauge",
          "description": "Total active connections",
          "group": null,
          "default": false
        },
        "upstream_cx_close_notify": {
          "type": "cumulative",
          "description": "Total connections closed via HTTP/1.1 connection close header or HTTP/2 GOAWAY",
          "group": null,
          "default": false
        },
        "upstream_cx_connect_attempts_exceeded": {
          "type": "cumulative",
          "description": "Total consecutive connection failures exceeding configured connection attempts",
          "group": null,
          "default": false
        },
        "upstream_cx_connect_fail": {
          "type": "cumulative",
          "description": "Total connection failures",
          "group": null,
          "default": false
        },
        "upstream_cx_connect_ms": {
          "type": "gauge",
          "description": "Connection establishment milliseconds",
          "group": null,
          "default": false
        },
        "upstream_cx_connect_timeout": {
          "type": "cumulative",
          "description": "Total connection connect timeouts",
          "group": null,
          "default": false
        },
        "upstream_cx_destroy": {
          "type": "cumulative",
          "description": "Total destroyed connections",
          "group": null,
          "default": false
        },
        "upstream_cx_destroy_local": {
          "type": "cumulative",
          "description": "Total connections destroyed locally",
          "group": null,
          "default": false
        },
        "upstream_cx_destroy_local_with_active_rq": {
          "type": "cumulative",
          "description": "Total connections destroyed locally with 1+ active request",
          "group": null,
          "default": false
        },
        "upstream_cx_destroy_remote": {
          "type": "cumulative",
          "description": "Total connections destroyed remotely",
          "group": null,
          "default": false
        },
        "upstream_cx_destroy_remote_with_active_rq": {
          "type": "cumulative",
          "description": "Total connections destroyed remotely with 1+ active request",
          "group": null,
          "default": false
        },
        "upstream_cx_destroy_with_active_rq": {
          "type": "cumulative",
          "description": "Total connections destroyed with 1+ active request",
          "group": null,
          "default": false
        },
        "upstream_cx_http1_total": {
          "type": "cumulative",
          "description": "Total HTTP/1.1 connections",
          "group": null,
          "default": false
        },
        "upstream_cx_http2_total": {
          "type": "cumulative",
          "description": "Total HTTP/2 connections",
          "group": null,
          "default": false
        },
        "upstream_cx_idle_timeout": {
          "type": "cumulative",
          "description": "Total connection idle timeouts",
          "group": null,
          "default": false
        },
        "upstream_cx_length_ms": {
          "type": "gauge",
          "description": "Connection length milliseconds",
          "group": null,
          "default": false
        },
        "upstream_cx_max_requests": {
          "type": "cumulative",
          "description": "Total connections closed due to maximum requests",
          "group": null,
          "default": false
        },
        "upstream_cx_none_healthy": {
          "type": "cumulative",
          "description": "Total times connection not established due to no healthy hosts",
          "group": null,
          "default": false
        },
        "upstream_cx_overflow": {
          "type": "cumulative",
          "description": "Total times that the cluster’s connection circuit breaker overflowed",
          "group": null,
          "default": false
        },
        "upstream_cx_pool_overflow": {
          "type": "cumulative",
          "description": "Total times that the cluster’s connection pool circuit breaker overflowed",
          "group": null,
          "default": false
        },
        "upstream_cx_protocol_error": {
          "type": "cumulative",
          "description": "Total connection protocol errors",
          "group": null,
          "default": false
        },
        "upstream_cx_rx_bytes_buffered": {
          "type": "gauge",
          "description": "Received connection bytes currently buffered",
          "group": null,
          "default": false
        },
        "upstream_cx_rx_bytes_total": {
          "type": "cumulative",
          "description": "Total received connection bytes",
          "group": null,
          "default": true
        },
        "upstream_cx_total": {
          "type": "cumulative",
          "description": "Total connections",
          "group": null,
          "default": false
        },
        "upstream_cx_tx_bytes_buffered": {
          "type": "gauge",
          "description": "Send connection bytes currently buffered",
          "group": null,
          "default": false
        },
        "upstream_cx_tx_bytes_total": {
          "type": "cumulative",
          "description": "Total sent connection bytes",
          "group": null,
          "default": false
        },
        "upstream_rq_2xx": {
          "type": "cumulative",
          "description": "Total number of HTTP response codes in the 200-299 range",
          "group": null,
          "default": false
        },
        "upstream_rq_3xx": {
          "type": "cumulative",
          "description": "Total number of HTTP response codes in the 300-399 range",
          "group": null,
          "default": false
        },
        "upstream_rq_4xx": {
          "type": "cumulative",
          "description": "Total number of HTTP response codes in the 400-499 range",
          "group": null,
          "default": true
        },
        "upstream_rq_5xx": {
          "type": "cumulative",
          "description": "Total number of HTTP response codes in the 500-599 range",
          "group": null,
          "default": true
        },
        "upstream_rq_\u003c___\u003e": {
          "type": "cumulative",
          "description": "Specific HTTP response codes (e.g., 201, 302, etc.)",
          "group": null,
          "default": false
        },
        "upstream_rq_active": {
          "type": "gauge",
          "description": "Total active requests",
          "group": null,
          "default": false
        },
        "upstream_rq_cancelled": {
          "type": "cumulative",
          "description": "Total requests cancelled before obtaining a connection pool connection",
          "group": null,
          "default": false
        },
        "upstream_rq_completed": {
          "type": "cumulative",
          "description": "Total upstream requests completed",
          "group": null,
          "default": true
        },
        "upstream_rq_maintenance_mode": {
          "type": "cumulative",
          "description": "Total requests that resulted in an immediate 503 due to maintenance mode",
          "group": null,
          "default": false
        },
        "upstream_rq_pending_active": {
          "type": "gauge",
          "description": "Total active requests pending a connection pool connection",
          "group": null,
          "default": false
        },
        "upstream_rq_pending_failure_eject": {
          "type": "cumulative",
          "description": "Total requests that were failed due to a connection pool connection failure",
          "group": null,
          "default": false
        },
        "upstream_rq_pending_overflow": {
          "type": "cumulative",
          "description": "Total requests that overflowed connection pool circuit breaking and were failed",
          "group": null,
          "default": false
        },
        "upstream_rq_pending_total": {
          "type": "cumulative",
          "description": "Total requests pending a connection pool connection",
          "group": null,
          "default": false
        },
        "upstream_rq_per_try_timeout": {
          "type": "cumulative",
          "description": "Total requests that hit the per try timeout",
          "group": null,
          "default": false
        },
        "upstream_rq_retry": {
          "type": "cumulative",
          "description": "Total request retries",
          "group": null,
          "default": true
        },
        "upstream_rq_retry_overflow": {
          "type": "cumulative",
          "description": "Total requests not retried due to circuit breaking",
          "group": null,
          "default": false
        },
        "upstream_rq_retry_success": {
          "type": "cumulative",
          "description": "Total request retry successes",
          "group": null,
          "default": false
        },
        "upstream_rq_rx_reset": {
          "type": "cumulative",
          "description": "Total requests that were reset remotely",
          "group": null,
          "default": false
        },
        "upstream_rq_time": {
          "type": "gauge",
          "description": "Request time milliseconds",
          "group": null,
          "default": true
        },
        "upstream_rq_timeout": {
          "type": "cumulative",
          "description": "Total requests that timed out waiting for a response",
          "group": null,
          "default": false
        },
        "upstream_rq_total": {
          "type": "cumulative",
          "description": "Total requests",
          "group": null,
          "default": false
        },
        "upstream_rq_tx_reset": {
          "type": "cumulative",
          "description": "Total requests that were reset locally",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/appmesh",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host/address on which to bind the UDP listener that accepts statsd datagrams",
            "default": "localhost",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "listenPort",
            "doc": "The port on which to listen for statsd messages (**default:** `8125`)",
            "default": null,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "metricPrefix",
            "doc": "A prefix in metric names that needs to be removed before metric name conversion",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "aspdotnet",
      "sendAll": true,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics about requests, errors, sessions,\nworker processes for ASP.NET applications.\n\n## Windows Performance Counters\nThe underlying source for these metrics are Windows Performance Counters.\nMost of the performance counters that we query in this monitor are actually Gauges\nthat represent rates per second and percentages.\n\nThis monitor reports the instantaneous values for these Windows Performance Counters.\nThis means that in between a collection interval, spikes could occur on the\nPerformance Counters.  The best way to mitigate this limitation is to increase\nthe reporting interval on this monitor to collect more frequently.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: aspdotnet\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "asp_net.application_restarts",
            "asp_net.applications_running",
            "asp_net.requests_current",
            "asp_net.requests_queue",
            "asp_net.requests_rejected",
            "asp_net.worker_process_restarts",
            "asp_net.worker_processes_running",
            "asp_net_applications.errors_during_execution",
            "asp_net_applications.errors_total_sec",
            "asp_net_applications.errors_unhandled_during_execution_sec",
            "asp_net_applications.pipeline_instance_count",
            "asp_net_applications.requests_failed",
            "asp_net_applications.requests_sec",
            "asp_net_applications.session_sql_server_connections_total",
            "asp_net_applications.sessions_active"
          ]
        }
      },
      "metrics": {
        "asp_net.application_restarts": {
          "type": "gauge",
          "description": "Count of ASP.NET application restarts.",
          "group": null,
          "default": false
        },
        "asp_net.applications_running": {
          "type": "gauge",
          "description": "Number of running ASP.NET applications.",
          "group": null,
          "default": false
        },
        "asp_net.requests_current": {
          "type": "gauge",
          "description": "Current number of ASP.NET requests.",
          "group": null,
          "default": false
        },
        "asp_net.requests_queue": {
          "type": "gauge",
          "description": "Number of queued ASP.NET requests.",
          "group": null,
          "default": false
        },
        "asp_net.requests_rejected": {
          "type": "gauge",
          "description": "Count of rejected ASP.NET requests.",
          "group": null,
          "default": false
        },
        "asp_net.worker_process_restarts": {
          "type": "gauge",
          "description": "Count of ASP.NET worker process restarts.",
          "group": null,
          "default": false
        },
        "asp_net.worker_processes_running": {
          "type": "gauge",
          "description": "Number of running ASP.NET worker processes.",
          "group": null,
          "default": false
        },
        "asp_net_applications.errors_during_execution": {
          "type": "gauge",
          "description": "Count of errors encountered by ASP.NET application durring execution.",
          "group": null,
          "default": false
        },
        "asp_net_applications.errors_total_sec": {
          "type": "gauge",
          "description": "Error rate per second for the given ASP.NET application.",
          "group": null,
          "default": false
        },
        "asp_net_applications.errors_unhandled_during_execution_sec": {
          "type": "gauge",
          "description": "Unhandled error rate per second countered while an ASP.NET application is running.",
          "group": null,
          "default": false
        },
        "asp_net_applications.pipeline_instance_count": {
          "type": "gauge",
          "description": "Number of instances in the ASP.NET application pipeline.",
          "group": null,
          "default": false
        },
        "asp_net_applications.requests_failed": {
          "type": "gauge",
          "description": "Count of failed requests in the ASP.NET application",
          "group": null,
          "default": false
        },
        "asp_net_applications.requests_sec": {
          "type": "gauge",
          "description": "Rate of requests in the ASP.NET application per second.",
          "group": null,
          "default": false
        },
        "asp_net_applications.session_sql_server_connections_total": {
          "type": "gauge",
          "description": "Number of connections to microsoft sql server by an ASP.NET application.",
          "group": null,
          "default": false
        },
        "asp_net_applications.sessions_active": {
          "type": "gauge",
          "description": "Number of active sessions in the ASP.NET application.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/aspdotnet",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) Number of seconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This is used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "cadvisor",
      "sendAll": false,
      "dimensions": {
        "container_id": {
          "description": "The ID of the running container"
        },
        "container_image": {
          "description": "The container image name"
        },
        "container_name": {
          "description": "The container's name as it appears in the pod spec, the same as container_spec_name but retained for backwards compatibility."
        },
        "container_spec_name": {
          "description": "The container's name as it appears in the pod spec"
        },
        "kubernetes_namespace": {
          "description": "The K8s namespace the container is part of"
        },
        "kubernetes_pod_name": {
          "description": "The pod instance under which this container runs"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod instance under which this container runs"
        }
      },
      "doc": "This monitor pulls metrics directly from cadvisor, which\nconventionally runs on port 4194, but can be configured to anything.  If you\nare running on Kubernetes, consider the [kubelet-stats](./kubelet-stats.md)\nmonitor because many K8s nodes do not expose cAdvisor on a network port,\neven though they are running it within Kubelet.\n\nIf you are running containers with Docker, there is a fair amount of\nduplication with the `docker-container-stats` monitor in terms of the\nmetrics sent (under distinct metric names) so you may want to consider not\nenabling the Docker monitor in a K8s environment, or else use filtering to\nwhitelist only certain metrics.  Note that this will cause the built-in\nDocker dashboards to be blank, but container metrics will be available on\nthe Kubernetes dashboards instead.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "container_cpu_cfs_periods",
            "container_cpu_cfs_throttled_periods",
            "container_cpu_cfs_throttled_time",
            "container_cpu_percent",
            "container_cpu_system_seconds_total",
            "container_cpu_usage_seconds_total",
            "container_cpu_user_seconds_total",
            "container_cpu_utilization",
            "container_cpu_utilization_per_core",
            "container_fs_io_current",
            "container_fs_io_time_seconds_total",
            "container_fs_io_time_weighted_seconds_total",
            "container_fs_limit_bytes",
            "container_fs_read_seconds_total",
            "container_fs_reads_merged_total",
            "container_fs_reads_total",
            "container_fs_sector_reads_total",
            "container_fs_sector_writes_total",
            "container_fs_usage_bytes",
            "container_fs_write_seconds_total",
            "container_fs_writes_merged_total",
            "container_fs_writes_total",
            "container_last_seen",
            "container_memory_failcnt",
            "container_memory_failures_total",
            "container_memory_rss",
            "container_memory_usage_bytes",
            "container_memory_working_set_bytes",
            "container_spec_cpu_period",
            "container_spec_cpu_quota",
            "container_spec_cpu_shares",
            "container_spec_memory_limit_bytes",
            "container_spec_memory_swap_limit_bytes",
            "container_start_time_seconds",
            "container_tasks_state",
            "machine_cpu_cores",
            "machine_cpu_frequency_khz",
            "machine_memory_bytes",
            "pod_network_receive_bytes_total",
            "pod_network_receive_errors_total",
            "pod_network_receive_packets_dropped_total",
            "pod_network_receive_packets_total",
            "pod_network_transmit_bytes_total",
            "pod_network_transmit_errors_total",
            "pod_network_transmit_packets_dropped_total",
            "pod_network_transmit_packets_total"
          ]
        }
      },
      "metrics": {
        "container_cpu_cfs_periods": {
          "type": "cumulative",
          "description": "Total number of elapsed CFS enforcement intervals",
          "group": null,
          "default": false
        },
        "container_cpu_cfs_throttled_periods": {
          "type": "cumulative",
          "description": "Total number of times tasks in the cgroup have been throttled",
          "group": null,
          "default": false
        },
        "container_cpu_cfs_throttled_time": {
          "type": "cumulative",
          "description": "Total time duration, in nanoseconds, for which tasks in the cgroup have been throttled",
          "group": null,
          "default": false
        },
        "container_cpu_percent": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization as a percentage of the total host CPU available.  This metric is equivalent to `container_cpu_utilization` / \u003c# of CPUs/cores on host\u003e.",
          "group": null,
          "default": true
        },
        "container_cpu_system_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative system cpu time consumed in nanoseconds",
          "group": null,
          "default": false
        },
        "container_cpu_usage_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative cpu time consumed per cpu in nanoseconds",
          "group": null,
          "default": false
        },
        "container_cpu_user_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative user cpu time consumed in nanoseconds",
          "group": null,
          "default": false
        },
        "container_cpu_utilization": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization in percentages.  This is equivalent to \"centicores\", or hundreths of CPU cores consumed.  This metric is **NOT** normalized by the total # of cores on the system.",
          "group": null,
          "default": true
        },
        "container_cpu_utilization_per_core": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization in percentages per core",
          "group": null,
          "default": false
        },
        "container_fs_io_current": {
          "type": "gauge",
          "description": "Number of I/Os currently in progress",
          "group": null,
          "default": false
        },
        "container_fs_io_time_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent doing I/Os",
          "group": null,
          "default": false
        },
        "container_fs_io_time_weighted_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative weighted I/O time in seconds",
          "group": null,
          "default": false
        },
        "container_fs_limit_bytes": {
          "type": "gauge",
          "description": "Number of bytes that the container may occupy on this filesystem",
          "group": null,
          "default": false
        },
        "container_fs_read_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent reading",
          "group": null,
          "default": true
        },
        "container_fs_reads_merged_total": {
          "type": "cumulative",
          "description": "Cumulative count of reads merged",
          "group": null,
          "default": false
        },
        "container_fs_reads_total": {
          "type": "cumulative",
          "description": "Cumulative count of reads completed",
          "group": null,
          "default": true
        },
        "container_fs_sector_reads_total": {
          "type": "cumulative",
          "description": "Cumulative count of sector reads completed",
          "group": null,
          "default": false
        },
        "container_fs_sector_writes_total": {
          "type": "cumulative",
          "description": "Cumulative count of sector writes completed",
          "group": null,
          "default": false
        },
        "container_fs_usage_bytes": {
          "type": "gauge",
          "description": "Number of bytes that are consumed by the container on this filesystem",
          "group": null,
          "default": true
        },
        "container_fs_write_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent writing",
          "group": null,
          "default": true
        },
        "container_fs_writes_merged_total": {
          "type": "cumulative",
          "description": "Cumulative count of writes merged",
          "group": null,
          "default": false
        },
        "container_fs_writes_total": {
          "type": "cumulative",
          "description": "Cumulative count of writes completed",
          "group": null,
          "default": true
        },
        "container_last_seen": {
          "type": "gauge",
          "description": "Last time a container was seen by the exporter",
          "group": null,
          "default": false
        },
        "container_memory_failcnt": {
          "type": "cumulative",
          "description": "Number of memory usage hits limits",
          "group": null,
          "default": false
        },
        "container_memory_failures_total": {
          "type": "cumulative",
          "description": "Cumulative count of memory allocation failures",
          "group": null,
          "default": true
        },
        "container_memory_rss": {
          "type": "gauge",
          "description": "Current RSS memory usage in bytes",
          "group": null,
          "default": false
        },
        "container_memory_usage_bytes": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": null,
          "default": true
        },
        "container_memory_working_set_bytes": {
          "type": "gauge",
          "description": "Current working set in bytes",
          "group": null,
          "default": false
        },
        "container_spec_cpu_period": {
          "type": "gauge",
          "description": "The number of microseconds that the [CFS scheduler](https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) uses as a window when limiting container processes",
          "group": null,
          "default": true
        },
        "container_spec_cpu_quota": {
          "type": "gauge",
          "description": "In CPU quota for the CFS process scheduler. In K8s this is equal to the containers's CPU limit as a fraction of 1 core and multiplied by the `container_spec_cpu_period`.  So if the CPU limit is `500m` (500 millicores) for a container and the `container_spec_cpu_period` is set to 100,000, this value will be 50,000.",
          "group": null,
          "default": true
        },
        "container_spec_cpu_shares": {
          "type": "gauge",
          "description": "CPU share of the container",
          "group": null,
          "default": false
        },
        "container_spec_memory_limit_bytes": {
          "type": "gauge",
          "description": "Memory limit for the container.",
          "group": null,
          "default": true
        },
        "container_spec_memory_swap_limit_bytes": {
          "type": "gauge",
          "description": "Memory swap limit for the container.",
          "group": null,
          "default": false
        },
        "container_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the container since unix epoch in seconds.",
          "group": null,
          "default": false
        },
        "container_tasks_state": {
          "type": "gauge",
          "description": "Number of tasks in given state",
          "group": null,
          "default": false
        },
        "machine_cpu_cores": {
          "type": "gauge",
          "description": "Number of CPU cores on the node.",
          "group": null,
          "default": true
        },
        "machine_cpu_frequency_khz": {
          "type": "gauge",
          "description": "Node's CPU frequency.",
          "group": null,
          "default": false
        },
        "machine_memory_bytes": {
          "type": "gauge",
          "description": "Amount of memory installed on the node.",
          "group": null,
          "default": true
        },
        "pod_network_receive_bytes_total": {
          "type": "cumulative",
          "description": "Cumulative count of bytes received. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": true
        },
        "pod_network_receive_errors_total": {
          "type": "cumulative",
          "description": "Cumulative count of errors encountered while receiving. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": true
        },
        "pod_network_receive_packets_dropped_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets dropped while receiving. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": false
        },
        "pod_network_receive_packets_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets received. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": false
        },
        "pod_network_transmit_bytes_total": {
          "type": "cumulative",
          "description": "Cumulative count of bytes transmitted. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": true
        },
        "pod_network_transmit_errors_total": {
          "type": "cumulative",
          "description": "Cumulative count of errors encountered while transmitting. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": true
        },
        "pod_network_transmit_packets_dropped_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets dropped while transmitting. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": false
        },
        "pod_network_transmit_packets_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets transmitted. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "CHTTPConfig",
        "doc": "CHTTPConfig is the monitor-specific config for cAdvisor",
        "package": "pkg/monitors/cadvisor",
        "fields": [
          {
            "yamlName": "cadvisorURL",
            "doc": "Where to find cAdvisor",
            "default": "http://localhost:4194",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/activemq",
      "sendAll": false,
      "dimensions": null,
      "doc": "SignalFx's integration with ActiveMQ wraps the [Collectd GenericJMX\nmonitor](https://docs.signalfx.com/en/latest/integrations/agent/monitors/collectd-genericjmx.html)\nto monitor ActiveMQ.\n\nUse this monitor to gather the following types of information from ActiveMQ:\n\n* Broker (Totals per broker)\n* Queue (Queue status)\n* Topic (Topic status)\n\nTo monitor the age of messages inside ActiveMQ queues, see [ActiveMQ\nmessage age listener](https://docs.signalfx.com/en/latest/integrations/integrations-reference/integrations.activemq.message.age.listener.html)[](sfx_link:amq-message-age).\n\n\u003c!--- SETUP ---\u003e\n## Example config\n\n```yaml\nmonitors:\n - type: collectd/activemq\n   host: localhost\n   # This is the remote JMX port for ActiveMQ\n   port: 1099\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.amq.TotalConnectionsCount",
            "gauge.amq.TotalConsumerCount",
            "gauge.amq.TotalDequeueCount",
            "gauge.amq.TotalEnqueueCount",
            "gauge.amq.TotalMessageCount",
            "gauge.amq.TotalProducerCount",
            "gauge.amq.queue.AverageBlockedTime",
            "gauge.amq.queue.AverageEnqueueTime",
            "gauge.amq.queue.AverageMessageSize",
            "gauge.amq.queue.BlockedSends",
            "gauge.amq.queue.ConsumerCount",
            "gauge.amq.queue.DequeueCount",
            "gauge.amq.queue.EnqueueCount",
            "gauge.amq.queue.ExpiredCount",
            "gauge.amq.queue.ForwardCount",
            "gauge.amq.queue.InFlightCount",
            "gauge.amq.queue.ProducerCount",
            "gauge.amq.queue.QueueSize",
            "gauge.amq.queue.TotalBlockedTime",
            "gauge.amq.topic.AverageBlockedTime",
            "gauge.amq.topic.AverageEnqueueTime",
            "gauge.amq.topic.AverageMessageSize",
            "gauge.amq.topic.BlockedSends",
            "gauge.amq.topic.ConsumerCount",
            "gauge.amq.topic.DequeueCount",
            "gauge.amq.topic.EnqueueCount",
            "gauge.amq.topic.ExpiredCount",
            "gauge.amq.topic.ForwardCount",
            "gauge.amq.topic.InFlightCount",
            "gauge.amq.topic.ProducerCount",
            "gauge.amq.topic.QueueSize",
            "gauge.amq.topic.TotalBlockedTime"
          ]
        },
        "jvm": {
          "description": "",
          "metrics": [
            "gauge.jvm.threads.count",
            "gauge.loaded_classes",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.init",
            "jmx_memory.max",
            "jmx_memory.used",
            "total_time_in_ms.collection_time"
          ]
        }
      },
      "metrics": {
        "counter.amq.TotalConnectionsCount": {
          "type": "counter",
          "description": "Total connections count per broker",
          "group": null,
          "default": true
        },
        "gauge.amq.TotalConsumerCount": {
          "type": "gauge",
          "description": "Total number of consumers subscribed to destinations on the broker",
          "group": null,
          "default": true
        },
        "gauge.amq.TotalDequeueCount": {
          "type": "gauge",
          "description": "Total number of messages that have been acknowledged from the broker.",
          "group": null,
          "default": false
        },
        "gauge.amq.TotalEnqueueCount": {
          "type": "gauge",
          "description": "Total number of messages that have been sent to the broker.",
          "group": null,
          "default": true
        },
        "gauge.amq.TotalMessageCount": {
          "type": "gauge",
          "description": "Total number of unacknowledged messages on the broker",
          "group": null,
          "default": true
        },
        "gauge.amq.TotalProducerCount": {
          "type": "gauge",
          "description": "Total number of message producers active on destinations on the broker",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.AverageBlockedTime": {
          "type": "gauge",
          "description": "Average time (ms) that messages have spent blocked by Flow Control.",
          "group": null,
          "default": false
        },
        "gauge.amq.queue.AverageEnqueueTime": {
          "type": "gauge",
          "description": "Average time (ms) that messages have been held at this destination",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.AverageMessageSize": {
          "type": "gauge",
          "description": "Average size of messages in this queue, in bytes.",
          "group": null,
          "default": false
        },
        "gauge.amq.queue.BlockedSends": {
          "type": "gauge",
          "description": "Number of messages blocked by Flow Control.",
          "group": null,
          "default": false
        },
        "gauge.amq.queue.ConsumerCount": {
          "type": "gauge",
          "description": "Number of consumers subscribed to this queue.",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.DequeueCount": {
          "type": "gauge",
          "description": "Number of messages that have been acknowledged and removed from the queue.",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.EnqueueCount": {
          "type": "gauge",
          "description": "Number of messages that have been sent to the queue.",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.ExpiredCount": {
          "type": "gauge",
          "description": "Number of messages that have expired from the queue.",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.ForwardCount": {
          "type": "gauge",
          "description": "Number of messages that have been forwarded from this queue to a networked broker.",
          "group": null,
          "default": false
        },
        "gauge.amq.queue.InFlightCount": {
          "type": "gauge",
          "description": "The number of messages that have been dispatched to consumers, but not acknowledged.",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.ProducerCount": {
          "type": "gauge",
          "description": "Number of producers publishing to this queue",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.QueueSize": {
          "type": "gauge",
          "description": "The number of messages in the queue that have yet to be consumed.",
          "group": null,
          "default": true
        },
        "gauge.amq.queue.TotalBlockedTime": {
          "type": "gauge",
          "description": "The total time (ms) that messages have spent blocked by Flow Control.",
          "group": null,
          "default": false
        },
        "gauge.amq.topic.AverageBlockedTime": {
          "type": "gauge",
          "description": "Average time (ms) that messages have been blocked by Flow Control.",
          "group": null,
          "default": false
        },
        "gauge.amq.topic.AverageEnqueueTime": {
          "type": "gauge",
          "description": "Average time (ms) that messages have been held at this destination.",
          "group": null,
          "default": true
        },
        "gauge.amq.topic.AverageMessageSize": {
          "type": "gauge",
          "description": "Average size of messages on this topic, in bytes.",
          "group": null,
          "default": false
        },
        "gauge.amq.topic.BlockedSends": {
          "type": "gauge",
          "description": "Number of messages blocked by Flow Control",
          "group": null,
          "default": false
        },
        "gauge.amq.topic.ConsumerCount": {
          "type": "gauge",
          "description": "The number of consumers subscribed to this topic",
          "group": null,
          "default": true
        },
        "gauge.amq.topic.DequeueCount": {
          "type": "gauge",
          "description": "Number of messages that have been acknowledged and removed from the topic.",
          "group": null,
          "default": false
        },
        "gauge.amq.topic.EnqueueCount": {
          "type": "gauge",
          "description": "The number of messages that have been sent to the topic.",
          "group": null,
          "default": true
        },
        "gauge.amq.topic.ExpiredCount": {
          "type": "gauge",
          "description": "The number of messages that have expired from this topic.",
          "group": null,
          "default": true
        },
        "gauge.amq.topic.ForwardCount": {
          "type": "gauge",
          "description": "The number of messages that have been forwarded from this topic to a networked broker.",
          "group": null,
          "default": false
        },
        "gauge.amq.topic.InFlightCount": {
          "type": "gauge",
          "description": "The number of messages that have been dispatched to consumers, but have not yet been acknowledged.",
          "group": null,
          "default": true
        },
        "gauge.amq.topic.ProducerCount": {
          "type": "gauge",
          "description": "Number of producers publishing to this topic.",
          "group": null,
          "default": true
        },
        "gauge.amq.topic.QueueSize": {
          "type": "gauge",
          "description": "Number of messages in the topic that have yet to be consumed.",
          "group": null,
          "default": true
        },
        "gauge.amq.topic.TotalBlockedTime": {
          "type": "gauge",
          "description": "The total time (ms) that messages have spent blocked by Flow Control",
          "group": null,
          "default": false
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "default": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "default": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "pkg/monitors/collectd/activemq",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "pkg/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "pkg/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "attributes",
                        "doc": "The plural form of the `attribute` config above.  Used to derive multiple metrics from a single MBean.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/apache",
      "sendAll": false,
      "dimensions": {
        "plugin_instance": {
          "description": "Set to whatever you set in the `name` config option."
        }
      },
      "doc": "Monitors Apache webservice instances using the information provided by\n`mod_status`.\n\n### Worker states\nApache worker threads can be in one of the following states:\n\n| State        | Remark                                  |\n|--------------|-----------------------------------------|\n| Open         | Open (unused) slot - no process         |\n| Waiting      | Idle and waiting for request            |\n| Sending      | Serving response                        |\n| KeepAlive    | Kept alive for possible next request    |\n| Idle_cleanup | Idle and marked for cleanup             |\n| Closing      | Closing connection                      |\n| Logging      | Writing to log file                     |\n| Reading      | Reading request                         |\n| Finishing    | Finishing as part of graceful shutdown  |\n| Starting     | Starting up to serve                    |\n\n\u003c!--- SETUP ---\u003e\n## Apache Setup\nTo configure the Apache webserver itself to expose status metrics:\n\n1. Enable the \u003ca target=\"_blank\" href=\"http://httpd.apache.org/docs/2.4/mod/mod_status.html\"\u003emod_status\u003c/a\u003e module in your Apache server.\n2. Add the following configuration to your Apache server:\n\n   ```\n    ExtendedStatus on\n    \u003cLocation /mod_status\u003e\n    SetHandler server-status\n    \u003c/Location\u003e\n   ```\n3. Restart Apache.\n\n_Note_: Make sure that the URL you provide for your `mod_status` module\nends in `?auto`. This returns the status page as `text/plain`, which this\nplugin requires.\n\n\u003c!--- SETUP ---\u003e\n## Config Examples\n\n```\nmonitors:\n - type: collectd/apache\n   host: localhost\n   port: 80\n```\n\nIf `mod_status` is exposed on an endpoint other than `/mod_status`, you can\nuse the `url` config option to specify the path:\n\n```\nmonitors:\n - type: collectd/apache\n   host: localhost\n   port: 80\n   url: \"http://{{.Host}}:{{.Port}}/server-status?auto\"\n```\n\nFor a full list of options, see [Configuration](#configuration).\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "apache_bytes",
            "apache_connections",
            "apache_idle_workers",
            "apache_requests",
            "apache_scoreboard.closing",
            "apache_scoreboard.dnslookup",
            "apache_scoreboard.finishing",
            "apache_scoreboard.idle_cleanup",
            "apache_scoreboard.keepalive",
            "apache_scoreboard.logging",
            "apache_scoreboard.open",
            "apache_scoreboard.reading",
            "apache_scoreboard.sending",
            "apache_scoreboard.starting",
            "apache_scoreboard.waiting"
          ]
        }
      },
      "metrics": {
        "apache_bytes": {
          "type": "cumulative",
          "description": "Amount of data served by Apache, in bytes.",
          "group": null,
          "default": true
        },
        "apache_connections": {
          "type": "gauge",
          "description": "The number of connections that are being served by Apache.  This is also equal to the number of busy worker threads, where 'busy' means any worker thread which has been started successfully and is not slated for idle cleanup.\n",
          "group": null,
          "default": true
        },
        "apache_idle_workers": {
          "type": "gauge",
          "description": "The number of Apache workers that are idling. If this number is consistently low, then your server may be too busy and you may have to increase the number of threads.  If it is consistently high, then the system may be under-utilized.\n",
          "group": null,
          "default": true
        },
        "apache_requests": {
          "type": "cumulative",
          "description": "The number of requests that have been served by Apache. This metric is useful to know total requests and the rate at which Apache is able to serve them.\n",
          "group": null,
          "default": true
        },
        "apache_scoreboard.closing": {
          "type": "gauge",
          "description": "This metric shows how many worker threads are in the process of closing TCP connections after serving a response. If this number is consistently high, then there might be a network issue or errant client preventing TCP tear-down.\n",
          "group": null,
          "default": false
        },
        "apache_scoreboard.dnslookup": {
          "type": "gauge",
          "description": "This metric counts the number of worker threads that are performing a DNS lookup. If this number is too high, check if there is a DNS resolution problem at your server. This can affect Apache server performance.\n",
          "group": null,
          "default": false
        },
        "apache_scoreboard.finishing": {
          "type": "gauge",
          "description": "The number of worker threads that are finishing as part of graceful server shutdown.",
          "group": null,
          "default": false
        },
        "apache_scoreboard.idle_cleanup": {
          "type": "gauge",
          "description": "The number of worker threads that are idle and ready for clean-up.",
          "group": null,
          "default": false
        },
        "apache_scoreboard.keepalive": {
          "type": "gauge",
          "description": "The number of worker threads that are maintaining keep-alive connections: keeping the connection \"alive\" after serving a response, in the expectation that another HTTP request will come on the same connection. At the end of the keep-alive interval, the connection is closed.\n",
          "group": null,
          "default": false
        },
        "apache_scoreboard.logging": {
          "type": "gauge",
          "description": "This metric shows how many worker threads are busy writing to the log file.  If this number is consistently high, your logging level may be too high or one or more modules may be too verbose.\n",
          "group": null,
          "default": false
        },
        "apache_scoreboard.open": {
          "type": "gauge",
          "description": "This metric shows how many worker slots are open.  The slots do not have a worker thread yet, but they can be spun up based on incoming requests.\n",
          "group": null,
          "default": true
        },
        "apache_scoreboard.reading": {
          "type": "gauge",
          "description": "This metric shows how many workers are in the process of receiving requests (headers or body).  If this number is consistently high, clients may be sending large headers or uploading large files.\n",
          "group": null,
          "default": false
        },
        "apache_scoreboard.sending": {
          "type": "gauge",
          "description": "This metric shows how many workers are sending responses.  It is normal for this to be a large number when measuring sites that serve large downloads.\n",
          "group": null,
          "default": false
        },
        "apache_scoreboard.starting": {
          "type": "gauge",
          "description": "This metric shows how many workers are being started up.  If this number is consistently high, then the system may be overloaded.\n",
          "group": null,
          "default": false
        },
        "apache_scoreboard.waiting": {
          "type": "gauge",
          "description": "This metric shows how many worker threads are ready and waiting for requests to come in.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/apache",
        "fields": [
          {
            "yamlName": "host",
            "doc": "The hostname of the Apache server",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "The port number of the Apache server",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "This will be sent as the `plugin_instance` dimension and can be any name you like.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "url",
            "doc": "The URL, either a final URL or a Go template that will be populated with the host and port values.",
            "default": "http://{{.Host}}:{{.Port}}/mod_status?auto",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/cassandra",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors Cassandra using the Collectd GenericJMX plugin.  This is\nessentially a wrapper around the\n[collectd-genericjmx](./collectd-genericjmx.md)[](sfx_link:java) monitor that comes with a\nset of predefined MBean definitions that a standard Cassandra deployment\nwill expose.\n\nUse this integration to monitor the following types of information from Cassandra nodes:\n\n - read/write/range-slice requests\n - read/write/range-slice errors (timeouts and unavailable)\n - read/write/range-slice latency (median, 99th percentile, maximum)\n - compaction activity\n - hint activity\n\nSupports Cassandra 2.0.10+.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.cassandra.ClientRequest.RangeSlice.Latency.Count",
            "counter.cassandra.ClientRequest.RangeSlice.Timeouts.Count",
            "counter.cassandra.ClientRequest.RangeSlice.Unavailables.Count",
            "counter.cassandra.ClientRequest.Read.Latency.Count",
            "counter.cassandra.ClientRequest.Read.Timeouts.Count",
            "counter.cassandra.ClientRequest.Read.Unavailables.Count",
            "counter.cassandra.ClientRequest.Write.Latency.Count",
            "counter.cassandra.ClientRequest.Write.Timeouts.Count",
            "counter.cassandra.ClientRequest.Write.Unavailables.Count",
            "counter.cassandra.Compaction.TotalCompactionsCompleted.Count",
            "gauge.cassandra.ClientRequest.RangeSlice.Latency.50thPercentile",
            "gauge.cassandra.ClientRequest.RangeSlice.Latency.99thPercentile",
            "gauge.cassandra.ClientRequest.RangeSlice.Latency.Max",
            "gauge.cassandra.ClientRequest.Read.Latency.50thPercentile",
            "gauge.cassandra.ClientRequest.Read.Latency.99thPercentile",
            "gauge.cassandra.ClientRequest.Read.Latency.Max",
            "gauge.cassandra.ClientRequest.Write.Latency.50thPercentile",
            "gauge.cassandra.ClientRequest.Write.Latency.99thPercentile",
            "gauge.cassandra.ClientRequest.Write.Latency.Max",
            "gauge.cassandra.Compaction.PendingTasks.Value",
            "gauge.cassandra.Storage.Load.Count",
            "gauge.cassandra.Storage.TotalHints.Count",
            "gauge.cassandra.Storage.TotalHintsInProgress.Count"
          ]
        },
        "jvm": {
          "description": "",
          "metrics": [
            "gauge.jvm.threads.count",
            "gauge.loaded_classes",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.init",
            "jmx_memory.max",
            "jmx_memory.used",
            "total_time_in_ms.collection_time"
          ]
        }
      },
      "metrics": {
        "counter.cassandra.ClientRequest.RangeSlice.Latency.Count": {
          "type": "cumulative",
          "description": "Count of range slice operations since server start. This typically indicates a server overload condition.\n\nIf this value is increasing across the cluster then the cluster is too small for the application range slice load.\n\nIf this value is increasing for a single server in a cluster, then one of the following conditions may be true:\n\n- one or more clients are directing more load to this server than the others\n- the server is experiencing hardware or software issues and may require maintenance.\n",
          "group": null,
          "default": true
        },
        "counter.cassandra.ClientRequest.RangeSlice.Timeouts.Count": {
          "type": "cumulative",
          "description": "Count of range slice timeouts since server start. This typically indicates a server overload condition.\n\nIf this value is increasing across the cluster then the cluster is too small for the application range slice load.\n\nIf this value is increasing for a single server in a cluster, then one of the following conditions may be true:\n- one or more clients are directing more load to this server than the others\n- the server is experiencing hardware or software issues and may require maintenance.\n",
          "group": null,
          "default": true
        },
        "counter.cassandra.ClientRequest.RangeSlice.Unavailables.Count": {
          "type": "cumulative",
          "description": "Count of range slice unavailables since server start. A non-zero value\nmeans that insufficient replicas were available to fulfil a range slice\nrequest at the requested consistency level.\n\nThis typically means that one or more nodes are down. To fix this condition,\nany down nodes must be restarted, or removed from the cluster.\n",
          "group": null,
          "default": true
        },
        "counter.cassandra.ClientRequest.Read.Latency.Count": {
          "type": "cumulative",
          "description": "Count of read operations since server start",
          "group": null,
          "default": true
        },
        "counter.cassandra.ClientRequest.Read.Timeouts.Count": {
          "type": "cumulative",
          "description": "Count of read timeouts since server start. This typically indicates a server overload condition.\n\nIf this value is increasing across the cluster then the cluster is too small for the application read load.\n\nIf this value is increasing for a single server in a cluster, then one of the following conditions may be true:\n- one or more clients are directing more load to this server than the others\n- the server is experiencing hardware or software issues and may require maintenance.\n",
          "group": null,
          "default": true
        },
        "counter.cassandra.ClientRequest.Read.Unavailables.Count": {
          "type": "cumulative",
          "description": "Count of read unavailables since server start. A non-zero value means\nthat insufficient replicas were available to fulfil a read request at\nthe requested consistency level. This typically means that one or more\nnodes are down. To fix this condition, any down nodes must be\nrestarted, or removed from the cluster.\n",
          "group": null,
          "default": true
        },
        "counter.cassandra.ClientRequest.Write.Latency.Count": {
          "type": "cumulative",
          "description": "Count of write operations since server start.",
          "group": null,
          "default": true
        },
        "counter.cassandra.ClientRequest.Write.Timeouts.Count": {
          "type": "cumulative",
          "description": "Count of write timeouts since server start. This typically indicates a server overload condition.\n\nIf this value is increasing across the cluster then the cluster is too small for the application write load.\n\nIf this value is increasing for a single server in a cluster, then one of the following conditions may be true:\n- one or more clients are directing more load to this server than the others\n- the server is experiencing hardware or software issues and may require maintenance.\n",
          "group": null,
          "default": true
        },
        "counter.cassandra.ClientRequest.Write.Unavailables.Count": {
          "type": "cumulative",
          "description": "Count of write unavailables since server start. A non-zero value means\nthat insufficient replicas were available to fulfil a write request at\nthe requested consistency level.\n\nThis typically means that one or more nodes are down. To fix this\ncondition, any down nodes must be restarted, or removed from the\ncluster.\n",
          "group": null,
          "default": true
        },
        "counter.cassandra.Compaction.TotalCompactionsCompleted.Count": {
          "type": "cumulative",
          "description": "Number of compaction operations since node start. If this value does\nnot increase steadily over time then the node may be experiencing\nproblems completing compaction operations.\n",
          "group": null,
          "default": false
        },
        "gauge.cassandra.ClientRequest.RangeSlice.Latency.50thPercentile": {
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra range slice latency. This value\nshould be similar across all nodes in the cluster. If some nodes have higher\nvalues than the rest of the cluster then they may have more connected clients\nor may be experiencing heavier than usual compaction load.\n",
          "group": null,
          "default": false
        },
        "gauge.cassandra.ClientRequest.RangeSlice.Latency.99thPercentile": {
          "type": "gauge",
          "description": "99th percentile of Cassandra range slice latency. This value should be\nsimilar across all nodes in the cluster. If some nodes have higher values than\nthe rest of the cluster then they may have more connected clients or may be\nexperiencing heavier than usual compaction load.\n",
          "group": null,
          "default": true
        },
        "gauge.cassandra.ClientRequest.RangeSlice.Latency.Max": {
          "type": "gauge",
          "description": "Maximum Cassandra range slice latency",
          "group": null,
          "default": false
        },
        "gauge.cassandra.ClientRequest.Read.Latency.50thPercentile": {
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra read latency. This value should\nbe similar across all nodes in the cluster. If some nodes have higher\nvalues than the rest of the cluster then they may have more connected\nclients or may be experiencing heavier than usual compaction load.\n",
          "group": null,
          "default": true
        },
        "gauge.cassandra.ClientRequest.Read.Latency.99thPercentile": {
          "type": "gauge",
          "description": "99th percentile of Cassandra read latency. This value should be similar\nacross all nodes in the cluster. If some nodes have higher values than\nthe rest of the cluster then they may have more connected clients or\nmay be experiencing heavier than usual compaction load.\n",
          "group": null,
          "default": true
        },
        "gauge.cassandra.ClientRequest.Read.Latency.Max": {
          "type": "gauge",
          "description": "Maximum Cassandra read latency",
          "group": null,
          "default": true
        },
        "gauge.cassandra.ClientRequest.Write.Latency.50thPercentile": {
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra write latency. This value should\nbe similar across all nodes in the cluster. If some nodes have higher\nvalues than the rest of the cluster then they may have more connected\nclients or may be experiencing heavier than usual compaction load.\n",
          "group": null,
          "default": true
        },
        "gauge.cassandra.ClientRequest.Write.Latency.99thPercentile": {
          "type": "gauge",
          "description": "99th percentile of Cassandra write latency. This value should be\nsimilar across all nodes in the cluster. If some nodes have higher\nvalues than the rest of the cluster then they may have more connected\nclients or may be experiencing heavier than usual compaction load.\n",
          "group": null,
          "default": true
        },
        "gauge.cassandra.ClientRequest.Write.Latency.Max": {
          "type": "gauge",
          "description": "Maximum Cassandra write latency",
          "group": null,
          "default": true
        },
        "gauge.cassandra.Compaction.PendingTasks.Value": {
          "type": "gauge",
          "description": "Number of compaction operations waiting to run. If this value is\ncontinually increasing then the node may be experiencing problems\ncompleting compaction operations.\n",
          "group": null,
          "default": true
        },
        "gauge.cassandra.Storage.Load.Count": {
          "type": "gauge",
          "description": "Storage used for Cassandra data in bytes. Use this metric to see how much storage is being used for data by a Cassandra node.\n\nThe value of this metric is influenced by:\n- Total data stored into the database\n- compaction behavior\n",
          "group": null,
          "default": true
        },
        "gauge.cassandra.Storage.TotalHints.Count": {
          "type": "gauge",
          "description": "Total hints since node start. Indicates that write operations cannot be\ndelivered to a node, usually because a node is down. If this value is\nincreasing and all nodes are up then there may be some connectivity\nissue between nodes in the cluster.\n",
          "group": null,
          "default": false
        },
        "gauge.cassandra.Storage.TotalHintsInProgress.Count": {
          "type": "gauge",
          "description": "Total pending hints. Indicates that write operations cannot be\ndelivered to a node, usually because a node is down. If this value is\nincreasing and all nodes are up then there may be some connectivity\nissue between nodes in the cluster.\n",
          "group": null,
          "default": true
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "default": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "default": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "pkg/monitors/collectd/cassandra",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "pkg/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "pkg/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "attributes",
                        "doc": "The plural form of the `attribute` config above.  Used to derive multiple metrics from a single MBean.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/chrony",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collectd NTP data from a chronyd instance\n\nSee https://collectd.org/documentation/manpages/collectd.conf.5.shtml#plugin_chrony\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/chrony",
        "fields": [
          {
            "yamlName": "host",
            "doc": "The hostname of the chronyd instance",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "The UDP port number of the chronyd instance.  Defaults to 323 in collectd if unspecified.",
            "default": null,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "timeout",
            "doc": "How long to wait for a response from chronyd before considering it down. Defaults to 2 seconds in the collectd plugin if not specified",
            "default": null,
            "required": false,
            "type": "uint",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/consul",
      "sendAll": false,
      "dimensions": {
        "consul_mode": {
          "description": "Whether this consul instance is running as a server or client"
        },
        "consul_node": {
          "description": "The name of the consul node"
        },
        "datacenter": {
          "description": "The name of the consul datacenter"
        }
      },
      "doc": "Monitors the Consul data store by using the\n[Consul collectd Python\nplugin](https://github.com/signalfx/collectd-consul), which collects metrics\nfrom Consul instances by hitting these endpoints:\n- [/agent/self](https://www.consul.io/api/agent.html#read-configuration)\n- [/agent/metrics](https://www.consul.io/api/agent.html#view-metrics)\n- [/catalog/nodes](https://www.consul.io/api/catalog.html#list-nodes)\n- [/catalog/node/:node](https://www.consul.io/api/catalog.html#list-services-for-node)\n- [/status/leader](https://www.consul.io/api/status.html#get-raft-leader)\n- [/status/peers](https://www.consul.io/api/status.html#list-raft-peers)\n- [/coordinate/datacenters](https://www.consul.io/api/coordinate.html#read-wan-coordinates)\n- [/coordinate/nodes](https://www.consul.io/api/coordinate.html#read-lan-coordinates)\n- [/health/state/any](https://www.consul.io/api/health.html#list-checks-in-state)\n\nSupports Consul 0.7.0+.\n\n\u003c!--- SETUP ---\u003e\n## Agent Statsd listener\nIf running Consul version below 0.9.1, configure the Consul agents that are\nto be monitored to send telemetry to a SignalFx Agent instance by adding\nthe below configuration to Consul agents configuration file:\n\n```\n{\"telemetry\":\n  {\"statsd_address\": \"\u003cagent host\u003e:\u003cagent port, default 8125\u003e\"}\n}\n```\nThis monitor should then be be configured with the `telemetryServer: true`\noption set. This will start a UDP server listening on `0.0.0.0:8125` by\ndefault.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "consul.dns.stale_queries",
            "consul.memberlist.msg.suspect",
            "consul.serf.member.flap",
            "gauge.consul.catalog.nodes.total",
            "gauge.consul.catalog.nodes_by_service",
            "gauge.consul.catalog.services.total",
            "gauge.consul.catalog.services_by_node",
            "gauge.consul.consul.dns.domain_query.AGENT.avg",
            "gauge.consul.consul.dns.domain_query.AGENT.max",
            "gauge.consul.consul.dns.domain_query.AGENT.min",
            "gauge.consul.consul.dns.ptr_query.AGENT.avg",
            "gauge.consul.consul.dns.ptr_query.AGENT.max",
            "gauge.consul.consul.dns.ptr_query.AGENT.min",
            "gauge.consul.consul.leader.reconcile.avg",
            "gauge.consul.consul.rpc.query",
            "gauge.consul.health.nodes.critical",
            "gauge.consul.health.nodes.passing",
            "gauge.consul.health.nodes.warning",
            "gauge.consul.health.services.critical",
            "gauge.consul.health.services.passing",
            "gauge.consul.health.services.warning",
            "gauge.consul.is_leader",
            "gauge.consul.network.dc.latency.avg",
            "gauge.consul.network.dc.latency.max",
            "gauge.consul.network.dc.latency.min",
            "gauge.consul.network.node.latency.avg",
            "gauge.consul.network.node.latency.max",
            "gauge.consul.network.node.latency.min",
            "gauge.consul.peers",
            "gauge.consul.raft.apply",
            "gauge.consul.raft.commitTime.avg",
            "gauge.consul.raft.commitTime.max",
            "gauge.consul.raft.commitTime.min",
            "gauge.consul.raft.leader.dispatchLog.avg",
            "gauge.consul.raft.leader.dispatchLog.max",
            "gauge.consul.raft.leader.dispatchLog.min",
            "gauge.consul.raft.leader.lastContact.avg",
            "gauge.consul.raft.leader.lastContact.max",
            "gauge.consul.raft.leader.lastContact.min",
            "gauge.consul.raft.replication.appendEntries.rpc.AGENT.avg",
            "gauge.consul.raft.replication.appendEntries.rpc.AGENT.max",
            "gauge.consul.raft.replication.appendEntries.rpc.AGENT.min",
            "gauge.consul.raft.state.candidate",
            "gauge.consul.raft.state.leader",
            "gauge.consul.rpc.query",
            "gauge.consul.runtime.alloc_bytes",
            "gauge.consul.runtime.heap_objects",
            "gauge.consul.runtime.num_goroutines",
            "gauge.consul.serf.events",
            "gauge.consul.serf.events.consul:new-leader",
            "gauge.consul.serf.member.join",
            "gauge.consul.serf.member.left",
            "gauge.consul.serf.queue.Event.avg",
            "gauge.consul.serf.queue.Event.max",
            "gauge.consul.serf.queue.Event.min",
            "gauge.consul.serf.queue.Query.avg",
            "gauge.consul.serf.queue.Query.max",
            "gauge.consul.serf.queue.Query.min"
          ]
        }
      },
      "metrics": {
        "consul.dns.stale_queries": {
          "type": "gauge",
          "description": "Number of times an agent serves a DNS query based on information from a server that is more than 5 seconds out of date. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "consul.memberlist.msg.suspect": {
          "type": "gauge",
          "description": "This increments when an agent suspects another as failed when executing random probes as part of the gossip protocol. These can be an indicator of overloaded agents, network problems, or configuration errors where agents can not connect to each other on the required ports. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "consul.serf.member.flap": {
          "type": "gauge",
          "description": " This metric increments when an agent is marked dead and then recovers within a short time period. This can be an indicator of overloaded agents, network problems, or configuration errors where agents can not connect to each other on the required ports. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.catalog.nodes.total": {
          "type": "gauge",
          "description": "The total number of nodes in the Consul datacenter. This metric is common to the cluster and, therefore, reported by leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode` to indicate which mode - server or client - is the reporting consul agent.",
          "group": null,
          "default": true
        },
        "gauge.consul.catalog.nodes_by_service": {
          "type": "gauge",
          "description": "Number of nodes providing a given service. This metric is reported by the leader only. The dimension `consul_service` indicates which service the metric corresponds too. Additionally, the metric also has the `datacenter` and `consul_mode` dimension.",
          "group": null,
          "default": true
        },
        "gauge.consul.catalog.services.total": {
          "type": "gauge",
          "description": "The total number of services registered with Consul in the given datacenter. This metric is common to the cluster and, therefore, reported by leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode` to indicate which mode - server or client - is the reporting consul agent.",
          "group": null,
          "default": true
        },
        "gauge.consul.catalog.services_by_node": {
          "type": "gauge",
          "description": "Number of services registered with a node. This metric is reported by the leader only. The dimension `consul_node` indicates which node the metric corresponds too. Additionally, the metric also has the `datacenter` and `consul_mode` dimension.",
          "group": null,
          "default": true
        },
        "gauge.consul.consul.dns.domain_query.AGENT.avg": {
          "type": "gauge",
          "description": "This tracks how long it takes to service forward DNS lookups on the given Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.consul.dns.domain_query.AGENT.max": {
          "type": "gauge",
          "description": "This tracks maximum time takes to service forward DNS lookups on the given Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.consul.dns.domain_query.AGENT.min": {
          "type": "gauge",
          "description": "This tracks minimum time it takes to service forward DNS lookups on the given Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.consul.dns.ptr_query.AGENT.avg": {
          "type": "gauge",
          "description": "This tracks average time it takes to service reverse DNS lookups on the given Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.consul.dns.ptr_query.AGENT.max": {
          "type": "gauge",
          "description": "This tracks maximum time it takes to service reverse DNS lookups on the given Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.consul.dns.ptr_query.AGENT.min": {
          "type": "gauge",
          "description": "This tracks minimum time it takes to service reverse DNS lookups on the given Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.consul.leader.reconcile.avg": {
          "type": "gauge",
          "description": "Time it takes the leader to reconcile the differences between Serf membership and Consul's store. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.consul.rpc.query": {
          "type": "gauge",
          "description": "A general measure of all read volume. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.health.nodes.critical": {
          "type": "gauge",
          "description": "Number of nodes for which health checks are reporting Critical state. This metric is reported by leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.health.nodes.passing": {
          "type": "gauge",
          "description": "Number of nodes which health checks are reporting to be in Passing state. This metric is reported by leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.health.nodes.warning": {
          "type": "gauge",
          "description": "Number of nodes which health checks are reporting to be in Warning state. This metric is reported by leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.health.services.critical": {
          "type": "gauge",
          "description": "Number of services for which health checks are reporting Critical state. This metric is reported by leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.health.services.passing": {
          "type": "gauge",
          "description": "Number of services which health checks are reporting to be in Passing state. This metric is reported by leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.health.services.warning": {
          "type": "gauge",
          "description": "Number of services which health checks are reporting to be in Warning state. This metric is reported by leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.is_leader": {
          "type": "gauge",
          "description": "Metric to map consul server's in leader or follower state. A follower instance returns value of 0 and leader returns a value of 1. Used by a Heat Map in the dashboard which makes recognizing the leader from followers visually easy. This metric comes with the dimension - `consul_server_state` which can be either leader or follower. Also has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.network.dc.latency.avg": {
          "type": "gauge",
          "description": "Average datacenter latency between 2 datacenters. This metric has the additional dimension `destination_dc` dimension. The latency is calculated between this destination datacenter and the agent's datacenter given by the `datacenter` dimension. Only the leader in the source datacenter calculates this metric. The metric also has the dimensions `consul_mode` and `consul_node`.",
          "group": null,
          "default": true
        },
        "gauge.consul.network.dc.latency.max": {
          "type": "gauge",
          "description": "Maximum datacenter latency between 2 datacenters. This metric has the additional dimension `destination_dc` dimension. The latency is calculated between this destination datacenter and the agent's datacenter given by the `datacenter` dimension. Only the leader in the source datacenter calculates this metric. The metric also has the dimensions `consul_mode` and `consul_node`.",
          "group": null,
          "default": false
        },
        "gauge.consul.network.dc.latency.min": {
          "type": "gauge",
          "description": "Minimum datacenter latency between 2 datacenters. This metric has the additional dimension `destination_dc` dimension. The latency is calculated between this destination datacenter and the agent's datacenter given by the `datacenter` dimension. Only the leader in the source datacenter calculates this metric. The metric also has the dimensions `consul_mode` and `consul_node`.",
          "group": null,
          "default": false
        },
        "gauge.consul.network.node.latency.avg": {
          "type": "gauge",
          "description": "Average network latency between given node and other nodes in the datacenter. The dimension `consul_node` corresponds to the source node. The metric also has the dimensions `datacenter` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.network.node.latency.max": {
          "type": "gauge",
          "description": "Minimum network latency between given node and other nodes in the datacenter. The dimension `consul_node` corresponds to the source node. The metric also has the dimensions `datacenter` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.network.node.latency.min": {
          "type": "gauge",
          "description": "Minimum network latency between given node and other nodes in the datacenter. The dimension `consul_node` corresponds to the source node. The metric also has the dimensions `datacenter` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.peers": {
          "type": "gauge",
          "description": "Number of consul Raft peers or consul agents in server mode in a given datacenter. This metric is reported by the leader only. This metric is reported with the dimension `datacenter`, `consul_node` name and `consul_mode`",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.apply": {
          "type": "gauge",
          "description": "This metric is a general indicator of the write load on the Consul servers. This metric has the global dimensions `consul_node`, `consul_mode` and `datacenter`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.commitTime.avg": {
          "type": "gauge",
          "description": "This measures the mean time it takes to commit a new entry to the Raft log on the leader. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.commitTime.max": {
          "type": "gauge",
          "description": "This measures the max time it takes to commit a new entry to the Raft log on the leader. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.commitTime.min": {
          "type": "gauge",
          "description": "This measures the minimum time it takes to commit a new entry to the Raft log on the leader. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.leader.dispatchLog.avg": {
          "type": "gauge",
          "description": "This measures the mean time it takes for the leader to write log entries to disk. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.leader.dispatchLog.max": {
          "type": "gauge",
          "description": "This measures the maximum time it takes for the leader to write log entries to disk. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.leader.dispatchLog.min": {
          "type": "gauge",
          "description": "This measures the minimum time it takes for the leader to write log entries to disk. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.leader.lastContact.avg": {
          "type": "gauge",
          "description": "This measures the time since the leader was last able to contact the follower nodes when checking its leader lease. It can be used as a measure for how stable the Raft timing is and how close the leader is to timing out its lease. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.leader.lastContact.max": {
          "type": "gauge",
          "description": "This measures the maximum time since the leader was last able to contact the follower nodes when checking its leader lease. It can be used as a measure for how stable the Raft timing is and how close the leader is to timing out its lease. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.leader.lastContact.min": {
          "type": "gauge",
          "description": "This measures the minimum time since the leader was last able to contact the follower nodes when checking its leader lease. It can be used as a measure for how stable the Raft timing is and how close the leader is to timing out its lease. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.replication.appendEntries.rpc.AGENT.avg": {
          "type": "gauge",
          "description": "This measures the time it takes to replicate log entries to followers. This is a general indicator of the load pressure on the Consul servers, as well as the performance of the communication between the servers. This metric is sent by the leader for each follower. The metric has the followers ip or hostname added to the metric name. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.raft.replication.appendEntries.rpc.AGENT.max": {
          "type": "gauge",
          "description": "This measures the maximum time it takes to replicate log entries to followers. This is a general indicator of the load pressure on the Consul servers, as well as the performance of the communication between the servers. This metric is sent by the leader for each follower. The metric has the followers ip or hostname added to the metric name. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.raft.replication.appendEntries.rpc.AGENT.min": {
          "type": "gauge",
          "description": "This measures the minimum time it takes to replicate log entries to followers. This is a general indicator of the load pressure on the Consul servers, as well as the performance of the communication between the servers. This metric is sent by the leader for each follower. The metric has the followers ip or hostname added to the metric name. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.raft.state.candidate": {
          "type": "gauge",
          "description": "Tracks the number of times given node enters the candidate state, i.e., the number of times the Consul server starts a leader election. If this increments without a leadership change occurring it could indicate that a single server is overloaded or is experiencing network connectivity issues. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.raft.state.leader": {
          "type": "gauge",
          "description": "This metric increments whenever a Consul server becomes a leader. If there are frequent leadership changes this may be indication that the servers are overloaded and aren't meeting the soft real-time requirements for Raft, or that there are networking problems between the servers. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.rpc.query": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.consul.runtime.alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated to Consul process on the node. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.runtime.heap_objects": {
          "type": "gauge",
          "description": "Number of heap objects allocated to Consul, indicates memory pressure on a Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.runtime.num_goroutines": {
          "type": "gauge",
          "description": "Number of GO routines run by Consul process on the node. Gives the general load pressure indicator for Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.serf.events": {
          "type": "gauge",
          "description": "Number of serf events processed by Consul. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.serf.events.consul:new-leader": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.consul.serf.member.join": {
          "type": "gauge",
          "description": "This metric tracks successful node joins to the Serf memberlist. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.serf.member.left": {
          "type": "gauge",
          "description": "This metric tracks successful node leaves to the Serf memberlist. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.serf.queue.Event.avg": {
          "type": "gauge",
          "description": "Average number of serf events in queue yet to be processed by Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.serf.queue.Event.max": {
          "type": "gauge",
          "description": "Maximum number of serf events in queue yet to be processed by Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": true
        },
        "gauge.consul.serf.queue.Event.min": {
          "type": "gauge",
          "description": "Minimum number of serf events in queue yet to be processed by Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.serf.queue.Query.avg": {
          "type": "gauge",
          "description": "Average number of serf queries in queue yet to be processed by Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.serf.queue.Query.max": {
          "type": "gauge",
          "description": "Maximum number of serf queries in queue yet to be processed by Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        },
        "gauge.consul.serf.queue.Query.min": {
          "type": "gauge",
          "description": "Minimum number of serf queries in queue yet to be processed by Consul agent. This metric has the dimensions `datacenter`, `consul_node` and `consul_mode`.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/consul",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "aclToken",
            "doc": "Consul ACL token",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "Set to `true` to connect to Consul using HTTPS.  You can figure the certificate for the server with the `caCertificate` config option.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "telemetryServer",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "telemetryHost",
            "doc": "IP address or DNS to which Consul is configured to send telemetry UDP packets. Relevant only if `telemetryServer` is set to true.",
            "default": "0.0.0.0",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "telemetryPort",
            "doc": "Port to which Consul is configured to send telemetry UDP packets. Relevant only if `telemetryServer` is set to true.",
            "default": 8125,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "Set to *true* to enable collecting all metrics from Consul's runtime telemetry send via UDP or from the `/agent/metrics` endpoint.",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertificate",
            "doc": "If Consul server has HTTPS enabled for the API, specifies the path to the CA's Certificate.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertificate",
            "doc": "If client-side authentication is enabled, specifies the path to the certificate file.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKey",
            "doc": "If client-side authentication is enabled, specifies the path to the key file.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "signalFxAccessToken",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/couchbase",
      "sendAll": false,
      "dimensions": null,
      "doc": "This is a Smart Agent monitor for [Couchbase](https://www.couchbase.com/)\nthat uses the [couchbase collectd Python\nplugin](https://github.com/signalfx/collectd-couchbase) to collect metrics\nfrom Couchbase server instances.\n\nFor general reference on how to monitor Couchbase, see \u003ca target=\"_blank\"\nhref=\"http://blog.couchbase.com/monitoring-couchbase-cluster\"\u003eCouchbase\nMonitoring\u003c/a\u003e and \u003ca target=\"_blank\"\nhref=\"http://developer.couchbase.com/documentation/server/4.0/monitoring/monitoring-rest.html\"\u003eMonitor\nusing the REST API\u003c/a\u003e.\n\n\u003c!--- METRICS ---\u003e\n## Note on bucket metrics\n\nThis plugin emits some metrics about the bucket's performance across the\ncluster, and some metrics about the bucket's performance per node.\n\nMetrics beginning with `gauge.bucket.basic.*` and\n`gauge.bucket.quota.*` are reported once per cluster. All other\nbucket metrics (`gauge.bucket.*`) are reported by every node that hosts\nthat bucket. In order to analyze bucket performance for the entire bucket,\napply functions like Sum or Mean to group node-level metrics together by\nbucket.\n\n\u003c!--- SETUP ---\u003e\n## Example Config\n\nSample YAML configuration with custom query:\n\n```yaml\nmonitors:\n- type: collectd/couchbase\n  host: 127.0.0.1\n  port: 8091\n  collectTarget: \"NODE\"\n  clusterName: \"my-cluster\"\n  username: \"user\"\n  password: \"password\"\n```\n",
      "groups": {
        "bucket": {
          "description": "Bucket metrics",
          "metrics": [
            "gauge.bucket.basic.dataUsed",
            "gauge.bucket.basic.diskFetches",
            "gauge.bucket.basic.diskUsed",
            "gauge.bucket.basic.itemCount",
            "gauge.bucket.basic.memUsed",
            "gauge.bucket.basic.opsPerSec",
            "gauge.bucket.basic.quotaPercentUsed",
            "gauge.bucket.op.cmd_get",
            "gauge.bucket.op.couch_docs_fragmentation",
            "gauge.bucket.op.couch_views_ops",
            "gauge.bucket.op.curr_connections",
            "gauge.bucket.op.curr_items",
            "gauge.bucket.op.disk_write_queue",
            "gauge.bucket.op.ep_bg_fetched",
            "gauge.bucket.op.ep_cache_miss_rate",
            "gauge.bucket.op.ep_diskqueue_drain",
            "gauge.bucket.op.ep_diskqueue_fill",
            "gauge.bucket.op.ep_mem_high_wat",
            "gauge.bucket.op.ep_mem_low_wat",
            "gauge.bucket.op.ep_num_value_ejects",
            "gauge.bucket.op.ep_oom_errors",
            "gauge.bucket.op.ep_queue_size",
            "gauge.bucket.op.ep_tmp_oom_errors",
            "gauge.bucket.op.mem_used",
            "gauge.bucket.op.ops",
            "gauge.bucket.op.vb_active_resident_items_ratio",
            "gauge.bucket.quota.ram",
            "gauge.bucket.quota.rawRAM"
          ]
        },
        "nodes": {
          "description": "Node metrics",
          "metrics": [
            "gauge.nodes.cmd_get",
            "gauge.nodes.couch_docs_actual_disk_size",
            "gauge.nodes.couch_docs_data_size",
            "gauge.nodes.couch_spatial_data_size",
            "gauge.nodes.couch_spatial_disk_size",
            "gauge.nodes.couch_views_actual_disk_size",
            "gauge.nodes.couch_views_data_size",
            "gauge.nodes.curr_items",
            "gauge.nodes.curr_items_tot",
            "gauge.nodes.ep_bg_fetched",
            "gauge.nodes.get_hits",
            "gauge.nodes.mcdMemoryAllocated",
            "gauge.nodes.mcdMemoryReserved",
            "gauge.nodes.mem_used",
            "gauge.nodes.memoryFree",
            "gauge.nodes.memoryTotal",
            "gauge.nodes.ops",
            "gauge.nodes.system.cpu_utilization_rate",
            "gauge.nodes.system.mem_free",
            "gauge.nodes.system.mem_total",
            "gauge.nodes.system.swap_total",
            "gauge.nodes.system.swap_used",
            "gauge.nodes.vb_replica_curr_items"
          ]
        },
        "storage": {
          "description": "Storage metrics",
          "metrics": [
            "gauge.storage.hdd.free",
            "gauge.storage.hdd.quotaTotal",
            "gauge.storage.hdd.total",
            "gauge.storage.hdd.used",
            "gauge.storage.hdd.usedByData",
            "gauge.storage.ram.quotaTotal",
            "gauge.storage.ram.quotaTotalPerNode",
            "gauge.storage.ram.quotaUsed",
            "gauge.storage.ram.quotaUsedPerNode",
            "gauge.storage.ram.total",
            "gauge.storage.ram.used",
            "gauge.storage.ram.usedByData"
          ]
        }
      },
      "metrics": {
        "gauge.bucket.basic.dataUsed": {
          "type": "gauge",
          "description": "Size of user data within buckets of the specified state that are resident in RAM (%)",
          "group": "bucket",
          "default": false
        },
        "gauge.bucket.basic.diskFetches": {
          "type": "gauge",
          "description": "Number of disk fetches",
          "group": "bucket",
          "default": false
        },
        "gauge.bucket.basic.diskUsed": {
          "type": "gauge",
          "description": "Amount of disk used (bytes)",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.basic.itemCount": {
          "type": "gauge",
          "description": "Number of items associated with the bucket",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.basic.memUsed": {
          "type": "gauge",
          "description": "Amount of memory used by the bucket (bytes)",
          "group": "bucket",
          "default": false
        },
        "gauge.bucket.basic.opsPerSec": {
          "type": "gauge",
          "description": "Number of operations per second",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.basic.quotaPercentUsed": {
          "type": "gauge",
          "description": "Percentage of RAM used (for active objects) against the configure bucket size (%)",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.cmd_get": {
          "type": "gauge",
          "description": "requested objects",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.couch_docs_fragmentation": {
          "type": "gauge",
          "description": "Percent fragmentation of documents in this bucket.",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.couch_views_ops": {
          "type": "gauge",
          "description": "view operations per second",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.curr_connections": {
          "type": "gauge",
          "description": "open connection per bucket",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.curr_items": {
          "type": "gauge",
          "description": "total number of stored items per bucket",
          "group": "bucket",
          "default": false
        },
        "gauge.bucket.op.disk_write_queue": {
          "type": "gauge",
          "description": "number of items waiting to be written to disk",
          "group": "bucket",
          "default": false
        },
        "gauge.bucket.op.ep_bg_fetched": {
          "type": "gauge",
          "description": "number of items fetched from disk",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ep_cache_miss_rate": {
          "type": "gauge",
          "description": "ratio of requested objects found in cache vs retrieved from disk",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ep_diskqueue_drain": {
          "type": "gauge",
          "description": "items removed from disk queue",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ep_diskqueue_fill": {
          "type": "gauge",
          "description": "enqueued items on disk queue",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ep_mem_high_wat": {
          "type": "gauge",
          "description": "memory high water mark - point at which active objects begin to be ejected from bucket",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ep_mem_low_wat": {
          "type": "gauge",
          "description": "memory low water mark",
          "group": "bucket",
          "default": false
        },
        "gauge.bucket.op.ep_num_value_ejects": {
          "type": "gauge",
          "description": "number of objects ejected out of the bucket",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ep_oom_errors": {
          "type": "gauge",
          "description": "request rejected - bucket is at quota, panic",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ep_queue_size": {
          "type": "gauge",
          "description": "number of items queued for storage",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ep_tmp_oom_errors": {
          "type": "gauge",
          "description": "request rejected - couchbase is making room by ejecting objects, try again later",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.mem_used": {
          "type": "gauge",
          "description": "memory used",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.op.ops": {
          "type": "gauge",
          "description": "total of gets, sets, increment and decrement",
          "group": "bucket",
          "default": false
        },
        "gauge.bucket.op.vb_active_resident_items_ratio": {
          "type": "gauge",
          "description": "ratio of items kept in memory vs stored on disk",
          "group": "bucket",
          "default": true
        },
        "gauge.bucket.quota.ram": {
          "type": "gauge",
          "description": "Amount of RAM used by the bucket (bytes).",
          "group": "bucket",
          "default": false
        },
        "gauge.bucket.quota.rawRAM": {
          "type": "gauge",
          "description": "Amount of raw RAM used by the bucket (bytes).",
          "group": "bucket",
          "default": false
        },
        "gauge.nodes.cmd_get": {
          "type": "gauge",
          "description": "Number of get commands",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.couch_docs_actual_disk_size": {
          "type": "gauge",
          "description": "Amount of disk space used by Couch docs.(bytes)",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.couch_docs_data_size": {
          "type": "gauge",
          "description": "Data size of couch documents associated with a node (bytes)",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.couch_spatial_data_size": {
          "type": "gauge",
          "description": "Size of object data for spatial views (bytes)",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.couch_spatial_disk_size": {
          "type": "gauge",
          "description": "Amount of disk space occupied by spatial views, in bytes.",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.couch_views_actual_disk_size": {
          "type": "gauge",
          "description": "Amount of disk space occupied by Couch views (bytes).",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.couch_views_data_size": {
          "type": "gauge",
          "description": "Size of object data for Couch views (bytes).",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.curr_items": {
          "type": "gauge",
          "description": "Number of current items",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.curr_items_tot": {
          "type": "gauge",
          "description": "Total number of items associated with node",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.ep_bg_fetched": {
          "type": "gauge",
          "description": "Number of disk fetches performed since server was started",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.get_hits": {
          "type": "gauge",
          "description": "Number of get hits",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.mcdMemoryAllocated": {
          "type": "gauge",
          "description": "Amount of memcached memory allocated (bytes).",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.mcdMemoryReserved": {
          "type": "gauge",
          "description": "Amount of memcached memory reserved (bytes).",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.mem_used": {
          "type": "gauge",
          "description": "Memory used by the node (bytes)",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.memoryFree": {
          "type": "gauge",
          "description": "Amount of memory free for the node (bytes).",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.memoryTotal": {
          "type": "gauge",
          "description": "Total memory available to the node (bytes).",
          "group": "nodes",
          "default": false
        },
        "gauge.nodes.ops": {
          "type": "gauge",
          "description": "Number of operations performed on Couchbase",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.system.cpu_utilization_rate": {
          "type": "gauge",
          "description": "The CPU utilization rate (%)",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.system.mem_free": {
          "type": "gauge",
          "description": "Free memory available to the node (bytes)",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.system.mem_total": {
          "type": "gauge",
          "description": "Total memory available to the node (bytes)",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.system.swap_total": {
          "type": "gauge",
          "description": "Total swap size allocated (bytes)",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.system.swap_used": {
          "type": "gauge",
          "description": "Amount of swap space used (bytes)",
          "group": "nodes",
          "default": true
        },
        "gauge.nodes.vb_replica_curr_items": {
          "type": "gauge",
          "description": "Number of items/documents that are replicas",
          "group": "nodes",
          "default": false
        },
        "gauge.storage.hdd.free": {
          "type": "gauge",
          "description": "Free harddrive space in the cluster (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.hdd.quotaTotal": {
          "type": "gauge",
          "description": "Harddrive quota total for the cluster (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.hdd.total": {
          "type": "gauge",
          "description": "Total harddrive space available to cluster (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.hdd.used": {
          "type": "gauge",
          "description": "Harddrive space used by the cluster (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.hdd.usedByData": {
          "type": "gauge",
          "description": "Harddrive use by the data in the cluster(bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.ram.quotaTotal": {
          "type": "gauge",
          "description": "Ram quota total for the cluster (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.ram.quotaTotalPerNode": {
          "type": "gauge",
          "description": "Ram quota total per node (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.ram.quotaUsed": {
          "type": "gauge",
          "description": "Ram quota used by the cluster (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.ram.quotaUsedPerNode": {
          "type": "gauge",
          "description": "Ram quota used per node (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.ram.total": {
          "type": "gauge",
          "description": "Total ram available to cluster (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.ram.used": {
          "type": "gauge",
          "description": "Ram used by the cluster (bytes)",
          "group": "storage",
          "default": false
        },
        "gauge.storage.ram.usedByData": {
          "type": "gauge",
          "description": "Ram used by the data in the cluster (bytes)",
          "group": "storage",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/couchbase",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "collectTarget",
            "doc": "Define what this Module block will monitor: \"NODE\", for a Couchbase node, or \"BUCKET\" for a Couchbase bucket.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "collectBucket",
            "doc": "If CollectTarget is \"BUCKET\", CollectBucket specifies the name of the bucket that this will monitor.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clusterName",
            "doc": "Name of this Couchbase cluster. (**default**:\"default\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "collectMode",
            "doc": "Change to \"detailed\" to collect all available metrics from Couchbase stats API. Defaults to \"default\", collecting a curated set that works well with SignalFx.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate with",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password to authenticate with",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/cpu",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor collects cpu usage data using the\ncollectd `cpu` plugin.  It aggregates the per-core CPU data into a single\nmetric and sends it to the SignalFx Metadata plugin in collectd, where the\nraw jiffy counts from the `cpu` plugin are converted to percent utilization\n(the `cpu.utilization` metric).\n\nSee https://collectd.org/wiki/index.php/Plugin:CPU\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "cpu.idle",
            "cpu.interrupt",
            "cpu.nice",
            "cpu.softirq",
            "cpu.steal",
            "cpu.system",
            "cpu.user",
            "cpu.wait"
          ]
        }
      },
      "metrics": {
        "cpu.idle": {
          "type": "cumulative",
          "description": "CPU time spent not in any other state. In order to get a percentage this value must be compared against the sum of all CPU states.\n",
          "group": null,
          "default": true
        },
        "cpu.interrupt": {
          "type": "cumulative",
          "description": "CPU time spent while servicing hardware interrupts. A hardware interrupt happens at the physical layer. When this occurs, the CPU will stop whatever else it is doing and service the interrupt. This metric measures how many jiffies were spent handling these interrupts. In order to get a percentage this value must be compared against the sum of all CPU states. A sustained high value for this metric may be caused by faulty hardware such as a broken peripheral.\n",
          "group": null,
          "default": false
        },
        "cpu.nice": {
          "type": "cumulative",
          "description": "CPU time spent in userspace running 'nice'-ed processes. In order to get a percentage this value must be compared against the sum of all CPU states. A sustained high value for this metric may be caused by: 1) The server not having enough CPU capacity for a process, 2) A programming error which causes a process to use an unexpected amount of CPU\n",
          "group": null,
          "default": false
        },
        "cpu.softirq": {
          "type": "cumulative",
          "description": "CPU time spent while servicing software interrupts. Unlike a hardware interrupt, a software interrupt happens at the sofware layer. Usually it is a userspace program requesting a service of the kernel. This metric measures how many jiffies were spent by the CPU handling these interrupts. In order to get a percentage this value must be compared against the sum of all CPU states. A sustained high value for this metric may be caused by a programming error which causes a process to unexpectedly request too many services from the kernel.\n",
          "group": null,
          "default": false
        },
        "cpu.steal": {
          "type": "cumulative",
          "description": "CPU time spent waiting for a hypervisor to service requests from other virtual machines. This metric is only present on virtual machines. This metric records how much time this virtual machine had to wait to have the hypervisor kernel service a request. In order to get a percentage this value must be compared against the sum of all CPU states. A sustained high value for this metric may be caused by: 1) Another VM on the same hypervisor using too many resources, or 2) An underpowered hypervisor\n",
          "group": null,
          "default": false
        },
        "cpu.system": {
          "type": "cumulative",
          "description": "CPU time spent running in the kernel. This value reflects how often processes are calling into the kernel for services (e.g to log to the console). In order to get a percentage this value must be compared against the sum of all CPU states. A sustained high value for this metric may be caused by: 1) A process that needs to be re-written to use kernel resources more efficiently, or 2) A userspace driver that is broken\n",
          "group": null,
          "default": false
        },
        "cpu.user": {
          "type": "cumulative",
          "description": "CPU time spent running in userspace. In order to get a percentage this value must be compared against the sum of all CPU states. If this value is high: 1) A process requires more CPU to run than is available on the server, or 2) There is an application programming error which is causing the CPU to be used unexpectedly.\n",
          "group": null,
          "default": false
        },
        "cpu.wait": {
          "type": "cumulative",
          "description": "Amount of total CPU time spent idle while waiting for an I/O operation to complete. In order to get a percentage this value must be compared against the sum of all CPU states. A high value for a sustained period may be caused by: 1) A slow hardware device that is taking too long to service requests, or 2) Too many requests being sent to an I/O device\n",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/cpu",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/cpufreq",
      "sendAll": true,
      "dimensions": null,
      "doc": "Monitors the actual clock speed of each CPU on a\nhost.  Useful for systems that vary the clock speed to conserve energy.\n\nSee https://collectd.org/wiki/index.php/Plugin:CPUFreq\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "cpufreq.\u003cN\u003e"
          ]
        }
      },
      "metrics": {
        "cpufreq.\u003cN\u003e": {
          "type": "gauge",
          "description": "The processor frequency in Hertz for the \u003cN\u003eth processor on the system.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/cpufreq",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/custom",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor lets you provide custom collectd\nconfiguration to be run by the managed collectd instance.  You can provide\nconfiguration for as many plugins as you want in a single instance of this\nmonitor configuration by either putting multiple `\u003cPlugin\u003e` blocks in a\nsingle `template` option, or specifying multiple `templates`.\n\nNote that a distinct instance of collectd is run for each instance of this\nmonitor, so it is more efficient to group plugin configurations into a\nsingle monitor configuration (either in one big `template` text blob, or\nsplit into multiple `templates`).  You should not group configurations if\nusing a discoveryRule since that would result in duplicate config for each\ninstance of the service endpoint discovered.\n\nYou can also use your own Python plugins in conjunction with the\n`ModulePath` option in\n[collectd-python](https://collectd.org/documentation/manpages/collectd-python.5.shtml).\nIf your Python plugin has dependencies of its own, you can specify the path\nto them by specifying multiple `ModulePath` options with those paths.\n\nHere is an example of a configuration with a custom Python plugin:\n\n```yaml\n  - type: collectd/custom\n    discoveryRule: container_image =~ \"myservice\"\n    template: |\n      LoadPlugin \"python\"\n      \u003cPlugin python\u003e\n        ModulePath \"/usr/lib/python2.7/dist-packages/health_checker\"\n        Import \"health_checker\"\n        \u003cModule health_checker\u003e\n          URL \"http://{{.Host}}:{{.Port}}\"\n          JSONKey \"isRunning\"\n          JSONVal \"1\"\n        \u003c/Module\u003e\n      \u003c/Plugin\u003e\n```\n\nWe have many collectd plugins included in the image that are not exposed as\nmonitors.  You can see the plugins in the `\u003cAGENT_BUNDLE\u003e/lib/collectd`\ndirectory, where `\u003cAGENT_BUNDLE\u003e` is the root of the filesystem in the\ncontainerized version, and is normally `/usr/lib/signalfx-agent` in the\nnon-containerized agent.\n\n## Running the collectd/exec plugin\nYou can use the collectd/custom monitor to run the collectd/exec plugin.\nIf you are not running the Smart Agent in the container, you can use any appropriate user\non your system.\nIf you are running the Smart Agent in a container, \nthen you need to use a non-root user when you run your script:\n\n```yaml\n  - type: collectd/custom\n    template: |\n      LoadPlugin exec\n      \u003cPlugin exec\u003e\n        Exec \"`non-root user`\" \"/path/to/script.sh\"\n      \u003c/Plugin\u003e\n```\n(replace `non-root user` with an actual non-root user on your host)\n\nTo learn how to use the collectd/exec plugin, see [the collectd-exec](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#plugin_exec)\ndocumentation.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the configuration for the collectd custom monitor",
        "package": "pkg/monitors/collectd/custom",
        "fields": [
          {
            "yamlName": "host",
            "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Host}}`.  It will be set to the hostname or IP address of the discovered service. If you aren't using service discovery, you can just hardcode the host/port in the config template and ignore these fields.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Port}}`.  It will be set to the port of the discovered service, if it is a TCP/UDP endpoint.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Name}}`.  It will be set to the name that the observer creates for the endpoint upon discovery.  You can generally ignore this field.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "template",
            "doc": "A config template for collectd.  You can include as many plugin blocks as you want in this value.  It is rendered as a standard Go template, so be mindful of the delimiters `{{` and `}}`.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "templates",
            "doc": "A list of templates, but otherwise equivalent to the above `template` option.  This enables you to have a single directory with collectd configuration files and load them all by using a globbed remote config value:",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "collectdReadThreads",
            "doc": "The number of read threads to use in collectd.  Will default to the number of templates provided, capped at 10, but if you manually specify it there is no limit.",
            "default": 0,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/df",
      "sendAll": false,
      "dimensions": null,
      "doc": "Tracks free disk space on the host using the collectd [df\nplugin](https://collectd.org/wiki/index.php/Plugin:DF).\n\nNote that on Linux a filesystem **must** be mounted in the same filesystem\nnamespace that the agent is running in for this monitor to be able to\ncollect statistics about that filesystem.  This is mostly an issue when\nrunning the agent in a container.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "df_complex.free",
            "df_complex.reserved",
            "df_complex.used",
            "percent_inodes.free",
            "percent_inodes.reserved",
            "percent_inodes.used"
          ]
        },
        "inodes": {
          "description": "",
          "metrics": [
            "df_inodes.free",
            "df_inodes.reserved",
            "df_inodes.used"
          ]
        },
        "percentage": {
          "description": "",
          "metrics": [
            "percent_bytes.free",
            "percent_bytes.reserved",
            "percent_bytes.used"
          ]
        }
      },
      "metrics": {
        "df_complex.free": {
          "type": "gauge",
          "description": "Measures free disk space in bytes on this file system.",
          "group": null,
          "default": true
        },
        "df_complex.reserved": {
          "type": "gauge",
          "description": "Measures disk space in bytes reserved for the super-user on this file system.",
          "group": null,
          "default": false
        },
        "df_complex.used": {
          "type": "gauge",
          "description": "Measures used disk space in bytes on this file system.",
          "group": null,
          "default": true
        },
        "df_inodes.free": {
          "type": "gauge",
          "description": "Measures free inodes in the file system.  Inodes are structures used by Unix filesystems to store metadata about files.",
          "group": "inodes",
          "default": false
        },
        "df_inodes.reserved": {
          "type": "gauge",
          "description": "Measures inodes reserved for the super user in the file system.  Inodes are structures used by Unix filesystems to store metadata about files.",
          "group": "inodes",
          "default": false
        },
        "df_inodes.used": {
          "type": "gauge",
          "description": "Measures used inodes in the file system.  Inodes are structures used by Unix filesystems to store metadata about files.",
          "group": "inodes",
          "default": false
        },
        "percent_bytes.free": {
          "type": "gauge",
          "description": "Measures free disk space as a percentage of total disk space on this file system.",
          "group": "percentage",
          "default": false
        },
        "percent_bytes.reserved": {
          "type": "gauge",
          "description": "Measures disk space reserved for the super-user as a percentage of total disk space of this file system.",
          "group": "percentage",
          "default": false
        },
        "percent_bytes.used": {
          "type": "gauge",
          "description": "Measures used disk space as a percentage of total disk space of this file system.",
          "group": "percentage",
          "default": false
        },
        "percent_inodes.free": {
          "type": "gauge",
          "description": "Measures free inodes as a percentage of total inodes in the file system.  Inodes are structures used by file systems to store information about files (other than its content).",
          "group": null,
          "default": false
        },
        "percent_inodes.reserved": {
          "type": "gauge",
          "description": "Measures inodes reserved for the super-user as a percentage of total inodes in the file system.  Inodes are structures used by file systems to store information about files (other than its content).",
          "group": null,
          "default": false
        },
        "percent_inodes.used": {
          "type": "gauge",
          "description": "Measures used inodes as a percentage of total inodes in the file system.  Inodes are structures used by file systems to store information about files (other than its content).",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/df",
        "fields": [
          {
            "yamlName": "hostFSPath",
            "doc": "Path to the root of the host filesystem.  Useful when running in a container and the host filesystem is mounted in some subdirectory under /.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "ignoreSelected",
            "doc": "If true, the filesystems selected by `fsTypes` and `mountPoints` will be excluded and all others included.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "fsTypes",
            "doc": "The filesystem types to include/exclude.",
            "default": [
              "aufs",
              "overlay",
              "tmpfs",
              "proc",
              "sysfs",
              "nsfs",
              "cgroup",
              "devpts",
              "selinuxfs",
              "devtmpfs",
              "debugfs",
              "mqueue",
              "hugetlbfs",
              "securityfs",
              "pstore",
              "binfmt_misc",
              "autofs"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mountPoints",
            "doc": "The mount paths to include/exclude, is interpreted as a regex if surrounded by `/`.  Note that you need to include the full path as the agent will see it, irrespective of the hostFSPath option.",
            "default": [
              "/^/var/lib/docker/",
              "/^/var/lib/rkt/pods/",
              "/^/net//",
              "/^/smb//"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "reportByDevice",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportInodes",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "valuesPercentage",
            "doc": "If true percent based metrics will be reported.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/disk",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor collects information about the usage of\nphysical disks and logical disks (partitions).\n\nSee https://collectd.org/wiki/index.php/Plugin:Disk.\n\n**This monitor has been deprecated in favor of the `disk-io` monitor.\nPlease migrate to that monitor as this collectd-based monitor will be\nremoved in a future release of the agent.**  Note that the `disk-io`\nmonitor has a different dimension (`disk` instead of `plugin_instance`) to\nspecify the disk.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "disk_io_time.io_time",
            "disk_io_time.weighted_io_time",
            "disk_merged.read",
            "disk_merged.write",
            "disk_octets.read",
            "disk_octets.write",
            "disk_ops.read",
            "disk_ops.write",
            "disk_time.read",
            "disk_time.write",
            "pending_operations"
          ]
        }
      },
      "metrics": {
        "disk_io_time.io_time": {
          "type": "cumulative",
          "description": "Amount of time spent doing IO in ms",
          "group": null,
          "default": false
        },
        "disk_io_time.weighted_io_time": {
          "type": "cumulative",
          "description": "Amount of time spent doing IO in ms multiplied by the queue length",
          "group": null,
          "default": false
        },
        "disk_merged.read": {
          "type": "cumulative",
          "description": "The number of disk reads merged into single physical disk access operations.",
          "group": null,
          "default": false
        },
        "disk_merged.write": {
          "type": "cumulative",
          "description": "The number of disk writes merged into single physical disk access operations.",
          "group": null,
          "default": false
        },
        "disk_octets.read": {
          "type": "cumulative",
          "description": "The number of bytes (octets) read from a disk.",
          "group": null,
          "default": false
        },
        "disk_octets.write": {
          "type": "cumulative",
          "description": "The number of bytes (octets) written to a disk.",
          "group": null,
          "default": false
        },
        "disk_ops.read": {
          "type": "cumulative",
          "description": "The number of disk read operations.",
          "group": null,
          "default": true
        },
        "disk_ops.write": {
          "type": "cumulative",
          "description": "The number of disk write operations.",
          "group": null,
          "default": true
        },
        "disk_time.read": {
          "type": "cumulative",
          "description": "The average amount of time it took to do a read operation.",
          "group": null,
          "default": false
        },
        "disk_time.write": {
          "type": "cumulative",
          "description": "The average amount of time it took to do a write operation.",
          "group": null,
          "default": false
        },
        "pending_operations": {
          "type": "gauge",
          "description": "Number of pending operations",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/disk",
        "fields": [
          {
            "yamlName": "disks",
            "doc": "Which devices to include/exclude",
            "default": [
              "/^loop[0-9]+$/",
              "/^dm-[0-9]+$/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "ignoreSelected",
            "doc": "If true, the disks selected by `disks` will be excluded and all others included.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/docker",
      "sendAll": false,
      "dimensions": null,
      "doc": "Pulls container stats from the Docker Engine.  We\nstrongly recommend using the\n[docker-container-stats](./docker-container-stats.md) monitor instead, as it\nwill scale to large number of containers much better.\n\nSee https://github.com/signalfx/docker-collectd-plugin.\n",
      "groups": {
        "blkio": {
          "description": "BlockIO metrics",
          "metrics": [
            "blkio.io_service_bytes_recursive.async",
            "blkio.io_service_bytes_recursive.read",
            "blkio.io_service_bytes_recursive.sync",
            "blkio.io_service_bytes_recursive.total",
            "blkio.io_service_bytes_recursive.write"
          ]
        },
        "cpu": {
          "description": "CPU metrics",
          "metrics": [
            "cpu.usage.kernelmode",
            "cpu.usage.system",
            "cpu.usage.total",
            "cpu.usage.usermode"
          ]
        },
        "memory": {
          "description": "Memory metrics",
          "metrics": [
            "memory.usage.limit",
            "memory.usage.max",
            "memory.usage.total"
          ]
        },
        "network": {
          "description": "Network metrics",
          "metrics": [
            "network.usage.rx_bytes",
            "network.usage.rx_dropped",
            "network.usage.rx_errors",
            "network.usage.rx_packets",
            "network.usage.tx_bytes",
            "network.usage.tx_dropped",
            "network.usage.tx_errors",
            "network.usage.tx_packets"
          ]
        }
      },
      "metrics": {
        "blkio.io_service_bytes_recursive.async": {
          "type": "cumulative",
          "description": "Volume, in bytes, of asynchronous block I/O",
          "group": "blkio",
          "default": true
        },
        "blkio.io_service_bytes_recursive.read": {
          "type": "cumulative",
          "description": "Volume, in bytes, of reads from block devices",
          "group": "blkio",
          "default": true
        },
        "blkio.io_service_bytes_recursive.sync": {
          "type": "cumulative",
          "description": "Volume, in bytes, of synchronous block I/O",
          "group": "blkio",
          "default": true
        },
        "blkio.io_service_bytes_recursive.total": {
          "type": "cumulative",
          "description": "Total volume, in bytes, of all block I/O",
          "group": "blkio",
          "default": true
        },
        "blkio.io_service_bytes_recursive.write": {
          "type": "cumulative",
          "description": "Volume, in bytes, of writes to block devices",
          "group": "blkio",
          "default": true
        },
        "cpu.usage.kernelmode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in kernel mode by the container",
          "group": "cpu",
          "default": true
        },
        "cpu.usage.system": {
          "type": "gauge",
          "description": "Jiffies of CPU time used by the system",
          "group": "cpu",
          "default": true
        },
        "cpu.usage.total": {
          "type": "gauge",
          "description": "Jiffies of CPU time used by the container",
          "group": "cpu",
          "default": true
        },
        "cpu.usage.usermode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in user mode by the container",
          "group": "cpu",
          "default": true
        },
        "memory.usage.limit": {
          "type": "gauge",
          "description": "Memory usage limit of the container, in bytes",
          "group": "memory",
          "default": true
        },
        "memory.usage.max": {
          "type": "gauge",
          "description": "Maximum measured memory usage of the container, in bytes",
          "group": "memory",
          "default": true
        },
        "memory.usage.total": {
          "type": "gauge",
          "description": "Bytes of memory used by the container",
          "group": "memory",
          "default": true
        },
        "network.usage.rx_bytes": {
          "type": "cumulative",
          "description": "Bytes received by the container via its network interface",
          "group": "network",
          "default": false
        },
        "network.usage.rx_dropped": {
          "type": "cumulative",
          "description": "Number of inbound network packets dropped by the container",
          "group": "network",
          "default": false
        },
        "network.usage.rx_errors": {
          "type": "cumulative",
          "description": "Errors receiving network packets",
          "group": "network",
          "default": false
        },
        "network.usage.rx_packets": {
          "type": "cumulative",
          "description": "Network packets received by the container via its network interface",
          "group": "network",
          "default": false
        },
        "network.usage.tx_bytes": {
          "type": "cumulative",
          "description": "Bytes sent by the container via its network interface",
          "group": "network",
          "default": false
        },
        "network.usage.tx_dropped": {
          "type": "cumulative",
          "description": "Number of outbound network packets dropped by the container",
          "group": "network",
          "default": false
        },
        "network.usage.tx_errors": {
          "type": "cumulative",
          "description": "Errors sending network packets",
          "group": "network",
          "default": false
        },
        "network.usage.tx_packets": {
          "type": "cumulative",
          "description": "Network packets sent by the container via its network interface",
          "group": "network",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/docker",
        "fields": [
          {
            "yamlName": "dimensions",
            "doc": "A set of dimensions to add to container metrics (see https://github.com/signalfx/docker-collectd-plugin#extracting-additional-dimensions).",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "dockerURL",
            "doc": "URL of the Docker engine, can be a unix socket path.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "excludedImages",
            "doc": "A list of images to exclude from monitoring",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedNames",
            "doc": "A list of container names to exclude from monitoring",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedLabels",
            "doc": "A map of label keys/values that will cause a container to be ignored.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "collectNetworkStats",
            "doc": "If true, will collect network stats about a container (will not work in some environments like Kubernetes).",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/elasticsearch",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors ElasticSearch instances. We strongly recommend using the\n[elasticsearch](./elasticsearch.md) monitor instead, as it will\nscale much better.\n\nYou can also [view the source of the Python\nplugin](https://github.com/signalfx/collectd-elasticsearch).\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "bytes.indices.primaries.merges.total-size",
            "bytes.indices.total.merges.total-size",
            "counter.http.total_open",
            "counter.indices.cache.field.eviction",
            "counter.indices.cache.filter.cache-count",
            "counter.indices.cache.filter.evictions",
            "counter.indices.cache.filter.hit-count",
            "counter.indices.cache.filter.miss-count",
            "counter.indices.cache.filter.total-count",
            "counter.indices.flush.time",
            "counter.indices.flush.total",
            "counter.indices.get.exists-time",
            "counter.indices.get.exists-total",
            "counter.indices.get.missing-time",
            "counter.indices.get.missing-total",
            "counter.indices.get.time",
            "counter.indices.get.total",
            "counter.indices.indexing.delete-time",
            "counter.indices.indexing.delete-total",
            "counter.indices.indexing.index-time",
            "counter.indices.indexing.index-total",
            "counter.indices.merges.time",
            "counter.indices.merges.total",
            "counter.indices.merges.total-size",
            "counter.indices.primaries.fielddata.evictions",
            "counter.indices.primaries.flush.total",
            "counter.indices.primaries.flush.total-time",
            "counter.indices.primaries.get.exists-time",
            "counter.indices.primaries.get.exists-total",
            "counter.indices.primaries.get.missing-time",
            "counter.indices.primaries.get.missing-total",
            "counter.indices.primaries.get.time",
            "counter.indices.primaries.indexing.delete-time",
            "counter.indices.primaries.indexing.delete-total",
            "counter.indices.primaries.indexing.index-time",
            "counter.indices.primaries.indexing.index-total",
            "counter.indices.primaries.merges.total",
            "counter.indices.primaries.merges.total-docs",
            "counter.indices.primaries.merges.total-time",
            "counter.indices.primaries.refresh.total",
            "counter.indices.primaries.refresh.total-time",
            "counter.indices.primaries.search.fetch-time",
            "counter.indices.primaries.search.fetch-total",
            "counter.indices.primaries.search.query-time",
            "counter.indices.primaries.search.query-total",
            "counter.indices.primaries.segments.count",
            "counter.indices.primaries.translog.operations",
            "counter.indices.primaries.warmer.total",
            "counter.indices.primaries.warmer.total.primaries.warmer.total-time",
            "counter.indices.refresh.time",
            "counter.indices.refresh.total",
            "counter.indices.search.fetch-time",
            "counter.indices.search.fetch-total",
            "counter.indices.search.query-time",
            "counter.indices.search.query-total",
            "counter.indices.search.scroll-time",
            "counter.indices.search.scroll.total",
            "counter.indices.total.fielddata.evictions",
            "counter.indices.total.flush.periodic",
            "counter.indices.total.get.exists-time",
            "counter.indices.total.get.exists-total",
            "counter.indices.total.get.missing-time",
            "counter.indices.total.get.missing-total",
            "counter.indices.total.get.time",
            "counter.indices.total.get.total",
            "counter.indices.total.indexing.delete-time",
            "counter.indices.total.indexing.delete-total",
            "counter.indices.total.indexing.index-time",
            "counter.indices.total.indexing.index-total",
            "counter.indices.total.merges.total",
            "counter.indices.total.merges.total-docs",
            "counter.indices.total.merges.total-time",
            "counter.indices.total.search.fetch-total",
            "counter.indices.total.search.query-time",
            "counter.indices.total.search.query-total",
            "counter.indices.total.translog.earliest_last_modified_age",
            "counter.indices.total.translog.uncommitted_operations",
            "counter.indices.total.translog.uncommitted_size_in_bytes",
            "counter.jvm.gc.count",
            "counter.jvm.gc.old-count",
            "counter.jvm.gc.old-time",
            "counter.jvm.gc.time",
            "counter.jvm.uptime",
            "counter.thread_pool.completed",
            "counter.thread_pool.rejected",
            "counter.transport.rx.count",
            "counter.transport.rx.size",
            "counter.transport.tx.count",
            "counter.transport.tx.size",
            "gauge.cluster.active-primary-shards",
            "gauge.cluster.active-shards",
            "gauge.cluster.initializing-shards",
            "gauge.cluster.number-of-data_nodes",
            "gauge.cluster.number-of-nodes",
            "gauge.cluster.relocating-shards",
            "gauge.cluster.status",
            "gauge.cluster.unassigned-shards",
            "gauge.http.current_open",
            "gauge.indices.cache.field.size",
            "gauge.indices.cache.filter.size",
            "gauge.indices.docs.count",
            "gauge.indices.docs.deleted",
            "gauge.indices.get.current",
            "gauge.indices.indexing.delete-current",
            "gauge.indices.indexing.index-current",
            "gauge.indices.merges.current",
            "gauge.indices.merges.current-docs",
            "gauge.indices.merges.current-size",
            "gauge.indices.merges.total-docs",
            "gauge.indices.primaries.completion.size",
            "gauge.indices.primaries.docs.count",
            "gauge.indices.primaries.docs.deleted",
            "gauge.indices.primaries.fielddata.memory-size",
            "gauge.indices.primaries.flush.periodic",
            "gauge.indices.primaries.get.current",
            "gauge.indices.primaries.indexing.delete-current",
            "gauge.indices.primaries.indexing.index-current",
            "gauge.indices.primaries.merges.current",
            "gauge.indices.primaries.merges.current-docs",
            "gauge.indices.primaries.merges.current-size",
            "gauge.indices.primaries.search.fetch-current",
            "gauge.indices.primaries.search.open-contexts",
            "gauge.indices.primaries.search.query-current",
            "gauge.indices.primaries.segments.index-writer-memory",
            "gauge.indices.primaries.segments.memory",
            "gauge.indices.primaries.segments.version-map-memory",
            "gauge.indices.primaries.store.size",
            "gauge.indices.primaries.translog.earliest_last_modified_age",
            "gauge.indices.primaries.translog.size",
            "gauge.indices.primaries.translog.uncommitted_operations",
            "gauge.indices.primaries.translog.uncommitted_size_in_bytes",
            "gauge.indices.primaries.warmer.current",
            "gauge.indices.search.fetch-current",
            "gauge.indices.search.open-contexts",
            "gauge.indices.search.query-current",
            "gauge.indices.search.scroll.current",
            "gauge.indices.segments.count",
            "gauge.indices.segments.index-writer-size",
            "gauge.indices.segments.size",
            "gauge.indices.store.size",
            "gauge.indices.total.docs.count",
            "gauge.indices.total.docs.deleted",
            "gauge.indices.total.fielddata.memory-size",
            "gauge.indices.total.filter-cache.memory-size",
            "gauge.indices.total.get.current",
            "gauge.indices.total.indexing.delete-current",
            "gauge.indices.total.indexing.index-current",
            "gauge.indices.total.merges.current",
            "gauge.indices.total.merges.current-docs",
            "gauge.indices.total.merges.current-size",
            "gauge.indices.total.search.open-contexts",
            "gauge.indices.total.search.query-current",
            "gauge.indices.total.store.size",
            "gauge.indices.translog.uncommitted_operations",
            "gauge.indices.translog.uncommitted_size_in_bytes",
            "gauge.jvm.mem.heap-committed",
            "gauge.jvm.mem.heap-used",
            "gauge.jvm.mem.non-heap-committed",
            "gauge.jvm.mem.non-heap-used",
            "gauge.jvm.mem.pools.old.max_in_bytes",
            "gauge.jvm.mem.pools.old.used_in_bytes",
            "gauge.jvm.mem.pools.young.max_in_bytes",
            "gauge.jvm.mem.pools.young.used_in_bytes",
            "gauge.jvm.threads.count",
            "gauge.jvm.threads.peak",
            "gauge.process.cpu.percent",
            "gauge.process.open_file_descriptors",
            "gauge.thread_pool.active",
            "gauge.thread_pool.largest",
            "gauge.thread_pool.queue",
            "gauge.thread_pool.threads",
            "gauge.transport.server_open",
            "percent.jvm.mem.heap-used-percent"
          ]
        }
      },
      "metrics": {
        "bytes.indices.primaries.merges.total-size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "bytes.indices.total.merges.total-size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.http.total_open": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.cache.field.eviction": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.cache.filter.cache-count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.cache.filter.evictions": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.cache.filter.hit-count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.cache.filter.miss-count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.cache.filter.total-count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.flush.time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.flush.total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.get.exists-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.get.exists-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.get.missing-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.get.missing-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.get.time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.get.total": {
          "type": "cumulative",
          "description": "The total number of get requests since node startup",
          "group": null,
          "default": true
        },
        "counter.indices.indexing.delete-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.indexing.delete-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.indexing.index-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.indexing.index-total": {
          "type": "cumulative",
          "description": "The total number of index requests since node startup",
          "group": null,
          "default": true
        },
        "counter.indices.merges.time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.merges.total": {
          "type": "cumulative",
          "description": "Total number of merges since node startup",
          "group": null,
          "default": true
        },
        "counter.indices.merges.total-size": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.fielddata.evictions": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.flush.total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.flush.total-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.get.exists-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.get.exists-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.get.missing-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.get.missing-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.get.time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.indexing.delete-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.indexing.delete-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.indexing.index-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.indexing.index-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.merges.total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.merges.total-docs": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.merges.total-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.refresh.total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.refresh.total-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.search.fetch-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.search.fetch-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.search.query-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.search.query-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.segments.count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.translog.operations": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.warmer.total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.primaries.warmer.total.primaries.warmer.total-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.refresh.time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.refresh.total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.search.fetch-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.search.fetch-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.search.query-time": {
          "type": "cumulative",
          "description": "Total time spent in search queries (milliseconds)",
          "group": null,
          "default": true
        },
        "counter.indices.search.query-total": {
          "type": "cumulative",
          "description": "The total number of search requests since node startup",
          "group": null,
          "default": true
        },
        "counter.indices.search.scroll-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.search.scroll.total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.fielddata.evictions": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.flush.periodic": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.get.exists-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.get.exists-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.get.missing-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.get.missing-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.get.time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.get.total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.indexing.delete-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.indexing.delete-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.indexing.index-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.indexing.index-total": {
          "type": "cumulative",
          "description": "The total number of index requests per cluster",
          "group": null,
          "default": true
        },
        "counter.indices.total.merges.total": {
          "type": "cumulative",
          "description": "Total number of merges per cluster",
          "group": null,
          "default": true
        },
        "counter.indices.total.merges.total-docs": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.merges.total-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.search.fetch-total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.search.query-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.search.query-total": {
          "type": "cumulative",
          "description": "The total number of search requests per cluster",
          "group": null,
          "default": true
        },
        "counter.indices.total.translog.earliest_last_modified_age": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.translog.uncommitted_operations": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.indices.total.translog.uncommitted_size_in_bytes": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.jvm.gc.count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.jvm.gc.old-count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.jvm.gc.old-time": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.jvm.gc.time": {
          "type": "cumulative",
          "description": "Total garbage collection time (milliseconds)",
          "group": null,
          "default": true
        },
        "counter.jvm.uptime": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.thread_pool.completed": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.thread_pool.rejected": {
          "type": "cumulative",
          "description": "Number of rejected thread pool requests",
          "group": null,
          "default": true
        },
        "counter.transport.rx.count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.transport.rx.size": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.transport.tx.count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.transport.tx.size": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.cluster.active-primary-shards": {
          "type": "gauge",
          "description": "The number of active primary shards",
          "group": null,
          "default": true
        },
        "gauge.cluster.active-shards": {
          "type": "gauge",
          "description": "The number of active shards",
          "group": null,
          "default": true
        },
        "gauge.cluster.initializing-shards": {
          "type": "gauge",
          "description": "The number of currently initializing shards",
          "group": null,
          "default": false
        },
        "gauge.cluster.number-of-data_nodes": {
          "type": "gauge",
          "description": "The current number of data nodes in the cluster",
          "group": null,
          "default": true
        },
        "gauge.cluster.number-of-nodes": {
          "type": "gauge",
          "description": "Total number of nodes in the cluster",
          "group": null,
          "default": true
        },
        "gauge.cluster.relocating-shards": {
          "type": "gauge",
          "description": "The number of shards that are currently being relocated",
          "group": null,
          "default": true
        },
        "gauge.cluster.status": {
          "type": "gauge",
          "description": "The health status of the cluster",
          "group": null,
          "default": false
        },
        "gauge.cluster.unassigned-shards": {
          "type": "gauge",
          "description": "The number of shards that are currently unassigned",
          "group": null,
          "default": true
        },
        "gauge.http.current_open": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.cache.field.size": {
          "type": "gauge",
          "description": "Field data size (bytes)",
          "group": null,
          "default": true
        },
        "gauge.indices.cache.filter.size": {
          "type": "gauge",
          "description": "Filter cache size (bytes)",
          "group": null,
          "default": true
        },
        "gauge.indices.docs.count": {
          "type": "gauge",
          "description": "Number of documents on this node",
          "group": null,
          "default": true
        },
        "gauge.indices.docs.deleted": {
          "type": "gauge",
          "description": "Number of deleted documents on this node",
          "group": null,
          "default": true
        },
        "gauge.indices.get.current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.indexing.delete-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.indexing.index-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.merges.current": {
          "type": "gauge",
          "description": "Number of active merges",
          "group": null,
          "default": true
        },
        "gauge.indices.merges.current-docs": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.merges.current-size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.merges.total-docs": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.completion.size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.docs.count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.docs.deleted": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.fielddata.memory-size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.flush.periodic": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.get.current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.indexing.delete-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.indexing.index-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.merges.current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.merges.current-docs": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.merges.current-size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.search.fetch-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.search.open-contexts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.search.query-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.segments.index-writer-memory": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.segments.memory": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.segments.version-map-memory": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.store.size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.translog.earliest_last_modified_age": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.translog.size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.translog.uncommitted_operations": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.translog.uncommitted_size_in_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.primaries.warmer.current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.search.fetch-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.search.open-contexts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.search.query-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.search.scroll.current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.segments.count": {
          "type": "gauge",
          "description": "Number of segments on this node",
          "group": null,
          "default": true
        },
        "gauge.indices.segments.index-writer-size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.segments.size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.store.size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.docs.count": {
          "type": "gauge",
          "description": "Number of documents in the cluster",
          "group": null,
          "default": true
        },
        "gauge.indices.total.docs.deleted": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.fielddata.memory-size": {
          "type": "gauge",
          "description": "Field data size (bytes)",
          "group": null,
          "default": true
        },
        "gauge.indices.total.filter-cache.memory-size": {
          "type": "gauge",
          "description": "Filter cache size (bytes)",
          "group": null,
          "default": true
        },
        "gauge.indices.total.get.current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.indexing.delete-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.indexing.index-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.merges.current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.merges.current-docs": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.merges.current-size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.search.open-contexts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.search.query-current": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.total.store.size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.translog.uncommitted_operations": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.indices.translog.uncommitted_size_in_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.jvm.mem.heap-committed": {
          "type": "gauge",
          "description": "Total heap committed by the process (bytes)",
          "group": null,
          "default": true
        },
        "gauge.jvm.mem.heap-used": {
          "type": "gauge",
          "description": "Total heap used (bytes)",
          "group": null,
          "default": true
        },
        "gauge.jvm.mem.non-heap-committed": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.jvm.mem.non-heap-used": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.jvm.mem.pools.old.max_in_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.jvm.mem.pools.old.used_in_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.jvm.mem.pools.young.max_in_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.jvm.mem.pools.young.used_in_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.jvm.threads.peak": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.process.cpu.percent": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.process.open_file_descriptors": {
          "type": "gauge",
          "description": "Number of currently open file descriptors",
          "group": null,
          "default": true
        },
        "gauge.thread_pool.active": {
          "type": "gauge",
          "description": "Number of active threads",
          "group": null,
          "default": false
        },
        "gauge.thread_pool.largest": {
          "type": "gauge",
          "description": "Highest active threads in thread pool",
          "group": null,
          "default": false
        },
        "gauge.thread_pool.queue": {
          "type": "gauge",
          "description": "Number of Tasks in thread pool",
          "group": null,
          "default": false
        },
        "gauge.thread_pool.threads": {
          "type": "gauge",
          "description": "Number of Threads in thread pool",
          "group": null,
          "default": false
        },
        "gauge.transport.server_open": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "percent.jvm.mem.heap-used-percent": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/elasticsearch",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "additionalMetrics",
            "doc": "AdditionalMetrics to report on",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "cluster",
            "doc": "Cluster name to which the node belongs. This is an optional config that will override the cluster name fetched from a node and will be used to populate the plugin_instance dimension",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "detailedMetrics",
            "doc": "DetailedMetrics turns on additional metric time series",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableClusterHealth",
            "doc": "EnableClusterHealth enables reporting on the cluster health",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableIndexStats",
            "doc": "EnableIndexStats reports metrics about indexes",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "indexes",
            "doc": "Indexes to report on",
            "default": [
              "_all"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "indexInterval",
            "doc": "IndexInterval is an interval in seconds at which the plugin will report index stats. It must be greater than or equal, and divisible by the Interval configuration",
            "default": 300,
            "required": false,
            "type": "uint",
            "elementKind": ""
          },
          {
            "yamlName": "indexStatsMasterOnly",
            "doc": "IndexStatsMasterOnly sends index stats from the master only",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "indexSummaryOnly",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password used to access elasticsearch stats api",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "protocol",
            "doc": "Protocol used to connect: http or https",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "threadPools",
            "doc": "ThreadPools to report on",
            "default": [
              "search",
              "index"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "username",
            "doc": "Username used to access elasticsearch stats api",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "version",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/etcd",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an etcd key/value store using the [collectd etcd Python plugin](https://github.com/signalfx/collectd-etcd).\n\nRequires etcd 2.0.8 or later.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.etcd.leader.counts.fail",
            "counter.etcd.leader.counts.success",
            "counter.etcd.self.recvappendreq.cnt",
            "counter.etcd.self.sendappendreq.cnt",
            "counter.etcd.store.compareanddelete.fail",
            "counter.etcd.store.compareanddelete.success",
            "counter.etcd.store.compareandswap.fail",
            "counter.etcd.store.compareandswap.success",
            "counter.etcd.store.create.fail",
            "counter.etcd.store.create.success",
            "counter.etcd.store.delete.fail",
            "counter.etcd.store.delete.success",
            "counter.etcd.store.expire.count",
            "counter.etcd.store.gets.fail",
            "counter.etcd.store.gets.success",
            "counter.etcd.store.sets.fail",
            "counter.etcd.store.sets.success",
            "counter.etcd.store.update.fail",
            "counter.etcd.store.update.success",
            "gauge.etcd.leader.latency.average",
            "gauge.etcd.leader.latency.current",
            "gauge.etcd.leader.latency.max",
            "gauge.etcd.leader.latency.min",
            "gauge.etcd.leader.latency.stddev",
            "gauge.etcd.self.recvbandwidth.rate",
            "gauge.etcd.self.recvpkg.rate",
            "gauge.etcd.self.sendbandwidth.rate",
            "gauge.etcd.self.sendpkg.rate",
            "gauge.etcd.store.watchers"
          ]
        }
      },
      "metrics": {
        "counter.etcd.leader.counts.fail": {
          "type": "counter",
          "description": "Total number of failed rpc requests to with a follower",
          "group": null,
          "default": true
        },
        "counter.etcd.leader.counts.success": {
          "type": "counter",
          "description": "Total number of successful rpc requests to with a follower",
          "group": null,
          "default": true
        },
        "counter.etcd.self.recvappendreq.cnt": {
          "type": "counter",
          "description": "Total number of append requests received by a member",
          "group": null,
          "default": true
        },
        "counter.etcd.self.sendappendreq.cnt": {
          "type": "counter",
          "description": "Total number of append requests sent by a member",
          "group": null,
          "default": true
        },
        "counter.etcd.store.compareanddelete.fail": {
          "type": "counter",
          "description": "Total number of failed compare-and-delete operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.compareanddelete.success": {
          "type": "counter",
          "description": "Total number of successful compare-and-delete operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.compareandswap.fail": {
          "type": "counter",
          "description": "Total number of failed compare-and-swap operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.compareandswap.success": {
          "type": "counter",
          "description": "Total number of successful compare-and-swap operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.create.fail": {
          "type": "counter",
          "description": "Total number of failed create operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.create.success": {
          "type": "counter",
          "description": "Total number of successful create operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.delete.fail": {
          "type": "counter",
          "description": "Total number of failed delete operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.delete.success": {
          "type": "counter",
          "description": "Total number of successful delete operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.expire.count": {
          "type": "counter",
          "description": "Total number of items expired due to TTL",
          "group": null,
          "default": true
        },
        "counter.etcd.store.gets.fail": {
          "type": "counter",
          "description": "Total number of failed get operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.gets.success": {
          "type": "counter",
          "description": "Total number of successful get operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.sets.fail": {
          "type": "counter",
          "description": "Total number of failed set operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.sets.success": {
          "type": "counter",
          "description": "Total number of successful set operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.update.fail": {
          "type": "counter",
          "description": "Total number of failed update operations",
          "group": null,
          "default": true
        },
        "counter.etcd.store.update.success": {
          "type": "counter",
          "description": "Total number of successful update operations",
          "group": null,
          "default": true
        },
        "gauge.etcd.leader.latency.average": {
          "type": "gauge",
          "description": "Average latency of a follower with respect to the leader",
          "group": null,
          "default": false
        },
        "gauge.etcd.leader.latency.current": {
          "type": "gauge",
          "description": "Current latency of a follower with respect to the leader",
          "group": null,
          "default": true
        },
        "gauge.etcd.leader.latency.max": {
          "type": "gauge",
          "description": "Max latency of a follower with respect to the leader",
          "group": null,
          "default": false
        },
        "gauge.etcd.leader.latency.min": {
          "type": "gauge",
          "description": "Min latency of a follower with respect to the leader",
          "group": null,
          "default": false
        },
        "gauge.etcd.leader.latency.stddev": {
          "type": "gauge",
          "description": "Std dev latency of a follower with respect to the leader",
          "group": null,
          "default": false
        },
        "gauge.etcd.self.recvbandwidth.rate": {
          "type": "gauge",
          "description": "Bandwidth rate of a follower",
          "group": null,
          "default": true
        },
        "gauge.etcd.self.recvpkg.rate": {
          "type": "gauge",
          "description": "Rate at which a follower receives packages",
          "group": null,
          "default": true
        },
        "gauge.etcd.self.sendbandwidth.rate": {
          "type": "gauge",
          "description": "Bandwidth rate of a leader",
          "group": null,
          "default": true
        },
        "gauge.etcd.self.sendpkg.rate": {
          "type": "gauge",
          "description": "Rate at which a leader sends packages",
          "group": null,
          "default": true
        },
        "gauge.etcd.store.watchers": {
          "type": "gauge",
          "description": "Number of watchers",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/etcd",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "clusterName",
            "doc": "An arbitrary name of the etcd cluster to make it easier to group together and identify instances.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslKeyFile",
            "doc": "Client private key if using client certificate authentication.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslCertificate",
            "doc": "Client public key if using client certificate authentication.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslCACerts",
            "doc": "Certificate authority or host certificate to trust.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "skipSSLValidation",
            "doc": "If `true`, etcd's SSL certificate will not be verified. Enabling this option results in the `sslCACerts` option being ignored.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/genericjmx",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors Java services that expose metrics on JMX using collectd's\nGenericJMX plugin. The GenericJMX plugin reads Managed Beans (MBeans) from\nan MBeanServer using JMX. The monitor uses an embedded Java runtime in\ncollectd via the [Java\nplugin](https://collectd.org/wiki/index.php/Plugin:Java) of collectd.\n\nThe Java Management Extensions (JMX) is a generic framework to provide and\nquery various management information. The interface is used by the Java\nVirtual Machine (JVM) to provide information about the memory used, threads\nand so on. These basic performance values can therefore be collected for\nevery Java process without any support in the Java process itself.\n\nAdvanced Java processes can use the JMX interface to provide performance\ninformation themselves. The Apache Tomcat application server, for example,\nprovides information on the number of requests processed, the number of\nbytes sent, processing time, and thread counts.\n\nSee the following for more information\n- https://collectd.org/documentation/manpages/collectd-java.5.shtml\n- https://collectd.org/wiki/index.php/Plugin:GenericJMX\n\n\u003c!--- SETUP ---\u003e\n### Config Example\nExample (gets the thread count from a standard JMX MBean available on all\nJava JMX-enabled apps):\n\n```yaml\n\nmonitors:\n - type: collectd/genericjmx\n   host: my-java-app\n   port: 7099\n   mBeanDefinitions:\n     threading:\n       objectName: java.lang:type=Threading\n       values:\n       - type: gauge\n         table: false\n         instancePrefix: jvm.threads.count\n         attribute: ThreadCount\n```\n\n\u003c!--- SETUP ---\u003e\n## Troubleshooting\n\nExposing JMX in your Java application can be a tricky process.  Oracle has a\n[helpful guide for Java\n8](https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html)\nthat explains how to expose JMX metrics automatically by setting Java\nproperties on your application.  Here are a set of Java properties that are\nknown to work with Java 7+:\n\n```\njava \\\n  -Dcom.sun.management.jmxremote.port=5000 \\\n  -Dcom.sun.management.jmxremote.authenticate=false \\\n  -Dcom.sun.management.jmxremote.ssl=false \\\n  -Dcom.sun.management.jmxremote.rmi.port=5000 \\\n  ...\n```\n\nThis should work as long as the agent is allowed to access port 5000 on the\nJava app's host (i.e. there is no firewall blocking it).  Note that this\ndoes not enable authentication or encryption, but these can be added if\ndesired.\n\nAssuming you have the `host` config set to `172.17.0.3` and the port set to\n`5000` (this is a totally arbitrary port and your JMX app will probably be\nsomething different), here are some errors you might receive and their\nmeanings:\n\n### Connection Refused\n```\nCreating MBean server connection failed: java.io.IOException: Failed to retrieve RMIServer stub: javax.naming.ServiceUnavailableException [Root exception is java.rmi.ConnectException: Connection refused to host: 172.17.0.3; nested exception is:\n     java.net.ConnectException: Connection refused (Connection refused)]\n```\n\nThis error indicates that the JMX connect port is not open on the specified\nhost.  Confirm (via netstat/ss or some other tool) that this port\nis indeed open on the configured host, and is listening on an appropriate\naddress (i.e. if the agent is running on a remote server then JMX should not\nbe listening on localhost only).\n\n### RMI Connection Issues\n\n```\nCreating MBean server connection failed: java.rmi.ConnectException: Connection refused to host: 172.17.0.3; nested exception is:\n     java.net.ConnectException: Connection timed out (Connection timed out)\n```\n\nThis indicates that the JMX connect port was reached successfully, but the\nRMI port that it was directed to is being blocked, probably by a firewall.\nThe easiest thing to do here is to make sure the\n`com.sun.management.jmxremote.rmi.port` property in your Java app is set to\nthe same port as the JMX connect port.  There may be other variations of\nthis that say `Connection reset` or `Connection refused` but they all\ngeneraly indicate a similar cause.\n",
      "groups": {
        "jvm": {
          "description": "",
          "metrics": [
            "gauge.jvm.threads.count",
            "gauge.loaded_classes",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.init",
            "jmx_memory.max",
            "jmx_memory.used",
            "total_time_in_ms.collection_time"
          ]
        }
      },
      "metrics": {
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "default": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "default": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "pkg/monitors/collectd/genericjmx",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "pkg/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "pkg/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "attributes",
                        "doc": "The plural form of the `attribute` config above.  Used to derive multiple metrics from a single MBean.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/hadoop",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects metrics about a Hadoop 2.0+ cluster using the [collectd Hadoop Python\nplugin](https://github.com/signalfx/collectd-hadoop). If a remote JMX port\nis exposed in the hadoop cluster, then you may also configure the\n[collectd/hadoopjmx](./collectd-hadoopjmx.md) monitor to collect additional\nmetrics about the hadoop cluster.\n\nThe `collectd/hadoop` monitor will collect metrics from the Resource Manager\nREST API for the following:\n- Cluster Metrics\n- Cluster Scheduler\n- Cluster Applications\n- Cluster Nodes\n- MapReduce Jobs\n\n\n\u003c!--- SETUP ---\u003e\n## Metric Endpoints in Hadoop\nSee the following links for more information about specific metric endpoints:\n\n\u003ca target=\"_blank\" href=\"https://hadoop.apache.org/docs/r2.7.4/hadoop-project-dist/hadoop-common/Metrics.html\"\u003ehttps://hadoop.apache.org/docs/r2.7.4/hadoop-project-dist/hadoop-common/Metrics.html\u003c/a\u003e\n\n\u003ca target=\"_blank\" href=\"https://hadoop.apache.org/docs/r2.7.4/hadoop-yarn/hadoop-yarn-site/ResourceManagerRest.html\"\u003ehttps://hadoop.apache.org/docs/r2.7.4/hadoop-yarn/hadoop-yarn-site/ResourceManagerRest.html\u003c/a\u003e\n\n\u003ca target=\"_blank\" href=\"https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapredAppMasterRest.html\"\u003ehttps://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapredAppMasterRest.html\u003c/a\u003e\n\n\u003c!--- SETUP ---\u003e\n## Sample Config\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/hadoop\n  host: 127.0.0.1\n  port: 8088\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.hadoop.cluster.metrics.total_mb",
            "counter.hadoop.cluster.metrics.total_nodes",
            "counter.hadoop.cluster.metrics.total_virtual_cores",
            "gauge.hadoop.cluster.metrics.active_nodes",
            "gauge.hadoop.cluster.metrics.allocated_mb",
            "gauge.hadoop.cluster.metrics.allocated_virtual_cores",
            "gauge.hadoop.cluster.metrics.apps_completed",
            "gauge.hadoop.cluster.metrics.apps_failed",
            "gauge.hadoop.cluster.metrics.apps_killed",
            "gauge.hadoop.cluster.metrics.apps_pending",
            "gauge.hadoop.cluster.metrics.apps_running",
            "gauge.hadoop.cluster.metrics.apps_submitted",
            "gauge.hadoop.cluster.metrics.available_mb",
            "gauge.hadoop.cluster.metrics.available_virtual_cores",
            "gauge.hadoop.cluster.metrics.containers_allocated",
            "gauge.hadoop.cluster.metrics.containers_pending",
            "gauge.hadoop.cluster.metrics.containers_reserved",
            "gauge.hadoop.cluster.metrics.decommissioned_nodes",
            "gauge.hadoop.cluster.metrics.lost_nodes",
            "gauge.hadoop.cluster.metrics.rebooted_nodes",
            "gauge.hadoop.cluster.metrics.reserved_mb",
            "gauge.hadoop.cluster.metrics.reserved_virtual_cores",
            "gauge.hadoop.cluster.metrics.total_mb",
            "gauge.hadoop.cluster.metrics.total_virtual_cores",
            "gauge.hadoop.cluster.metrics.unhealthy_nodes",
            "gauge.hadoop.mapreduce.job.elapsedTime",
            "gauge.hadoop.mapreduce.job.failedMapAttempts",
            "gauge.hadoop.mapreduce.job.failedReduceAttempts",
            "gauge.hadoop.mapreduce.job.mapsTotal",
            "gauge.hadoop.mapreduce.job.successfulMapAttempts",
            "gauge.hadoop.mapreduce.job.successfulReduceAttempts",
            "gauge.hadoop.resource.manager.apps.allocatedMB",
            "gauge.hadoop.resource.manager.apps.allocatedVCores",
            "gauge.hadoop.resource.manager.apps.clusterUsagePercentage",
            "gauge.hadoop.resource.manager.apps.memorySeconds",
            "gauge.hadoop.resource.manager.apps.priority",
            "gauge.hadoop.resource.manager.apps.progress",
            "gauge.hadoop.resource.manager.apps.queueUsagePercentage",
            "gauge.hadoop.resource.manager.apps.runningContainers",
            "gauge.hadoop.resource.manager.apps.vcoreSeconds",
            "gauge.hadoop.resource.manager.nodes.availMemoryMB",
            "gauge.hadoop.resource.manager.nodes.availableVirtualCores",
            "gauge.hadoop.resource.manager.nodes.numContainers",
            "gauge.hadoop.resource.manager.nodes.usedMemoryMB",
            "gauge.hadoop.resource.manager.nodes.usedVirtualCores",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.absoluteCapacity",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.absoluteMaxCapacity",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.absoluteUsedCapacity",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.allocatedContainers",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.capacity",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.maxApplications",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.maxApplicationsPerUser",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.maxCapacity",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.numActiveApplications",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.numApplications",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.numContainers",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.numPendingApplications",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.pendingContainers",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.reservedContainers",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.usedCapacity",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.userLimit",
            "gauge.hadoop.resource.manager.scheduler.leaf.queue.userLimitFactor",
            "gauge.hadoop.resource.manager.scheduler.root.queue.capacity",
            "gauge.hadoop.resource.manager.scheduler.root.queue.maxCapacity",
            "gauge.hadoop.resource.manager.scheduler.root.queue.usedCapacity"
          ]
        },
        "applications": {
          "description": "",
          "metrics": [
            "hadoop.resource.manager.apps.allocatedMB",
            "hadoop.resource.manager.apps.allocatedVCores",
            "hadoop.resource.manager.apps.clusterUsagePercentage",
            "hadoop.resource.manager.apps.memorySeconds",
            "hadoop.resource.manager.apps.numAMContainerPreempted",
            "hadoop.resource.manager.apps.numNonAMContainerPreempted",
            "hadoop.resource.manager.apps.preemptedResourceMB",
            "hadoop.resource.manager.apps.preemptedResourceVCores",
            "hadoop.resource.manager.apps.priority",
            "hadoop.resource.manager.apps.progress",
            "hadoop.resource.manager.apps.queueUsagePercentage",
            "hadoop.resource.manager.apps.runningContainers",
            "hadoop.resource.manager.apps.vcoreSeconds"
          ]
        },
        "cluster": {
          "description": "",
          "metrics": [
            "hadoop.cluster.metrics.active_nodes",
            "hadoop.cluster.metrics.allocated_mb",
            "hadoop.cluster.metrics.allocated_virtual_cores",
            "hadoop.cluster.metrics.apps_completed",
            "hadoop.cluster.metrics.apps_failed",
            "hadoop.cluster.metrics.apps_killed",
            "hadoop.cluster.metrics.apps_pending",
            "hadoop.cluster.metrics.apps_running",
            "hadoop.cluster.metrics.apps_submitted",
            "hadoop.cluster.metrics.available_mb",
            "hadoop.cluster.metrics.available_virtual_cores",
            "hadoop.cluster.metrics.containers_allocated",
            "hadoop.cluster.metrics.containers_pending",
            "hadoop.cluster.metrics.containers_reserved",
            "hadoop.cluster.metrics.decommissioned_nodes",
            "hadoop.cluster.metrics.lost_nodes",
            "hadoop.cluster.metrics.rebooted_nodes",
            "hadoop.cluster.metrics.reserved_mb",
            "hadoop.cluster.metrics.reserved_virtual_cores",
            "hadoop.cluster.metrics.total_mb",
            "hadoop.cluster.metrics.total_nodes",
            "hadoop.cluster.metrics.total_virtual_cores",
            "hadoop.cluster.metrics.unhealthy_nodes"
          ]
        },
        "fifo-scheduler": {
          "description": "",
          "metrics": [
            "hadoop.resource.manager.scheduler.fifo.availNodeCapacity",
            "hadoop.resource.manager.scheduler.fifo.capacity",
            "hadoop.resource.manager.scheduler.fifo.maxQueueMemoryCapacity",
            "hadoop.resource.manager.scheduler.fifo.minQueueMemoryCapacity",
            "hadoop.resource.manager.scheduler.fifo.numContainers",
            "hadoop.resource.manager.scheduler.fifo.numNodes",
            "hadoop.resource.manager.scheduler.fifo.totalNodeCapacity",
            "hadoop.resource.manager.scheduler.fifo.usedCapacity",
            "hadoop.resource.manager.scheduler.fifo.usedNodeCapacity"
          ]
        },
        "leaf-queue": {
          "description": "",
          "metrics": [
            "hadoop.resource.manager.scheduler.leaf.queue.absoluteCapacity",
            "hadoop.resource.manager.scheduler.leaf.queue.absoluteMaxCapacity",
            "hadoop.resource.manager.scheduler.leaf.queue.absoluteUsedCapacity",
            "hadoop.resource.manager.scheduler.leaf.queue.allocatedContainers",
            "hadoop.resource.manager.scheduler.leaf.queue.capacity",
            "hadoop.resource.manager.scheduler.leaf.queue.maxActiveApplications",
            "hadoop.resource.manager.scheduler.leaf.queue.maxActiveApplicationsPerUser",
            "hadoop.resource.manager.scheduler.leaf.queue.maxApplications",
            "hadoop.resource.manager.scheduler.leaf.queue.maxApplicationsPerUser",
            "hadoop.resource.manager.scheduler.leaf.queue.maxCapacity",
            "hadoop.resource.manager.scheduler.leaf.queue.numActiveApplications",
            "hadoop.resource.manager.scheduler.leaf.queue.numApplications",
            "hadoop.resource.manager.scheduler.leaf.queue.numContainers",
            "hadoop.resource.manager.scheduler.leaf.queue.numPendingApplications",
            "hadoop.resource.manager.scheduler.leaf.queue.pendingContainers",
            "hadoop.resource.manager.scheduler.leaf.queue.reservedContainers",
            "hadoop.resource.manager.scheduler.leaf.queue.usedCapacity",
            "hadoop.resource.manager.scheduler.leaf.queue.userLimit",
            "hadoop.resource.manager.scheduler.leaf.queue.userLimitFactor"
          ]
        },
        "mapreduce-jobs": {
          "description": "",
          "metrics": [
            "hadoop.mapreduce.job.elapsedTime",
            "hadoop.mapreduce.job.failedMapAttempts",
            "hadoop.mapreduce.job.failedReduceAttempts",
            "hadoop.mapreduce.job.killedMapAttempts",
            "hadoop.mapreduce.job.killedReduceAttempts",
            "hadoop.mapreduce.job.mapsCompleted",
            "hadoop.mapreduce.job.mapsPending",
            "hadoop.mapreduce.job.mapsRunning",
            "hadoop.mapreduce.job.mapsTotal",
            "hadoop.mapreduce.job.newMapAttempts",
            "hadoop.mapreduce.job.newReduceAttempts",
            "hadoop.mapreduce.job.reducesCompleted",
            "hadoop.mapreduce.job.reducesPending",
            "hadoop.mapreduce.job.reducesTotal",
            "hadoop.mapreduce.job.runningMapAttempts",
            "hadoop.mapreduce.job.runningReduceAttempts",
            "hadoop.mapreduce.job.successfulMapAttempts",
            "hadoop.mapreduce.job.successfulReduceAttempts"
          ]
        },
        "node-resources": {
          "description": "",
          "metrics": [
            "hadoop.resource.manager.node.nodeCPUUsage",
            "hadoop.resource.manager.node.nodePhysicalMemoryMB",
            "hadoop.resource.manager.node.nodeVirtualMemoryMB"
          ]
        },
        "nodes": {
          "description": "",
          "metrics": [
            "hadoop.resource.manager.nodes.availMemoryMB",
            "hadoop.resource.manager.nodes.availableVirtualCores",
            "hadoop.resource.manager.nodes.numContainers",
            "hadoop.resource.manager.nodes.usedMemoryMB",
            "hadoop.resource.manager.nodes.usedVirtualCores"
          ]
        },
        "queue-users": {
          "description": "",
          "metrics": [
            "hadoop.resource.manager.scheduler.queue.users.numActiveApplications",
            "hadoop.resource.manager.scheduler.queue.users.numPendingApplications"
          ]
        },
        "resource-objects": {
          "description": "",
          "metrics": [
            "hadoop.resource.manager.scheduler.queue.resource.memory",
            "hadoop.resource.manager.scheduler.queue.resource.vCores"
          ]
        },
        "root-queue": {
          "description": "",
          "metrics": [
            "hadoop.resource.manager.scheduler.root.queue.capacity",
            "hadoop.resource.manager.scheduler.root.queue.maxCapacity",
            "hadoop.resource.manager.scheduler.root.queue.usedCapacity"
          ]
        }
      },
      "metrics": {
        "counter.hadoop.cluster.metrics.total_mb": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.hadoop.cluster.metrics.total_nodes": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.hadoop.cluster.metrics.total_virtual_cores": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.cluster.metrics.active_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.allocated_mb": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.allocated_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.apps_completed": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.apps_failed": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.apps_killed": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.cluster.metrics.apps_pending": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.cluster.metrics.apps_running": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.apps_submitted": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.available_mb": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.available_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.containers_allocated": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.cluster.metrics.containers_pending": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.cluster.metrics.containers_reserved": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.cluster.metrics.decommissioned_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.lost_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.rebooted_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.reserved_mb": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.reserved_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.total_mb": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.total_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.cluster.metrics.unhealthy_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.mapreduce.job.elapsedTime": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.mapreduce.job.failedMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.mapreduce.job.failedReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.mapreduce.job.mapsTotal": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.mapreduce.job.successfulMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.mapreduce.job.successfulReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.allocatedMB": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.allocatedVCores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.clusterUsagePercentage": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.memorySeconds": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.priority": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.progress": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.queueUsagePercentage": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.runningContainers": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.apps.vcoreSeconds": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.nodes.availMemoryMB": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.nodes.availableVirtualCores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.nodes.numContainers": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.nodes.usedMemoryMB": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.nodes.usedVirtualCores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.absoluteCapacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.absoluteMaxCapacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.absoluteUsedCapacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.allocatedContainers": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.capacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.maxApplications": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.maxApplicationsPerUser": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.maxCapacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.numActiveApplications": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.numApplications": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.numContainers": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.numPendingApplications": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.pendingContainers": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.reservedContainers": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.usedCapacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.userLimit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.userLimitFactor": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.root.queue.capacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.root.queue.maxCapacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.hadoop.resource.manager.scheduler.root.queue.usedCapacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "hadoop.cluster.metrics.active_nodes": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.allocated_mb": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.allocated_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.apps_completed": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.apps_failed": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.apps_killed": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.apps_pending": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.apps_running": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.apps_submitted": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.available_mb": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.available_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.containers_allocated": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.containers_pending": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.containers_reserved": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.decommissioned_nodes": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.lost_nodes": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.rebooted_nodes": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.reserved_mb": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.reserved_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.total_mb": {
          "type": "counter",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.total_nodes": {
          "type": "counter",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.total_virtual_cores": {
          "type": "counter",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.cluster.metrics.unhealthy_nodes": {
          "type": "gauge",
          "description": "",
          "group": "cluster",
          "default": false
        },
        "hadoop.mapreduce.job.elapsedTime": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.failedMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.failedReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.killedMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.killedReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.mapsCompleted": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.mapsPending": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.mapsRunning": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.mapsTotal": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.newMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.newReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.reducesCompleted": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.reducesPending": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.reducesTotal": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.runningMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.runningReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.successfulMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.mapreduce.job.successfulReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": "mapreduce-jobs",
          "default": false
        },
        "hadoop.resource.manager.apps.allocatedMB": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.allocatedVCores": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.clusterUsagePercentage": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.memorySeconds": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.numAMContainerPreempted": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.numNonAMContainerPreempted": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.preemptedResourceMB": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.preemptedResourceVCores": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.priority": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.progress": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.queueUsagePercentage": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.runningContainers": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.apps.vcoreSeconds": {
          "type": "gauge",
          "description": "",
          "group": "applications",
          "default": false
        },
        "hadoop.resource.manager.node.nodeCPUUsage": {
          "type": "gauge",
          "description": "",
          "group": "node-resources",
          "default": false
        },
        "hadoop.resource.manager.node.nodePhysicalMemoryMB": {
          "type": "gauge",
          "description": "",
          "group": "node-resources",
          "default": false
        },
        "hadoop.resource.manager.node.nodeVirtualMemoryMB": {
          "type": "gauge",
          "description": "",
          "group": "node-resources",
          "default": false
        },
        "hadoop.resource.manager.nodes.availMemoryMB": {
          "type": "gauge",
          "description": "",
          "group": "nodes",
          "default": false
        },
        "hadoop.resource.manager.nodes.availableVirtualCores": {
          "type": "gauge",
          "description": "",
          "group": "nodes",
          "default": false
        },
        "hadoop.resource.manager.nodes.numContainers": {
          "type": "gauge",
          "description": "",
          "group": "nodes",
          "default": false
        },
        "hadoop.resource.manager.nodes.usedMemoryMB": {
          "type": "gauge",
          "description": "",
          "group": "nodes",
          "default": false
        },
        "hadoop.resource.manager.nodes.usedVirtualCores": {
          "type": "gauge",
          "description": "",
          "group": "nodes",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.availNodeCapacity": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.capacity": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.maxQueueMemoryCapacity": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.minQueueMemoryCapacity": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.numContainers": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.numNodes": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.totalNodeCapacity": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.usedCapacity": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.fifo.usedNodeCapacity": {
          "type": "gauge",
          "description": "",
          "group": "fifo-scheduler",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.absoluteCapacity": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.absoluteMaxCapacity": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.absoluteUsedCapacity": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.allocatedContainers": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.capacity": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.maxActiveApplications": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.maxActiveApplicationsPerUser": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.maxApplications": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.maxApplicationsPerUser": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.maxCapacity": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.numActiveApplications": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.numApplications": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.numContainers": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.numPendingApplications": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.pendingContainers": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.reservedContainers": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.usedCapacity": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.userLimit": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.leaf.queue.userLimitFactor": {
          "type": "gauge",
          "description": "",
          "group": "leaf-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.queue.resource.memory": {
          "type": "gauge",
          "description": "",
          "group": "resource-objects",
          "default": false
        },
        "hadoop.resource.manager.scheduler.queue.resource.vCores": {
          "type": "gauge",
          "description": "",
          "group": "resource-objects",
          "default": false
        },
        "hadoop.resource.manager.scheduler.queue.users.numActiveApplications": {
          "type": "gauge",
          "description": "",
          "group": "queue-users",
          "default": false
        },
        "hadoop.resource.manager.scheduler.queue.users.numPendingApplications": {
          "type": "gauge",
          "description": "",
          "group": "queue-users",
          "default": false
        },
        "hadoop.resource.manager.scheduler.root.queue.capacity": {
          "type": "gauge",
          "description": "",
          "group": "root-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.root.queue.maxCapacity": {
          "type": "gauge",
          "description": "",
          "group": "root-queue",
          "default": false
        },
        "hadoop.resource.manager.scheduler.root.queue.usedCapacity": {
          "type": "gauge",
          "description": "",
          "group": "root-queue",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/hadoop",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Resource Manager Hostname",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Resource Manager Port",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "verbose",
            "doc": "Log verbose information about the plugin",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/hadoopjmx",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects metrics about a Hadoop 2.0+ cluster using using collectd's GenericJMX\nplugin. You may also configure the\n[collectd/hadoop](https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/collectd-hadoop.md)\nmonitor to collect additional metrics about the hadoop cluster from the\nREST API\n\nTo enable JMX in Hadoop, add the following JVM options to hadoop-env.sh and yarn-env.sh respectively\n\n**hadoop-env.sh:**\n```sh\nexport HADOOP_NAMENODE_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5677 $HADOOP_NAMENODE_OPTS\"\nexport HADOOP_DATANODE_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5679 $HADOOP_DATANODE_OPTS\"\n```\n\n**yarn-env.sh:**\n```sh\nexport YARN_NODEMANAGER_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=8002 $YARN_NODEMANAGER_OPTS\"\nexport YARN_RESOURCEMANAGER_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5680 $YARN_RESOURCEMANAGER_OPTS\"\n```\n\nThis monitor has a set of built in MBeans configured for:\n  - [Name Nodes](https://github.com/signalfx/signalfx-agent/tree/master/pkg/monitors/collectd/hadoopjmx/nameNodeMBeans.go)\n  - [Resource Manager](https://github.com/signalfx/signalfx-agent/tree/master/pkg/monitors/collectd/hadoopjmx/resourceManagerMBeans.go)\n  - [Node Manager](https://github.com/signalfx/signalfx-agent/tree/master/pkg/monitors/collectd/hadoopjmx/nodeManagerMBeans.go)\n  - [Data Nodes](https://github.com/signalfx/signalfx-agent/tree/master/pkg/monitors/collectd/hadoopjmx/dataNodeMBeans.go)\n\nSample YAML configuration:\n\nName Node\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5677\n  nodeType: nameNode\n```\n\nResource Manager\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5680\n  nodeType: resourceManager\n```\n\nNode Manager\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 8002\n  nodeType: nodeManager\n```\n\nData Node\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5679\n  nodeType: dataNode\n```\n",
      "groups": {
        "data-node": {
          "description": "Metrics for DataNodes containing HDFS files",
          "metrics": [
            "counter.hadoop-datanode-blocks-read",
            "counter.hadoop-datanode-blocks-written",
            "counter.hadoop-datanode-bytes-read",
            "counter.hadoop-datanode-bytes-written",
            "gauge.hadoop-datanode-fs-capacity",
            "gauge.hadoop-datanode-fs-dfs-remaining",
            "gauge.hadoop-datanode-fs-dfs-used",
            "gauge.hadoop-datanode-info-xceiver",
            "gauge.hadoop-datanode-jvm-heap-used",
            "gauge.hadoop-datanode-jvm-non-heap-used",
            "gauge.hadoop-datanode-rpc-call-queue-length",
            "gauge.hadoop-datanode-rpc-open-connections",
            "gauge.hadoop-datanode-rpc-processing-avg",
            "gauge.hadoop-datanode-rpc-queue-time-avg"
          ]
        },
        "jvm": {
          "description": "JVM metrics",
          "metrics": [
            "gauge.jvm.threads.count",
            "gauge.loaded_classes",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.init",
            "jmx_memory.max",
            "jmx_memory.used",
            "total_time_in_ms.collection_time"
          ]
        },
        "name-node": {
          "description": "Metrics for NameNodes containing HDFS metadata",
          "metrics": [
            "counter.hadoop-namenode-files-total",
            "counter.hadoop-namenode-gc-count",
            "counter.hadoop-namenode-gc-time",
            "counter.hadoop-namenode-rpc-total-calls",
            "counter.hadoop-namenode-total-load",
            "counter.hadoop-namenode-volume-failures",
            "gauge.hadoop-namenode-blocks-with-corrupt-replicas",
            "gauge.hadoop-namenode-capacity-remaining",
            "gauge.hadoop-namenode-capacity-total",
            "gauge.hadoop-namenode-capacity-used",
            "gauge.hadoop-namenode-corrupt-blocks",
            "gauge.hadoop-namenode-current-heap-used",
            "gauge.hadoop-namenode-dead-datanodes",
            "gauge.hadoop-namenode-dfs-free",
            "gauge.hadoop-namenode-live-datanodes",
            "gauge.hadoop-namenode-max-heap",
            "gauge.hadoop-namenode-missing-blocks",
            "gauge.hadoop-namenode-percent-dfs-used",
            "gauge.hadoop-namenode-percent-remaining",
            "gauge.hadoop-namenode-rpc-avg-process-time",
            "gauge.hadoop-namenode-rpc-avg-queue",
            "gauge.hadoop-namenode-stale-datanodes",
            "gauge.hadoop-namenode-under-replicated-blocks"
          ]
        },
        "node-manager": {
          "description": "Metrics for Node Manager",
          "metrics": [
            "counter.hadoop-nodeManager-containers-failed",
            "counter.hadoop-nodeManager-containers-launched",
            "gauge.hadoop-nodeManager-allocated-memory",
            "gauge.hadoop-nodeManager-allocated-vcores",
            "gauge.hadoop-nodeManager-available-memory",
            "gauge.hadoop-nodeManager-available-vcores"
          ]
        },
        "resource-manager": {
          "description": "Metrics for Hadoop resource management",
          "metrics": [
            "gauge.hadoop-resourceManager-active-apps",
            "gauge.hadoop-resourceManager-active-nms",
            "gauge.hadoop-resourceManager-active-users",
            "gauge.hadoop-resourceManager-allocated-containers",
            "gauge.hadoop-resourceManager-allocated-memory",
            "gauge.hadoop-resourceManager-allocated-vcores",
            "gauge.hadoop-resourceManager-available-memory",
            "gauge.hadoop-resourceManager-available-vcores",
            "gauge.hadoop-resourceManager-heap-max",
            "gauge.hadoop-resourceManager-heap-used"
          ]
        }
      },
      "metrics": {
        "counter.hadoop-datanode-blocks-read": {
          "type": "cumulative",
          "description": "",
          "group": "data-node",
          "default": false
        },
        "counter.hadoop-datanode-blocks-written": {
          "type": "cumulative",
          "description": "",
          "group": "data-node",
          "default": false
        },
        "counter.hadoop-datanode-bytes-read": {
          "type": "cumulative",
          "description": "",
          "group": "data-node",
          "default": false
        },
        "counter.hadoop-datanode-bytes-written": {
          "type": "cumulative",
          "description": "",
          "group": "data-node",
          "default": false
        },
        "counter.hadoop-namenode-files-total": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "default": false
        },
        "counter.hadoop-namenode-gc-count": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "counter.hadoop-namenode-gc-time": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "counter.hadoop-namenode-rpc-total-calls": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "counter.hadoop-namenode-total-load": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "counter.hadoop-namenode-volume-failures": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "counter.hadoop-nodeManager-containers-failed": {
          "type": "cumulative",
          "description": "",
          "group": "node-manager",
          "default": false
        },
        "counter.hadoop-nodeManager-containers-launched": {
          "type": "cumulative",
          "description": "",
          "group": "node-manager",
          "default": false
        },
        "gauge.hadoop-datanode-fs-capacity": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": true
        },
        "gauge.hadoop-datanode-fs-dfs-remaining": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": true
        },
        "gauge.hadoop-datanode-fs-dfs-used": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": true
        },
        "gauge.hadoop-datanode-info-xceiver": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": false
        },
        "gauge.hadoop-datanode-jvm-heap-used": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": true
        },
        "gauge.hadoop-datanode-jvm-non-heap-used": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": false
        },
        "gauge.hadoop-datanode-rpc-call-queue-length": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": true
        },
        "gauge.hadoop-datanode-rpc-open-connections": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": true
        },
        "gauge.hadoop-datanode-rpc-processing-avg": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": true
        },
        "gauge.hadoop-datanode-rpc-queue-time-avg": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "default": true
        },
        "gauge.hadoop-namenode-blocks-with-corrupt-replicas": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": false
        },
        "gauge.hadoop-namenode-capacity-remaining": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": false
        },
        "gauge.hadoop-namenode-capacity-total": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-capacity-used": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-corrupt-blocks": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": false
        },
        "gauge.hadoop-namenode-current-heap-used": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-dead-datanodes": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-dfs-free": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-live-datanodes": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-max-heap": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-missing-blocks": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": false
        },
        "gauge.hadoop-namenode-percent-dfs-used": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": false
        },
        "gauge.hadoop-namenode-percent-remaining": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-rpc-avg-process-time": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-rpc-avg-queue": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-namenode-stale-datanodes": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": false
        },
        "gauge.hadoop-namenode-under-replicated-blocks": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "default": true
        },
        "gauge.hadoop-nodeManager-allocated-memory": {
          "type": "gauge",
          "description": "",
          "group": "node-manager",
          "default": false
        },
        "gauge.hadoop-nodeManager-allocated-vcores": {
          "type": "gauge",
          "description": "",
          "group": "node-manager",
          "default": false
        },
        "gauge.hadoop-nodeManager-available-memory": {
          "type": "gauge",
          "description": "",
          "group": "node-manager",
          "default": false
        },
        "gauge.hadoop-nodeManager-available-vcores": {
          "type": "gauge",
          "description": "",
          "group": "node-manager",
          "default": false
        },
        "gauge.hadoop-resourceManager-active-apps": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": false
        },
        "gauge.hadoop-resourceManager-active-nms": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": false
        },
        "gauge.hadoop-resourceManager-active-users": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": false
        },
        "gauge.hadoop-resourceManager-allocated-containers": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": false
        },
        "gauge.hadoop-resourceManager-allocated-memory": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": false
        },
        "gauge.hadoop-resourceManager-allocated-vcores": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": true
        },
        "gauge.hadoop-resourceManager-available-memory": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": false
        },
        "gauge.hadoop-resourceManager-available-vcores": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": true
        },
        "gauge.hadoop-resourceManager-heap-max": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": false
        },
        "gauge.hadoop-resourceManager-heap-used": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "default": false
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "default": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "default": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/hadoopjmx",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "pkg/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "pkg/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "attributes",
                        "doc": "The plural form of the `attribute` config above.  Used to derive multiple metrics from a single MBean.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          },
          {
            "yamlName": "nodeType",
            "doc": "Hadoop Node Type",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/haproxy",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitors an [HAProxy](http://www.haproxy.org/) instance.  Requires HAProxy 1.5+.\n\n\u003c!--- SETUP ---\u003e\n### Socket Config\nThe location of the HAProxy socket file is defined in the HAProxy config file, as in the following example:\n\n```\nglobal\n    daemon\n    stats socket /var/run/haproxy.sock\n    stats timeout 2m\n```\n\nNote: it is possible to use a tcp socket for stats in HAProxy. Users will\nfirst need to define in their collectd-haproxy plugin config file the tcp\naddress for the socket, for example `localhost:9000`, and then in the\nhaproxy.cfg file change the stats socket to listen on the same address\n```\nglobal\n    daemon\n    stats socket localhost:9000\n    stats timeout 2m\n```\n\nFor a more restricted tcp socket, a backend server can be defined to listen\nto stats on localhost. A frontend proxy can use the backend server on a\ndifferent port, with ACLs to restrict access. See below for example.\nDepending on how restrictive your socket is, you may need to add the\nsignalfx-agent user to the haproxy group:\n`sudo usermod -a -G haproxy signalfx-agent`\n\n```\nglobal\n    daemon\n    stats socket localhost:9000\n    stats timeout 2m\n\nbackend stats-backend\n    mode tcp\n    server stats-localhost localhost:9000\n\nfrontend stats-frontend\n    bind *:9001\n    default_backend stats-backend\n    acl ...\n    acl ...\n```\n\n\u003c!--- SETUP ---\u003e\n### SELinux Setup\n\nIf you have SELinux enabled, create a SELinux policy package downloading\nthe [type enforcement\nfile](https://github.com/signalfx/collectd-haproxy/blob/master/selinux/collectd-haproxy.te)\nto some place on your server.  Run the commands below to create and install\nthe policy package.\n\n    $ checkmodule -M -m -o collectd-haproxy.mod collectd-haproxy.te\n    checkmodule:  loading policy configuration from collectd-haproxy.te\n    checkmodule:  policy configuration loaded\n    checkmodule:  writing binary representation (version 17) to collectd-haproxy.mod\n    $ semodule_package -o collectd-haproxy.pp -m collectd-haproxy.mod\n    $ sudo semodule -i collectd-haproxy.pp\n    $ sudo reboot\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.connection_total",
            "counter.server_selected_total",
            "derive.bytes_in",
            "derive.bytes_out",
            "derive.cli_abrt",
            "derive.comp_byp",
            "derive.comp_in",
            "derive.comp_out",
            "derive.comp_rsp",
            "derive.compress_bps_in",
            "derive.compress_bps_out",
            "derive.connections",
            "derive.denied_request",
            "derive.denied_response",
            "derive.downtime",
            "derive.error_connection",
            "derive.error_request",
            "derive.error_response",
            "derive.failed_checks",
            "derive.redispatched",
            "derive.request_total",
            "derive.requests",
            "derive.response_1xx",
            "derive.response_2xx",
            "derive.response_3xx",
            "derive.response_4xx",
            "derive.response_5xx",
            "derive.response_other",
            "derive.retries",
            "derive.session_total",
            "derive.srv_abrt",
            "derive.ssl_cache_lookups",
            "derive.ssl_cache_misses",
            "derive.ssl_connections",
            "derive.uptime_seconds",
            "gauge.active_servers",
            "gauge.backup_servers",
            "gauge.check_duration",
            "gauge.connection_rate",
            "gauge.connection_rate_max",
            "gauge.current_connections",
            "gauge.current_ssl_connections",
            "gauge.denied_tcp_connections",
            "gauge.denied_tcp_sessions",
            "gauge.idle_pct",
            "gauge.intercepted_requests",
            "gauge.last_session",
            "gauge.max_connection_rate",
            "gauge.max_connections",
            "gauge.max_pipes",
            "gauge.max_session_rate",
            "gauge.max_ssl_connections",
            "gauge.pipes_free",
            "gauge.pipes_used",
            "gauge.queue_current",
            "gauge.queue_limit",
            "gauge.queue_max",
            "gauge.queue_time_avg",
            "gauge.request_rate",
            "gauge.request_rate_max",
            "gauge.response_time_avg",
            "gauge.run_queue",
            "gauge.session_current",
            "gauge.session_rate",
            "gauge.session_rate_all",
            "gauge.session_rate_limit",
            "gauge.session_rate_max",
            "gauge.session_time_average",
            "gauge.session_time_avg",
            "gauge.ssl_backend_key_rate",
            "gauge.ssl_frontend_key_rate",
            "gauge.ssl_rate",
            "gauge.tasks",
            "gauge.throttle",
            "gauge.zlib_mem_usage"
          ]
        }
      },
      "metrics": {
        "counter.connection_total": {
          "type": "counter",
          "description": "Cumulative number of connections (frontend). This corresponds to HAProxy's \"conn_tot\" metric.",
          "group": null,
          "default": false
        },
        "counter.server_selected_total": {
          "type": "counter",
          "description": "Number of times a server was selected, either for new sessions or when re-dispatching. This corresponds to HAProxy's \"lbtot\" metric.",
          "group": null,
          "default": true
        },
        "derive.bytes_in": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `bin` metric -  Bytes in",
          "group": null,
          "default": true
        },
        "derive.bytes_out": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `bout` metric -  Bytes out",
          "group": null,
          "default": true
        },
        "derive.cli_abrt": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `cli_abrt` metric -  Number of data transfers aborted by the client",
          "group": null,
          "default": false
        },
        "derive.comp_byp": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_byp` metric -  Number of bytes that bypassed the HTTP compressor (CPU/BW limit)",
          "group": null,
          "default": false
        },
        "derive.comp_in": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_in` metric -  Number of HTTP response bytes fed to the compressor",
          "group": null,
          "default": false
        },
        "derive.comp_out": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_out` metric -  Number of HTTP response bytes emitted by the compressor",
          "group": null,
          "default": false
        },
        "derive.comp_rsp": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_rsp` metric -  Number of HTTP responses that were compressed",
          "group": null,
          "default": false
        },
        "derive.compress_bps_in": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CompressBpsIn` metric.",
          "group": null,
          "default": false
        },
        "derive.compress_bps_out": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CompressBpsOut` metric.",
          "group": null,
          "default": false
        },
        "derive.connections": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumConns` metric. Cumulative number of connections.",
          "group": null,
          "default": false
        },
        "derive.denied_request": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `dreq` metric -  Requests denied because of security concerns. - For tcp this is because of a matched tcp-request content rule.",
          "group": null,
          "default": true
        },
        "derive.denied_response": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `dresp` metric -  Responses denied because of security concerns. - For http this is because of a matched http-request rule, or",
          "group": null,
          "default": true
        },
        "derive.downtime": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `downtime` metric -  Total downtime (in seconds). The value for the backend is the downtime for the whole backend, not the sum of the server downtime.",
          "group": null,
          "default": false
        },
        "derive.error_connection": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `econ` metric -  Number of requests that encountered an error trying to connect to a backend server. The backend stat is the sum of the stat",
          "group": null,
          "default": true
        },
        "derive.error_request": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `ereq` metric -  Request errors.",
          "group": null,
          "default": true
        },
        "derive.error_response": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `eresp` metric -  Response errors. srv_abrt will be counted here also. Responses denied because of security concerns.",
          "group": null,
          "default": true
        },
        "derive.failed_checks": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `chkfail` metric -  Number of failed checks. (Only counts checks failed when the server is up.)",
          "group": null,
          "default": false
        },
        "derive.redispatched": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `wredis` metric -  Number of times a request was redispatched to another server. The server value counts the number of times that server was",
          "group": null,
          "default": true
        },
        "derive.request_total": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `req_tot` metric -  Total number of HTTP requests received",
          "group": null,
          "default": false
        },
        "derive.requests": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumReq` metric.",
          "group": null,
          "default": true
        },
        "derive.response_1xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_1xx` metric -  Http responses with 1xx code",
          "group": null,
          "default": false
        },
        "derive.response_2xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_2xx` metric -  Http responses with 2xx code",
          "group": null,
          "default": true
        },
        "derive.response_3xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_3xx` metric -  Http responses with 3xx code",
          "group": null,
          "default": false
        },
        "derive.response_4xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_4xx` metric -  Http responses with 4xx code",
          "group": null,
          "default": true
        },
        "derive.response_5xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_5xx` metric -  Http responses with 5xx code",
          "group": null,
          "default": true
        },
        "derive.response_other": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_other` metric -  Http responses with other codes (protocol error)",
          "group": null,
          "default": false
        },
        "derive.retries": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `wretr` metric -  Number of times a connection to a server was retried.",
          "group": null,
          "default": true
        },
        "derive.session_total": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `stot` metric -  Cumulative number of connections",
          "group": null,
          "default": false
        },
        "derive.srv_abrt": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `srv_abrt` metric -  Number of data transfers aborted by the server (inc. in eresp)",
          "group": null,
          "default": false
        },
        "derive.ssl_cache_lookups": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `SslCacheLookups` metric.",
          "group": null,
          "default": false
        },
        "derive.ssl_cache_misses": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `SslCacheMisses` metric.",
          "group": null,
          "default": false
        },
        "derive.ssl_connections": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumSslConns` metric.",
          "group": null,
          "default": false
        },
        "derive.uptime_seconds": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `Uptime_sec` metric.",
          "group": null,
          "default": false
        },
        "gauge.active_servers": {
          "type": "gauge",
          "description": "Number of active servers. This corresponds to HAProxy's \"act\" metric.",
          "group": null,
          "default": false
        },
        "gauge.backup_servers": {
          "type": "gauge",
          "description": "Number of backup servers. This corresponds to HAProxy's \"bck\" metric.",
          "group": null,
          "default": false
        },
        "gauge.check_duration": {
          "type": "gauge",
          "description": "Time in ms took to finish to last health check. This corresponds to HAProxy's \"check_duration\" metric.",
          "group": null,
          "default": false
        },
        "gauge.connection_rate": {
          "type": "gauge",
          "description": "Number of connections over the last elapsed second (frontend). This corresponds to HAProxy's \"conn_rate\" metric.",
          "group": null,
          "default": true
        },
        "gauge.connection_rate_max": {
          "type": "gauge",
          "description": "Highest known connection rate. This corresponds to HAProxy's \"conn_rate_max\" metric.",
          "group": null,
          "default": false
        },
        "gauge.current_connections": {
          "type": "gauge",
          "description": "Current number of connections. Corresponds to HAProxy's `CurrConns` metric.",
          "group": null,
          "default": false
        },
        "gauge.current_ssl_connections": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `CurrSslConns` metric.",
          "group": null,
          "default": false
        },
        "gauge.denied_tcp_connections": {
          "type": "gauge",
          "description": "Requests denied by 'tcp-request connection' rules. This corresponds to HAProxy's \"dcon\" metric.",
          "group": null,
          "default": false
        },
        "gauge.denied_tcp_sessions": {
          "type": "gauge",
          "description": "Requests denied by 'tcp-request session' rules. This corresponds to HAProxy's \"dses\" metric.",
          "group": null,
          "default": false
        },
        "gauge.idle_pct": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's \"Idle_pct\" metric. Ratio of system polling time versus total time.",
          "group": null,
          "default": true
        },
        "gauge.intercepted_requests": {
          "type": "gauge",
          "description": "Cumulative number of intercepted requests, corresponds to HAProxys metric 'intercepted'",
          "group": null,
          "default": false
        },
        "gauge.last_session": {
          "type": "gauge",
          "description": "Number of seconds since last session was assigned to server/backend. This corresponds to HAProxy's \"lastsess\" metric.",
          "group": null,
          "default": false
        },
        "gauge.max_connection_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxConnRate` metric.",
          "group": null,
          "default": false
        },
        "gauge.max_connections": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxConn` metric.",
          "group": null,
          "default": false
        },
        "gauge.max_pipes": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxPipes` metric.",
          "group": null,
          "default": false
        },
        "gauge.max_session_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxSessRate` metric.",
          "group": null,
          "default": false
        },
        "gauge.max_ssl_connections": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxSslConns` metric.",
          "group": null,
          "default": false
        },
        "gauge.pipes_free": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `PipesFree` metric.",
          "group": null,
          "default": false
        },
        "gauge.pipes_used": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `PipesUsed` metric.",
          "group": null,
          "default": false
        },
        "gauge.queue_current": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `qcur` metric -  Current queued requests. For the backend this reports the number queued without a server assigned.",
          "group": null,
          "default": true
        },
        "gauge.queue_limit": {
          "type": "gauge",
          "description": "Configured max queue for the server, 0 being no limit. Corresponds to HAProxy's \"qlimit\" metric.",
          "group": null,
          "default": false
        },
        "gauge.queue_max": {
          "type": "gauge",
          "description": "Max number of queued requests, queue_current, corresponds to HAProxy's 'qmax' metric.",
          "group": null,
          "default": false
        },
        "gauge.queue_time_avg": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.request_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `req_rate` metric -  HTTP requests per second over last elapsed second",
          "group": null,
          "default": true
        },
        "gauge.request_rate_max": {
          "type": "gauge",
          "description": "Max number of HTTP requests per second observed. Corresponds to HAProxy's \"req_rate_max\" metric.",
          "group": null,
          "default": false
        },
        "gauge.response_time_avg": {
          "type": "gauge",
          "description": "Average total session time in ms over the last 1024 requests. Corresponds to HAProxy's \"ttime\" metric.",
          "group": null,
          "default": true
        },
        "gauge.run_queue": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `Run_queue` metric.",
          "group": null,
          "default": false
        },
        "gauge.session_current": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `scur` metric -  Current sessions",
          "group": null,
          "default": true
        },
        "gauge.session_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `rate` metric -  Number of sessions per second over last elapsed second",
          "group": null,
          "default": true
        },
        "gauge.session_rate_all": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.session_rate_limit": {
          "type": "gauge",
          "description": "Configured limit on number of new sessions per second. Corresponds to HAProxy's \"rate_lim\" metric.",
          "group": null,
          "default": false
        },
        "gauge.session_rate_max": {
          "type": "gauge",
          "description": "Max number of new sessions per second",
          "group": null,
          "default": false
        },
        "gauge.session_time_average": {
          "type": "gauge",
          "description": "Average total session time in ms over the last 1024 requests. Corresponds to HAProxy's \"ttime\" metric.",
          "group": null,
          "default": false
        },
        "gauge.session_time_avg": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gauge.ssl_backend_key_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslBackendKeyRate` metric.",
          "group": null,
          "default": false
        },
        "gauge.ssl_frontend_key_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslFrontendKeyRate` metric.",
          "group": null,
          "default": false
        },
        "gauge.ssl_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslRate` metric.",
          "group": null,
          "default": false
        },
        "gauge.tasks": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `Tasks` metric.",
          "group": null,
          "default": false
        },
        "gauge.throttle": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `throttle` metric -  Current throttle percentage for the server, when slowstart is active, or no value if not in slowstart.",
          "group": null,
          "default": false
        },
        "gauge.zlib_mem_usage": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `ZlibMemUsage` metric.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/haproxy",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "proxiesToMonitor",
            "doc": "A list of all the pxname(s) or svname(s) that you want to monitor (e.g. `[\"http-in\", \"server1\", \"backend\"]`)",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedMetrics",
            "doc": "Deprecated.  Please use `datapointsToExclude` on the monitor config block instead.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/health-checker",
      "sendAll": true,
      "dimensions": null,
      "doc": "A simple Collectd Python-based monitor\nthat hits an endpoint and checks if the configured JSON value is returned in\nthe response body.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/healthchecker",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "path",
            "doc": "The HTTP path that contains a JSON document to verify",
            "default": "/",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "jsonKey",
            "doc": "If `jsonKey` and `jsonVal` are given, the given endpoint will be interpreted as a JSON document and will be expected to contain the given key and value for the service to be considered healthy.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "jsonVal",
            "doc": "This can be either a string or numeric type",
            "default": null,
            "required": false,
            "type": "interface",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the endpoint will be connected to on HTTPS instead of plain HTTP.  It is invalid to specify this if `tcpCheck` is true.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipSecurity",
            "doc": "If true, and `useHTTPS` is true, the server's SSL/TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "tcpCheck",
            "doc": "If true, the plugin will verify that it can connect to the given host/port value. JSON checking is not supported.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/interface",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collectd stats about network interfaces on the\nsystem by using the [collectd interface\nplugin](https://collectd.org/wiki/index.php/Plugin:Interface).\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "if_dropped.rx",
            "if_dropped.tx",
            "if_errors.rx",
            "if_errors.tx",
            "if_octets.rx",
            "if_octets.tx",
            "if_packets.rx",
            "if_packets.tx"
          ]
        }
      },
      "metrics": {
        "if_dropped.rx": {
          "type": "cumulative",
          "description": "Count of received packets dropped by the interface",
          "group": null,
          "default": false
        },
        "if_dropped.tx": {
          "type": "cumulative",
          "description": "Count of transmitted packets dropped by the interface",
          "group": null,
          "default": false
        },
        "if_errors.rx": {
          "type": "cumulative",
          "description": "Count of receive errors on the interface",
          "group": null,
          "default": true
        },
        "if_errors.tx": {
          "type": "cumulative",
          "description": "Count of transmit errors on the interface",
          "group": null,
          "default": true
        },
        "if_octets.rx": {
          "type": "cumulative",
          "description": "Count of bytes (octets) received on the interface",
          "group": null,
          "default": true
        },
        "if_octets.tx": {
          "type": "cumulative",
          "description": "Count of bytes (octets) transmitted by the interface",
          "group": null,
          "default": true
        },
        "if_packets.rx": {
          "type": "cumulative",
          "description": "Count of packets received on the interface",
          "group": null,
          "default": false
        },
        "if_packets.tx": {
          "type": "cumulative",
          "description": "Count of packets transmitted by the interface",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/netinterface",
        "fields": [
          {
            "yamlName": "excludedInterfaces",
            "doc": "List of interface names to exclude from monitoring",
            "default": [
              "/^lo\\d*$/",
              "/^docker.*/",
              "/^t(un|ap)\\d*$/",
              "/^veth.*$/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "includedInterfaces",
            "doc": "List of all the interfaces you want to monitor, all others will be ignored.  If you set both included and excludedInterfaces, only includedInterfaces will be honored.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/jenkins",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors jenkins by using the\n[jenkins collectd Python\nplugin](https://github.com/signalfx/collectd-jenkins), which collects\nmetrics from Jenkins instances by hitting these endpoints:\n[../api/json](https://wiki.jenkins.io/display/jenkins/remote+access+api)\n(job metrics)  and\n[metrics/\u0026lt;MetricsKey\u0026gt;/..](https://wiki.jenkins.io/display/JENKINS/Metrics+Plugin)\n(default and optional Codahale/Dropwizard JVM metrics).\n\nRequires Jenkins 1.580.3 or later, as well as the Jenkins Metrics Plugin (see Setup).\n\n\u003c!--- SETUP ---\u003e\n## Install Jenkins Metrics Plugin\nThis monitor requires the Metrics Plugin in Jenkins. Go to `Manage Jenkins -\u003e Manage Plugins -\u003e Available -\u003e Search \"Metrics Plugin\"`\nto find and install this plugin in your Jenkins UI.\n\n\n\u003c!--- SETUP ---\u003e\n## Example Config\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n```\n\nSample YAML configuration with specific enhanced metrics included\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n  includeMetrics:\n  - \"vm.daemon.count\"\n  - \"vm.terminated.count\"\n```\n\nSample YAML configuration with all enhanced metrics included\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n  enhancedMetrics: true\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gauge.jenkins.job.duration",
            "gauge.jenkins.node.executor.count.value",
            "gauge.jenkins.node.executor.in-use.value",
            "gauge.jenkins.node.health-check.score",
            "gauge.jenkins.node.health.disk.space",
            "gauge.jenkins.node.health.plugins",
            "gauge.jenkins.node.health.temporary.space",
            "gauge.jenkins.node.health.thread-deadlock",
            "gauge.jenkins.node.online.status",
            "gauge.jenkins.node.queue.size.value",
            "gauge.jenkins.node.slave.online.status",
            "gauge.jenkins.node.vm.memory.heap.usage",
            "gauge.jenkins.node.vm.memory.non-heap.used",
            "gauge.jenkins.node.vm.memory.total.used"
          ]
        }
      },
      "metrics": {
        "gauge.jenkins.job.duration": {
          "type": "gauge",
          "description": "Time taken to complete the job in ms.",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.executor.count.value": {
          "type": "gauge",
          "description": "Total Number of executors in an instance",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.executor.in-use.value": {
          "type": "gauge",
          "description": "Total number of executors being used in an instance",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.health-check.score": {
          "type": "gauge",
          "description": "Mean health score of an instance",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.health.disk.space": {
          "type": "gauge",
          "description": "Binary value of disk space health",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.health.plugins": {
          "type": "gauge",
          "description": "Boolean value indicating state of plugins",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.health.temporary.space": {
          "type": "gauge",
          "description": "Binary value of temporary space health",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.health.thread-deadlock": {
          "type": "gauge",
          "description": "Boolean value indicating a deadlock",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.online.status": {
          "type": "gauge",
          "description": "Boolean value of instance is reachable or not",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.queue.size.value": {
          "type": "gauge",
          "description": "Total number pending jobs in queue",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.slave.online.status": {
          "type": "gauge",
          "description": "Boolean value for slave is reachable or not",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.vm.memory.heap.usage": {
          "type": "gauge",
          "description": "Percent utilization of the heap memory",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.vm.memory.non-heap.used": {
          "type": "gauge",
          "description": "Total amount of non-heap memory used",
          "group": null,
          "default": true
        },
        "gauge.jenkins.node.vm.memory.total.used": {
          "type": "gauge",
          "description": "Total Memory used by instance",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/jenkins",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "metricsKey",
            "doc": "Key required for collecting metrics.  The access key located at `Manage Jenkins \u003e Configure System \u003e Metrics \u003e ADD.` If empty, click `Generate`.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "Whether to enable enhanced metrics",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "includeMetrics",
            "doc": "Used to enable individual enhanced metrics when `enhancedMetrics` is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "username",
            "doc": "User with security access to jenkins",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "apiToken",
            "doc": "API Token of the user",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "Whether to enable HTTPS.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "sslKeyFile",
            "doc": "Path to the keyfile",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslCertificate",
            "doc": "Path to the certificate",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslCACerts",
            "doc": "Path to the ca file",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "Skip SSL certificate validation",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/kafka",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Kafka instance using collectd's\nGenericJMX plugin. See the [collectd/genericjmx\nmonitor](./collectd-genericjmx.md)[](sfx_link:java) for more information on\nhow to configure custom MBeans, as well as information on troubleshooting\nJMX setup.\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/pkg/monitors/collectd/kafka/mbeans.go)\nfor which it pulls metrics from Kafka's JMX endpoint.\n\nNote that this monitor supports Kafka v0.8.2.x and above. For Kafka v1.x.x and above,\napart from the list of default metrics, kafka.server:type=ZooKeeperClientMetrics,name=ZooKeeperRequestLatencyMs\nis a good metric to monitor since it gives an understanding of how long brokers wait for\nrequests to Zookeeper to be completed. Since Zookeeper is an integral part of a Kafka cluster,\nmonitoring it using the [Zookeeper\nmonitor](https://docs.signalfx.com/en/latest/integrations/agent/monitors/collectd-zookeeper.html)[](sfx_link:zookeeper)\nis recommended. It is also a good idea to monitor disk utilization and network metrics of\nthe underlying host.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.kafka-bytes-in",
            "counter.kafka-bytes-out",
            "counter.kafka-isr-expands",
            "counter.kafka-isr-shrinks",
            "counter.kafka-leader-election-rate",
            "counter.kafka-messages-in",
            "counter.kafka-unclean-elections-rate",
            "counter.kafka.fetch-consumer.total-time.count",
            "counter.kafka.fetch-follower.total-time.count",
            "counter.kafka.logs.flush-time.count",
            "counter.kafka.produce.total-time.count",
            "gauge.kafka-active-controllers",
            "gauge.kafka-max-lag",
            "gauge.kafka-offline-partitions-count",
            "gauge.kafka-request-queue",
            "gauge.kafka-underreplicated-partitions",
            "gauge.kafka.fetch-consumer.total-time.99th",
            "gauge.kafka.fetch-consumer.total-time.median",
            "gauge.kafka.fetch-follower.total-time.99th",
            "gauge.kafka.fetch-follower.total-time.median",
            "gauge.kafka.logs.flush-time.99th",
            "gauge.kafka.logs.flush-time.median",
            "gauge.kafka.produce.total-time.99th",
            "gauge.kafka.produce.total-time.median"
          ]
        },
        "jvm": {
          "description": "",
          "metrics": [
            "gauge.jvm.threads.count",
            "gauge.loaded_classes",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.init",
            "jmx_memory.max",
            "jmx_memory.used",
            "total_time_in_ms.collection_time"
          ]
        }
      },
      "metrics": {
        "counter.kafka-bytes-in": {
          "type": "cumulative",
          "description": "Number of bytes received per second across all topics",
          "group": null,
          "default": true
        },
        "counter.kafka-bytes-out": {
          "type": "cumulative",
          "description": "Number of bytes transmitted per second across all topics",
          "group": null,
          "default": true
        },
        "counter.kafka-isr-expands": {
          "type": "cumulative",
          "description": "When a broker is brought up after a failure, it starts catching up by reading from the leader. Once it is caught up, it gets added back to the ISR.",
          "group": null,
          "default": true
        },
        "counter.kafka-isr-shrinks": {
          "type": "cumulative",
          "description": "When a broker goes down, ISR for some of partitions will shrink. When that broker is up again, ISR will be expanded once the replicas are fully caught up. Other than that, the expected value for both ISR shrink rate and expansion rate is 0.",
          "group": null,
          "default": true
        },
        "counter.kafka-leader-election-rate": {
          "type": "cumulative",
          "description": "Number of leader elections",
          "group": null,
          "default": false
        },
        "counter.kafka-messages-in": {
          "type": "cumulative",
          "description": "Number of messages received per second across all topics",
          "group": null,
          "default": true
        },
        "counter.kafka-unclean-elections-rate": {
          "type": "cumulative",
          "description": "Number of unclean leader elections. This happens when a leader goes down and an out-of-sync replica is chosen to be the leader",
          "group": null,
          "default": true
        },
        "counter.kafka.fetch-consumer.total-time.count": {
          "type": "cumulative",
          "description": "Number of fetch requests from consumers per second across all partitions",
          "group": null,
          "default": true
        },
        "counter.kafka.fetch-follower.total-time.count": {
          "type": "cumulative",
          "description": "Number of fetch requests from followers per second across all partitions",
          "group": null,
          "default": false
        },
        "counter.kafka.logs.flush-time.count": {
          "type": "cumulative",
          "description": "Number of log flushes",
          "group": null,
          "default": false
        },
        "counter.kafka.produce.total-time.count": {
          "type": "cumulative",
          "description": "Number of producer requests",
          "group": null,
          "default": true
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "gauge.kafka-active-controllers": {
          "type": "gauge",
          "description": "Specifies if the broker an active controller",
          "group": null,
          "default": true
        },
        "gauge.kafka-max-lag": {
          "type": "gauge",
          "description": "Maximum lag in messages between the follower and leader replicas",
          "group": null,
          "default": true
        },
        "gauge.kafka-offline-partitions-count": {
          "type": "gauge",
          "description": "Number of partitions that don’t have an active leader and are hence not writable or readable",
          "group": null,
          "default": true
        },
        "gauge.kafka-request-queue": {
          "type": "gauge",
          "description": "Number of requests in the request queue across all partitions on the broker",
          "group": null,
          "default": true
        },
        "gauge.kafka-underreplicated-partitions": {
          "type": "gauge",
          "description": "Number of underreplicated partitions across all topics on the broker",
          "group": null,
          "default": true
        },
        "gauge.kafka.fetch-consumer.total-time.99th": {
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process fetch requests from consumers",
          "group": null,
          "default": true
        },
        "gauge.kafka.fetch-consumer.total-time.median": {
          "type": "gauge",
          "description": "Median time it takes to process a fetch request from consumers",
          "group": null,
          "default": true
        },
        "gauge.kafka.fetch-follower.total-time.99th": {
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process fetch requests from followers",
          "group": null,
          "default": true
        },
        "gauge.kafka.fetch-follower.total-time.median": {
          "type": "gauge",
          "description": "Median time it takes to process a fetch request from follower",
          "group": null,
          "default": true
        },
        "gauge.kafka.logs.flush-time.99th": {
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to flush logs",
          "group": null,
          "default": false
        },
        "gauge.kafka.logs.flush-time.median": {
          "type": "gauge",
          "description": "Median time it takes to flush logs",
          "group": null,
          "default": false
        },
        "gauge.kafka.produce.total-time.99th": {
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process produce requests",
          "group": null,
          "default": true
        },
        "gauge.kafka.produce.total-time.median": {
          "type": "gauge",
          "description": "Median time it takes to process a produce request",
          "group": null,
          "default": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "default": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "default": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/kafka",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "pkg/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "pkg/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "attributes",
                        "doc": "The plural form of the `attribute` config above.  Used to derive multiple metrics from a single MBean.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          },
          {
            "yamlName": "clusterName",
            "doc": "Cluster name to which the broker belongs",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/kafka_consumer",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Java based Kafka consumer using [collectd's GenericJMX plugin](./collectd-genericjmx.md)[](sfx_link:java).\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/pkg/monitors/collectd/kafkaconsumer/mbeans.go)\nfor which it pulls metrics from the Kafka consumer's JMX endpoint.\n\nSample YAML configuration:\n```yaml\nmonitors:\n  - type: collectd/kafka_consumer\n    host: localhost\n    port: 9099\n    mBeansToOmit:\n      - fetch-size-avg-per-topic\n```\n\nNote that this monitor requires Kafka v0.9.0.0 or above and collects metrics from the new consumer API.\nAlso, per-topic metrics that are collected by default are not available through the new consumer API in\nv0.9.0.0 which can cause the logs to flood with warnings related to the MBean not being found.\nUse the `mBeansToOmit` config option in such cases. The above example configuration will not attempt to\ncollect the MBean referenced by `fetch-size-avg-per-topic`. Here is a\n[list](https://github.com/signalfx/signalfx-agent/tree/master/pkg/monitors/collectd/kafkaconsumer/mbeans.go)\nof metrics collected by default.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gauge.kafka.consumer.bytes-consumed-rate",
            "gauge.kafka.consumer.fetch-rate",
            "gauge.kafka.consumer.fetch-size-avg",
            "gauge.kafka.consumer.records-consumed-rate",
            "gauge.kafka.consumer.records-lag-max"
          ]
        },
        "jvm": {
          "description": "",
          "metrics": [
            "gauge.jvm.threads.count",
            "gauge.loaded_classes",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.init",
            "jmx_memory.max",
            "jmx_memory.used",
            "total_time_in_ms.collection_time"
          ]
        }
      },
      "metrics": {
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "gauge.kafka.consumer.bytes-consumed-rate": {
          "type": "gauge",
          "description": "Average number of bytes consumed per second. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter.",
          "group": null,
          "default": true
        },
        "gauge.kafka.consumer.fetch-rate": {
          "type": "gauge",
          "description": "Number of records consumed per second.",
          "group": null,
          "default": true
        },
        "gauge.kafka.consumer.fetch-size-avg": {
          "type": "gauge",
          "description": "Average number of bytes fetched per request. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter.",
          "group": null,
          "default": true
        },
        "gauge.kafka.consumer.records-consumed-rate": {
          "type": "gauge",
          "description": "Average number of records consumed per second. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter.",
          "group": null,
          "default": true
        },
        "gauge.kafka.consumer.records-lag-max": {
          "type": "gauge",
          "description": "Maximum lag in of records for any partition in this window. An increasing value over time is your best indication that the consumer group is not keeping up with the producers.",
          "group": null,
          "default": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "default": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "default": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "pkg/monitors/collectd/kafkaconsumer",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "pkg/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "pkg/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "attributes",
                        "doc": "The plural form of the `attribute` config above.  Used to derive multiple metrics from a single MBean.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/kafka_producer",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Java based Kafka producer using GenericJMX.\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/pkg/monitors/collectd/kafkaproducer/mbeans.go)\nfor which it pulls metrics from the Kafka producer's JMX endpoint.\n\nSample YAML configuration:\n```yaml\nmonitors:\n  - type: collectd/kafka_producer\n    host: localhost\n    port: 8099\n```\n\nNote that this monitor requires Kafka v0.9.0.0 or above and collects metrics from the new producer API.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gauge.kafka.producer.byte-rate",
            "gauge.kafka.producer.compression-rate",
            "gauge.kafka.producer.io-wait-time-ns-avg",
            "gauge.kafka.producer.outgoing-byte-rate",
            "gauge.kafka.producer.record-error-rate",
            "gauge.kafka.producer.record-retry-rate",
            "gauge.kafka.producer.record-send-rate",
            "gauge.kafka.producer.request-latency-avg",
            "gauge.kafka.producer.request-rate",
            "gauge.kafka.producer.response-rate"
          ]
        },
        "jvm": {
          "description": "",
          "metrics": [
            "gauge.jvm.threads.count",
            "gauge.loaded_classes",
            "invocations",
            "jmx_memory.committed",
            "jmx_memory.init",
            "jmx_memory.max",
            "jmx_memory.used",
            "total_time_in_ms.collection_time"
          ]
        }
      },
      "metrics": {
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "gauge.kafka.producer.byte-rate": {
          "type": "gauge",
          "description": "Average number of bytes sent per second for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.compression-rate": {
          "type": "gauge",
          "description": "Average compression rate of record batches for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.io-wait-time-ns-avg": {
          "type": "gauge",
          "description": "Average length of time the I/O thread spent waiting for a socket ready for reads or writes in nanoseconds. This metric has client-id dimension.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.outgoing-byte-rate": {
          "type": "gauge",
          "description": "Average number of outgoing bytes sent per second to all servers. This metric has client-id dimension.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.record-error-rate": {
          "type": "gauge",
          "description": "Average per-second number of record sends that resulted in errors for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.record-retry-rate": {
          "type": "gauge",
          "description": "Average per-second number of retried record sends for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.record-send-rate": {
          "type": "gauge",
          "description": "Average number of records sent per second for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.request-latency-avg": {
          "type": "gauge",
          "description": "Average request latency in ms. Time it takes on average for the producer to get responses from the broker. This metric has client-id dimension.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.request-rate": {
          "type": "gauge",
          "description": "Average number of requests sent per second. This metric has client-id dimension.",
          "group": null,
          "default": true
        },
        "gauge.kafka.producer.response-rate": {
          "type": "gauge",
          "description": "Average number of responses received per second. This metric has client-id dimension.",
          "group": null,
          "default": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "default": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "default": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "default": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "pkg/monitors/collectd/kafkaproducer",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "pkg/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "pkg/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "attributes",
                        "doc": "The plural form of the `attribute` config above.  Used to derive multiple metrics from a single MBean.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/kong",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Kong instance using\n[collectd-kong](https://github.com/signalfx/collectd-kong).  The Smart\nAgent includes collectd and this plugin as part of the standard\ninstallation, so no additional installation is required once you have the\nSmart Agent.\n\nThe SignalFx Kong collectd plugin provides users with the ability to gather\nand report their service traffic metrics with collectd, in tandem with\n[kong-plugin-signalfx](https://github.com/signalfx/kong-plugin-signalfx).\n\nThis plugin emits metrics for configurable request/response lifecycle groups including:\n\n* Counters for response counts\n* Counters for cumulative response and request sizes\n* Counters for cumulative request, upstream, and Kong latencies\n\nThese request/response lifecycle groups can be optionally partitioned by tunable levels of granularity by:\n\n* API or Service Name/ID\n* Route ID\n* Request HTTP Method\n* Response HTTP Status Code\n\nIn addition to these groups, system-wide connection stats can be provided, including:\n\n* A counter for total fielded requests\n* Gauges for active connections and their various states\n* A gauge for database connectivity\n\nThe `metrics` field below is populated with a set of metrics that are\ndescribed at https://github.com/signalfx/collectd-kong/blob/master/README.md.\n\n\u003c!--- SETUP ---\u003e\n### Install Kong Lua Plugin\n\nPlease download and install this Lua module on all Kong servers by\nfollowing [these instructions](https://github.com/signalfx/kong-plugin-signalfx/blob/master/README.md).\n\n### REQUIREMENTS AND DEPENDENCIES\n\nThis plugin requires:\n\n| Software          | Version        |\n|-------------------|----------------|\n| Kong | 0.11.2+ |\n| Configured [kong-plugin-signalfx](https://github.com/signalfx/kong-plugin-signalfx) | 0.0.1+ |\n\n\n\u003c!--- SETUP ---\u003e\n## Example Config\n#\nSample YAML configuration:\n\n```yaml\nmonitors:\n  - type: collectd/kong\n    host: 127.0.0.1\n    port: 8001\n    metrics:\n      - metric: request_latency\n        report: true\n      - metric: connections_accepted\n        report: false\n```\n\nSample YAML configuration with custom /signalfx route and white and blacklists\n\n```yaml\nmonitors:\n  - type: collectd/kong\n    host: 127.0.0.1\n    port: 8443\n    url: https://127.0.0.1:8443/routed_signalfx\n    authHeader:\n      header: Authorization\n      value: HeaderValue\n    metrics:\n      - metric: request_latency\n        report: true\n    reportStatusCodeGroups: true\n    statusCodes:\n      - 202\n      - 403\n      - 405\n      - 419\n      - \"5*\"\n    serviceNamesBlacklist:\n      - \"*SomeService*\"\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.kong.connections.accepted",
            "counter.kong.connections.handled",
            "counter.kong.kong.latency",
            "counter.kong.requests.count",
            "counter.kong.requests.latency",
            "counter.kong.requests.size",
            "counter.kong.responses.count",
            "counter.kong.responses.size",
            "counter.kong.upstream.latency",
            "gauge.kong.connections.active",
            "gauge.kong.connections.reading",
            "gauge.kong.connections.waiting",
            "gauge.kong.connections.writing",
            "gauge.kong.database.reachable"
          ]
        }
      },
      "metrics": {
        "counter.kong.connections.accepted": {
          "type": "cumulative",
          "description": "Total number of all accepted connections.",
          "group": null,
          "default": false
        },
        "counter.kong.connections.handled": {
          "type": "cumulative",
          "description": "Total number of all handled connections (accounting for resource limits).",
          "group": null,
          "default": false
        },
        "counter.kong.kong.latency": {
          "type": "cumulative",
          "description": "Time spent in Kong request handling and balancer (ms).",
          "group": null,
          "default": true
        },
        "counter.kong.requests.count": {
          "type": "cumulative",
          "description": "Total number of all requests made to Kong API and proxy server.",
          "group": null,
          "default": true
        },
        "counter.kong.requests.latency": {
          "type": "cumulative",
          "description": "Time elapsed between the first bytes being read from each client request and the log writes after the last bytes were sent to the clients (ms).",
          "group": null,
          "default": true
        },
        "counter.kong.requests.size": {
          "type": "cumulative",
          "description": "Total bytes received/proxied from client requests.",
          "group": null,
          "default": true
        },
        "counter.kong.responses.count": {
          "type": "cumulative",
          "description": "Total number of responses provided to clients.",
          "group": null,
          "default": true
        },
        "counter.kong.responses.size": {
          "type": "cumulative",
          "description": "Total bytes sent/proxied to clients.",
          "group": null,
          "default": true
        },
        "counter.kong.upstream.latency": {
          "type": "cumulative",
          "description": "Time spent waiting for upstream response (ms).",
          "group": null,
          "default": true
        },
        "gauge.kong.connections.active": {
          "type": "gauge",
          "description": "The current number of active client connections (includes waiting).",
          "group": null,
          "default": true
        },
        "gauge.kong.connections.reading": {
          "type": "gauge",
          "description": "The current number of connections where nginx is reading the request header.",
          "group": null,
          "default": true
        },
        "gauge.kong.connections.waiting": {
          "type": "gauge",
          "description": "The current number of idle client connections waiting for a request.",
          "group": null,
          "default": true
        },
        "gauge.kong.connections.writing": {
          "type": "gauge",
          "description": "The current number of connections where nginx is writing the response back to the client.",
          "group": null,
          "default": true
        },
        "gauge.kong.database.reachable": {
          "type": "gauge",
          "description": "kong.dao:db.reachable() at time of metric query",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/kong",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Kong host to connect with (used for autodiscovery and URL)",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port for kong-plugin-signalfx hosting server (used for autodiscovery and URL)",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "Registration name when using multiple instances in Smart Agent",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "url",
            "doc": "kong-plugin-signalfx metric plugin",
            "default": "http://{{.Host}}:{{.Port}}/signalfx",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "authHeader",
            "doc": "Header and its value to use for requests to SFx metric endpoint",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "Header",
              "doc": "Header defines name/value pair for AuthHeader option",
              "package": "pkg/monitors/collectd/kong",
              "fields": [
                {
                  "yamlName": "header",
                  "doc": "Name of header to include with GET",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "value",
                  "doc": "Value of header",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "verifyCerts",
            "doc": "Whether to verify certificates when using ssl/tls",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caBundle",
            "doc": "CA Bundle file or directory",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCert",
            "doc": "Client certificate file (with or without included key)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertKey",
            "doc": "Client cert key if not bundled with clientCert",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "verbose",
            "doc": "Whether to use debug logging for collectd-kong",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metrics",
            "doc": "List of metric names and report flags. See monitor description for more details.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Metric",
              "doc": "Metric is for use with `Metric \"metric_name\" bool` collectd plugin format",
              "package": "pkg/monitors/collectd/kong",
              "fields": [
                {
                  "yamlName": "metric",
                  "doc": "Name of metric, per collectd-kong",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "report",
                  "doc": "Whether to report this metric",
                  "default": null,
                  "required": true,
                  "type": "bool",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "reportApiIds",
            "doc": "Report metrics for distinct API IDs where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportApiNames",
            "doc": "Report metrics for distinct API names where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportServiceIds",
            "doc": "Report metrics for distinct Service IDs where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportServiceNames",
            "doc": "Report metrics for distinct Service names where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportRouteIds",
            "doc": "Report metrics for distinct Route IDs where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportHttpMethods",
            "doc": "Report metrics for distinct HTTP methods where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportStatusCodeGroups",
            "doc": "Report metrics for distinct HTTP status code groups (eg. \"5xx\") where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportStatusCodes",
            "doc": "Report metrics for distinct HTTP status codes where applicable (mutually exclusive with ReportStatusCodeGroups)",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "apiIds",
            "doc": "List of API ID patterns to report distinct metrics for, if reportApiIds is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "apiIdsBlacklist",
            "doc": "List of API ID patterns to not report distinct metrics for, if reportApiIds is true or apiIds are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "apiNames",
            "doc": "List of API name patterns to report distinct metrics for, if reportApiNames is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "apiNamesBlacklist",
            "doc": "List of API name patterns to not report distinct metrics for, if reportApiNames is true or apiNames are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "serviceIds",
            "doc": "List of Service ID patterns to report distinct metrics for, if reportServiceIds is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "serviceIdsBlacklist",
            "doc": "List of Service ID patterns to not report distinct metrics for, if reportServiceIds is true or serviceIds are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "serviceNames",
            "doc": "List of Service name patterns to report distinct metrics for, if reportServiceNames is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "serviceNamesBlacklist",
            "doc": "List of Service name patterns to not report distinct metrics for, if reportServiceNames is true or serviceNames are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "routeIds",
            "doc": "List of Route ID patterns to report distinct metrics for, if reportRouteIds is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "routeIdsBlacklist",
            "doc": "List of Route ID patterns to not report distinct metrics for, if reportRouteIds is true or routeIds are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "httpMethods",
            "doc": "List of HTTP method patterns to report distinct metrics for, if reportHttpMethods is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "httpMethodsBlacklist",
            "doc": "List of HTTP method patterns to not report distinct metrics for, if reportHttpMethods is true or httpMethods are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "statusCodes",
            "doc": "List of HTTP status code patterns to report distinct metrics for, if reportStatusCodes is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "statusCodesBlacklist",
            "doc": "List of HTTP status code patterns to not report distinct metrics for, if reportStatusCodes is true or statusCodes are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/load",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors process load on the host using the collectd\n[Load plugin](https://collectd.org/wiki/index.php/Plugin:Load).\n\n**This monitor has been deprecated in favor of the `load` monitor. That\nmonitor emits the same metrics and is fully compatible.  This\n`collectd/load` monitor will be removed in a future release of the agent.\"\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "load.longterm",
            "load.midterm",
            "load.shortterm"
          ]
        }
      },
      "metrics": {
        "load.longterm": {
          "type": "gauge",
          "description": "Average CPU load per core over the last 15 minutes",
          "group": null,
          "default": true
        },
        "load.midterm": {
          "type": "gauge",
          "description": "Average CPU load per core over the last five minutes",
          "group": null,
          "default": true
        },
        "load.shortterm": {
          "type": "gauge",
          "description": "Average CPU load per core over the last one minute",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/load",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/marathon",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Mesos Marathon instance using the\n[collectd Marathon Python plugin](https://github.com/signalfx/collectd-marathon).\n\nSee the [integrations\ndoc](https://docs.signalfx.com/en/latest/integrations/integrations-reference/integrations.marathon.html)\nfor more information on configuration.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n  - type: collectd/marathon\n    host: 127.0.0.1\n    port: 8080\n    scheme: http\n```\n\nSample YAML configuration for DC/OS:\n\n```yaml\nmonitors:\n  - type: collectd/marathon\n    host: 127.0.0.1\n    port: 8080\n    scheme: https\n    dcosAuthURL: https://leader.mesos/acs/api/v1/auth/login\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gauge.marathon.app.cpu.allocated",
            "gauge.marathon.app.cpu.allocated.per.instance",
            "gauge.marathon.app.delayed",
            "gauge.marathon.app.deployments.total",
            "gauge.marathon.app.disk.allocated",
            "gauge.marathon.app.disk.allocated.per.instance",
            "gauge.marathon.app.gpu.allocated",
            "gauge.marathon.app.gpu.allocated.per.instance",
            "gauge.marathon.app.instances.total",
            "gauge.marathon.app.memory.allocated",
            "gauge.marathon.app.memory.allocated.per.instance",
            "gauge.marathon.app.tasks.running",
            "gauge.marathon.app.tasks.staged",
            "gauge.marathon.app.tasks.unhealthy",
            "gauge.marathon.task.healthchecks.failing.total",
            "gauge.marathon.task.healthchecks.passing.total",
            "gauge.marathon.task.staged.time.elapsed",
            "gauge.marathon.task.start.time.elapsed"
          ]
        }
      },
      "metrics": {
        "gauge.marathon.app.cpu.allocated": {
          "type": "gauge",
          "description": "Number of CPUs allocated to an application",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.cpu.allocated.per.instance": {
          "type": "gauge",
          "description": "Configured number of CPUs allocated to each application instance",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.delayed": {
          "type": "gauge",
          "description": "Indicates if the application is delayed or not",
          "group": null,
          "default": false
        },
        "gauge.marathon.app.deployments.total": {
          "type": "gauge",
          "description": "Number of application deployments",
          "group": null,
          "default": false
        },
        "gauge.marathon.app.disk.allocated": {
          "type": "gauge",
          "description": "Storage allocated to a Marathon application",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.disk.allocated.per.instance": {
          "type": "gauge",
          "description": "Configured storage allocated each to application instance",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.gpu.allocated": {
          "type": "gauge",
          "description": "GPU Allocated to a Marathon application",
          "group": null,
          "default": false
        },
        "gauge.marathon.app.gpu.allocated.per.instance": {
          "type": "gauge",
          "description": "Configured number of GPUs allocated to each application instance",
          "group": null,
          "default": false
        },
        "gauge.marathon.app.instances.total": {
          "type": "gauge",
          "description": "Number of application instances",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.memory.allocated": {
          "type": "gauge",
          "description": "Memory Allocated to a Marathon application",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.memory.allocated.per.instance": {
          "type": "gauge",
          "description": "Configured amount of memory allocated to each application instance",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.tasks.running": {
          "type": "gauge",
          "description": "Number tasks running for an application",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.tasks.staged": {
          "type": "gauge",
          "description": "Number tasks staged for an application",
          "group": null,
          "default": true
        },
        "gauge.marathon.app.tasks.unhealthy": {
          "type": "gauge",
          "description": "Number unhealthy tasks for an application",
          "group": null,
          "default": true
        },
        "gauge.marathon.task.healthchecks.failing.total": {
          "type": "gauge",
          "description": "The number of failing health checks for a task",
          "group": null,
          "default": true
        },
        "gauge.marathon.task.healthchecks.passing.total": {
          "type": "gauge",
          "description": "The number of passing health checks for a task",
          "group": null,
          "default": true
        },
        "gauge.marathon.task.staged.time.elapsed": {
          "type": "gauge",
          "description": "The amount of time the task spent in staging",
          "group": null,
          "default": false
        },
        "gauge.marathon.task.start.time.elapsed": {
          "type": "gauge",
          "description": "Time elapsed since the task started",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/marathon",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username used to authenticate with Marathon.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password used to authenticate with Marathon.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "scheme",
            "doc": "Set to either `http` or `https`.",
            "default": "http",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "dcosAuthURL",
            "doc": "The dcos authentication URL which the plugin uses to get authentication tokens from. Set scheme to \"https\" if operating DC/OS in strict mode and dcosAuthURL to \"https://leader.mesos/acs/api/v1/auth/login\" (which is the default DNS entry provided by DC/OS)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/memcached",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an instance of memcached using the [collectd memcached\nplugin](https://collectd.org/wiki/index.php/Plugin:memcached).  Requires\nMemcached 1.1 or later.\n\nThe monitor collects the following information from Memcached nodes:\n\n* request information (including hits, misses \u0026 evictions)\n* current connections\n* net input/output bytes\n* number of items cached\n\nDocumentation for Memcached can be found at https://github.com/memcached/memcached/wiki.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "connections.opened",
            "df.cache.free",
            "df.cache.used",
            "memcached_command.flush",
            "memcached_command.get",
            "memcached_command.meta",
            "memcached_command.set",
            "memcached_command.touch",
            "memcached_connections.current",
            "memcached_items.current",
            "memcached_octets.rx",
            "memcached_octets.tx",
            "memcached_ops.decr_hits",
            "memcached_ops.decr_misses",
            "memcached_ops.delete_hits",
            "memcached_ops.delete_misses",
            "memcached_ops.evictions",
            "memcached_ops.hits",
            "memcached_ops.incr_hits",
            "memcached_ops.incr_misses",
            "memcached_ops.misses",
            "ps_count.threads",
            "ps_cputime.syst",
            "ps_cputime.user",
            "total_events.listen_disabled"
          ]
        }
      },
      "metrics": {
        "connections.opened": {
          "type": "cumulative",
          "description": "Number of connections opened since server began running",
          "group": null,
          "default": false
        },
        "df.cache.free": {
          "type": "gauge",
          "description": "Unused storage bytes",
          "group": null,
          "default": true
        },
        "df.cache.used": {
          "type": "gauge",
          "description": "Current number of bytes used to store items",
          "group": null,
          "default": true
        },
        "memcached_command.flush": {
          "type": "cumulative",
          "description": "Number of flush requests",
          "group": null,
          "default": false
        },
        "memcached_command.get": {
          "type": "cumulative",
          "description": "Number of retrieval requests",
          "group": null,
          "default": true
        },
        "memcached_command.meta": {
          "type": "cumulative",
          "description": "Number of meta requests",
          "group": null,
          "default": false
        },
        "memcached_command.set": {
          "type": "cumulative",
          "description": "Number of storage requests",
          "group": null,
          "default": true
        },
        "memcached_command.touch": {
          "type": "cumulative",
          "description": "Number of touch requests",
          "group": null,
          "default": false
        },
        "memcached_connections.current": {
          "type": "gauge",
          "description": "Current number of open connections",
          "group": null,
          "default": true
        },
        "memcached_items.current": {
          "type": "gauge",
          "description": "Current number of items stored by this instance",
          "group": null,
          "default": true
        },
        "memcached_octets.rx": {
          "type": "cumulative",
          "description": "Total network bytes read by this server",
          "group": null,
          "default": true
        },
        "memcached_octets.tx": {
          "type": "cumulative",
          "description": "Total network bytes written by this server",
          "group": null,
          "default": true
        },
        "memcached_ops.decr_hits": {
          "type": "cumulative",
          "description": "Number of successful Decr requests",
          "group": null,
          "default": false
        },
        "memcached_ops.decr_misses": {
          "type": "cumulative",
          "description": "Number of decr requests against missing keys",
          "group": null,
          "default": false
        },
        "memcached_ops.delete_hits": {
          "type": "cumulative",
          "description": "Number of successful delete requests",
          "group": null,
          "default": false
        },
        "memcached_ops.delete_misses": {
          "type": "cumulative",
          "description": "Number of delete requests against missing keys",
          "group": null,
          "default": false
        },
        "memcached_ops.evictions": {
          "type": "cumulative",
          "description": "Number of valid items removed from cache",
          "group": null,
          "default": true
        },
        "memcached_ops.hits": {
          "type": "cumulative",
          "description": "Number of keys that have been requested and found present",
          "group": null,
          "default": true
        },
        "memcached_ops.incr_hits": {
          "type": "cumulative",
          "description": "Number of successful incr requests",
          "group": null,
          "default": false
        },
        "memcached_ops.incr_misses": {
          "type": "cumulative",
          "description": "Number of incr requests against missing keys",
          "group": null,
          "default": false
        },
        "memcached_ops.misses": {
          "type": "cumulative",
          "description": "Number of items that have been requested and not found",
          "group": null,
          "default": true
        },
        "ps_count.threads": {
          "type": "gauge",
          "description": "Number of worker threads requested",
          "group": null,
          "default": false
        },
        "ps_cputime.syst": {
          "type": "cumulative",
          "description": "Total system time for this instance",
          "group": null,
          "default": false
        },
        "ps_cputime.user": {
          "type": "cumulative",
          "description": "Total user time for this instance",
          "group": null,
          "default": false
        },
        "total_events.listen_disabled": {
          "type": "cumulative",
          "description": "Number of times connection limit has been exceeded",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/memcached",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "reportHost",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/memory",
      "sendAll": false,
      "dimensions": null,
      "doc": "Sends memory usage stats for the underlying host.\nSee https://collectd.org/wiki/index.php/Plugin:Memory\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "memory.buffered",
            "memory.cached",
            "memory.free",
            "memory.slab_recl",
            "memory.slab_unrecl",
            "memory.used"
          ]
        }
      },
      "metrics": {
        "memory.buffered": {
          "type": "gauge",
          "description": "Bytes of memory used for buffering I/O",
          "group": null,
          "default": true
        },
        "memory.cached": {
          "type": "gauge",
          "description": "Bytes of memory used for disk caching",
          "group": null,
          "default": true
        },
        "memory.free": {
          "type": "gauge",
          "description": "Bytes of memory available for use",
          "group": null,
          "default": true
        },
        "memory.slab_recl": {
          "type": "gauge",
          "description": "Bytes of memory, used for SLAB-allocation of kernel objects, that can be reclaimed.",
          "group": null,
          "default": true
        },
        "memory.slab_unrecl": {
          "type": "gauge",
          "description": "Bytes of memory, used for SLAB-allocation of kernel objects, that can't be reclaimed",
          "group": null,
          "default": true
        },
        "memory.used": {
          "type": "gauge",
          "description": "Bytes of memory in use by the system.",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/memory",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/mongodb",
      "sendAll": false,
      "dimensions": {
        "plugin_instance": {
          "description": "Port number of the MongoDB instance"
        }
      },
      "doc": "Monitors an instance of MongoDB using the [collectd MongoDB Python\nplugin](https://github.com/signalfx/collectd-mongodb).  Requires MongoDB\n2.6 or later.\n\nThis monitor captures the following metrics about MongoDB generally:\n\n* memory\n* network input/output bytes count\n* heap usage\n* db connections\n* operations count\n* active client connections\n* queued operations\n\nThe plugin also captures the following DB-specific metrics:\n\n* db size\n* db counters\n\nDocumentation for MongoDB can be found [here](http://docs.mongodb.org/manual/).\n\n\u003c!--- SETUP ---\u003e\n### Creating a MongoDB user for collectd\n\nIf you're monitoring a secured MongoDB deployment, it is a good practice to create a MongoDB user with minimal read-only roles, as follows:\n\n```\ndb.createUser( {\n  user: \"collectd\",\n  pwd: \"collectd\",\n  roles: [ { role: \"readAnyDatabase\", db: \"admin\" }, { role: \"clusterMonitor\", db: \"admin\" } ]\n});\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.asserts.regular",
            "counter.asserts.warning",
            "counter.backgroundFlushing.flushes",
            "counter.extra_info.page_faults",
            "counter.lock.Database.acquireCount.intentExclusive",
            "counter.lock.Database.acquireCount.intentShared",
            "counter.lock.Database.acquireCount.read",
            "counter.lock.Database.acquireCount.write",
            "counter.lock.Global.acquireCount.intentExclusive",
            "counter.lock.Global.acquireCount.intentShared",
            "counter.lock.Global.acquireCount.write",
            "counter.network.bytesIn",
            "counter.network.bytesOut",
            "counter.network.numRequests",
            "counter.opcounters.command",
            "counter.opcounters.delete",
            "counter.opcounters.getmore",
            "counter.opcounters.insert",
            "counter.opcounters.query",
            "counter.opcounters.update",
            "counter.opcountersRepl.command",
            "counter.opcountersRepl.delete",
            "counter.opcountersRepl.getmore",
            "counter.opcountersRepl.insert",
            "counter.opcountersRepl.query",
            "counter.opcountersRepl.update",
            "gauge.backgroundFlushing.average_ms",
            "gauge.backgroundFlushing.last_ms",
            "gauge.collection.max",
            "gauge.collection.maxSize",
            "gauge.collections",
            "gauge.connections.available",
            "gauge.connections.current",
            "gauge.connections.totalCreated",
            "gauge.dataSize",
            "gauge.extra_info.heap_usage_bytes",
            "gauge.globalLock.activeClients.readers",
            "gauge.globalLock.activeClients.total",
            "gauge.globalLock.activeClients.writers",
            "gauge.globalLock.currentQueue.readers",
            "gauge.globalLock.currentQueue.total",
            "gauge.globalLock.currentQueue.writers",
            "gauge.indexSize",
            "gauge.indexes",
            "gauge.mem.mapped",
            "gauge.mem.resident",
            "gauge.mem.virtual",
            "gauge.numExtents",
            "gauge.objects",
            "gauge.storageSize",
            "gauge.uptime"
          ]
        },
        "collection": {
          "description": "",
          "metrics": [
            "counter.collection.index.accesses.ops",
            "gauge.collection.avgObjSize",
            "gauge.collection.count",
            "gauge.collection.indexSize",
            "gauge.collection.size",
            "gauge.collection.storageSize"
          ]
        },
        "collection-top": {
          "description": "",
          "metrics": [
            "counter.collection.commandsCount",
            "counter.collection.commandsTime",
            "counter.collection.getmoreCount",
            "counter.collection.getmoreTime",
            "counter.collection.insertCount",
            "counter.collection.insertTime",
            "counter.collection.queriesCount",
            "counter.collection.queriesTime",
            "counter.collection.readLockCount",
            "counter.collection.readLockTime",
            "counter.collection.removeCount",
            "counter.collection.removeTime",
            "counter.collection.totalCount",
            "counter.collection.totalTime",
            "counter.collection.updateCount",
            "counter.collection.updateTime",
            "counter.collection.writeLockCount",
            "counter.collection.writeLockTime"
          ]
        }
      },
      "metrics": {
        "counter.asserts.regular": {
          "type": "cumulative",
          "description": "The number of regular assertions raised since the MongoDB process started. Check the log file for more information about these messages.",
          "group": null,
          "default": false
        },
        "counter.asserts.warning": {
          "type": "cumulative",
          "description": "In MongoDB 3.x and earlier, the field returns the number of warnings raised since the MongoDB process started.  In MongodDB 4, this is always 0.",
          "group": null,
          "default": false
        },
        "counter.backgroundFlushing.flushes": {
          "type": "gauge",
          "description": "Number of times the database has been flushed",
          "group": null,
          "default": true
        },
        "counter.collection.commandsCount": {
          "type": "counter",
          "description": "Number of commands issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.commandsTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing commands issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.getmoreCount": {
          "type": "counter",
          "description": "Number of getMore requests issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.getmoreTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing getMore requests for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.index.accesses.ops": {
          "type": "counter",
          "description": "Number of times an index has been used (only on Mongo 3.2+)",
          "group": "collection",
          "default": false
        },
        "counter.collection.insertCount": {
          "type": "counter",
          "description": "Number of inserts issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.insertTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing insert requests for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.queriesCount": {
          "type": "counter",
          "description": "Number of queries issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.queriesTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing query requests for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.readLockCount": {
          "type": "counter",
          "description": "Number of read locks issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.readLockTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing read locks for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.removeCount": {
          "type": "counter",
          "description": "Number of remove requests issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.removeTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing remove requests for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.totalCount": {
          "type": "counter",
          "description": "Total number of operations issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.totalTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing all operations for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.updateCount": {
          "type": "counter",
          "description": "Number of update requests issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.updateTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing update requests for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.writeLockCount": {
          "type": "counter",
          "description": "Number of write locks issued for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.collection.writeLockTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing write locks for a collection",
          "group": "collection-top",
          "default": false
        },
        "counter.extra_info.page_faults": {
          "type": "gauge",
          "description": "Mongod page faults",
          "group": null,
          "default": true
        },
        "counter.lock.Database.acquireCount.intentExclusive": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.lock.Database.acquireCount.intentShared": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.lock.Database.acquireCount.read": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.lock.Database.acquireCount.write": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.lock.Global.acquireCount.intentExclusive": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.lock.Global.acquireCount.intentShared": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.lock.Global.acquireCount.write": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "counter.network.bytesIn": {
          "type": "gauge",
          "description": "Network bytes received by the database server",
          "group": null,
          "default": true
        },
        "counter.network.bytesOut": {
          "type": "gauge",
          "description": "Network bytes sent by the database server",
          "group": null,
          "default": true
        },
        "counter.network.numRequests": {
          "type": "cumulative",
          "description": "Requests received by the server",
          "group": null,
          "default": true
        },
        "counter.opcounters.command": {
          "type": "cumulative",
          "description": "Number of commands since last restart",
          "group": null,
          "default": false
        },
        "counter.opcounters.delete": {
          "type": "cumulative",
          "description": "Number of deletes since last restart",
          "group": null,
          "default": true
        },
        "counter.opcounters.getmore": {
          "type": "cumulative",
          "description": "Number of getmore operations since last restart",
          "group": null,
          "default": false
        },
        "counter.opcounters.insert": {
          "type": "cumulative",
          "description": "Number of inserts since last restart",
          "group": null,
          "default": true
        },
        "counter.opcounters.query": {
          "type": "cumulative",
          "description": "Number of queries since last restart",
          "group": null,
          "default": true
        },
        "counter.opcounters.update": {
          "type": "cumulative",
          "description": "Number of updates since last restart",
          "group": null,
          "default": true
        },
        "counter.opcountersRepl.command": {
          "type": "cumulative",
          "description": "Number of replicated commands since last restart",
          "group": null,
          "default": false
        },
        "counter.opcountersRepl.delete": {
          "type": "cumulative",
          "description": "Number of replicated deletes since last restart",
          "group": null,
          "default": false
        },
        "counter.opcountersRepl.getmore": {
          "type": "cumulative",
          "description": "Number of replicated getmore operations since last restart",
          "group": null,
          "default": false
        },
        "counter.opcountersRepl.insert": {
          "type": "cumulative",
          "description": "Number of replicated inserts since last restart",
          "group": null,
          "default": false
        },
        "counter.opcountersRepl.query": {
          "type": "cumulative",
          "description": "Number of replicated queries since last restart",
          "group": null,
          "default": false
        },
        "counter.opcountersRepl.update": {
          "type": "cumulative",
          "description": "Number of replicated updates since last restart",
          "group": null,
          "default": false
        },
        "gauge.backgroundFlushing.average_ms": {
          "type": "gauge",
          "description": "Average time (ms) to write data to disk",
          "group": null,
          "default": true
        },
        "gauge.backgroundFlushing.last_ms": {
          "type": "gauge",
          "description": "Most recent time (ms) spent writing data to disk",
          "group": null,
          "default": true
        },
        "gauge.collection.avgObjSize": {
          "type": "gauge",
          "description": "Mean object/document size of a collection",
          "group": "collection",
          "default": false
        },
        "gauge.collection.count": {
          "type": "gauge",
          "description": "Number of objects/documents in a collection",
          "group": "collection",
          "default": false
        },
        "gauge.collection.indexSize": {
          "type": "gauge",
          "description": "Size of a particular index on a collection",
          "group": "collection",
          "default": false
        },
        "gauge.collection.max": {
          "type": "gauge",
          "description": "Maximum number of documents in a capped collection",
          "group": null,
          "default": false
        },
        "gauge.collection.maxSize": {
          "type": "gauge",
          "description": "Maximum disk usage of a capped collection",
          "group": null,
          "default": false
        },
        "gauge.collection.size": {
          "type": "gauge",
          "description": "Size of a collection in bytes, not including indexes",
          "group": "collection",
          "default": false
        },
        "gauge.collection.storageSize": {
          "type": "gauge",
          "description": "Size of the collection on disk in bytes, never decreases.",
          "group": "collection",
          "default": false
        },
        "gauge.collections": {
          "type": "gauge",
          "description": "Number of collections",
          "group": null,
          "default": false
        },
        "gauge.connections.available": {
          "type": "gauge",
          "description": "Number of available incoming connections",
          "group": null,
          "default": false
        },
        "gauge.connections.current": {
          "type": "gauge",
          "description": "Number of current client connections",
          "group": null,
          "default": true
        },
        "gauge.connections.totalCreated": {
          "type": "cumulative",
          "description": "Count of all incoming connections created to the server. This number includes connections that have since closed.",
          "group": null,
          "default": false
        },
        "gauge.dataSize": {
          "type": "gauge",
          "description": "Total size of data, in bytes",
          "group": null,
          "default": true
        },
        "gauge.extra_info.heap_usage_bytes": {
          "type": "gauge",
          "description": "Heap size used by the mongod process, in bytes",
          "group": null,
          "default": true
        },
        "gauge.globalLock.activeClients.readers": {
          "type": "gauge",
          "description": "Number of active client connections performing reads",
          "group": null,
          "default": true
        },
        "gauge.globalLock.activeClients.total": {
          "type": "gauge",
          "description": "Total number of active client connections",
          "group": null,
          "default": false
        },
        "gauge.globalLock.activeClients.writers": {
          "type": "gauge",
          "description": "Number of active client connections performing writes",
          "group": null,
          "default": true
        },
        "gauge.globalLock.currentQueue.readers": {
          "type": "gauge",
          "description": "Read operations currently in queue",
          "group": null,
          "default": true
        },
        "gauge.globalLock.currentQueue.total": {
          "type": "gauge",
          "description": "Total operations currently in queue",
          "group": null,
          "default": false
        },
        "gauge.globalLock.currentQueue.writers": {
          "type": "gauge",
          "description": "Write operations currently in queue",
          "group": null,
          "default": true
        },
        "gauge.indexSize": {
          "type": "gauge",
          "description": "Total size of indexes, in bytes",
          "group": null,
          "default": true
        },
        "gauge.indexes": {
          "type": "gauge",
          "description": "Number of indexes across all collections",
          "group": null,
          "default": false
        },
        "gauge.mem.mapped": {
          "type": "gauge",
          "description": "Mongodb mapped memory usage, in MB",
          "group": null,
          "default": true
        },
        "gauge.mem.resident": {
          "type": "gauge",
          "description": "Mongodb resident memory usage, in MB",
          "group": null,
          "default": true
        },
        "gauge.mem.virtual": {
          "type": "gauge",
          "description": "Mongodb virtual memory usage, in MB",
          "group": null,
          "default": true
        },
        "gauge.numExtents": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.objects": {
          "type": "gauge",
          "description": "Number of documents across all collections",
          "group": null,
          "default": true
        },
        "gauge.storageSize": {
          "type": "gauge",
          "description": "Total bytes allocated to collections for document storage",
          "group": null,
          "default": true
        },
        "gauge.uptime": {
          "type": "counter",
          "description": "Uptime of this server in milliseconds",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/mongodb",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host name/IP address of the Mongo instance",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the Mongo instance (default: 27017)",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "databases",
            "doc": "Name(s) of database(s) that you would like metrics from. Note: the first database in this list must be \"admin\", as it is used to perform a `serverStatus()` command.",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "username",
            "doc": "The MongoDB user to connect as",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "The password of the above user",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useTLS",
            "doc": "If true, will connect to Mongo using TLS",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCerts",
            "doc": "Path to a CA cert that will be used to verify the certificate that Mongo presents (not needed if not using TLS or if Mongo's cert is signed by a globally trusted issuer already installed in the default location on your OS)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tlsClientCert",
            "doc": "Path to a client certificate (not needed unless your Mongo instance requires x509 client verification)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tlsClientKey",
            "doc": "Path to a client certificate key (not needed unless your Mongo instance requires x509 client verification, or if your client cert above has the key included)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tlsClientKeyPassPhrase",
            "doc": "Passphrase for the TLSClientKey above",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendCollectionMetrics",
            "doc": "Whether to send collection level metrics or not",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "sendCollectionTopMetrics",
            "doc": "Whether to send collection level top (timing) metrics or not",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/mysql",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a MySQL database server using collectd's [MySQL\nplugin](https://collectd.org/wiki/index.php/Plugin:MySQL). It supports\nMySQL versions 5.x or later.\n\nThis monitor connects to a MySQL instance and reports on the values\nreturned by a `SHOW STATUS` command. This includes the following:\n\n  - Number of commands processed\n  - Table and row operations (handlers)\n  - State of the query cache\n  - Status of MySQL threads\n  - Network traffic\n\n\u003c!--- SETUP ---\u003e\n### Note on localhost\nOn Unix, MySQL programs treat the host name `localhost` specially, in a way\nthat is likely different from what is expected compared to other\nnetwork-based programs. For connections to `localhost`, MySQL programs\nattempt to connect to the local server by using a Unix socket file. To ensure\nthat the client makes a TCP/IP connection to the local server specify a host\nname value of `127.0.0.1`, or the IP address or name of the local server.\n\n\u003c!--- SETUP ---\u003e\n### Databases\nYou have to specify each database you want to monitor individually under\nthe `databases` config option.  If you have a common authentication to all\ndatabases being monitored, you can specify that in the top-level\n`username`/`password` options, otherwise they can be specified at the\ndatabase level.\n\n\n\u003c!--- SETUP ---\u003e\n### Example Config\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: collectd/mysql\n   host: 127.0.0.1\n   port: 3306\n   databases:\n     - name: dbname\n     - name: securedb\n       username: admin\n       password: s3cr3t\n   username: dbuser\n   password: passwd\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "cache_result.cache_size",
            "cache_result.qcache-hits",
            "cache_result.qcache-inserts",
            "cache_result.qcache-not_cached",
            "cache_result.qcache-prunes",
            "cache_size.qcache",
            "mysql_commands.admin_commands",
            "mysql_commands.alter_db",
            "mysql_commands.alter_db_upgrade",
            "mysql_commands.alter_event",
            "mysql_commands.alter_function",
            "mysql_commands.alter_procedure",
            "mysql_commands.alter_server",
            "mysql_commands.alter_table",
            "mysql_commands.alter_tablespace",
            "mysql_commands.alter_user",
            "mysql_commands.analyze",
            "mysql_commands.assign_to_keycache",
            "mysql_commands.begin",
            "mysql_commands.binlog",
            "mysql_commands.call_procedure",
            "mysql_commands.change_db",
            "mysql_commands.change_master",
            "mysql_commands.check",
            "mysql_commands.checksum",
            "mysql_commands.commit",
            "mysql_commands.create_db",
            "mysql_commands.create_event",
            "mysql_commands.create_function",
            "mysql_commands.create_index",
            "mysql_commands.create_procedure",
            "mysql_commands.create_server",
            "mysql_commands.create_table",
            "mysql_commands.create_trigger",
            "mysql_commands.create_udf",
            "mysql_commands.create_user",
            "mysql_commands.create_view",
            "mysql_commands.dealloc_sql",
            "mysql_commands.delete",
            "mysql_commands.delete_multi",
            "mysql_commands.do",
            "mysql_commands.drop_db",
            "mysql_commands.drop_event",
            "mysql_commands.drop_function",
            "mysql_commands.drop_index",
            "mysql_commands.drop_procedure",
            "mysql_commands.drop_server",
            "mysql_commands.drop_table",
            "mysql_commands.drop_trigger",
            "mysql_commands.drop_user",
            "mysql_commands.drop_view",
            "mysql_commands.empty_query",
            "mysql_commands.execute_sql",
            "mysql_commands.flush",
            "mysql_commands.get_diagnostics",
            "mysql_commands.grant",
            "mysql_commands.ha_close",
            "mysql_commands.ha_open",
            "mysql_commands.ha_read",
            "mysql_commands.help",
            "mysql_commands.insert",
            "mysql_commands.insert_select",
            "mysql_commands.install_plugin",
            "mysql_commands.kill",
            "mysql_commands.load",
            "mysql_commands.lock_tables",
            "mysql_commands.optimize",
            "mysql_commands.preload_keys",
            "mysql_commands.prepare_sql",
            "mysql_commands.purge",
            "mysql_commands.purge_before_date",
            "mysql_commands.release_savepoint",
            "mysql_commands.rename_table",
            "mysql_commands.rename_user",
            "mysql_commands.repair",
            "mysql_commands.replace",
            "mysql_commands.replace_select",
            "mysql_commands.reset",
            "mysql_commands.resignal",
            "mysql_commands.revoke",
            "mysql_commands.revoke_all",
            "mysql_commands.rollback",
            "mysql_commands.rollback_to_savepoint",
            "mysql_commands.savepoint",
            "mysql_commands.select",
            "mysql_commands.set_option",
            "mysql_commands.show_binlog_events",
            "mysql_commands.show_binlogs",
            "mysql_commands.show_charsets",
            "mysql_commands.show_collations",
            "mysql_commands.show_create_db",
            "mysql_commands.show_create_event",
            "mysql_commands.show_create_func",
            "mysql_commands.show_create_proc",
            "mysql_commands.show_create_table",
            "mysql_commands.show_create_trigger",
            "mysql_commands.show_databases",
            "mysql_commands.show_engine_logs",
            "mysql_commands.show_engine_mutex",
            "mysql_commands.show_engine_status",
            "mysql_commands.show_errors",
            "mysql_commands.show_events",
            "mysql_commands.show_fields",
            "mysql_commands.show_function_code",
            "mysql_commands.show_function_status",
            "mysql_commands.show_grants",
            "mysql_commands.show_keys",
            "mysql_commands.show_master_status",
            "mysql_commands.show_open_tables",
            "mysql_commands.show_plugins",
            "mysql_commands.show_privileges",
            "mysql_commands.show_procedure_code",
            "mysql_commands.show_procedure_status",
            "mysql_commands.show_processlist",
            "mysql_commands.show_profile",
            "mysql_commands.show_profiles",
            "mysql_commands.show_relaylog_events",
            "mysql_commands.show_slave_hosts",
            "mysql_commands.show_slave_status",
            "mysql_commands.show_status",
            "mysql_commands.show_storage_engines",
            "mysql_commands.show_table_status",
            "mysql_commands.show_tables",
            "mysql_commands.show_triggers",
            "mysql_commands.show_variables",
            "mysql_commands.show_warnings",
            "mysql_commands.signal",
            "mysql_commands.slave_start",
            "mysql_commands.slave_stop",
            "mysql_commands.truncate",
            "mysql_commands.uninstall_plugin",
            "mysql_commands.unlock_tables",
            "mysql_commands.update",
            "mysql_commands.update_multi",
            "mysql_commands.xa_commit",
            "mysql_commands.xa_end",
            "mysql_commands.xa_prepare",
            "mysql_commands.xa_recover",
            "mysql_commands.xa_rollback",
            "mysql_commands.xa_start",
            "mysql_handler.commit",
            "mysql_handler.delete",
            "mysql_handler.external_lock",
            "mysql_handler.prepare",
            "mysql_handler.read_first",
            "mysql_handler.read_key",
            "mysql_handler.read_next",
            "mysql_handler.read_prev",
            "mysql_handler.read_rnd",
            "mysql_handler.read_rnd_next",
            "mysql_handler.rollback",
            "mysql_handler.savepoint",
            "mysql_handler.savepoint_rollback",
            "mysql_handler.update",
            "mysql_handler.write",
            "mysql_locks.immediate",
            "mysql_locks.waited",
            "mysql_octets.rx",
            "mysql_octets.tx",
            "mysql_select.full_join",
            "mysql_select.full_range_join",
            "mysql_select.range",
            "mysql_select.range_check",
            "mysql_select.scan",
            "mysql_slow_queries",
            "mysql_sort.range",
            "mysql_sort.scan",
            "mysql_sort_merge_passes",
            "mysql_sort_rows",
            "threads.cached",
            "threads.connected",
            "threads.running",
            "total_threads.created"
          ]
        }
      },
      "metrics": {
        "cache_result.cache_size": {
          "type": "gauge",
          "description": "MySQL Qcache Size",
          "group": null,
          "default": false
        },
        "cache_result.qcache-hits": {
          "type": "cumulative",
          "description": "The number of hits on MySQL query cache.",
          "group": null,
          "default": true
        },
        "cache_result.qcache-inserts": {
          "type": "cumulative",
          "description": "The number of inserts into MySQL query cache.",
          "group": null,
          "default": true
        },
        "cache_result.qcache-not_cached": {
          "type": "cumulative",
          "description": "The number of MySQL queries that were not cacheable or not cached.",
          "group": null,
          "default": false
        },
        "cache_result.qcache-prunes": {
          "type": "cumulative",
          "description": "The number of queries that were pruned from query cache because of low-memory condition.",
          "group": null,
          "default": false
        },
        "cache_size.qcache": {
          "type": "gauge",
          "description": "The number of queries in MySQL query cache.",
          "group": null,
          "default": true
        },
        "mysql_commands.admin_commands": {
          "type": "cumulative",
          "description": "The number of MySQL ADMIN commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_db": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER DB commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_db_upgrade": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER DB UPGRADE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_event": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER EVENT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_function": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER FUNCTION commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_procedure": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER PROCEDURE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_server": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER SERVER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_table": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER TABLE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_tablespace": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER TABLESPACE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.alter_user": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER USER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.analyze": {
          "type": "cumulative",
          "description": "The number of MySQL ANALYZE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.assign_to_keycache": {
          "type": "cumulative",
          "description": "The number of MySQL ASSIGN TO KEYCACHE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.begin": {
          "type": "cumulative",
          "description": "The number of MySQL BEGIN commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.binlog": {
          "type": "cumulative",
          "description": "The number of MySQL BINLOG commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.call_procedure": {
          "type": "cumulative",
          "description": "The number of MySQL CALL PROCEDURE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.change_db": {
          "type": "cumulative",
          "description": "The number of MySQL CHANGE DB commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.change_master": {
          "type": "cumulative",
          "description": "The number of MySQL CHANGE MASTER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.check": {
          "type": "cumulative",
          "description": "The number of MySQL CHECK commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.checksum": {
          "type": "cumulative",
          "description": "The number of MySQL CHECKSUM commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.commit": {
          "type": "cumulative",
          "description": "The number of MySQL COMMIT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_db": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE DB commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_event": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE EVENT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_function": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE FUNCTION commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_index": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE INDEX commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_procedure": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE PROCEDURE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_server": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE SERVER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_table": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE TABLE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_trigger": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE TRIGGER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_udf": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE UDF commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_user": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE USER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.create_view": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE VIEW commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.dealloc_sql": {
          "type": "cumulative",
          "description": "The number of MySQL DEALLOC SQL commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.delete": {
          "type": "cumulative",
          "description": "The number of MySQL DELETE commands executed",
          "group": null,
          "default": true
        },
        "mysql_commands.delete_multi": {
          "type": "cumulative",
          "description": "The number of MySQL DELETE MULTI commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.do": {
          "type": "cumulative",
          "description": "The number of MySQL DO commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_db": {
          "type": "cumulative",
          "description": "The number of MySQL DROP DB commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_event": {
          "type": "cumulative",
          "description": "The number of MySQL DROP EVENT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_function": {
          "type": "cumulative",
          "description": "The number of MySQL DROP FUNCTION commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_index": {
          "type": "cumulative",
          "description": "The number of MySQL DROP INDEX commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_procedure": {
          "type": "cumulative",
          "description": "The number of MySQL DROP PROCEDURE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_server": {
          "type": "cumulative",
          "description": "The number of MySQL DROP SERVER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_table": {
          "type": "cumulative",
          "description": "The number of MySQL DROP TABLE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_trigger": {
          "type": "cumulative",
          "description": "The number of MySQL DROP TRIGGER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_user": {
          "type": "cumulative",
          "description": "The number of MySQL DROP USER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.drop_view": {
          "type": "cumulative",
          "description": "The number of MySQL DROP VIEW commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.empty_query": {
          "type": "cumulative",
          "description": "The number of MySQL EMPTY QUERY commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.execute_sql": {
          "type": "cumulative",
          "description": "The number of MySQL EXECUTE SQL commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.flush": {
          "type": "cumulative",
          "description": "The number of MySQL FLUSH commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.get_diagnostics": {
          "type": "cumulative",
          "description": "The number of MySQL GET DIAGNOSTICS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.grant": {
          "type": "cumulative",
          "description": "The number of MySQL GRANT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.ha_close": {
          "type": "cumulative",
          "description": "The number of MySQL HA CLOSE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.ha_open": {
          "type": "cumulative",
          "description": "The number of MySQL HA OPEN commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.ha_read": {
          "type": "cumulative",
          "description": "The number of MySQL HA READ commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.help": {
          "type": "cumulative",
          "description": "The number of MySQL HELP commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.insert": {
          "type": "cumulative",
          "description": "The number of MySQL INSERT commands executed",
          "group": null,
          "default": true
        },
        "mysql_commands.insert_select": {
          "type": "cumulative",
          "description": "The number of MySQL INSERT SELECT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.install_plugin": {
          "type": "cumulative",
          "description": "The number of MySQL INSTALL PLUGIN commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.kill": {
          "type": "cumulative",
          "description": "The number of MySQL KILL commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.load": {
          "type": "cumulative",
          "description": "The number of MySQL LOAD commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.lock_tables": {
          "type": "cumulative",
          "description": "The number of MySQL LOCK TABLES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.optimize": {
          "type": "cumulative",
          "description": "The number of MySQL OPTIMIZE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.preload_keys": {
          "type": "cumulative",
          "description": "The number of MySQL PRELOAD KEYS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.prepare_sql": {
          "type": "cumulative",
          "description": "The number of MySQL PREPARE SQL commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.purge": {
          "type": "cumulative",
          "description": "The number of MySQL PURGE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.purge_before_date": {
          "type": "cumulative",
          "description": "The number of MySQL PURGE BEFORE DATE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.release_savepoint": {
          "type": "cumulative",
          "description": "The number of MySQL RELEASE SAVEPOINT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.rename_table": {
          "type": "cumulative",
          "description": "The number of MySQL RENAME TABLE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.rename_user": {
          "type": "cumulative",
          "description": "The number of MySQL RENAME USER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.repair": {
          "type": "cumulative",
          "description": "The number of MySQL REPAIR commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.replace": {
          "type": "cumulative",
          "description": "The number of MySQL REPLACE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.replace_select": {
          "type": "cumulative",
          "description": "The number of MySQL REPLACE SELECT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.reset": {
          "type": "cumulative",
          "description": "The number of MySQL RESET commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.resignal": {
          "type": "cumulative",
          "description": "The number of MySQL RESIGNAL commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.revoke": {
          "type": "cumulative",
          "description": "The number of MySQL REVOKE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.revoke_all": {
          "type": "cumulative",
          "description": "The number of MySQL REVOKE ALL commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.rollback": {
          "type": "cumulative",
          "description": "The number of MySQL ROLLBACK commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.rollback_to_savepoint": {
          "type": "cumulative",
          "description": "The number of MySQL ROLLBACK TO SAVEPOINT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.savepoint": {
          "type": "cumulative",
          "description": "The number of MySQL SAVEPOINT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.select": {
          "type": "cumulative",
          "description": "The number of MySQL SELECT commands executed",
          "group": null,
          "default": true
        },
        "mysql_commands.set_option": {
          "type": "cumulative",
          "description": "The number of MySQL SET OPTION commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_binlog_events": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW BINLOG EVENTS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_binlogs": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW BINLOGS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_charsets": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CHARSETS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_collations": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW COLLATIONS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_create_db": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE DB commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_create_event": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE EVENT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_create_func": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE FUNC commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_create_proc": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE PROC commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_create_table": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE TABLE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_create_trigger": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE TRIGGER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_databases": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW DATABASES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_engine_logs": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW ENGINE LOGS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_engine_mutex": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW ENGINE MUTEX commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_engine_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW ENGINE STATUS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_errors": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW ERRORS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_events": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW EVENTS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_fields": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW FIELDS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_function_code": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW FUNCTION CODE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_function_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW FUNCTION STATUS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_grants": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW GRANTS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_keys": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW KEYS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_master_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW MASTER STATUS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_open_tables": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW OPEN TABLES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_plugins": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PLUGINS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_privileges": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PRIVILEGES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_procedure_code": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROCEDURE CODE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_procedure_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROCEDURE STATUS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_processlist": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROCESSLIST commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_profile": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROFILE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_profiles": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROFILES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_relaylog_events": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW RELAYLOG EVENTS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_slave_hosts": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW SLAVE HOSTS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_slave_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW SLAVE STATUS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW STATUS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_storage_engines": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW STORAGE ENGINES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_table_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW TABLE STATUS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_tables": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW TABLES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_triggers": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW TRIGGERS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_variables": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW VARIABLES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.show_warnings": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW WARNINGS commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.signal": {
          "type": "cumulative",
          "description": "The number of MySQL SIGNAL commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.slave_start": {
          "type": "cumulative",
          "description": "The number of MySQL SLAVE START commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.slave_stop": {
          "type": "cumulative",
          "description": "The number of MySQL SLAVE STOP commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.truncate": {
          "type": "cumulative",
          "description": "The number of MySQL TRUNCATE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.uninstall_plugin": {
          "type": "cumulative",
          "description": "The number of MySQL UNINSTALL PLUGIN commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.unlock_tables": {
          "type": "cumulative",
          "description": "The number of MySQL UNLOCK TABLES commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.update": {
          "type": "cumulative",
          "description": "The number of MySQL UPDATE commands executed",
          "group": null,
          "default": true
        },
        "mysql_commands.update_multi": {
          "type": "cumulative",
          "description": "The number of MySQL UPDATE MULTI commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.xa_commit": {
          "type": "cumulative",
          "description": "The number of MySQL XA COMMIT commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.xa_end": {
          "type": "cumulative",
          "description": "The number of MySQL XA END commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.xa_prepare": {
          "type": "cumulative",
          "description": "The number of MySQL XA PREPARE commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.xa_recover": {
          "type": "cumulative",
          "description": "The number of MySQL XA RECOVER commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.xa_rollback": {
          "type": "cumulative",
          "description": "The number of MySQL XA ROLLBACK commands executed",
          "group": null,
          "default": false
        },
        "mysql_commands.xa_start": {
          "type": "cumulative",
          "description": "The number of MySQL XA START commands executed",
          "group": null,
          "default": false
        },
        "mysql_handler.commit": {
          "type": "cumulative",
          "description": "The number of internal COMMIT statements.",
          "group": null,
          "default": false
        },
        "mysql_handler.delete": {
          "type": "cumulative",
          "description": "The number of times rows have been deleted from tables.",
          "group": null,
          "default": false
        },
        "mysql_handler.external_lock": {
          "type": "cumulative",
          "description": "The number of external_lock occurences.",
          "group": null,
          "default": false
        },
        "mysql_handler.prepare": {
          "type": "cumulative",
          "description": "The number of times \"Prepare\" phase was executed in the two-phase commit operations.",
          "group": null,
          "default": false
        },
        "mysql_handler.read_first": {
          "type": "cumulative",
          "description": "The number of times the first entry in an index was read.",
          "group": null,
          "default": false
        },
        "mysql_handler.read_key": {
          "type": "cumulative",
          "description": "The number of times a row was read based on a key.",
          "group": null,
          "default": false
        },
        "mysql_handler.read_next": {
          "type": "cumulative",
          "description": "The number of requests to read the next row in key order.",
          "group": null,
          "default": false
        },
        "mysql_handler.read_prev": {
          "type": "cumulative",
          "description": "The number of requests to read the previous row in key order.",
          "group": null,
          "default": false
        },
        "mysql_handler.read_rnd": {
          "type": "cumulative",
          "description": "The number of requests that read a random fixed position in the data file.",
          "group": null,
          "default": false
        },
        "mysql_handler.read_rnd_next": {
          "type": "cumulative",
          "description": "The number of requests for the next row in the data file.",
          "group": null,
          "default": false
        },
        "mysql_handler.rollback": {
          "type": "cumulative",
          "description": "The number of requests for a rollback operation on the storage engine.",
          "group": null,
          "default": false
        },
        "mysql_handler.savepoint": {
          "type": "cumulative",
          "description": "The number of requests to place a savepoint on the storage engine.  This can be used to roll back later.",
          "group": null,
          "default": false
        },
        "mysql_handler.savepoint_rollback": {
          "type": "cumulative",
          "description": "The number of requests to roll back to a savepoint.",
          "group": null,
          "default": false
        },
        "mysql_handler.update": {
          "type": "cumulative",
          "description": "The number of requests to update a row in a table.",
          "group": null,
          "default": false
        },
        "mysql_handler.write": {
          "type": "cumulative",
          "description": "The number of requests to insert a row in a table.",
          "group": null,
          "default": false
        },
        "mysql_locks.immediate": {
          "type": "cumulative",
          "description": "The number of MySQL table locks which were granted immediately.",
          "group": null,
          "default": true
        },
        "mysql_locks.waited": {
          "type": "cumulative",
          "description": "The number of MySQL table locks which had to wait before being granted.",
          "group": null,
          "default": true
        },
        "mysql_octets.rx": {
          "type": "cumulative",
          "description": "The number of bytes received by MySQL server from all clients.",
          "group": null,
          "default": true
        },
        "mysql_octets.tx": {
          "type": "cumulative",
          "description": "The number of bytes sent by MySQL server to all clients.",
          "group": null,
          "default": true
        },
        "mysql_select.full_join": {
          "type": "cumulative",
          "description": "The number of joins that perform full table scans.",
          "group": null,
          "default": false
        },
        "mysql_select.full_range_join": {
          "type": "cumulative",
          "description": "The number of joins that used a range search on a reference table.",
          "group": null,
          "default": false
        },
        "mysql_select.range": {
          "type": "cumulative",
          "description": "The number of joins that used a range on the first table.",
          "group": null,
          "default": false
        },
        "mysql_select.range_check": {
          "type": "cumulative",
          "description": "The number of joins without keys that check for key usage after each row.",
          "group": null,
          "default": false
        },
        "mysql_select.scan": {
          "type": "cumulative",
          "description": "The number of joins that did a full scan of the first table.",
          "group": null,
          "default": false
        },
        "mysql_slow_queries": {
          "type": "cumulative",
          "description": "The number of queries that have taken more than long_query_time seconds.",
          "group": null,
          "default": false
        },
        "mysql_sort.range": {
          "type": "cumulative",
          "description": "The number of sorts that were done using ranges.",
          "group": null,
          "default": false
        },
        "mysql_sort.scan": {
          "type": "cumulative",
          "description": "The number of sorts that were done by scanning the table.",
          "group": null,
          "default": false
        },
        "mysql_sort_merge_passes": {
          "type": "cumulative",
          "description": "The number of merge passes done by the sorting algorithm.",
          "group": null,
          "default": false
        },
        "mysql_sort_rows": {
          "type": "cumulative",
          "description": "The number of rows that were sorted.",
          "group": null,
          "default": false
        },
        "threads.cached": {
          "type": "gauge",
          "description": "The number of threads cached by MySQL for re-use on a new client connection.  A MySQL thread corresponds to a single MySQL connection.",
          "group": null,
          "default": true
        },
        "threads.connected": {
          "type": "gauge",
          "description": "The number of currently open MySQL connections.  A MySQL thread corresponds to a single MySQL connection.",
          "group": null,
          "default": true
        },
        "threads.running": {
          "type": "gauge",
          "description": "The number of MySQL threads that are processing a query.  A MySQL thread corresponds to a single MySQL connection.",
          "group": null,
          "default": false
        },
        "total_threads.created": {
          "type": "cumulative",
          "description": "The total number of threads created by MySQL for client connections.  A MySQL thread corresponds to a single MySQL connection.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/mysql",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "databases",
            "doc": "A list of databases along with optional authentication credentials.",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Database",
              "doc": "Database configures a particular MySQL database",
              "package": "pkg/monitors/collectd/mysql",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "username",
                  "doc": "",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "password",
                  "doc": "",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "username",
            "doc": "These credentials serve as defaults for all databases if not overridden",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "reportHost",
            "doc": "A SignalFx extension to the plugin that allows us to disable the normal behavior of the MySQL collectd plugin where the `host` dimension is set to the hostname of the MySQL database server.  When `false` (the recommended and default setting), the globally configured `hostname` config is used instead.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/nginx",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an NGINX instance using our fork of the\ncollectd nginx plugin based on the [collectd nginx\nplugin](https://collectd.org/wiki/index.php/Plugin:nginx).\n\nNote that this montior requires special configuration enabled in NGINX (see Setup).\n\n\u003c!--- SETUP ---\u003e\n### NGINX-specific configuration\n\nYou must configure NGINX to expose status information by editing the NGINX\nconfiguration.  Please see\n[ngx_http_stub_status_module](http://nginx.org/en/docs/http/ngx_http_stub_status_module.html)\nfor a guide to configuring the NGINX stats module\n`ngx_http_stub_status_module`.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "connections.accepted",
            "connections.failed",
            "connections.handled",
            "nginx_connections.active",
            "nginx_connections.reading",
            "nginx_connections.waiting",
            "nginx_connections.writing",
            "nginx_requests"
          ]
        }
      },
      "metrics": {
        "connections.accepted": {
          "type": "cumulative",
          "description": "Connections accepted by NGINX Web Server",
          "group": null,
          "default": true
        },
        "connections.failed": {
          "type": "cumulative",
          "description": "Connections failed by the NGINX Web Server",
          "group": null,
          "default": false
        },
        "connections.handled": {
          "type": "cumulative",
          "description": "Connections handled by NGINX Web Server",
          "group": null,
          "default": true
        },
        "nginx_connections.active": {
          "type": "gauge",
          "description": "Connections active in NGINX Web Server",
          "group": null,
          "default": true
        },
        "nginx_connections.reading": {
          "type": "gauge",
          "description": "Connections being read by NGINX Web Server",
          "group": null,
          "default": true
        },
        "nginx_connections.waiting": {
          "type": "gauge",
          "description": "Connections waited on by NGINX Web Server",
          "group": null,
          "default": true
        },
        "nginx_connections.writing": {
          "type": "gauge",
          "description": "Connections being written by NGINX Web Server",
          "group": null,
          "default": true
        },
        "nginx_requests": {
          "type": "cumulative",
          "description": "Requests handled by NGINX Web Server",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/nginx",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "url",
            "doc": "The full URL of the status endpoint; can be a template",
            "default": "http://{{.Host}}:{{.Port}}/nginx_status",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "timeout",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/openstack",
      "sendAll": false,
      "dimensions": {
        "plugin": {
          "description": "This is always set to `openstack`."
        },
        "plugin_instance": {
          "description": "This will contain the project id and name of the project given in the configuration."
        }
      },
      "doc": "Monitors [Openstack](https://www.openstack.org/) by using the [Openstack\ncollectd Python plugin](https://github.com/signalfx/collectd-openstack),\nwhich collects metrics from Openstack instances.  This plugin is installed\nwith the Smart Agent, so no additional installation is required to use this\nmontior.\n\nThis monitor covers the following Openstack components:\n\n* Nova (Compute)\n* Cinder (BlockStorge)\n* Neutron (Network)\n\nPlease see the reference for OpenStack [Monitoring](https://wiki.openstack.org/wiki/Operations/Monitoring).\n\n\u003c!--- SETUP ---\u003e\n### Deployment Host\n\nIdentify a host on which the SignalFx agent will run. This integration\ncollects data from OpenStack remotely via APIs, and so those API endpoints\nmust be visible to the host on which the agent runs.  We do not recommend\ninstalling the agent directly on a compute instance because a compute\ninstance/resource under one project cannot get stats about the resources\nunder other projects. Also, a compute instance may go down due to lack of\nresources in the project.\n\n\u003c!--- SETUP ---\u003e\n### Example config\n```yaml\nmonitors:\n- type: collectd/openstack\n  authURL: \"http://192.168.11.111/identity/v3\"\n  username: \"admin\"\n  password: \"secret\"\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.openstack.nova.server.cpu_time",
            "counter.openstack.nova.server.rx",
            "counter.openstack.nova.server.rx_packets",
            "counter.openstack.nova.server.tx",
            "counter.openstack.nova.server.tx_packets",
            "gauge.openstack.cinder.limit.maxTotalBackupGigabytes",
            "gauge.openstack.cinder.limit.maxTotalBackups",
            "gauge.openstack.cinder.limit.maxTotalSnapshots",
            "gauge.openstack.cinder.limit.maxTotalVolumeGigabytes",
            "gauge.openstack.cinder.limit.maxTotalVolumes",
            "gauge.openstack.cinder.limit.totalBackupGigabytesUsed",
            "gauge.openstack.cinder.limit.totalBackupsUsed",
            "gauge.openstack.cinder.limit.totalGigabytesUsed",
            "gauge.openstack.cinder.limit.totalSnapshotsUsed",
            "gauge.openstack.cinder.limit.totalVolumesUsed",
            "gauge.openstack.cinder.snapshot.count",
            "gauge.openstack.cinder.snapshot.size",
            "gauge.openstack.cinder.volume.count",
            "gauge.openstack.cinder.volume.size",
            "gauge.openstack.neutron.floatingip.count",
            "gauge.openstack.neutron.network.count",
            "gauge.openstack.neutron.router.count",
            "gauge.openstack.neutron.securitygroup.count",
            "gauge.openstack.neutron.subnet.count",
            "gauge.openstack.nova.hypervisor.current_workload",
            "gauge.openstack.nova.hypervisor.disk_available_least",
            "gauge.openstack.nova.hypervisor.free_disk_gb",
            "gauge.openstack.nova.hypervisor.free_ram_mb",
            "gauge.openstack.nova.hypervisor.load_average",
            "gauge.openstack.nova.hypervisor.local_gb",
            "gauge.openstack.nova.hypervisor.local_gb_used",
            "gauge.openstack.nova.hypervisor.memory_mb",
            "gauge.openstack.nova.hypervisor.memory_mb_used",
            "gauge.openstack.nova.hypervisor.running_vms",
            "gauge.openstack.nova.hypervisor.vcpus",
            "gauge.openstack.nova.hypervisor.vcpus_used",
            "gauge.openstack.nova.limit.maxImageMeta",
            "gauge.openstack.nova.limit.maxSecurityGroups",
            "gauge.openstack.nova.limit.maxTotalCores",
            "gauge.openstack.nova.limit.maxTotalFloatingIps",
            "gauge.openstack.nova.limit.maxTotalInstances",
            "gauge.openstack.nova.limit.maxTotalKeypairs",
            "gauge.openstack.nova.limit.maxTotalRAMSize",
            "gauge.openstack.nova.limit.totalCoresUsed",
            "gauge.openstack.nova.limit.totalFloatingIpsUsed",
            "gauge.openstack.nova.limit.totalInstancesUsed",
            "gauge.openstack.nova.limit.totalRAMUsed",
            "gauge.openstack.nova.limit.totalSecurityGroupsUsed",
            "gauge.openstack.nova.server.memory",
            "gauge.openstack.nova.server.memory-actual",
            "gauge.openstack.nova.server.memory-rss",
            "gauge.openstack.nova.server.vda_read",
            "gauge.openstack.nova.server.vda_read_req",
            "gauge.openstack.nova.server.vda_write",
            "gauge.openstack.nova.server.vda_write_req"
          ]
        }
      },
      "metrics": {
        "counter.openstack.nova.server.cpu_time": {
          "type": "counter",
          "description": "Virtual CPU time consumed in nanoseconds",
          "group": null,
          "default": false
        },
        "counter.openstack.nova.server.rx": {
          "type": "counter",
          "description": "Size of network packet received in bytes",
          "group": null,
          "default": true
        },
        "counter.openstack.nova.server.rx_packets": {
          "type": "counter",
          "description": "Received packets at an instance",
          "group": null,
          "default": true
        },
        "counter.openstack.nova.server.tx": {
          "type": "counter",
          "description": "Size of network packet transmitted in bytes",
          "group": null,
          "default": true
        },
        "counter.openstack.nova.server.tx_packets": {
          "type": "counter",
          "description": "Transmitted packets at an instance",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.maxTotalBackupGigabytes": {
          "type": "gauge",
          "description": "Maximum backup space available at cinder component for project in Gigabytes",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.maxTotalBackups": {
          "type": "gauge",
          "description": "Total available backups used at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.maxTotalSnapshots": {
          "type": "gauge",
          "description": "Total available snapshots at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.maxTotalVolumeGigabytes": {
          "type": "gauge",
          "description": "Total available block storage at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.maxTotalVolumes": {
          "type": "gauge",
          "description": "Maximum volume resources available at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.totalBackupGigabytesUsed": {
          "type": "gauge",
          "description": "Total backup space used at cinder component for project in Gigabytes",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.totalBackupsUsed": {
          "type": "gauge",
          "description": "Total backups used at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.totalGigabytesUsed": {
          "type": "gauge",
          "description": "Total block storage used at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.totalSnapshotsUsed": {
          "type": "gauge",
          "description": "Total snapshots used at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.limit.totalVolumesUsed": {
          "type": "gauge",
          "description": "Volume resources used at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.snapshot.count": {
          "type": "gauge",
          "description": "Total number of snapshots at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.snapshot.size": {
          "type": "gauge",
          "description": "Total snapshot size at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.volume.count": {
          "type": "gauge",
          "description": "Total number of volumes at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.cinder.volume.size": {
          "type": "gauge",
          "description": "Total volume size at cinder component for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.neutron.floatingip.count": {
          "type": "gauge",
          "description": "Overall floating IPs used across projects",
          "group": null,
          "default": true
        },
        "gauge.openstack.neutron.network.count": {
          "type": "gauge",
          "description": "Overall Network resources used across projects",
          "group": null,
          "default": true
        },
        "gauge.openstack.neutron.router.count": {
          "type": "gauge",
          "description": "Overall router resources used across projects",
          "group": null,
          "default": true
        },
        "gauge.openstack.neutron.securitygroup.count": {
          "type": "gauge",
          "description": "Overall securitygroup resources used across projects",
          "group": null,
          "default": true
        },
        "gauge.openstack.neutron.subnet.count": {
          "type": "gauge",
          "description": "Overall subnet resources used in all projects",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.current_workload": {
          "type": "gauge",
          "description": "Total current active hypervisor tasks in project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.disk_available_least": {
          "type": "gauge",
          "description": "Minimum free disk space available in Gigabyte",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.free_disk_gb": {
          "type": "gauge",
          "description": "Maximum free disk space available in Gigabyte",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.free_ram_mb": {
          "type": "gauge",
          "description": "Maximum free ram space available in Megabyte",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.load_average": {
          "type": "gauge",
          "description": "Average CPU load on the hypervisor",
          "group": null,
          "default": false
        },
        "gauge.openstack.nova.hypervisor.local_gb": {
          "type": "gauge",
          "description": "Maximum available local disk space in Gigabyte",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.local_gb_used": {
          "type": "gauge",
          "description": "Total disk space used in Gigabyte",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.memory_mb": {
          "type": "gauge",
          "description": "Maximum available memory in MB at hypervisor",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.memory_mb_used": {
          "type": "gauge",
          "description": "Total memory used in MB at hypervisor",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.running_vms": {
          "type": "gauge",
          "description": "Total running VMs at hypervisor",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.vcpus": {
          "type": "gauge",
          "description": "Available physical cores at hypervisor",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.hypervisor.vcpus_used": {
          "type": "gauge",
          "description": "Used virtual CPUs used",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.maxImageMeta": {
          "type": "gauge",
          "description": "Maximum number of metadata items associated with an image for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.maxSecurityGroups": {
          "type": "gauge",
          "description": "Maximum available security groups for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.maxTotalCores": {
          "type": "gauge",
          "description": "Maximum available VCPUs in project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.maxTotalFloatingIps": {
          "type": "gauge",
          "description": "Maximum available floating IPs for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.maxTotalInstances": {
          "type": "gauge",
          "description": "Maximum available instances in project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.maxTotalKeypairs": {
          "type": "gauge",
          "description": "Maximum available keypairs for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.maxTotalRAMSize": {
          "type": "gauge",
          "description": "Maximum available RAM size for project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.totalCoresUsed": {
          "type": "gauge",
          "description": "Total cores used in the project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.totalFloatingIpsUsed": {
          "type": "gauge",
          "description": "Total floating IPs used in the project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.totalInstancesUsed": {
          "type": "gauge",
          "description": "Total instances used in the project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.totalRAMUsed": {
          "type": "gauge",
          "description": "Total RAM used in the project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.limit.totalSecurityGroupsUsed": {
          "type": "gauge",
          "description": "Total RAM used in the project",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.server.memory": {
          "type": "gauge",
          "description": "Memory provisioned at an instance",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.server.memory-actual": {
          "type": "gauge",
          "description": "Actual memory used at an instance",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.server.memory-rss": {
          "type": "gauge",
          "description": "Memory used not including disk pages at an instance",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.server.vda_read": {
          "type": "gauge",
          "description": "Size of virtual disk read requests in bytes",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.server.vda_read_req": {
          "type": "gauge",
          "description": "Virtual disk read requests from an instance",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.server.vda_write": {
          "type": "gauge",
          "description": "Size of virtual disk write requests in bytes",
          "group": null,
          "default": true
        },
        "gauge.openstack.nova.server.vda_write_req": {
          "type": "gauge",
          "description": "Virtual disk write requests from an instance",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/openstack",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "authURL",
            "doc": "Keystone authentication URL/endpoint for the OpenStack cloud",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate with keystone identity",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password to authenticate with keystone identity",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "projectName",
            "doc": "Specify the name of Project to be monitored (**default**:\"demo\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "projectDomainID",
            "doc": "The project domain (**default**:\"default\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "userDomainID",
            "doc": "The user domain id (**default**:\"default\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/postgresql",
      "sendAll": false,
      "dimensions": null,
      "doc": "**This monitor is deprecated in favor of the [postgresql monitor](./postgresql.md).**\n\nMonitors a PostgreSQL database server using collectd's\n[PostgreSQL plugin](https://collectd.org/wiki/index.php/Plugin:PostgreSQL).\n\nYou have to specify each database you want to monitor individually under the\n`databases` key.  If you have a common authentication to all databases being\nmonitored, you can specify that in the top-level `username`/`password`\noptions, otherwise they can be specified at the database level.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/postgresql\n  host: 127.0.0.1\n  port: 5432\n  username: \"username1\"\n  password: \"password1\"\n  databases:\n  - name: \"testdb\"\n    username: \"test_user\"\n    password: \"test_pwd\"\n```\n\nSample YAML configuration with custom query:\n\n```yaml\nmonitors:\n- type: collectd/postgresql\n  host: 127.0.0.1\n  port: 5432\n  username: \"username1\"\n  password: \"password1\"\n  queries:\n  - name: \"exampleQuery\"\n    params:\n    - \"hostname\"\n    statement: \"Select * From test Where host = $1;\"\n    results:\n    - type: \"gauge\"\n      valuesFrom:\n      - \"test\"\n      instancePrefix: \"test\"\n databases:\n - name: \"test\"\n   username: \"username2\"\n   password: \"password2\"\n   queries:\n   - \"exampleQuery\"\n\nmetricsToInclude:\n   - metricNames:\n     - gauge.test\n     monitorType: collectd/postgresql\n```\nNote that the metric names for the additional metrics picked up from the\nqueries provided depend on the type, instancePrefix and/or instancesFrom\nparameters being passed in.\nSee [PostgreSQL plugin](https://collectd.org/wiki/index.php/Plugin:PostgreSQL)\nfor details.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "pg_blks.heap_hit",
            "pg_blks.heap_read",
            "pg_blks.idx_hit",
            "pg_blks.idx_read",
            "pg_blks.tidx_hit",
            "pg_blks.tidx_read",
            "pg_blks.toast_hit",
            "pg_blks.toast_read",
            "pg_db_size",
            "pg_n_tup_c.del",
            "pg_n_tup_c.hot_upd",
            "pg_n_tup_c.ins",
            "pg_n_tup_c.upd",
            "pg_n_tup_g.dead",
            "pg_n_tup_g.live",
            "pg_numbackends",
            "pg_scan.idx",
            "pg_scan.idx_tup_fetch",
            "pg_scan.seq",
            "pg_scan.seq_tup_read",
            "pg_xact.commit",
            "pg_xact.num_deadlocks",
            "pg_xact.rollback"
          ]
        }
      },
      "metrics": {
        "pg_blks.heap_hit": {
          "type": "gauge",
          "description": "Number of buffer hits",
          "group": null,
          "default": true
        },
        "pg_blks.heap_read": {
          "type": "gauge",
          "description": "Number of disk blocks read",
          "group": null,
          "default": true
        },
        "pg_blks.idx_hit": {
          "type": "gauge",
          "description": "Number of index buffer hits",
          "group": null,
          "default": true
        },
        "pg_blks.idx_read": {
          "type": "gauge",
          "description": "Number of index blocks read",
          "group": null,
          "default": true
        },
        "pg_blks.tidx_hit": {
          "type": "gauge",
          "description": "Number of TOAST index buffer hits",
          "group": null,
          "default": false
        },
        "pg_blks.tidx_read": {
          "type": "gauge",
          "description": "Number of TOAST index blocks read",
          "group": null,
          "default": false
        },
        "pg_blks.toast_hit": {
          "type": "gauge",
          "description": "Number of TOAST buffer hits",
          "group": null,
          "default": false
        },
        "pg_blks.toast_read": {
          "type": "gauge",
          "description": "Number of disk blocks read",
          "group": null,
          "default": false
        },
        "pg_db_size": {
          "type": "gauge",
          "description": "Size of the database on disk, in bytes",
          "group": null,
          "default": true
        },
        "pg_n_tup_c.del": {
          "type": "gauge",
          "description": "Number of delete operations",
          "group": null,
          "default": true
        },
        "pg_n_tup_c.hot_upd": {
          "type": "gauge",
          "description": "Number of update operations not requiring index update",
          "group": null,
          "default": false
        },
        "pg_n_tup_c.ins": {
          "type": "gauge",
          "description": "Number of insert operations",
          "group": null,
          "default": true
        },
        "pg_n_tup_c.upd": {
          "type": "gauge",
          "description": "Number of update operations",
          "group": null,
          "default": true
        },
        "pg_n_tup_g.dead": {
          "type": "gauge",
          "description": "Number of dead rows in the database",
          "group": null,
          "default": false
        },
        "pg_n_tup_g.live": {
          "type": "gauge",
          "description": "Number of live rows in the database",
          "group": null,
          "default": true
        },
        "pg_numbackends": {
          "type": "gauge",
          "description": "Number of server processes",
          "group": null,
          "default": true
        },
        "pg_scan.idx": {
          "type": "gauge",
          "description": "Number of index scans",
          "group": null,
          "default": true
        },
        "pg_scan.idx_tup_fetch": {
          "type": "gauge",
          "description": "Number of rows read from index scans",
          "group": null,
          "default": true
        },
        "pg_scan.seq": {
          "type": "gauge",
          "description": "Number of sequential scans",
          "group": null,
          "default": true
        },
        "pg_scan.seq_tup_read": {
          "type": "gauge",
          "description": "Number of rows read from sequential scans",
          "group": null,
          "default": true
        },
        "pg_xact.commit": {
          "type": "gauge",
          "description": "Number of commits",
          "group": null,
          "default": true
        },
        "pg_xact.num_deadlocks": {
          "type": "gauge",
          "description": "Number of deadlocks detected by the database",
          "group": null,
          "default": false
        },
        "pg_xact.rollback": {
          "type": "gauge",
          "description": "Number of rollbacks",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/postgresql",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "databases",
            "doc": "A list of databases along with optional authentication credentials.",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Database",
              "doc": "Database configures a particular PostgreSQL database",
              "package": "pkg/monitors/collectd/postgresql",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "The name of the database",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "username",
                  "doc": "Username used to access the database",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "password",
                  "doc": "Password used to access the database",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "interval",
                  "doc": "Interval to query the database in seconds",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "expireDelay",
                  "doc": "Skip expired values in query output",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "sslMode",
                  "doc": "Specify whether to use an ssl connection with PostgreSQL. (prefer(default), disable, allow, require)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "krbSrvName",
                  "doc": "Specify the Kerberos service name used to authenticate with kerberos 5 or GSSAPI",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "queries",
                  "doc": "Queries used to generate metrics. These will override the default set. If no queries are specified, the default set will be used [`custom_deadlocks`, `backends`, `transactions`, `queries`, `queries_by_table`, `query_plans`, `table_states`, `query_plans_by_table`, `table_states_by_table`, `disk_io`, `disk_io_by_table`, `disk_usage`]",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          },
          {
            "yamlName": "queries",
            "doc": "PostgreSQL queries and metric mappings",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Query",
              "doc": "Query adds a new query for retrieving metrics",
              "package": "pkg/monitors/collectd/postgresql",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "Name used to refer to the query in the database block",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "statement",
                  "doc": "Statement is a SQL statement to execute",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "results",
                  "doc": "Result blocks that define mappings of SQL query results to metrics",
                  "default": null,
                  "required": true,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "Result",
                    "doc": "Result maps values from a query to a metric",
                    "package": "pkg/monitors/collectd/postgresql",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Type defines a metric type",
                        "default": null,
                        "required": true,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "valuesFrom",
                        "doc": "Specifies columns in the SQL result to use as the metric value.  The number of columns must match the expected number of values for the metric type.",
                        "default": null,
                        "required": true,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "A prefix for the type instance",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancesFrom",
                        "doc": "Specifies columns in the SQL result to uses for the type instance.  Multiple columns are joined with a hyphen \"-\".",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "params",
                  "doc": "Parameters used to fill in $1,$2,$... tokens in the SQL statement.  Acceptable values are hostname, database, instance, username, interval",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "pluginInstanceFrom",
                  "doc": "Specifies the column that should be used to populate plugin instance",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "minVersion",
                  "doc": "The minimum version of PostgreSQL that the query is compatible with.  The version must be specified as a two decimal digit. Ex. 7.2.3 -\u003e 70203",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "maxVersion",
                  "doc": "The maximum version of PostgreSQL that the query is compatible with.  The version must be specified as a two decimal digit. Ex. 7.2.3 -\u003e 70203",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "username",
            "doc": "A username that serves as a default for all databases if not overridden",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "A password that serves as a default for all databases if not overridden",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "reportHost",
            "doc": "A SignalFx extension to the plugin that allows us to disable the normal behavior of the PostgreSQL collectd plugin where the `host` dimension is set to the hostname of the PostgreSQL database server.  When `false` (the recommended and default setting), the globally configured `hostname` config is used instead.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/processes",
      "sendAll": true,
      "dimensions": null,
      "doc": "Gathers information about processes running on\nthe host.  See\nhttps://collectd.org/documentation/manpages/collectd.conf.5.shtml#plugin_processes\nand https://collectd.org/wiki/index.php/Plugin:Processes for more\ninformation on the configuration options.\n\nExample:\n\n```yaml\n procPath: /proc\n monitors:\n  - type: collectd/processes\n    processes:\n      - mysql\n      - myapp\n    processMatch:\n      docker: \"docker.*\"\n    collectContextSwitch: true\n```\n\nThe above config will send process metrics for processes named *mysql* and\n*myapp*, along with additional metrics on the number of context switches the\nprocess has made.  Also, all processes that start with `docker` will have\ntheir process metrics aggregated together and sent with a `plugin_instance`\nvalue of `docker`.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "disk_octets.read",
            "disk_octets.write",
            "fork_rate",
            "io_octets.rx",
            "io_octets.tx",
            "io_ops.read",
            "io_ops.write",
            "ps_code",
            "ps_count.processes",
            "ps_count.threads",
            "ps_cputime.syst",
            "ps_cputime.user",
            "ps_data",
            "ps_pagefaults.majflt",
            "ps_pagefaults.minflt",
            "ps_rss",
            "ps_stacksize",
            "ps_state.blocked",
            "ps_state.paging",
            "ps_state.running",
            "ps_state.sleeping",
            "ps_state.stopped",
            "ps_state.zombies",
            "ps_vm"
          ]
        }
      },
      "metrics": {
        "disk_octets.read": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "disk_octets.write": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "fork_rate": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "io_octets.rx": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "io_octets.tx": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "io_ops.read": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "io_ops.write": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_code": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_count.processes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_count.threads": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_cputime.syst": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_cputime.user": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_data": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_pagefaults.majflt": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_pagefaults.minflt": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_rss": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_stacksize": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_state.blocked": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_state.paging": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_state.running": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_state.sleeping": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_state.stopped": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_state.zombies": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ps_vm": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/processes",
        "fields": [
          {
            "yamlName": "processes",
            "doc": "A list of process names to match",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "processMatch",
            "doc": "A map with keys specifying the `plugin_instance` value to be sent for the values which are regexes that match process names.  See example in description.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "collectContextSwitch",
            "doc": "Collect metrics on the number of context switches made by the process",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "procFSPath",
            "doc": "(Deprecated) Please set the agent configuration `procPath` instead of this monitor configuration option. The path to the proc filesystem -- useful to override if the agent is running in a container.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/protocols",
      "sendAll": false,
      "dimensions": null,
      "doc": "Gathers metrics about the network protocol\nstacks running on the system by using the [collectd protocols\nplugin](https://collectd.org/wiki/index.php/Plugin:Protocols).\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "protocol_counter.ActiveOpens",
            "protocol_counter.CurrEstab",
            "protocol_counter.DelayedACKs",
            "protocol_counter.InDestUnreachs",
            "protocol_counter.OutSegs",
            "protocol_counter.PassiveOpens",
            "protocol_counter.RetransSegs"
          ]
        }
      },
      "metrics": {
        "protocol_counter.ActiveOpens": {
          "type": "cumulative",
          "description": "The number of times TCP connections transitioned from the CLOSED state to the SYN-SENT state.",
          "group": null,
          "default": true
        },
        "protocol_counter.CurrEstab": {
          "type": "cumulative",
          "description": "The number of TCP connections currently in either ESTABLISHED or CLOSE-WAIT state.",
          "group": null,
          "default": false
        },
        "protocol_counter.DelayedACKs": {
          "type": "cumulative",
          "description": "The number of acknowledgements delayed by TCP Delayed Acknowledgement",
          "group": null,
          "default": false
        },
        "protocol_counter.InDestUnreachs": {
          "type": "cumulative",
          "description": "The number of ICMP Destination Unreachable messages received",
          "group": null,
          "default": false
        },
        "protocol_counter.OutSegs": {
          "type": "cumulative",
          "description": "The total number of segments that have been sent, including those on current connections but excluding those containing only retransmitted octets.\n",
          "group": null,
          "default": false
        },
        "protocol_counter.PassiveOpens": {
          "type": "cumulative",
          "description": "The number of times that a server opened a connection, due to receiving a TCP SYN packet.",
          "group": null,
          "default": false
        },
        "protocol_counter.RetransSegs": {
          "type": "cumulative",
          "description": "The total number of segments retransmitted",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/protocols",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/python",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor runs arbitrary collectd Python\nplugins directly, apart from collectd.  It implements a mock collectd Python\ninterface that supports most, but not all, of the real collectd.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config specifies configurations that are specific to the individual python based monitor",
        "package": "pkg/monitors/collectd/python",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host will be filled in by auto-discovery if this monitor has a discovery rule.  It can then be used under pluginConfig by the template `{{.Host}}`",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port will be filled in by auto-discovery if this monitor has a discovery rule.  It can then be used under pluginConfig by the template `{{.Port}}`",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "moduleName",
            "doc": "Corresponds to the ModuleName option in collectd-python",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "modulePaths",
            "doc": "Corresponds to a set of ModulePath options in collectd-python",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "pluginConfig",
            "doc": "This is a yaml form of the collectd config.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "interface"
          },
          {
            "yamlName": "typesDBPaths",
            "doc": "A set of paths to [../types.db files](https://collectd.org/documentation/manpages/types.db.5.shtml) that are needed by your plugin.  If not specified, the runner will use the global collectd ../types.db file.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/rabbitmq",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an instance of RabbitMQ using the [collectd RabbitMQ Python\nPlugin](https://github.com/signalfx/collectd-rabbitmq). This monitor uses\nthe [RabbitMQ Management HTTP\nAPI](https://www.rabbitmq.com/management.html) to poll for statistics on a\nRabbitMQ server, then reports them to the agent.  Works for RabbitMQ 3.0\nand later.\n\n**Note that you must individually enable each of the five `collect*`\noptions to get metrics pertaining to those facets of a RabbitMQ instance.\nIf none of them are enabled, no metrics will be sent.**\n",
      "groups": {
        "channel": {
          "description": "Channels metrics",
          "metrics": [
            "counter.channel.message_stats.ack",
            "counter.channel.message_stats.confirm",
            "counter.channel.message_stats.deliver",
            "counter.channel.message_stats.deliver_get",
            "counter.channel.message_stats.publish",
            "gauge.channel.connection_details.peer_port",
            "gauge.channel.consumer_count",
            "gauge.channel.global_prefetch_count",
            "gauge.channel.message_stats.ack_details.rate",
            "gauge.channel.message_stats.confirm_details.rate",
            "gauge.channel.message_stats.deliver_details.rate",
            "gauge.channel.message_stats.deliver_get_details.rate",
            "gauge.channel.message_stats.publish_details.rate",
            "gauge.channel.messages_unacknowledged",
            "gauge.channel.messages_uncommitted",
            "gauge.channel.messages_unconfirmed",
            "gauge.channel.number",
            "gauge.channel.prefetch_count"
          ]
        },
        "connection": {
          "description": "Connections metrics",
          "metrics": [
            "counter.connection.channel_max",
            "counter.connection.recv_cnt",
            "counter.connection.recv_oct",
            "counter.connection.send_cnt",
            "counter.connection.send_oct",
            "gauge.connection.channels",
            "gauge.connection.connected_at",
            "gauge.connection.frame_max",
            "gauge.connection.peer_port",
            "gauge.connection.port",
            "gauge.connection.recv_oct_details.rate",
            "gauge.connection.send_oct_details.rate",
            "gauge.connection.send_pend",
            "gauge.connection.timeout"
          ]
        },
        "exchange": {
          "description": "Exchanges metrics",
          "metrics": [
            "counter.exchange.message_stats.confirm",
            "counter.exchange.message_stats.publish_in",
            "counter.exchange.message_stats.publish_out",
            "gauge.exchange.message_stats.confirm_details.rate",
            "gauge.exchange.message_stats.publish_in_details.rate",
            "gauge.exchange.message_stats.publish_out_details.rate"
          ]
        },
        "node": {
          "description": "Nodes metrics",
          "metrics": [
            "counter.node.io_read_bytes",
            "counter.node.io_read_count",
            "counter.node.mnesia_disk_tx_count",
            "counter.node.mnesia_ram_tx_count",
            "gauge.node.disk_free",
            "gauge.node.disk_free_details.rate",
            "gauge.node.disk_free_limit",
            "gauge.node.fd_total",
            "gauge.node.fd_used",
            "gauge.node.fd_used_details.rate",
            "gauge.node.io_read_avg_time",
            "gauge.node.io_read_avg_time_details.rate",
            "gauge.node.io_read_bytes_details.rate",
            "gauge.node.io_read_count_details.rate",
            "gauge.node.io_sync_avg_time",
            "gauge.node.io_sync_avg_time_details.rate",
            "gauge.node.io_write_avg_time",
            "gauge.node.io_write_avg_time_details.rate",
            "gauge.node.mem_limit",
            "gauge.node.mem_used",
            "gauge.node.mem_used_details.rate",
            "gauge.node.mnesia_disk_tx_count_details.rate",
            "gauge.node.mnesia_ram_tx_count_details.rate",
            "gauge.node.net_ticktime",
            "gauge.node.proc_total",
            "gauge.node.proc_used",
            "gauge.node.proc_used_details.rate",
            "gauge.node.processors",
            "gauge.node.run_queue",
            "gauge.node.sockets_total",
            "gauge.node.sockets_used",
            "gauge.node.sockets_used_details.rate",
            "gauge.node.uptime"
          ]
        },
        "queue": {
          "description": "Queues metrics",
          "metrics": [
            "counter.queue.disk_reads",
            "counter.queue.disk_writes",
            "counter.queue.message_stats.ack",
            "counter.queue.message_stats.deliver",
            "counter.queue.message_stats.deliver_get",
            "counter.queue.message_stats.publish",
            "gauge.queue.backing_queue_status.avg_ack_egress_rate",
            "gauge.queue.backing_queue_status.avg_ack_ingress_rate",
            "gauge.queue.backing_queue_status.avg_egress_rate",
            "gauge.queue.backing_queue_status.avg_ingress_rate",
            "gauge.queue.backing_queue_status.len",
            "gauge.queue.backing_queue_status.next_seq_id",
            "gauge.queue.backing_queue_status.q1",
            "gauge.queue.backing_queue_status.q2",
            "gauge.queue.backing_queue_status.q3",
            "gauge.queue.backing_queue_status.q4",
            "gauge.queue.consumer_utilisation",
            "gauge.queue.consumers",
            "gauge.queue.memory",
            "gauge.queue.message_bytes",
            "gauge.queue.message_bytes_persistent",
            "gauge.queue.message_bytes_ram",
            "gauge.queue.message_bytes_ready",
            "gauge.queue.message_bytes_unacknowledged",
            "gauge.queue.message_stats.ack_details.rate",
            "gauge.queue.message_stats.deliver_details.rate",
            "gauge.queue.message_stats.deliver_get_details.rate",
            "gauge.queue.message_stats.publish_details.rate",
            "gauge.queue.messages",
            "gauge.queue.messages_details.rate",
            "gauge.queue.messages_persistent",
            "gauge.queue.messages_ram",
            "gauge.queue.messages_ready",
            "gauge.queue.messages_ready_details.rate",
            "gauge.queue.messages_ready_ram",
            "gauge.queue.messages_unacknowledged",
            "gauge.queue.messages_unacknowledged_details.rate",
            "gauge.queue.messages_unacknowledged_ram"
          ]
        }
      },
      "metrics": {
        "counter.channel.message_stats.ack": {
          "type": "counter",
          "description": "The number of acknowledged messages",
          "group": "channel",
          "default": false
        },
        "counter.channel.message_stats.confirm": {
          "type": "counter",
          "description": "Count of messages confirmed.",
          "group": "channel",
          "default": false
        },
        "counter.channel.message_stats.deliver": {
          "type": "counter",
          "description": "Count of messages delivered in acknowledgement mode to consumers.",
          "group": "channel",
          "default": false
        },
        "counter.channel.message_stats.deliver_get": {
          "type": "counter",
          "description": "Count of all messages delivered on the channel",
          "group": "channel",
          "default": false
        },
        "counter.channel.message_stats.publish": {
          "type": "counter",
          "description": "Count of messages published.",
          "group": "channel",
          "default": false
        },
        "counter.connection.channel_max": {
          "type": "counter",
          "description": "The maximum number of channels on the connection",
          "group": "connection",
          "default": false
        },
        "counter.connection.recv_cnt": {
          "type": "counter",
          "description": "Number of packets received on the connection",
          "group": "connection",
          "default": false
        },
        "counter.connection.recv_oct": {
          "type": "counter",
          "description": "Number of octets received on the connection",
          "group": "connection",
          "default": false
        },
        "counter.connection.send_cnt": {
          "type": "counter",
          "description": "Number of packets sent by the connection",
          "group": "connection",
          "default": false
        },
        "counter.connection.send_oct": {
          "type": "counter",
          "description": "Number of octets sent by the connection",
          "group": "connection",
          "default": false
        },
        "counter.exchange.message_stats.confirm": {
          "type": "counter",
          "description": "Count of messages confirmed.",
          "group": "exchange",
          "default": false
        },
        "counter.exchange.message_stats.publish_in": {
          "type": "counter",
          "description": "Count of messages published \"in\" to an exchange, i.e. not taking account of routing.",
          "group": "exchange",
          "default": true
        },
        "counter.exchange.message_stats.publish_out": {
          "type": "counter",
          "description": "Count of messages published \"out\" of an exchange, i.e. taking account of routing.",
          "group": "exchange",
          "default": false
        },
        "counter.node.io_read_bytes": {
          "type": "counter",
          "description": "Total number of bytes read from disk by the persister.",
          "group": "node",
          "default": false
        },
        "counter.node.io_read_count": {
          "type": "counter",
          "description": "Total number of read operations by the persister.",
          "group": "node",
          "default": false
        },
        "counter.node.mnesia_disk_tx_count": {
          "type": "counter",
          "description": "Number of Mnesia transactions which have been performed that required writes to disk.",
          "group": "node",
          "default": false
        },
        "counter.node.mnesia_ram_tx_count": {
          "type": "counter",
          "description": "Number of Mnesia transactions which have been performed that did not require writes to disk.",
          "group": "node",
          "default": false
        },
        "counter.queue.disk_reads": {
          "type": "counter",
          "description": "Total number of times messages have been read from disk by this queue since it started.",
          "group": "queue",
          "default": false
        },
        "counter.queue.disk_writes": {
          "type": "counter",
          "description": "Total number of times messages have been written to disk by this queue since it started.",
          "group": "queue",
          "default": false
        },
        "counter.queue.message_stats.ack": {
          "type": "counter",
          "description": "Number of acknowledged messages processed by the queue",
          "group": "queue",
          "default": false
        },
        "counter.queue.message_stats.deliver": {
          "type": "counter",
          "description": "Count of messages delivered in acknowledgement mode to consumers.",
          "group": "queue",
          "default": true
        },
        "counter.queue.message_stats.deliver_get": {
          "type": "counter",
          "description": "Count of all messages delivered on the queue",
          "group": "queue",
          "default": false
        },
        "counter.queue.message_stats.publish": {
          "type": "counter",
          "description": "Count of messages published.",
          "group": "queue",
          "default": false
        },
        "gauge.channel.connection_details.peer_port": {
          "type": "gauge",
          "description": "The peer port number of the channel",
          "group": "channel",
          "default": false
        },
        "gauge.channel.consumer_count": {
          "type": "gauge",
          "description": "The number of consumers the channel has",
          "group": "channel",
          "default": false
        },
        "gauge.channel.global_prefetch_count": {
          "type": "gauge",
          "description": "QoS prefetch limit for the entire channel, 0 if unlimited.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.message_stats.ack_details.rate": {
          "type": "gauge",
          "description": "How much the channel message ack count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.message_stats.confirm_details.rate": {
          "type": "gauge",
          "description": "How much the channel message confirm count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.message_stats.deliver_details.rate": {
          "type": "gauge",
          "description": "How much the channel deliver count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.message_stats.deliver_get_details.rate": {
          "type": "gauge",
          "description": "How much the channel message count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.message_stats.publish_details.rate": {
          "type": "gauge",
          "description": "How much the channel message publish count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.messages_unacknowledged": {
          "type": "gauge",
          "description": "Number of messages delivered via this channel but not yet acknowledged.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.messages_uncommitted": {
          "type": "gauge",
          "description": "Number of messages received in an as yet uncommitted transaction.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.messages_unconfirmed": {
          "type": "gauge",
          "description": "Number of published messages not yet confirmed. On channels not in confirm mode, this remains 0.",
          "group": "channel",
          "default": false
        },
        "gauge.channel.number": {
          "type": "gauge",
          "description": "The number of the channel, which uniquely identifies it within a connection.",
          "group": "channel",
          "default": true
        },
        "gauge.channel.prefetch_count": {
          "type": "gauge",
          "description": "QoS prefetch limit for new consumers, 0 if unlimited.",
          "group": "channel",
          "default": false
        },
        "gauge.connection.channels": {
          "type": "gauge",
          "description": "The current number of channels on the connection",
          "group": "connection",
          "default": false
        },
        "gauge.connection.connected_at": {
          "type": "gauge",
          "description": "The integer timestamp of the most recent time the connection was established",
          "group": "connection",
          "default": false
        },
        "gauge.connection.frame_max": {
          "type": "gauge",
          "description": "Maximum permissible size of a frame (in bytes) to negotiate with clients.",
          "group": "connection",
          "default": false
        },
        "gauge.connection.peer_port": {
          "type": "gauge",
          "description": "The peer port of the connection",
          "group": "connection",
          "default": false
        },
        "gauge.connection.port": {
          "type": "gauge",
          "description": "The port the connection is established on",
          "group": "connection",
          "default": false
        },
        "gauge.connection.recv_oct_details.rate": {
          "type": "gauge",
          "description": "How much the connection's octets received count has changed per second in the most recent sampling interval.",
          "group": "connection",
          "default": false
        },
        "gauge.connection.send_oct_details.rate": {
          "type": "gauge",
          "description": "How much the connection's octets sent count has changed per second in the most recent sampling interval.",
          "group": "connection",
          "default": false
        },
        "gauge.connection.send_pend": {
          "type": "gauge",
          "description": "The number of messages in the send queue of the connection",
          "group": "connection",
          "default": false
        },
        "gauge.connection.timeout": {
          "type": "gauge",
          "description": "The current timeout setting (in seconds) of the connection",
          "group": "connection",
          "default": false
        },
        "gauge.exchange.message_stats.confirm_details.rate": {
          "type": "gauge",
          "description": "How much the message confirm count has changed per second in the most recent sampling interval.",
          "group": "exchange",
          "default": false
        },
        "gauge.exchange.message_stats.publish_in_details.rate": {
          "type": "gauge",
          "description": "How much the exchange publish-in count has changed per second in the most recent sampling interval.",
          "group": "exchange",
          "default": false
        },
        "gauge.exchange.message_stats.publish_out_details.rate": {
          "type": "gauge",
          "description": "How much the exchange publish-out count has changed per second in the most recent sampling interval.",
          "group": "exchange",
          "default": false
        },
        "gauge.node.disk_free": {
          "type": "gauge",
          "description": "Disk free space (in bytes) on the node",
          "group": "node",
          "default": true
        },
        "gauge.node.disk_free_details.rate": {
          "type": "gauge",
          "description": "How much the disk free space has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.disk_free_limit": {
          "type": "gauge",
          "description": "Point (in bytes) at which the disk alarm will go off.",
          "group": "node",
          "default": true
        },
        "gauge.node.fd_total": {
          "type": "gauge",
          "description": "Total number of file descriptors available.",
          "group": "node",
          "default": true
        },
        "gauge.node.fd_used": {
          "type": "gauge",
          "description": "Number of used file descriptors.",
          "group": "node",
          "default": true
        },
        "gauge.node.fd_used_details.rate": {
          "type": "gauge",
          "description": "How much the number of used file descriptors has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.io_read_avg_time": {
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each disk read operation in the last statistics interval.",
          "group": "node",
          "default": true
        },
        "gauge.node.io_read_avg_time_details.rate": {
          "type": "gauge",
          "description": "How much the I/O read average time has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.io_read_bytes_details.rate": {
          "type": "gauge",
          "description": "How much the number of bytes read from disk has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.io_read_count_details.rate": {
          "type": "gauge",
          "description": "How much the number of read operations has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.io_sync_avg_time": {
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each fsync() operation in the last statistics interval.",
          "group": "node",
          "default": true
        },
        "gauge.node.io_sync_avg_time_details.rate": {
          "type": "gauge",
          "description": "How much the average I/O sync time has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.io_write_avg_time": {
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each disk write operation in the last statistics interval.",
          "group": "node",
          "default": true
        },
        "gauge.node.io_write_avg_time_details.rate": {
          "type": "gauge",
          "description": "How much the I/O write time has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.mem_limit": {
          "type": "gauge",
          "description": "Point (in bytes) at which the memory alarm will go off.",
          "group": "node",
          "default": true
        },
        "gauge.node.mem_used": {
          "type": "gauge",
          "description": "Memory used in bytes.",
          "group": "node",
          "default": true
        },
        "gauge.node.mem_used_details.rate": {
          "type": "gauge",
          "description": "How much the count has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.mnesia_disk_tx_count_details.rate": {
          "type": "gauge",
          "description": "How much the Mnesia disk transaction count has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.mnesia_ram_tx_count_details.rate": {
          "type": "gauge",
          "description": "How much the RAM-only Mnesia transaction count has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.net_ticktime": {
          "type": "gauge",
          "description": "Current kernel net_ticktime setting for the node.",
          "group": "node",
          "default": false
        },
        "gauge.node.proc_total": {
          "type": "gauge",
          "description": "The maximum number of Erlang processes that can run in an Erlang VM.",
          "group": "node",
          "default": false
        },
        "gauge.node.proc_used": {
          "type": "gauge",
          "description": "Number of Erlang processes currently running in use.",
          "group": "node",
          "default": false
        },
        "gauge.node.proc_used_details.rate": {
          "type": "gauge",
          "description": "How much the number of erlang processes in use has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.processors": {
          "type": "gauge",
          "description": "Number of cores detected and usable by Erlang.",
          "group": "node",
          "default": false
        },
        "gauge.node.run_queue": {
          "type": "gauge",
          "description": "Average number of Erlang processes waiting to run.",
          "group": "node",
          "default": false
        },
        "gauge.node.sockets_total": {
          "type": "gauge",
          "description": "Number of file descriptors available for use as sockets.",
          "group": "node",
          "default": false
        },
        "gauge.node.sockets_used": {
          "type": "gauge",
          "description": "Number of file descriptors used as sockets.",
          "group": "node",
          "default": false
        },
        "gauge.node.sockets_used_details.rate": {
          "type": "gauge",
          "description": "How much the number of sockets used has changed per second in the most recent sampling interval.",
          "group": "node",
          "default": false
        },
        "gauge.node.uptime": {
          "type": "gauge",
          "description": "Time since the Erlang VM started, in milliseconds.",
          "group": "node",
          "default": true
        },
        "gauge.queue.backing_queue_status.avg_ack_egress_rate": {
          "type": "gauge",
          "description": "Rate at which unacknowledged message records leave RAM, e.g. because acks arrive or unacked messages are paged out",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.avg_ack_ingress_rate": {
          "type": "gauge",
          "description": "Rate at which unacknowledged message records enter RAM, e.g. because messages are delivered requiring acknowledgement",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.avg_egress_rate": {
          "type": "gauge",
          "description": "Average egress (outbound) rate, not including messages that are sent straight through to auto-acking consumers.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.avg_ingress_rate": {
          "type": "gauge",
          "description": "Average ingress (inbound) rate, not including messages that are sent straight through to auto-acking consumers.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.len": {
          "type": "gauge",
          "description": "Total backing queue length, in messages",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.next_seq_id": {
          "type": "gauge",
          "description": "The next sequence ID to be used in the backing queue",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.q1": {
          "type": "gauge",
          "description": "Number of messages in backing queue q1",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.q2": {
          "type": "gauge",
          "description": "Number of messages in backing queue q2",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.q3": {
          "type": "gauge",
          "description": "Number of messages in backing queue q3",
          "group": "queue",
          "default": false
        },
        "gauge.queue.backing_queue_status.q4": {
          "type": "gauge",
          "description": "Number of messages in backing queue q4",
          "group": "queue",
          "default": false
        },
        "gauge.queue.consumer_utilisation": {
          "type": "gauge",
          "description": "Fraction of the time (between 0.0 and 1.0) that the queue is able to immediately deliver messages to consumers.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.consumers": {
          "type": "gauge",
          "description": "Number of consumers of the queue",
          "group": "queue",
          "default": true
        },
        "gauge.queue.memory": {
          "type": "gauge",
          "description": "Bytes of memory consumed by the Erlang process associated with the queue, including stack, heap and internal structures.",
          "group": "queue",
          "default": true
        },
        "gauge.queue.message_bytes": {
          "type": "gauge",
          "description": "Sum of the size of all message bodies in the queue. This does not include the message properties (including headers) or any overhead.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.message_bytes_persistent": {
          "type": "gauge",
          "description": "Total number of persistent messages in the queue (will always be 0 for transient queues).",
          "group": "queue",
          "default": false
        },
        "gauge.queue.message_bytes_ram": {
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages which are in RAM.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.message_bytes_ready": {
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages ready to be delivered to clients.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.message_bytes_unacknowledged": {
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages delivered to clients but not yet acknowledged.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.message_stats.ack_details.rate": {
          "type": "gauge",
          "description": "How much the number of acknowledged messages has changed per second in the most recent sampling interval.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.message_stats.deliver_details.rate": {
          "type": "gauge",
          "description": "How much the count of messages delivered has changed per second in the most recent sampling interval.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.message_stats.deliver_get_details.rate": {
          "type": "gauge",
          "description": "How much the count of all messages delivered has changed per second in the most recent sampling interval.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.message_stats.publish_details.rate": {
          "type": "gauge",
          "description": "How much the count of messages published has changed per second in the most recent sampling interval.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages": {
          "type": "gauge",
          "description": "Sum of ready and unacknowledged messages (queue depth).",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages_details.rate": {
          "type": "gauge",
          "description": "How much the queue depth has changed per second in the most recent sampling interval.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages_persistent": {
          "type": "gauge",
          "description": "Total number of persistent messages in the queue (will always be 0 for transient queues).",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages_ram": {
          "type": "gauge",
          "description": "Total number of messages which are resident in RAM.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages_ready": {
          "type": "gauge",
          "description": "Number of messages ready to be delivered to clients.",
          "group": "queue",
          "default": true
        },
        "gauge.queue.messages_ready_details.rate": {
          "type": "gauge",
          "description": "How much the count of messages ready has changed per second in the most recent sampling interval.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages_ready_ram": {
          "type": "gauge",
          "description": "Number of messages from messages_ready which are resident in RAM.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages_unacknowledged": {
          "type": "gauge",
          "description": "Number of messages delivered to clients but not yet acknowledged.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages_unacknowledged_details.rate": {
          "type": "gauge",
          "description": "How much the count of unacknowledged messages has changed per second in the most recent sampling interval.",
          "group": "queue",
          "default": false
        },
        "gauge.queue.messages_unacknowledged_ram": {
          "type": "gauge",
          "description": "Number of messages from messages_unacknowledged which are resident in RAM.",
          "group": "queue",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/rabbitmq",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "brokerName",
            "doc": "The name of the particular RabbitMQ instance.  Can be a Go template using other config options. This will be used as the `plugin_instance` dimension.",
            "default": "{{.host}}-{{.port}}",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "collectChannels",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "collectConnections",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "collectExchanges",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "collectNodes",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "collectQueues",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "httpTimeout",
            "doc": "",
            "default": null,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "verbosityLevel",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/redis",
      "sendAll": false,
      "dimensions": {
        "plugin_instance": {
          "description": "Identifies the Redis instance -- will be of the form `\u003chost\u003e_\u003cport\u003e`."
        }
      },
      "doc": "Monitors a redis instance using the [collectd Python Redis\nplugin](https://github.com/signalfx/redis-collectd-plugin).  Supports Redis\n2.8 and later.\n\nYou can capture any kind of Redis metrics like:\n\n * Memory used\n * Commands processed per second\n * Number of connected clients and slaves\n * Number of blocked clients\n * Number of keys stored (per database)\n * Uptime\n * Changes since last save\n * Replication delay (per slave)\n\n\n\u003c!--- OVERVIEW ---\u003e\n### Monitoring length of Redis lists\n\nTo monitor the length of list keys, the key and database index must be\nspecified in the config. Specify keys in the config file in the form\n`sendListLengths: [{databaseIndex: $db_index, keyPattern: \"$key_name\"}]`.\n`$key_name` can be a globbed pattern (only `*` is supported), in which case\nall keys matching that glob will be processed.  Don't forget to surround\nthe pattern with double quotes or else the asterisks might be\nmisinterpreted.  If any keys match the glob that are not lists, an error\nwill be sent to the collectd logs.\n\nLengths will be reported to SignalFx under the metric `gauge.key_llen`, a\nseparate time series for each list.\n\n**Warning**: The `KEYS` command is used to match the globs so don't try and\nmatch something that is very big, as this command is not highly optimized and\ncan block other commands from executing.\n\nNote: To avoid duplication reporting, this should only be reported in one node.\nKeys can be defined in either the master or slave config.\n\nSample YAML configuration with list lengths:\n\n```yaml\nmonitors:\n- type: collectd/redis\n  host: 127.0.0.1\n  port: 9100\n  sendListLengths:\n  - databaseIndex: 0\n    keyPattern: 'mylist*'\n```\n\n\u003c!--- SETUP ---\u003e\n### Example Config\n\n```yaml\nmonitors:\n- type: collectd/redis\n  host: 127.0.0.1\n  port: 9100\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "bytes.used_memory",
            "bytes.used_memory_lua",
            "bytes.used_memory_peak",
            "bytes.used_memory_rss",
            "counter.commands_processed",
            "counter.connections_received",
            "counter.evicted_keys",
            "counter.expired_keys",
            "counter.lru_clock",
            "counter.rejected_connections",
            "counter.total_net_input_bytes",
            "counter.total_net_output_bytes",
            "counter.used_cpu_sys",
            "counter.used_cpu_sys_children",
            "counter.used_cpu_user",
            "counter.used_cpu_user_children",
            "derive.keyspace_hits",
            "derive.keyspace_misses",
            "gauge.blocked_clients",
            "gauge.changes_since_last_save",
            "gauge.client_biggest_input_buf",
            "gauge.client_longest_output_list",
            "gauge.connected_clients",
            "gauge.connected_slaves",
            "gauge.db0_avg_ttl",
            "gauge.db0_expires",
            "gauge.db0_keys",
            "gauge.instantaneous_ops_per_sec",
            "gauge.key_llen",
            "gauge.latest_fork_usec",
            "gauge.master_last_io_seconds_ago",
            "gauge.master_repl_offset",
            "gauge.mem_fragmentation_ratio",
            "gauge.rdb_bgsave_in_progress",
            "gauge.repl_backlog_first_byte_offset",
            "gauge.slave_repl_offset",
            "gauge.uptime_in_days",
            "gauge.uptime_in_seconds"
          ]
        }
      },
      "metrics": {
        "bytes.used_memory": {
          "type": "gauge",
          "description": "Number of bytes allocated by Redis",
          "group": null,
          "default": true
        },
        "bytes.used_memory_lua": {
          "type": "gauge",
          "description": "Number of bytes used by the Lua engine",
          "group": null,
          "default": false
        },
        "bytes.used_memory_peak": {
          "type": "gauge",
          "description": "Peak Number of bytes allocated by Redis",
          "group": null,
          "default": false
        },
        "bytes.used_memory_rss": {
          "type": "gauge",
          "description": "Number of bytes allocated by Redis as seen by the OS",
          "group": null,
          "default": true
        },
        "counter.commands_processed": {
          "type": "cumulative",
          "description": "Total number of commands processed by the server",
          "group": null,
          "default": true
        },
        "counter.connections_received": {
          "type": "cumulative",
          "description": "Total number of connections accepted by the server",
          "group": null,
          "default": false
        },
        "counter.evicted_keys": {
          "type": "cumulative",
          "description": "Number of evicted keys due to maxmemory limit",
          "group": null,
          "default": true
        },
        "counter.expired_keys": {
          "type": "cumulative",
          "description": "Total number of key expiration events",
          "group": null,
          "default": true
        },
        "counter.lru_clock": {
          "type": "cumulative",
          "description": "Clock incrementing every minute, for LRU management",
          "group": null,
          "default": false
        },
        "counter.rejected_connections": {
          "type": "cumulative",
          "description": "Number of connections rejected because of maxclients limit",
          "group": null,
          "default": true
        },
        "counter.total_net_input_bytes": {
          "type": "cumulative",
          "description": "Total number of bytes inputted",
          "group": null,
          "default": true
        },
        "counter.total_net_output_bytes": {
          "type": "cumulative",
          "description": "Total number of bytes outputted",
          "group": null,
          "default": true
        },
        "counter.used_cpu_sys": {
          "type": "cumulative",
          "description": "System CPU consumed by the Redis server",
          "group": null,
          "default": true
        },
        "counter.used_cpu_sys_children": {
          "type": "cumulative",
          "description": "System CPU consumed by the background processes",
          "group": null,
          "default": false
        },
        "counter.used_cpu_user": {
          "type": "cumulative",
          "description": "User CPU consumed by the Redis server",
          "group": null,
          "default": true
        },
        "counter.used_cpu_user_children": {
          "type": "cumulative",
          "description": "User CPU consumed by the background processes",
          "group": null,
          "default": false
        },
        "derive.keyspace_hits": {
          "type": "cumulative",
          "description": "Number of successful lookup of keys in the main dictionary",
          "group": null,
          "default": true
        },
        "derive.keyspace_misses": {
          "type": "cumulative",
          "description": "Number of failed lookup of keys in the main dictionary",
          "group": null,
          "default": true
        },
        "gauge.blocked_clients": {
          "type": "gauge",
          "description": "Number of clients pending on a blocking call",
          "group": null,
          "default": true
        },
        "gauge.changes_since_last_save": {
          "type": "gauge",
          "description": "Number of changes since the last dump",
          "group": null,
          "default": false
        },
        "gauge.client_biggest_input_buf": {
          "type": "gauge",
          "description": "Biggest input buffer among current client connections",
          "group": null,
          "default": false
        },
        "gauge.client_longest_output_list": {
          "type": "gauge",
          "description": "Longest output list among current client connections",
          "group": null,
          "default": false
        },
        "gauge.connected_clients": {
          "type": "gauge",
          "description": "Number of client connections (excluding connections from slaves)",
          "group": null,
          "default": true
        },
        "gauge.connected_slaves": {
          "type": "gauge",
          "description": "Number of connected slaves",
          "group": null,
          "default": false
        },
        "gauge.db0_avg_ttl": {
          "type": "gauge",
          "description": "The average time to live for all keys in redis",
          "group": null,
          "default": false
        },
        "gauge.db0_expires": {
          "type": "gauge",
          "description": "The total number of keys in redis that will expire",
          "group": null,
          "default": false
        },
        "gauge.db0_keys": {
          "type": "gauge",
          "description": "The total number of keys stored in redis",
          "group": null,
          "default": false
        },
        "gauge.instantaneous_ops_per_sec": {
          "type": "gauge",
          "description": "Number of commands processed per second",
          "group": null,
          "default": false
        },
        "gauge.key_llen": {
          "type": "gauge",
          "description": "Length of an list key",
          "group": null,
          "default": false
        },
        "gauge.latest_fork_usec": {
          "type": "gauge",
          "description": "Duration of the latest fork operation in microseconds",
          "group": null,
          "default": false
        },
        "gauge.master_last_io_seconds_ago": {
          "type": "gauge",
          "description": "Number of seconds since the last interaction with master",
          "group": null,
          "default": false
        },
        "gauge.master_repl_offset": {
          "type": "gauge",
          "description": "Master replication offset",
          "group": null,
          "default": true
        },
        "gauge.mem_fragmentation_ratio": {
          "type": "gauge",
          "description": "Ratio between used_memory_rss and used_memory",
          "group": null,
          "default": false
        },
        "gauge.rdb_bgsave_in_progress": {
          "type": "gauge",
          "description": "Flag indicating a RDB save is on-going",
          "group": null,
          "default": false
        },
        "gauge.repl_backlog_first_byte_offset": {
          "type": "gauge",
          "description": "Slave replication backlog offset",
          "group": null,
          "default": false
        },
        "gauge.slave_repl_offset": {
          "type": "gauge",
          "description": "Slave replication offset",
          "group": null,
          "default": true
        },
        "gauge.uptime_in_days": {
          "type": "gauge",
          "description": "Number of days up",
          "group": null,
          "default": false
        },
        "gauge.uptime_in_seconds": {
          "type": "gauge",
          "description": "Number of seconds up",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/redis",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "The name for the node is a canonical identifier which is used as plugin instance. It is limited to 64 characters in length.  (**default**: \"{host}:{port}\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "auth",
            "doc": "Password to use for authentication.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendListLengths",
            "doc": "Specify a pattern of keys to lists for which to send their length as a metric. See below for more details.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "ListLength",
              "doc": "ListLength defines a database index and key pattern for sending list lengths",
              "package": "pkg/monitors/collectd/redis",
              "fields": [
                {
                  "yamlName": "databaseIndex",
                  "doc": "The database index.",
                  "default": null,
                  "required": true,
                  "type": "uint16",
                  "elementKind": ""
                },
                {
                  "yamlName": "keyPattern",
                  "doc": "Can be a globbed pattern (only * is supported), in which case all keys matching that glob will be processed.  The pattern should be placed in single quotes (').  Ex. `'mylist*'`",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/signalfx-metadata",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collectd Python plugin that aggregates various metrics from other collectd\nplugins.\n\nIt has deprecated functionality to send host metadata and process \"top\"\ninfo, but this has been replaced by the `host-metadata` and `processlist`\nmonitors, respectively.\n\nYou can also [view the Python plugin\ncode](https://github.com/signalfx/collectd-signalfx/).\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "cpu.utilization",
            "cpu.utilization_per_core",
            "disk.summary_utilization",
            "disk.utilization",
            "disk_ops.total",
            "memory.utilization",
            "network.total"
          ]
        }
      },
      "metrics": {
        "cpu.utilization": {
          "type": "gauge",
          "description": "Percent of CPU used on this host.",
          "group": null,
          "default": true
        },
        "cpu.utilization_per_core": {
          "type": "gauge",
          "description": "Percent of CPU used on each core. `perCoreCPUUtil` config must be set to true.",
          "group": null,
          "default": false
        },
        "disk.summary_utilization": {
          "type": "gauge",
          "description": "Percent of disk space utilized on all volumes on this host.",
          "group": null,
          "default": true
        },
        "disk.utilization": {
          "type": "gauge",
          "description": "Percent of disk used on this volume.",
          "group": null,
          "default": true
        },
        "disk_ops.total": {
          "type": "cumulative",
          "description": "Total number of disk read and write operations on this host.",
          "group": null,
          "default": true
        },
        "memory.utilization": {
          "type": "gauge",
          "description": "Percent of memory in use on this host.",
          "group": null,
          "default": true
        },
        "network.total": {
          "type": "cumulative",
          "description": "Total amount of inbound and outbound network traffic on this host, in bytes.",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/metadata",
        "fields": [
          {
            "yamlName": "writeServerURL",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "procFSPath",
            "doc": "(Deprecated) Please set the agent configuration `procPath` instead of this monitor configuration option. The path to the proc filesystem. Useful to override in containerized environments.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "etcPath",
            "doc": "(Deprecated) Please set the agent configuration `etcPath` instead of this monitor configuration option. The path to the main host config dir. Useful to override in containerized environments.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "perCoreCPUUtil",
            "doc": "Collect the cpu utilization per core, reported as `cpu.utilization_per_core`.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "persistencePath",
            "doc": "A directory where the metadata plugin can persist the history of successful host metadata syncs so that host metadata is not sent redundantly.",
            "default": "/var/run/signalfx-agent",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "omitProcessInfo",
            "doc": "If true, process \"top\" information will not be sent.  This can be useful if you have an extremely high number of processes and performance of the plugin is poor.  This defaults to `false`, but should be set to `true` if using the `processlist` monitor since that duplicates this functionality.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "dogStatsDPort",
            "doc": "Set this to a non-zero value to enable the DogStatsD listener as part of this monitor.  The listener will accept metrics on the DogStatsD format, and sends them as SignalFx datapoints to our backend.  Setting to a value setting the `DogStatsDPort` to `0` will result in a random port assignment. **Note: The listener emits directly to SignalFx and will not be subject to filters configured with the SignalFx Smart Agent.  Internal stats about the SignalFx Smart Agent will not reflect datapoints set through the DogStatsD listener**",
            "default": null,
            "required": false,
            "type": "uint",
            "elementKind": ""
          },
          {
            "yamlName": "token",
            "doc": "This is only required when running the DogStatsD listener.  Set this to your SignalFx access token.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "dogStatsDIP",
            "doc": "Optionally override the default ip that the DogStatsD listener listens on.  (**default**: \"0.0.0.0\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "ingestEndpoint",
            "doc": "This is optional only used when running the DogStatsD listener. By default the DogStatsD listener will emit to SignalFx Ingest. (**default**: \"https://ingest.signalfx.com\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "verbose",
            "doc": "Set this to enable verbose logging from the monitor",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/solr",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors Solr instances by using the [collectd Solr\nplugin](https://github.com/signalfx/collectd-solr).  Supports Solr 6.6 and\nlater.\n\n*NOTE: This plugin can collect metrics from Solr only when a Solr instance is running in SolrCloud mode*\n\nThe [solr-collectd](https://github.com/signalfx/collectd-solr) plugin\ncollects metrics from solr instances hitting these endpoints:\n\n - [statistics](https://lucene.apache.org/solr/guide/6_6/performance-statistics-reference.html) (default metrics)\n - [metrics](https://lucene.apache.org/solr/guide/6_6/metrics-reporting.html) (optional metrics)\n\n\n\u003c!--- SETUP ---\u003e\n### Sample YAML configuration\n\n```yaml\nmonitors:\n- type: collectd/solr\n  host: 127.0.0.1\n  port: 8983\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.solr.http_2xx_responses",
            "counter.solr.http_4xx_responses",
            "counter.solr.http_5xx_responses",
            "counter.solr.http_requests",
            "counter.solr.jvm_classes_loaded",
            "counter.solr.node_collections_requests",
            "counter.solr.node_cores_requests",
            "counter.solr.node_metric_request_count",
            "counter.solr.node_metrics_requests",
            "counter.solr.node_zookeeper_requests",
            "counter.solr.openFileDescriptorCount",
            "counter.solr.replication_handler_requests",
            "counter.solr.search_query_requests",
            "counter.solr.update_handler_requests",
            "counter.solr.zookeeper_errors",
            "gauge.solr.core_deleted_docs",
            "gauge.solr.core_index_size",
            "gauge.solr.core_max_docs",
            "gauge.solr.core_num_docs",
            "gauge.solr.core_totalspace",
            "gauge.solr.core_usablespace",
            "gauge.solr.document_cache_cumulative_hitratio",
            "gauge.solr.field_value_cache_cumulative_hitratio",
            "gauge.solr.http_active_requests",
            "gauge.solr.jetty_get_request_latency",
            "gauge.solr.jetty_post_request_latency",
            "gauge.solr.jetty_request_latency",
            "gauge.solr.jvm_gc_cms_count",
            "gauge.solr.jvm_gc_cms_time",
            "gauge.solr.jvm_gc_parnew_count",
            "gauge.solr.jvm_gc_parnew_time",
            "gauge.solr.jvm_heap_usage",
            "gauge.solr.jvm_mapped_memory_capacity",
            "gauge.solr.jvm_mapped_memory_used",
            "gauge.solr.jvm_memory_pools_Code-Cache_usage",
            "gauge.solr.jvm_memory_pools_Metaspace_usage",
            "gauge.solr.jvm_memory_pools_Par-Eden-Space_usage",
            "gauge.solr.jvm_memory_pools_Par-Survivor-Space_usage",
            "gauge.solr.jvm_total_memory",
            "gauge.solr.jvm_total_memory_used",
            "gauge.solr.node_metric_request_time",
            "gauge.solr.query_result_cache_cumulative_hitratio",
            "gauge.solr.replication_handler_response",
            "gauge.solr.search_query_response",
            "gauge.solr.searcher_warmup",
            "gauge.solr.shard_cumulative_docs",
            "gauge.solr.update_request_handler_response",
            "gauge.solr.zookeeper_request_time"
          ]
        }
      },
      "metrics": {
        "counter.solr.http_2xx_responses": {
          "type": "counter",
          "description": "Total number of 2xx http responses",
          "group": null,
          "default": true
        },
        "counter.solr.http_4xx_responses": {
          "type": "counter",
          "description": "Total number of 4xx http responses",
          "group": null,
          "default": true
        },
        "counter.solr.http_5xx_responses": {
          "type": "counter",
          "description": "Total number of 5xx http responses",
          "group": null,
          "default": true
        },
        "counter.solr.http_requests": {
          "type": "counter",
          "description": "Total number of http requests",
          "group": null,
          "default": true
        },
        "counter.solr.jvm_classes_loaded": {
          "type": "counter",
          "description": "Number of JVM classes loaded",
          "group": null,
          "default": false
        },
        "counter.solr.node_collections_requests": {
          "type": "counter",
          "description": "Number of collection level requets to Solr node",
          "group": null,
          "default": true
        },
        "counter.solr.node_cores_requests": {
          "type": "counter",
          "description": "Number of core level requets to Solr node",
          "group": null,
          "default": true
        },
        "counter.solr.node_metric_request_count": {
          "type": "counter",
          "description": "Number of metric requests",
          "group": null,
          "default": false
        },
        "counter.solr.node_metrics_requests": {
          "type": "counter",
          "description": "Number of metrics level requets to Solr node",
          "group": null,
          "default": true
        },
        "counter.solr.node_zookeeper_requests": {
          "type": "counter",
          "description": "Number of zookeeper level requets to Solr node",
          "group": null,
          "default": true
        },
        "counter.solr.openFileDescriptorCount": {
          "type": "counter",
          "description": "Number of open file descriptors",
          "group": null,
          "default": false
        },
        "counter.solr.replication_handler_requests": {
          "type": "counter",
          "description": "Number of replication handler requets",
          "group": null,
          "default": false
        },
        "counter.solr.search_query_requests": {
          "type": "counter",
          "description": "Number of search query requests",
          "group": null,
          "default": true
        },
        "counter.solr.update_handler_requests": {
          "type": "counter",
          "description": "Number of update handler requets",
          "group": null,
          "default": true
        },
        "counter.solr.zookeeper_errors": {
          "type": "counter",
          "description": "Number of failures/error at Zookeeper",
          "group": null,
          "default": false
        },
        "gauge.solr.core_deleted_docs": {
          "type": "gauge",
          "description": "Number of deleted docs in Solr core",
          "group": null,
          "default": true
        },
        "gauge.solr.core_index_size": {
          "type": "gauge",
          "description": "Size of a core index",
          "group": null,
          "default": true
        },
        "gauge.solr.core_max_docs": {
          "type": "gauge",
          "description": "Total number of docs in Solr core",
          "group": null,
          "default": true
        },
        "gauge.solr.core_num_docs": {
          "type": "gauge",
          "description": "Total number of indexed docs in Solr core",
          "group": null,
          "default": true
        },
        "gauge.solr.core_totalspace": {
          "type": "gauge",
          "description": "Total space allocated for core",
          "group": null,
          "default": true
        },
        "gauge.solr.core_usablespace": {
          "type": "gauge",
          "description": "Usable space available in core",
          "group": null,
          "default": true
        },
        "gauge.solr.document_cache_cumulative_hitratio": {
          "type": "gauge",
          "description": "Cummulative hit ration of document cache",
          "group": null,
          "default": true
        },
        "gauge.solr.field_value_cache_cumulative_hitratio": {
          "type": "gauge",
          "description": "Cummulative hit ration of filed value cache",
          "group": null,
          "default": true
        },
        "gauge.solr.http_active_requests": {
          "type": "gauge",
          "description": "Number of http active requests",
          "group": null,
          "default": false
        },
        "gauge.solr.jetty_get_request_latency": {
          "type": "gauge",
          "description": "Time to process http get request",
          "group": null,
          "default": false
        },
        "gauge.solr.jetty_post_request_latency": {
          "type": "gauge",
          "description": "Time to process http post request",
          "group": null,
          "default": false
        },
        "gauge.solr.jetty_request_latency": {
          "type": "gauge",
          "description": "Http request response time",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_gc_cms_count": {
          "type": "gauge",
          "description": "JVM Garbage Collector - CMS invocation count",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_gc_cms_time": {
          "type": "gauge",
          "description": "JVM Garbage Collector - CMS prcoess time",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_gc_parnew_count": {
          "type": "gauge",
          "description": "JVM Garbage Collector - Parnew invocation count",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_gc_parnew_time": {
          "type": "gauge",
          "description": "JVM Garbage Collector - Parnew process time",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_heap_usage": {
          "type": "gauge",
          "description": "JVM Heap usage",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_mapped_memory_capacity": {
          "type": "gauge",
          "description": "Total JVM mapped memory capacity",
          "group": null,
          "default": false
        },
        "gauge.solr.jvm_mapped_memory_used": {
          "type": "gauge",
          "description": "Total JVM mapped memory used",
          "group": null,
          "default": false
        },
        "gauge.solr.jvm_memory_pools_Code-Cache_usage": {
          "type": "gauge",
          "description": "JVM memory pools - PCode Cache usage",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_memory_pools_Metaspace_usage": {
          "type": "gauge",
          "description": "JVM memory pools - Metaspace usage",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_memory_pools_Par-Eden-Space_usage": {
          "type": "gauge",
          "description": "JVM memory pools - Par Eden space usage",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_memory_pools_Par-Survivor-Space_usage": {
          "type": "gauge",
          "description": "JVM memory pools - Par Survivor space usage",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_total_memory": {
          "type": "gauge",
          "description": "JVM total memory allocated",
          "group": null,
          "default": true
        },
        "gauge.solr.jvm_total_memory_used": {
          "type": "gauge",
          "description": "JVM memory used",
          "group": null,
          "default": true
        },
        "gauge.solr.node_metric_request_time": {
          "type": "gauge",
          "description": "Time to process a metric request",
          "group": null,
          "default": false
        },
        "gauge.solr.query_result_cache_cumulative_hitratio": {
          "type": "gauge",
          "description": "Cummulative hit ration of query cache",
          "group": null,
          "default": true
        },
        "gauge.solr.replication_handler_response": {
          "type": "gauge",
          "description": "Resplication handler response time",
          "group": null,
          "default": false
        },
        "gauge.solr.search_query_response": {
          "type": "gauge",
          "description": "Search query response time",
          "group": null,
          "default": true
        },
        "gauge.solr.searcher_warmup": {
          "type": "gauge",
          "description": "Time to new searcher to warm up",
          "group": null,
          "default": true
        },
        "gauge.solr.shard_cumulative_docs": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gauge.solr.update_request_handler_response": {
          "type": "gauge",
          "description": "Update request handler response time",
          "group": null,
          "default": true
        },
        "gauge.solr.zookeeper_request_time": {
          "type": "gauge",
          "description": "Time to process a request at zookeeper",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/solr",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "cluster",
            "doc": "Cluster name of this solr cluster.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "EnhancedMetrics boolean to indicate whether stats from /metrics are needed",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "includeMetrics",
            "doc": "IncludeMetrics metric names from the /admin/metrics endpoint to include (valid when EnhancedMetrics is \"false\")",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "excludeMetrics",
            "doc": "ExcludeMetrics metric names from the /admin/metrics endpoint to exclude (valid when EnhancedMetrics is \"true\")",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/spark",
      "sendAll": false,
      "dimensions": {
        "cluster": {
          "description": "set to value corresponding to key `cluster` in configuration file"
        },
        "spark_process": {
          "description": "Either master or worker to differentiate master- and worker- specific metrics like master.apps and worker.coresFree"
        }
      },
      "doc": "Collects metrics about a Spark cluster using the [collectd Spark Python\nplugin](https://github.com/signalfx/collectd-spark). That plugin collects\nmetrics from Spark cluster and instances by hitting endpoints specified in\nSpark's [Monitoring and Instrumentation\ndocumentation](https://spark.apache.org/docs/latest/monitoring.html) under\n`REST API` and `Metrics`.\n\nWe currently only support cluster modes Standalone, Mesos, and Hadoop Yarn\nvia HTTP endpoints.\n\nYou have to specify distinct monitor configurations and discovery rules for\nmaster and worker processes.  For the master configuration, set `isMaster`\nto true.\n\nWhen running Spark on Apache Hadoop / Yarn, this integration is only capable\nof reporting application metrics from the master node.  Please use the\ncollectd/hadoop monitor to report on the health of the cluster.\n\n\u003c!--- SETUP ---\u003e\n### Example config:\n\nAn example configuration for monitoring applications on Yarn\n```yaml\nmonitors:\n  - type: collectd/spark\n    host: 000.000.000.000\n    port: 8088\n    clusterType: Yarn\n    isMaster: true\n    collectApplicationMetrics: true\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.HiveExternalCatalog.fileCacheHits",
            "counter.HiveExternalCatalog.filesDiscovered",
            "counter.HiveExternalCatalog.hiveClientCalls",
            "counter.HiveExternalCatalog.parallelListingJobCount",
            "counter.HiveExternalCatalog.partitionsFetched",
            "counter.spark.driver.completed_tasks",
            "counter.spark.driver.disk_used",
            "counter.spark.driver.failed_tasks",
            "counter.spark.driver.memory_used",
            "counter.spark.driver.total_duration",
            "counter.spark.driver.total_input_bytes",
            "counter.spark.driver.total_shuffle_read",
            "counter.spark.driver.total_shuffle_write",
            "counter.spark.driver.total_tasks",
            "counter.spark.executor.completed_tasks",
            "counter.spark.executor.disk_used",
            "counter.spark.executor.failed_tasks",
            "counter.spark.executor.memory_used",
            "counter.spark.executor.total_duration",
            "counter.spark.executor.total_input_bytes",
            "counter.spark.executor.total_shuffle_read",
            "counter.spark.executor.total_shuffle_write",
            "counter.spark.executor.total_tasks",
            "counter.spark.streaming.num_processed_records",
            "counter.spark.streaming.num_received_records",
            "counter.spark.streaming.num_total_completed_batches",
            "gauge.jvm.MarkSweepCompact.count",
            "gauge.jvm.MarkSweepCompact.time",
            "gauge.jvm.heap.committed",
            "gauge.jvm.heap.used",
            "gauge.jvm.non-heap.committed",
            "gauge.jvm.non-heap.used",
            "gauge.jvm.pools.Code-Cache.committed",
            "gauge.jvm.pools.Code-Cache.used",
            "gauge.jvm.pools.Compressed-Class-Space.committed",
            "gauge.jvm.pools.Compressed-Class-Space.used",
            "gauge.jvm.pools.Eden-Space.committed",
            "gauge.jvm.pools.Eden-Space.used",
            "gauge.jvm.pools.Metaspace.committed",
            "gauge.jvm.pools.Metaspace.used",
            "gauge.jvm.pools.Survivor-Space.committed",
            "gauge.jvm.pools.Survivor-Space.used",
            "gauge.jvm.pools.Tenured-Gen.committed",
            "gauge.jvm.pools.Tenured-Gen.used",
            "gauge.jvm.total.committed",
            "gauge.jvm.total.used",
            "gauge.master.aliveWorkers",
            "gauge.master.apps",
            "gauge.master.waitingApps",
            "gauge.master.workers",
            "gauge.spark.driver.active_tasks",
            "gauge.spark.driver.max_memory",
            "gauge.spark.driver.rdd_blocks",
            "gauge.spark.executor.active_tasks",
            "gauge.spark.executor.count",
            "gauge.spark.executor.max_memory",
            "gauge.spark.executor.rdd_blocks",
            "gauge.spark.job.num_active_stages",
            "gauge.spark.job.num_active_tasks",
            "gauge.spark.job.num_completed_stages",
            "gauge.spark.job.num_completed_tasks",
            "gauge.spark.job.num_failed_stages",
            "gauge.spark.job.num_failed_tasks",
            "gauge.spark.job.num_skipped_stages",
            "gauge.spark.job.num_skipped_tasks",
            "gauge.spark.job.num_tasks",
            "gauge.spark.num_active_stages",
            "gauge.spark.num_running_jobs",
            "gauge.spark.stage.disk_bytes_spilled",
            "gauge.spark.stage.executor_run_time",
            "gauge.spark.stage.input_bytes",
            "gauge.spark.stage.input_records",
            "gauge.spark.stage.memory_bytes_spilled",
            "gauge.spark.stage.output_bytes",
            "gauge.spark.stage.output_records",
            "gauge.spark.stage.shuffle_read_bytes",
            "gauge.spark.stage.shuffle_read_records",
            "gauge.spark.stage.shuffle_write_bytes",
            "gauge.spark.stage.shuffle_write_records",
            "gauge.spark.streaming.avg_input_rate",
            "gauge.spark.streaming.avg_processing_time",
            "gauge.spark.streaming.avg_scheduling_delay",
            "gauge.spark.streaming.avg_total_delay",
            "gauge.spark.streaming.num_active_batches",
            "gauge.spark.streaming.num_inactive_receivers",
            "gauge.worker.coresFree",
            "gauge.worker.coresUsed",
            "gauge.worker.executors",
            "gauge.worker.memFree_MB",
            "gauge.worker.memUsed_MB"
          ]
        }
      },
      "metrics": {
        "counter.HiveExternalCatalog.fileCacheHits": {
          "type": "counter",
          "description": "Total number of file level cache hits occurred",
          "group": null,
          "default": false
        },
        "counter.HiveExternalCatalog.filesDiscovered": {
          "type": "counter",
          "description": "Total number of files discovered",
          "group": null,
          "default": false
        },
        "counter.HiveExternalCatalog.hiveClientCalls": {
          "type": "counter",
          "description": "Total number of client calls sent to Hive for query processing",
          "group": null,
          "default": false
        },
        "counter.HiveExternalCatalog.parallelListingJobCount": {
          "type": "counter",
          "description": "Total number of Hive-specific jobs running in parallel",
          "group": null,
          "default": false
        },
        "counter.HiveExternalCatalog.partitionsFetched": {
          "type": "counter",
          "description": "Total number of partitions fetched",
          "group": null,
          "default": false
        },
        "counter.spark.driver.completed_tasks": {
          "type": "counter",
          "description": "Total number of completed tasks in driver mapped to a particular application",
          "group": null,
          "default": false
        },
        "counter.spark.driver.disk_used": {
          "type": "counter",
          "description": "Amount of disk used by driver mapped to a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.driver.failed_tasks": {
          "type": "counter",
          "description": "Total number of failed tasks in driver mapped to a particular application",
          "group": null,
          "default": false
        },
        "counter.spark.driver.memory_used": {
          "type": "counter",
          "description": "Amount of memory used by driver mapped to a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.driver.total_duration": {
          "type": "counter",
          "description": "Fraction of time spent by driver mapped to a particular application",
          "group": null,
          "default": false
        },
        "counter.spark.driver.total_input_bytes": {
          "type": "counter",
          "description": "Number of input bytes in driver mapped to a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.driver.total_shuffle_read": {
          "type": "counter",
          "description": "Size read during a shuffle in driver mapped to a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.driver.total_shuffle_write": {
          "type": "counter",
          "description": "Size written to during a shuffle in driver mapped to a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.driver.total_tasks": {
          "type": "counter",
          "description": "Total number of tasks in driver mapped to a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.executor.completed_tasks": {
          "type": "counter",
          "description": "Completed tasks across executors working for a particular application",
          "group": null,
          "default": false
        },
        "counter.spark.executor.disk_used": {
          "type": "counter",
          "description": "Amount of disk used across executors working for a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.executor.failed_tasks": {
          "type": "counter",
          "description": "Failed tasks across executors working for a particular application",
          "group": null,
          "default": false
        },
        "counter.spark.executor.memory_used": {
          "type": "counter",
          "description": "Amount of memory used across executors working for a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.executor.total_duration": {
          "type": "counter",
          "description": "Fraction of time spent across executors working for a particular application",
          "group": null,
          "default": false
        },
        "counter.spark.executor.total_input_bytes": {
          "type": "counter",
          "description": "Number of input bytes across executors working for a particular application",
          "group": null,
          "default": true
        },
        "counter.spark.executor.total_shuffle_read": {
          "type": "counter",
          "description": "Size read during a shuffle in a particular application's executors",
          "group": null,
          "default": true
        },
        "counter.spark.executor.total_shuffle_write": {
          "type": "counter",
          "description": "Size written to during a shuffle in a particular application's executors",
          "group": null,
          "default": true
        },
        "counter.spark.executor.total_tasks": {
          "type": "counter",
          "description": "Total tasks across executors working for a particular application",
          "group": null,
          "default": false
        },
        "counter.spark.streaming.num_processed_records": {
          "type": "counter",
          "description": "Number of processed records in a streaming application",
          "group": null,
          "default": true
        },
        "counter.spark.streaming.num_received_records": {
          "type": "counter",
          "description": "Number of received records in a streaming application",
          "group": null,
          "default": true
        },
        "counter.spark.streaming.num_total_completed_batches": {
          "type": "counter",
          "description": "Number of batches completed in a streaming application",
          "group": null,
          "default": true
        },
        "gauge.jvm.MarkSweepCompact.count": {
          "type": "gauge",
          "description": "Garbage collection count",
          "group": null,
          "default": false
        },
        "gauge.jvm.MarkSweepCompact.time": {
          "type": "gauge",
          "description": "Garbage collection time",
          "group": null,
          "default": false
        },
        "gauge.jvm.heap.committed": {
          "type": "gauge",
          "description": "Amount of committed heap memory (in MB)",
          "group": null,
          "default": true
        },
        "gauge.jvm.heap.used": {
          "type": "gauge",
          "description": "Amount of used heap memory (in MB)",
          "group": null,
          "default": true
        },
        "gauge.jvm.non-heap.committed": {
          "type": "gauge",
          "description": "Amount of committed non-heap memory (in MB)",
          "group": null,
          "default": true
        },
        "gauge.jvm.non-heap.used": {
          "type": "gauge",
          "description": "Amount of used non-heap memory (in MB)",
          "group": null,
          "default": true
        },
        "gauge.jvm.pools.Code-Cache.committed": {
          "type": "gauge",
          "description": "Amount of memory committed for compilation and storage of native code",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Code-Cache.used": {
          "type": "gauge",
          "description": "Amount of memory used to compile and store native code",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Compressed-Class-Space.committed": {
          "type": "gauge",
          "description": "Amount of memory committed for compressing a class object",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Compressed-Class-Space.used": {
          "type": "gauge",
          "description": "Amount of memory used to compress a class object",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Eden-Space.committed": {
          "type": "gauge",
          "description": "Amount of memory committed for the initial allocation of objects",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Eden-Space.used": {
          "type": "gauge",
          "description": "Amount of memory used for the initial allocation of objects",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Metaspace.committed": {
          "type": "gauge",
          "description": "Amount of memory committed for storing classes and classloaders",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Metaspace.used": {
          "type": "gauge",
          "description": "Amount of memory used to store classes and classloaders",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Survivor-Space.committed": {
          "type": "gauge",
          "description": "Amount of memory committed specifically for objects that have survived GC of the Eden Space",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Survivor-Space.used": {
          "type": "gauge",
          "description": "Amount of memory used for objects that have survived GC of the Eden Space",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Tenured-Gen.committed": {
          "type": "gauge",
          "description": "Amount of memory committed to store objects that have lived in the survivor space for a given period of time",
          "group": null,
          "default": false
        },
        "gauge.jvm.pools.Tenured-Gen.used": {
          "type": "gauge",
          "description": "Amount of memory used for objects that have lived in the survivor space for a given period of time",
          "group": null,
          "default": false
        },
        "gauge.jvm.total.committed": {
          "type": "gauge",
          "description": "Amount of committed JVM memory (in MB)",
          "group": null,
          "default": true
        },
        "gauge.jvm.total.used": {
          "type": "gauge",
          "description": "Amount of used JVM memory (in MB)",
          "group": null,
          "default": true
        },
        "gauge.master.aliveWorkers": {
          "type": "gauge",
          "description": "Total functioning workers",
          "group": null,
          "default": true
        },
        "gauge.master.apps": {
          "type": "gauge",
          "description": "Total number of active applications in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.master.waitingApps": {
          "type": "gauge",
          "description": "Total number of waiting applications in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.master.workers": {
          "type": "gauge",
          "description": "Total number of workers in spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.driver.active_tasks": {
          "type": "gauge",
          "description": "Total number of active tasks in driver mapped to a particular application",
          "group": null,
          "default": false
        },
        "gauge.spark.driver.max_memory": {
          "type": "gauge",
          "description": "Maximum memory used by driver mapped to a particular application",
          "group": null,
          "default": true
        },
        "gauge.spark.driver.rdd_blocks": {
          "type": "gauge",
          "description": "Number of RDD blocks in the driver mapped to a particular application",
          "group": null,
          "default": false
        },
        "gauge.spark.executor.active_tasks": {
          "type": "gauge",
          "description": "Total number of active tasks across all executors working for a particular application",
          "group": null,
          "default": false
        },
        "gauge.spark.executor.count": {
          "type": "gauge",
          "description": "Total number of executors performing for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.executor.max_memory": {
          "type": "gauge",
          "description": "Max memory across all executors working for a particular application",
          "group": null,
          "default": true
        },
        "gauge.spark.executor.rdd_blocks": {
          "type": "gauge",
          "description": "Number of RDD blocks across all executors working for a particular application",
          "group": null,
          "default": false
        },
        "gauge.spark.job.num_active_stages": {
          "type": "gauge",
          "description": "Total number of active stages for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.job.num_active_tasks": {
          "type": "gauge",
          "description": "Total number of active tasks for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.job.num_completed_stages": {
          "type": "gauge",
          "description": "Total number of completed stages for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.job.num_completed_tasks": {
          "type": "gauge",
          "description": "Total number of completed tasks for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.job.num_failed_stages": {
          "type": "gauge",
          "description": "Total number of failed stages for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.job.num_failed_tasks": {
          "type": "gauge",
          "description": "Total number of failed tasks for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.job.num_skipped_stages": {
          "type": "gauge",
          "description": "Total number of skipped stages for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.job.num_skipped_tasks": {
          "type": "gauge",
          "description": "Total number of skipped tasks for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.job.num_tasks": {
          "type": "gauge",
          "description": "Total number of tasks for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.num_active_stages": {
          "type": "gauge",
          "description": "Total number of active stages for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.num_running_jobs": {
          "type": "gauge",
          "description": "Total number of running jobs for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.stage.disk_bytes_spilled": {
          "type": "gauge",
          "description": "Actual size written to disk for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.stage.executor_run_time": {
          "type": "gauge",
          "description": "Fraction of time spent by (and averaged across) executors for a particular application",
          "group": null,
          "default": true
        },
        "gauge.spark.stage.input_bytes": {
          "type": "gauge",
          "description": "Input size for a particular application",
          "group": null,
          "default": true
        },
        "gauge.spark.stage.input_records": {
          "type": "gauge",
          "description": "Input records received for a particular application",
          "group": null,
          "default": true
        },
        "gauge.spark.stage.memory_bytes_spilled": {
          "type": "gauge",
          "description": "Size spilled to disk from memory for an active application in the spark cluster",
          "group": null,
          "default": true
        },
        "gauge.spark.stage.output_bytes": {
          "type": "gauge",
          "description": "Output size for a particular application",
          "group": null,
          "default": true
        },
        "gauge.spark.stage.output_records": {
          "type": "gauge",
          "description": "Output records written to for a particular application",
          "group": null,
          "default": true
        },
        "gauge.spark.stage.shuffle_read_bytes": {
          "type": "gauge",
          "description": "Read size during shuffle phase for a particular application",
          "group": null,
          "default": false
        },
        "gauge.spark.stage.shuffle_read_records": {
          "type": "gauge",
          "description": "Number of records read during shuffle phase for a particular application",
          "group": null,
          "default": false
        },
        "gauge.spark.stage.shuffle_write_bytes": {
          "type": "gauge",
          "description": "Size written during shuffle phase for a particular application",
          "group": null,
          "default": false
        },
        "gauge.spark.stage.shuffle_write_records": {
          "type": "gauge",
          "description": "Number of records written to during shuffle phase for a particular application",
          "group": null,
          "default": false
        },
        "gauge.spark.streaming.avg_input_rate": {
          "type": "gauge",
          "description": "Average input rate of records across retained batches in a streaming application",
          "group": null,
          "default": true
        },
        "gauge.spark.streaming.avg_processing_time": {
          "type": "gauge",
          "description": "Average processing time in a streaming application",
          "group": null,
          "default": true
        },
        "gauge.spark.streaming.avg_scheduling_delay": {
          "type": "gauge",
          "description": "Average scheduling delay in a streaming application",
          "group": null,
          "default": true
        },
        "gauge.spark.streaming.avg_total_delay": {
          "type": "gauge",
          "description": "Average total delay in a streaming application",
          "group": null,
          "default": true
        },
        "gauge.spark.streaming.num_active_batches": {
          "type": "gauge",
          "description": "Number of active batches in a streaming application",
          "group": null,
          "default": true
        },
        "gauge.spark.streaming.num_inactive_receivers": {
          "type": "gauge",
          "description": "Number of inactive receivers in a streaming application",
          "group": null,
          "default": true
        },
        "gauge.worker.coresFree": {
          "type": "gauge",
          "description": "Total cores free for a particular worker process",
          "group": null,
          "default": true
        },
        "gauge.worker.coresUsed": {
          "type": "gauge",
          "description": "Total cores used by a particular worker process",
          "group": null,
          "default": true
        },
        "gauge.worker.executors": {
          "type": "gauge",
          "description": "Total number of executors for a particular worker process",
          "group": null,
          "default": true
        },
        "gauge.worker.memFree_MB": {
          "type": "gauge",
          "description": "Total memory free for a particular worker process",
          "group": null,
          "default": true
        },
        "gauge.worker.memUsed_MB": {
          "type": "gauge",
          "description": "Memory used by a particular worker process",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/spark",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "isMaster",
            "doc": "Set to `true` when monitoring a master Spark node",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "clusterType",
            "doc": "Should be one of `Standalone` or `Mesos` or `Yarn`.  Cluster metrics will not be collected on Yarn.  Please use the collectd/hadoop monitor to gain insights to your cluster's health.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "collectApplicationMetrics",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/statsd",
      "sendAll": true,
      "dimensions": null,
      "doc": "The StatsD plugin for collectd listens for StatsD\nevents, aggregates them and transmits them according to collectd's\nconfiguration. Use this plugin to send data from StatsD to SignalFx [statsd\nplugin](https://collectd.org/wiki/index.php/Plugin:StatsD).\n\nSignalFx supports `Counter`, `Timer` and `Gauge` types which are dispatched\nas the collectd types - `derive`, `latency` and `gauge` respectively.\nIn SignalFx, for a statsd metric, its collectd type is attached as a\nprefix to the metric name. As an example, if you send in the gauge -\n\n```\n$ echo \"statsd.test:1|g\" | nc -w 1 -u 127.0.0.1 8125\n```\n\nThis will be reported to SignalFx as \"gauge.statsd.test\"\n\n### USAGE\n\n#### Adding dimensions to StatsD metrics\n\nAdd dimensions to your metrics by adding key-value pairs to your StatsD\nmetric names as follows:\n\n```\n$ echo \"statsd.[foo=bar,dim=val]test:1|g\" | nc -w 1 -u 127.0.0.1 8125\n```\n\nThis creates a metric called `statsd.test` of type gauge, with dimensions\n`foo=bar` and `dim=val`.\n\n#### Delete[Type]s boolean setting\n\nThese options control what happens if metrics are not updated in an\ninterval. If set to False, the default, metrics are dispatched unchanged,\ni.e. the rate of counters and size of sets will be zero, timers report NaN\nand gauges are unchanged. If set to True, the such metrics are not\ndispatched and removed from the internal cache.\n\nSignalFx's default configuration for this plugin sets all `Delete[Type]s`\nconfiguration options to `True`. We strongly recommend this in order to\nensure that metrics that have stopped reporting are not reported as 0 in\nperpetuity. Setting these parameters to `False` results in collectd's memory\nusage increasing over time, as the set of metrics reported from StatsD grows\nindefinitely. This is especially important in environments that are\nlong-running or whose metrics change frequently.\n\n#### CounterSum boolean setting\n\nWhen enabled, creates a count metric which reports the change since the last\nread. This option primarily exists for compatibility with the statsd\nimplementation by Etsy.\n\nIf you are only looking at the counts generated by each reporting interval,\nequivalent to\n[Counters](https://docs.signalfx.com/en/latest/metrics-metadata/metric-types.html?highlight=Counters)\nin SignalFx then we'd recommend that you set CounterSum to `True`. It will\nsend in an additional counter metric with a prefix of `count`.\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: collectd/statsd\n   listenAddress: \"0.0.0.0\"\n   listenPort: 8125\n   deleteSets: true\n   timerPercentile: 90.0\n```\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/statsd",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host/address on which to bind the UDP listener that accepts statsd datagrams",
            "default": "localhost",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "listenPort",
            "doc": "The port on which to listen for statsd messages",
            "default": 8125,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "deleteSets",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteCounters",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteTimers",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteGauges",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timerPercentile",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "float64",
            "elementKind": ""
          },
          {
            "yamlName": "timerUpper",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timerCount",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timerSum",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timerLower",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "counterSum",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/systemd",
      "sendAll": true,
      "dimensions": {
        "plugin": {
          "description": "The name of the collectd plugin. Facilitates filtering operations in the SignalFx app"
        },
        "systemd_service": {
          "description": "The name of the systemd service that the reported metric applies to"
        }
      },
      "doc": "This [SignalFx Smart Agent](https://github.com/signalfx/signalfx-agent) monitor collects metrics about the state of\nconfigured systemd services using the [collectd-systemd](https://github.com/signalfx/collectd-systemd)\nplugin. A service is in the state that a metric represents if the metric value is 1 and not in that state if the\nmetric value is 0. The name of the service that the metric is reporiting about is assigned to dimension\n`systemd_service`.\n\nThe collectd-systemd plugin reads the status of systemd services from host location `/var/run/dbus/system_bus_socket`.\nThis means that the host location must be mounted to the container in which the SignalFx Smart Agent is running.\nThe agent container must also run in privilege mode. Below is an excerpt of the docker run command.\n```yaml\ndocker run ...\\\n  --privileged \\\n  -v /var/run/dbus/system_bus_socket:/var/run/dbus/system_bus_socket:ro \\\n...\n```\nBelow is a sample SignalFx Smart Agent YAML configuration for monitoring the state of `docker` and `ubuntu-fan`\nservices. See [here](https://github.com/signalfx/signalfx-agent#configuration) for SignalFx Smart Agent\nconfiguration details.\n```yaml\nmonitors:\n- type: collectd/systemd\n  intervalSeconds: 10\n  services:\n    - docker\n    - ubuntu-fan\n```\nOnly the metric `gauge.substate.running`, which indicates whether a service is running or not, gets reported by default.\nThe other metrics must be configure explicitly using the `sendActiveState`, `sendSubState` and `sendLoadState`\nconfiguration flags (see below). The metrics are grouped into `ActiveState`, `SubState` and `LoadState` groups.\n```\nmonitors:\n- type: collectd/systemd\n  intervalSeconds: 10\n  services:\n    - docker\n    - ubuntu-fan\n  sendActiveState: true\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gauge.active_state.activating",
            "gauge.active_state.active",
            "gauge.active_state.deactivating",
            "gauge.active_state.failed",
            "gauge.active_state.inactive",
            "gauge.active_state.reloading",
            "gauge.load_state.error",
            "gauge.load_state.loaded",
            "gauge.load_state.masked",
            "gauge.load_state.not-found",
            "gauge.substate.dead",
            "gauge.substate.exited",
            "gauge.substate.failed",
            "gauge.substate.running"
          ]
        },
        "ActiveState": {
          "description": "Metrics which indicate whether a service is currently active or not",
          "metrics": null
        },
        "LoadState": {
          "description": "Metrics which indicate whether a service's unit configuration file has been loaded",
          "metrics": null
        },
        "SubState": {
          "description": "Metrics which provide further clarification of a service's active state",
          "metrics": null
        }
      },
      "metrics": {
        "gauge.active_state.activating": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service has previously been inactive but is currently in the process of entering an active state",
          "group": null,
          "default": false
        },
        "gauge.active_state.active": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is active",
          "group": null,
          "default": false
        },
        "gauge.active_state.deactivating": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is currently in the process of deactivation",
          "group": null,
          "default": false
        },
        "gauge.active_state.failed": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is inactive the previous run was not successful",
          "group": null,
          "default": false
        },
        "gauge.active_state.inactive": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is inactive and the previous run was successful or no previous run has taken place yet",
          "group": null,
          "default": false
        },
        "gauge.active_state.reloading": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is active and currently reloading its configuration",
          "group": null,
          "default": false
        },
        "gauge.load_state.error": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service configuration failed to load",
          "group": null,
          "default": false
        },
        "gauge.load_state.loaded": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service configuration was loaded and parsed successfully",
          "group": null,
          "default": false
        },
        "gauge.load_state.masked": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is currently masked out (i.e. symlinked to /dev/null etc)",
          "group": null,
          "default": false
        },
        "gauge.load_state.not-found": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service configuration was not found",
          "group": null,
          "default": false
        },
        "gauge.substate.dead": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service died",
          "group": null,
          "default": false
        },
        "gauge.substate.exited": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service exited",
          "group": null,
          "default": false
        },
        "gauge.substate.failed": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service failed",
          "group": null,
          "default": false
        },
        "gauge.substate.running": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is running",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/systemd",
        "fields": [
          {
            "yamlName": "services",
            "doc": "Systemd services to report on",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "sendActiveState",
            "doc": "Flag for sending metrics about the state of systemd services",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "sendSubState",
            "doc": "Flag for sending more detailed metrics about the state of systemd services",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "sendLoadState",
            "doc": "Flag for sending metrics about the load state of systemd services",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/uptime",
      "sendAll": false,
      "dimensions": null,
      "doc": "Sends a single metric of the total number of\nseconds the host has been up, using the [collectd uptime\nplugin](https://collectd.org/wiki/index.php/Plugin:Uptime).\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "uptime"
          ]
        }
      },
      "metrics": {
        "uptime": {
          "type": "gauge",
          "description": "Seconds since system boot",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/uptime",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/vmem",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects information about the virtual memory\nsubsystem of the kernel using the [collectd vmem\nplugin](https://collectd.org/wiki/index.php/Plugin:vmem).  There is no\nconfiguration available for this plugin.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "vmpage_faults.majflt",
            "vmpage_faults.minflt",
            "vmpage_io.memory.in",
            "vmpage_io.memory.out",
            "vmpage_io.swap.in",
            "vmpage_io.swap.out",
            "vmpage_number.free_pages",
            "vmpage_number.mapped",
            "vmpage_number.shmem_pmdmapped"
          ]
        }
      },
      "metrics": {
        "vmpage_faults.majflt": {
          "type": "cumulative",
          "description": "Number of major page faults on the system",
          "group": null,
          "default": false
        },
        "vmpage_faults.minflt": {
          "type": "cumulative",
          "description": "Number of minor page faults on the system",
          "group": null,
          "default": false
        },
        "vmpage_io.memory.in": {
          "type": "cumulative",
          "description": "Page Ins for Memory",
          "group": null,
          "default": false
        },
        "vmpage_io.memory.out": {
          "type": "cumulative",
          "description": "Page Outs for Memory",
          "group": null,
          "default": false
        },
        "vmpage_io.swap.in": {
          "type": "cumulative",
          "description": "Page Ins for Swap",
          "group": null,
          "default": true
        },
        "vmpage_io.swap.out": {
          "type": "cumulative",
          "description": "Page Outs for Swap",
          "group": null,
          "default": true
        },
        "vmpage_number.free_pages": {
          "type": "cumulative",
          "description": "Number of free memory pages",
          "group": null,
          "default": false
        },
        "vmpage_number.mapped": {
          "type": "cumulative",
          "description": "Number of mapped pages",
          "group": null,
          "default": false
        },
        "vmpage_number.shmem_pmdmapped": {
          "type": "gauge",
          "description": "The amount of shared (shmem/tmpfs) memory backed by huge pages",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/vmem",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/zookeeper",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an Apache Zookeeper instance using the [Zookeeper collectd\nplugin](https://github.com/signalfx/collectd-zookeeper). This plugin is\ninstalled with the Smart Agent so no additional installation is required to\nuse this monitor.  Supports Zookeeper 3.4.0 or later.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "counter.zk_fsync_threshold_exceed_count",
            "counter.zk_packets_received",
            "counter.zk_packets_sent",
            "gauge.zk_approximate_data_size",
            "gauge.zk_avg_latency",
            "gauge.zk_ephemerals_count",
            "gauge.zk_is_leader",
            "gauge.zk_max_file_descriptor_count",
            "gauge.zk_max_latency",
            "gauge.zk_min_latency",
            "gauge.zk_num_alive_connections",
            "gauge.zk_open_file_descriptor_count",
            "gauge.zk_outstanding_requests",
            "gauge.zk_service_health",
            "gauge.zk_watch_count",
            "gauge.zk_znode_count"
          ]
        }
      },
      "metrics": {
        "counter.zk_fsync_threshold_exceed_count": {
          "type": "cumulative",
          "description": "Number of times fsync duration has exceeded warning threshold",
          "group": null,
          "default": false
        },
        "counter.zk_packets_received": {
          "type": "cumulative",
          "description": "Count of the number of ZooKeeper packets received by a server",
          "group": null,
          "default": true
        },
        "counter.zk_packets_sent": {
          "type": "cumulative",
          "description": "Count of the number of ZooKeeper packets sent from a server",
          "group": null,
          "default": true
        },
        "gauge.zk_approximate_data_size": {
          "type": "gauge",
          "description": "Size of data in bytes that a ZooKeeper server has in its data tree",
          "group": null,
          "default": true
        },
        "gauge.zk_avg_latency": {
          "type": "gauge",
          "description": "Average time in milliseconds for requests to be processed",
          "group": null,
          "default": true
        },
        "gauge.zk_ephemerals_count": {
          "type": "gauge",
          "description": "Number of ephemeral nodes that a ZooKeeper server has in its data tree",
          "group": null,
          "default": true
        },
        "gauge.zk_is_leader": {
          "type": "gauge",
          "description": "1 if the node is a leader, 0 if the node is a follower",
          "group": null,
          "default": false
        },
        "gauge.zk_max_file_descriptor_count": {
          "type": "gauge",
          "description": "Maximum number of file descriptors that a ZooKeeper server can open",
          "group": null,
          "default": true
        },
        "gauge.zk_max_latency": {
          "type": "gauge",
          "description": "Maximum time in milliseconds for a request to be processed",
          "group": null,
          "default": false
        },
        "gauge.zk_min_latency": {
          "type": "gauge",
          "description": "Minimum time in milliseconds for a request to be processed",
          "group": null,
          "default": false
        },
        "gauge.zk_num_alive_connections": {
          "type": "gauge",
          "description": "Number of active clients connected to a ZooKeeper server",
          "group": null,
          "default": true
        },
        "gauge.zk_open_file_descriptor_count": {
          "type": "gauge",
          "description": "Number of file descriptors that a ZooKeeper server has open",
          "group": null,
          "default": true
        },
        "gauge.zk_outstanding_requests": {
          "type": "gauge",
          "description": "Number of currently executing requests",
          "group": null,
          "default": false
        },
        "gauge.zk_service_health": {
          "type": "gauge",
          "description": "1 if server is running, otherwise 0",
          "group": null,
          "default": false
        },
        "gauge.zk_watch_count": {
          "type": "gauge",
          "description": "Number of watches placed on Z-Nodes on a ZooKeeper server",
          "group": null,
          "default": true
        },
        "gauge.zk_znode_count": {
          "type": "gauge",
          "description": "Number of z-nodes that a ZooKeeper server has in its data tree",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "pkg/monitors/collectd/zookeeper",
        "fields": [
          {
            "yamlName": "pythonBinary",
            "doc": "Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host or IP address of the Zookeeper node",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Main port of the Zookeeper node",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "This will be the value of the `plugin_instance` dimension on emitted metrics, if provided.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "conviva",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor uses version 2.4 of the Conviva Experience Insights REST APIs to pull\n`Real-Time/Live` video playing experience metrics from Conviva.\n\nOnly `Live` conviva metrics listed\n[here](https://community.conviva.com/site/global/apis_data/experience_insights_api/index.gsp#metrics)\nare supported. All metrics are gauges. The Conviva metrics are converted to SignalFx metrics with dimensions\nnamed account and filter. The account dimension is the name of the Conviva account and the filter dimension\nis the name of the Conviva filter applied to the metric. In the case of MetricLenses, the constituent\nMetricLens metrics and MetricLens dimensions are included. The values of the MetricLens dimensions are\nderived from the values of the associated MetricLens dimension entities.\n\nBelow is a sample YAML configuration showing the most basic configuration of the Conviva monitor\nusing only the required fields. For this configuration the monitor will default to fetching quality MetricLens\nmetrics for all dimensions from the default Conviva account using the `All Traffic` filter.\n\n```\nmonitors:\n- type: conviva\n pulseUsername: \u003cusername\u003e\n pulsePassword: \u003cpassword\u003e\n```\n\nIndividual metrics are configured as a list of metricConfigs as shown in sample configuration below. The\nmetrics a fetched using the specified metricParameter. Find the list of metric parameters [below](#conviva-monitor-metric-parameters-and-metrics).\nThe Conviva metrics reported to SignalFx are prefixed by `conviva.`, `conviva.quality_metriclens.` and\n`conviva.audience_metriclens.` accordingly. The metric names are the `titles` of the metrics, which correspond to the Conviva\n`metric parameters` [here](https://community.conviva.com/site/global/apis_data/experience_insights_api/index.gsp#metrics).\nWhere an account is not provided the default account is fetched and used. Where no filters are specified the\n`All Traffic` filter is used. Where MetricLens dimensions are not specified all MetricLens dimensions\nare fetched and used. The `_ALL_` keyword means all. MetricLens dimension configuration applies only to MetricLenses.\nIf specified for a regular metric they will be ignored. MetricLens dimensions listed in `excludeMetricLensDimensions`\nwill be excluded.\n\n```\nmonitors:\n- type: conviva\n pulseUsername: \u003cusername\u003e\n pulsePassword: \u003cpassword\u003e\n metricConfigs:\n   - account: c3.NBC\n     metricParameter: quality_metriclens\n     filters:\n       - All Traffic\n     metricLensDimensions:\n       - Cities\n   - metricParameter: avg_bitrate\n     maxFiltersPerRequest: 99\n     filters:\n       - _ALL_\n   - metricParameter: concurrent_plays\n   - metricParameter: audience_metriclens\n     filters:\n       - All Traffic\n     metricLensDimensions:\n       - _ALL_\n     excludeMetricLensDimensions:\n       - CDNs\n```\n\nAdd the extra dimension metric_source as shown in sample configuration below for the convenience of searching\nfor your metrics in SignalFx using the metric_source value you specify. Also, version 2.4 of the Conviva Experience\nInsights REST APIs limits the number of filters per request to 99. Specify the maximum number of filters per request\nusing `maxFiltersPerRequest` as shown in the example above in order to limit the number of filters per request.\n\n```\nmonitors:\n- type: conviva\n pulseUsername: \u003cusername\u003e\n pulsePassword: \u003cpassword\u003e\n extraDimensions:\n   metric_source: conviva\n```\n\n## Conviva Monitor Metric Parameters and Metrics\n\nMetric Parameters are conviva monitor metricParameter configuration values. Metrics are the metrics that get reported to SignalFx\n\n|Metric Parameters|Metrics|Description|\n|----------------|------|-----------|\n|attempts|conviva.\u003cbr/\u003eattempts|Attempts time-series|\n|avg_bitrate|conviva.\u003cbr/\u003eavg_bitrate|Average bitrate time-series|\n|concurrent_plays|conviva.\u003cbr/\u003econcurrent_plays|Concurrent plays time-series|\n|connection_induced\u003cbr/\u003e_rebuffering_ratio|conviva.\u003cbr/\u003econnection_induced\u003cbr/\u003e_rebuffering_ratio|Connection induced rebuffering ratio simple-series|\n|connection_induced\u003cbr/\u003e_rebuffering_ratio\u003cbr/\u003e_timeseries|conviva.\u003cbr/\u003econnection_induced\u003cbr/\u003e_rebuffering_ratio\u003cbr/\u003e_timeseries|Connection induced rebuffering ratio time-series|\n|duration_connection\u003cbr/\u003e_induced_rebuffering\u003cbr/\u003e_ratio_distribution|conviva.\u003cbr/\u003eduration_connection\u003cbr/\u003e_induced_rebuffering\u003cbr/\u003e_ratio_distribution|Duration vs. connection induced rebuffering ratio distribution label-series|\n|exits_before\u003cbr/\u003e_video_star|conviva.\u003cbr/\u003eexits_before\u003cbr/\u003e_video_start|Exits before video start time-series|\n|ended_plays|conviva.\u003cbr/\u003eended_plays|Ended plays simple-series|\n|ended_plays\u003cbr/\u003e_timeseries|conviva.\u003cbr/\u003eended_plays\u003cbr/\u003e_timeseries|Ended plays time-series|\n|plays|conviva.\u003cbr/\u003eplays|Plays time-series|\n|play_bitrate\u003cbr/\u003e_distribution|conviva.\u003cbr/\u003eplay_bitrate\u003cbr/\u003e_distribution|Play bitrate distribution label-series|\n|play_buffering\u003cbr/\u003e_ratio_distribution|conviva.\u003cbr/\u003eplay_buffering\u003cbr/\u003e_ratio_distribution|Play buffering ratio distribution label-series|\n|play_connection\u003cbr/\u003e_induced_rebuffering\u003cbr/\u003e_ratio_distribution|conviva.\u003cbr/\u003eplay_connection\u003cbr/\u003e_induced_rebuffering\u003cbr/\u003e_ratio_distribution|Play connection induced rebuffering ratio distribution label-series|\n|quality_summary|conviva.\u003cbr/\u003equality_summary|Quality summary label-series|\n|rebuffered_plays|conviva.\u003cbr/\u003erebuffered_plays|Rebuffered plays time-series|\n|rebuffering_ratio|conviva.\u003cbr/\u003erebuffering_ratio|Rebuffering ratio time-series|\n|top_assets_15_mins|conviva.\u003cbr/\u003etop_assets_15_mins|Top assets over last 15 minutes simple-table|\n|top_assets_summary|conviva.\u003cbr/\u003etop_assets_summary|Top assets summary label-series|\n|video_playback\u003cbr/\u003e_failures|conviva.\u003cbr/\u003evideo_playback\u003cbr/\u003e_failures|Video playback failures simple-series|\n|video_playback\u003cbr/\u003e_failures_timeseries|conviva.\u003cbr/\u003evideo_playback\u003cbr/\u003e_failures_timeseries|Video playback failures time-series|\n|video_playback\u003cbr/\u003e_failures_distribution|conviva.\u003cbr/\u003evideo_playback\u003cbr/\u003e_failures_distribution|Video playback failures distribution label-series|\n|video_restart\u003cbr/\u003e_time|conviva.\u003cbr/\u003evideo_restart\u003cbr/\u003e_time|Video restart time simple-series|\n|video_restart\u003cbr/\u003e_time_timeseries|conviva.\u003cbr/\u003evideo_restart\u003cbr/\u003e_time_timeseries|Video restart time time-series|\n|video_restart\u003cbr/\u003e_time_distribution|conviva.\u003cbr/\u003evideo_restart_time\u003cbr/\u003e_distribution|Video restart time distribution label-series|\n|video_start\u003cbr/\u003e_failures|conviva.\u003cbr/\u003evideo_start\u003cbr/\u003e_failures|Video start failures time-series|\n|video_start\u003cbr/\u003e_failures_errornames|conviva.\u003cbr/\u003evideo_start\u003cbr/\u003e_failures_errornames|Video start failures by error names simple-table|\n|video_startup_time|conviva.\u003cbr/\u003evideo_startup_time|Video startup time label-series|\n|quality_metriclens|conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003etotal_attempts|Attempts|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003evideo_start\u003cbr/\u003e_failures_percent|Video Start Failures(VSF) (%)|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003eexits_before\u003cbr/\u003e_video_start\u003cbr/\u003e_percent|Exits Before Video Starts (EBVS) (%)|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003eplays_percent|Plays (%)|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003evideo_startup\u003cbr/\u003e_time_sec|Video Startup Time (sec)|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003erebuffering_ratio\u003cbr/\u003e_percent|Rebuffering Ratio (%)|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003eaverage_bitrate\u003cbr/\u003e_kbps|Average Bitrate (bps). This metric can be returned in kbps with the ab_units=kbps parameter. Unless this parameter is specified, average bitrate is bps.|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003evideo_playback\u003cbr/\u003e_failures_percent|Video Playback Failures (%)|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003eended_plays|Ended Plays|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003econnection_induced\u003cbr/\u003e_rebuffering_ratio\u003cbr/\u003e_percent|Connection Induced ReBuffering Ratio (%)|\n||conviva.\u003cbr/\u003equality_metriclens.\u003cbr/\u003evideo_restart_time|Video Restart Time|\n|audience_metriclens|conviva.\u003cbr/\u003eaudience_metriclens.\u003cbr/\u003econcurrent_plays|Concurrent Plays|\n||conviva.\u003cbr/\u003eaudience_metriclens.\u003cbr/\u003eplays|Plays|\n||conviva.\u003cbr/\u003eaudience_metriclens.\u003cbr/\u003eended_plays|Ended Plays|\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "conviva.video_startup_time"
          ]
        },
        "attempts": {
          "description": "",
          "metrics": [
            "conviva.attempts"
          ]
        },
        "audience_metriclens": {
          "description": "",
          "metrics": [
            "conviva.audience_metriclens.concurrent_plays",
            "conviva.audience_metriclens.ended_plays",
            "conviva.audience_metriclens.plays"
          ]
        },
        "avg_bitrate": {
          "description": "",
          "metrics": [
            "conviva.avg_bitrate"
          ]
        },
        "concurrent_plays": {
          "description": "",
          "metrics": [
            "conviva.concurrent_plays"
          ]
        },
        "connection_induced_rebuffering_ratio": {
          "description": "",
          "metrics": [
            "conviva.connection_induced_rebuffering_ratio"
          ]
        },
        "connection_induced_rebuffering_ratio_timeseries": {
          "description": "",
          "metrics": [
            "conviva.connection_induced_rebuffering_ratio_timeseries"
          ]
        },
        "duration_connection_induced_rebuffering_ratio_distribution": {
          "description": "",
          "metrics": [
            "conviva.duration_connection_induced_rebuffering_ratio_distribution"
          ]
        },
        "ended_plays": {
          "description": "",
          "metrics": [
            "conviva.ended_plays"
          ]
        },
        "ended_plays_timeseries": {
          "description": "",
          "metrics": [
            "conviva.ended_plays_timeseries"
          ]
        },
        "exits_before_video_start": {
          "description": "",
          "metrics": [
            "conviva.exits_before_video_start"
          ]
        },
        "play_bitrate_distribution": {
          "description": "",
          "metrics": [
            "conviva.play_bitrate_distribution"
          ]
        },
        "play_buffering_ratio_distribution": {
          "description": "",
          "metrics": [
            "conviva.play_buffering_ratio_distribution"
          ]
        },
        "play_connection_induced_rebuffering_ratio_distribution": {
          "description": "",
          "metrics": [
            "conviva.play_connection_induced_rebuffering_ratio_distribution"
          ]
        },
        "plays": {
          "description": "",
          "metrics": [
            "conviva.plays"
          ]
        },
        "quality_metriclens": {
          "description": "",
          "metrics": [
            "conviva.quality_metriclens.average_bitrate_kbps",
            "conviva.quality_metriclens.connection_induced_rebuffering_ratio_percent",
            "conviva.quality_metriclens.ended_plays",
            "conviva.quality_metriclens.exits_before_video_start_percent",
            "conviva.quality_metriclens.plays_percent",
            "conviva.quality_metriclens.rebuffering_ratio_percent",
            "conviva.quality_metriclens.total_attempts",
            "conviva.quality_metriclens.video_playback_failures_percent",
            "conviva.quality_metriclens.video_restart_time",
            "conviva.quality_metriclens.video_start_failures_percent",
            "conviva.quality_metriclens.video_startup_time_sec"
          ]
        },
        "quality_summary": {
          "description": "",
          "metrics": [
            "conviva.quality_summary"
          ]
        },
        "rebuffered_plays": {
          "description": "",
          "metrics": [
            "conviva.rebuffered_plays"
          ]
        },
        "rebuffering_ratio": {
          "description": "",
          "metrics": [
            "conviva.rebuffering_ratio"
          ]
        },
        "top_assets_15_mins": {
          "description": "",
          "metrics": [
            "conviva.top_assets_15_mins"
          ]
        },
        "top_assets_summary": {
          "description": "",
          "metrics": [
            "conviva.top_assets_summary"
          ]
        },
        "video_playback_failures": {
          "description": "",
          "metrics": [
            "conviva.video_playback_failures"
          ]
        },
        "video_playback_failures_distribution": {
          "description": "",
          "metrics": [
            "conviva.video_playback_failures_distribution"
          ]
        },
        "video_playback_failures_timeseries": {
          "description": "",
          "metrics": [
            "conviva.video_playback_failures_timeseries"
          ]
        },
        "video_restart_time": {
          "description": "",
          "metrics": [
            "conviva.video_restart_time"
          ]
        },
        "video_restart_time_distribution": {
          "description": "",
          "metrics": [
            "conviva.video_restart_time_distribution"
          ]
        },
        "video_restart_time_timeseries": {
          "description": "",
          "metrics": [
            "conviva.video_restart_time_timeseries"
          ]
        },
        "video_start_failures": {
          "description": "",
          "metrics": [
            "conviva.video_start_failures"
          ]
        },
        "video_start_failures_errornames": {
          "description": "",
          "metrics": [
            "conviva.video_start_failures_errornames"
          ]
        }
      },
      "metrics": {
        "conviva.attempts": {
          "type": "gauge",
          "description": "Attempts time-series",
          "group": "attempts",
          "default": true
        },
        "conviva.audience_metriclens.concurrent_plays": {
          "type": "gauge",
          "description": "Concurrent Plays",
          "group": "audience_metriclens",
          "default": true
        },
        "conviva.audience_metriclens.ended_plays": {
          "type": "gauge",
          "description": "Ended Plays",
          "group": "audience_metriclens",
          "default": true
        },
        "conviva.audience_metriclens.plays": {
          "type": "gauge",
          "description": "Plays",
          "group": "audience_metriclens",
          "default": true
        },
        "conviva.avg_bitrate": {
          "type": "gauge",
          "description": "Average bitrate time-series",
          "group": "avg_bitrate",
          "default": true
        },
        "conviva.concurrent_plays": {
          "type": "gauge",
          "description": "Concurrent plays time-series",
          "group": "concurrent_plays",
          "default": true
        },
        "conviva.connection_induced_rebuffering_ratio": {
          "type": "gauge",
          "description": "Connection induced rebuffering ratio simple-series",
          "group": "connection_induced_rebuffering_ratio",
          "default": true
        },
        "conviva.connection_induced_rebuffering_ratio_timeseries": {
          "type": "gauge",
          "description": "Connection induced rebuffering ratio time-series",
          "group": "connection_induced_rebuffering_ratio_timeseries",
          "default": true
        },
        "conviva.duration_connection_induced_rebuffering_ratio_distribution": {
          "type": "gauge",
          "description": "Duration vs. connection induced rebuffering ratio distribution label-series",
          "group": "duration_connection_induced_rebuffering_ratio_distribution",
          "default": true
        },
        "conviva.ended_plays": {
          "type": "gauge",
          "description": "Ended plays simple-series",
          "group": "ended_plays",
          "default": true
        },
        "conviva.ended_plays_timeseries": {
          "type": "gauge",
          "description": "Ended plays time-series",
          "group": "ended_plays_timeseries",
          "default": true
        },
        "conviva.exits_before_video_start": {
          "type": "gauge",
          "description": "Exits before video start time-series",
          "group": "exits_before_video_start",
          "default": true
        },
        "conviva.play_bitrate_distribution": {
          "type": "gauge",
          "description": "Play bitrate distribution label-series",
          "group": "play_bitrate_distribution",
          "default": true
        },
        "conviva.play_buffering_ratio_distribution": {
          "type": "gauge",
          "description": "Play buffering ratio distribution label-series",
          "group": "play_buffering_ratio_distribution",
          "default": true
        },
        "conviva.play_connection_induced_rebuffering_ratio_distribution": {
          "type": "gauge",
          "description": "Play connection induced rebuffering ratio distribution label-series",
          "group": "play_connection_induced_rebuffering_ratio_distribution",
          "default": true
        },
        "conviva.plays": {
          "type": "gauge",
          "description": "Plays time-series",
          "group": "plays",
          "default": true
        },
        "conviva.quality_metriclens.average_bitrate_kbps": {
          "type": "gauge",
          "description": "Average Bitrate (bps). This metric can be returned in kbps with the ab_units=kbps parameter. Unless this parameter is specified, average bitrate is bps",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.connection_induced_rebuffering_ratio_percent": {
          "type": "gauge",
          "description": "Connection Induced ReBuffering Ratio (%)",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.ended_plays": {
          "type": "gauge",
          "description": "Ended Plays",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.exits_before_video_start_percent": {
          "type": "gauge",
          "description": "Exits Before Video Starts (EBVS) (%)",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.plays_percent": {
          "type": "gauge",
          "description": "Plays (%)",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.rebuffering_ratio_percent": {
          "type": "gauge",
          "description": "Rebuffering Ratio (%)",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.total_attempts": {
          "type": "gauge",
          "description": "Attempts",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.video_playback_failures_percent": {
          "type": "gauge",
          "description": "Video Playback Failures (%)",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.video_restart_time": {
          "type": "gauge",
          "description": "Video Restart Time",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.video_start_failures_percent": {
          "type": "gauge",
          "description": "Video Start Failures(VSF) (%)",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_metriclens.video_startup_time_sec": {
          "type": "gauge",
          "description": "Video Startup Time (sec)",
          "group": "quality_metriclens",
          "default": true
        },
        "conviva.quality_summary": {
          "type": "gauge",
          "description": "Quality summary label-series",
          "group": "quality_summary",
          "default": true
        },
        "conviva.rebuffered_plays": {
          "type": "gauge",
          "description": "Rebuffered plays time-series",
          "group": "rebuffered_plays",
          "default": true
        },
        "conviva.rebuffering_ratio": {
          "type": "gauge",
          "description": "Rebuffering ratio time-series",
          "group": "rebuffering_ratio",
          "default": true
        },
        "conviva.top_assets_15_mins": {
          "type": "gauge",
          "description": "Top assets over last 15 minutes simple-table",
          "group": "top_assets_15_mins",
          "default": true
        },
        "conviva.top_assets_summary": {
          "type": "gauge",
          "description": "Top assets summary label-series",
          "group": "top_assets_summary",
          "default": true
        },
        "conviva.video_playback_failures": {
          "type": "gauge",
          "description": "Video playback failures simple-series",
          "group": "video_playback_failures",
          "default": true
        },
        "conviva.video_playback_failures_distribution": {
          "type": "gauge",
          "description": "Video playback failures distribution label-series",
          "group": "video_playback_failures_distribution",
          "default": true
        },
        "conviva.video_playback_failures_timeseries": {
          "type": "gauge",
          "description": "Video playback failures time-series",
          "group": "video_playback_failures_timeseries",
          "default": true
        },
        "conviva.video_restart_time": {
          "type": "gauge",
          "description": "Video restart time simple-series",
          "group": "video_restart_time",
          "default": true
        },
        "conviva.video_restart_time_distribution": {
          "type": "gauge",
          "description": "Video restart time distribution label-series",
          "group": "video_restart_time_distribution",
          "default": true
        },
        "conviva.video_restart_time_timeseries": {
          "type": "gauge",
          "description": "Video restart time time-series",
          "group": "video_restart_time_timeseries",
          "default": true
        },
        "conviva.video_start_failures": {
          "type": "gauge",
          "description": "Video start failures time-series",
          "group": "video_start_failures",
          "default": true
        },
        "conviva.video_start_failures_errornames": {
          "type": "gauge",
          "description": "Video start failures by error names simple-table",
          "group": "video_start_failures_errornames",
          "default": true
        },
        "conviva.video_startup_time": {
          "type": "gauge",
          "description": "Video startup time label-series",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/conviva",
        "fields": [
          {
            "yamlName": "pulseUsername",
            "doc": "Conviva Pulse username required with each API request.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pulsePassword",
            "doc": "Conviva Pulse password required with each API request.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "timeoutSeconds",
            "doc": "",
            "default": 10,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "metricConfigs",
            "doc": "Conviva metrics to fetch. The default is quality_metriclens metric with the \"All Traffic\" filter applied and all quality_metriclens dimensions.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "metricConfig",
              "doc": "metricConfig for configuring individual metric",
              "package": "pkg/monitors/conviva",
              "fields": [
                {
                  "yamlName": "account",
                  "doc": "Conviva customer account name. The default account is fetched used if not specified.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "metricParameter",
                  "doc": "",
                  "default": "quality_metriclens",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "filters",
                  "doc": "Filter names. The default is `All Traffic` filter",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "metricLensDimensions",
                  "doc": "MetricLens dimension names. The default is names of all MetricLens dimensions of the account",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "excludeMetricLensDimensions",
                  "doc": "MetricLens dimension names to exclude.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "maxFiltersPerRequest",
                  "doc": "Max number of filters per request. The default is the number of filters. Multiple requests are made if the number of filters is more than maxFiltersPerRequest",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "coredns",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes prometheus metrics exposed by CoreDNS. The default port for these metrics\nare exposed on port 9153, at the /metrics path. For more information about CoreDNS prometheus\nmetrics, check out their [documentation](https://coredns.io/plugins/metrics/).\n\nThe following is an example configuration for a Kubernetes environment:\n\n```\nmonitors:\n- type: coredns\n  discoveryRule: kubernetes_pod_name =~ \"coredns\" \u0026\u0026 port == 9153\n  extraDimensions:\n    metric_source: \"k8s-coredns\"\n```",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "coredns_build_info",
            "coredns_cache_hits_total",
            "coredns_cache_misses_total",
            "coredns_cache_size",
            "coredns_dns_request_count_total",
            "coredns_dns_request_duration_seconds",
            "coredns_dns_request_duration_seconds_bucket",
            "coredns_dns_request_duration_seconds_count",
            "coredns_dns_request_size_bytes",
            "coredns_dns_request_size_bytes_bucket",
            "coredns_dns_request_size_bytes_count",
            "coredns_dns_request_type_count_total",
            "coredns_dns_response_rcode_count_total",
            "coredns_dns_response_size_bytes",
            "coredns_dns_response_size_bytes_bucket",
            "coredns_dns_response_size_bytes_count",
            "coredns_health_request_duration_seconds",
            "coredns_health_request_duration_seconds_bucket",
            "coredns_health_request_duration_seconds_count",
            "coredns_panic_count_total",
            "coredns_proxy_request_count_total",
            "coredns_proxy_request_duration_seconds",
            "coredns_proxy_request_duration_seconds_bucket",
            "coredns_proxy_request_duration_seconds_count",
            "go_gc_duration_seconds",
            "go_gc_duration_seconds_count",
            "go_gc_duration_seconds_quantile",
            "go_goroutines",
            "go_memstats_alloc_bytes",
            "go_memstats_alloc_bytes_total",
            "go_memstats_buck_hash_sys_bytes",
            "go_memstats_frees_total",
            "go_memstats_gc_sys_bytes",
            "go_memstats_heap_alloc_bytes",
            "go_memstats_heap_idle_bytes",
            "go_memstats_heap_inuse_bytes",
            "go_memstats_heap_objects",
            "go_memstats_heap_released_bytes_total",
            "go_memstats_heap_sys_bytes",
            "go_memstats_last_gc_time_seconds",
            "go_memstats_lookups_total",
            "go_memstats_mallocs_total",
            "go_memstats_mcache_inuse_bytes",
            "go_memstats_mcache_sys_bytes",
            "go_memstats_mspan_inuse_bytes",
            "go_memstats_mspan_sys_bytes",
            "go_memstats_next_gc_bytes",
            "go_memstats_other_sys_bytes",
            "go_memstats_stack_inuse_bytes",
            "go_memstats_stack_sys_bytes",
            "go_memstats_sys_bytes",
            "process_cpu_seconds_total",
            "process_max_fds",
            "process_open_fds",
            "process_resident_memory_bytes",
            "process_start_time_seconds",
            "process_virtual_memory_bytes"
          ]
        }
      },
      "metrics": {
        "coredns_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by version, revision, and goversion from which CoreDNS was built.",
          "group": null,
          "default": false
        },
        "coredns_cache_hits_total": {
          "type": "cumulative",
          "description": "The count of cache misses.",
          "group": null,
          "default": false
        },
        "coredns_cache_misses_total": {
          "type": "cumulative",
          "description": "The count of cache misses.",
          "group": null,
          "default": false
        },
        "coredns_cache_size": {
          "type": "cumulative",
          "description": "Size of DNS cache.",
          "group": null,
          "default": true
        },
        "coredns_dns_request_count_total": {
          "type": "cumulative",
          "description": "Counter of DNS requests made per zone, protocol and family.",
          "group": null,
          "default": true
        },
        "coredns_dns_request_duration_seconds": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (sum)",
          "group": null,
          "default": false
        },
        "coredns_dns_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (bucket)",
          "group": null,
          "default": false
        },
        "coredns_dns_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (count)",
          "group": null,
          "default": false
        },
        "coredns_dns_request_size_bytes": {
          "type": "cumulative",
          "description": "Size of the EDNS0 UDP buffer in bytes (64K for TCP). (sum)",
          "group": null,
          "default": true
        },
        "coredns_dns_request_size_bytes_bucket": {
          "type": "cumulative",
          "description": "Size of the EDNS0 UDP buffer in bytes (64K for TCP). (bucket)",
          "group": null,
          "default": false
        },
        "coredns_dns_request_size_bytes_count": {
          "type": "cumulative",
          "description": "Size of the EDNS0 UDP buffer in bytes (64K for TCP). (count)",
          "group": null,
          "default": false
        },
        "coredns_dns_request_type_count_total": {
          "type": "cumulative",
          "description": "Counter of DNS requests per type, per zone.",
          "group": null,
          "default": true
        },
        "coredns_dns_response_rcode_count_total": {
          "type": "cumulative",
          "description": "Counter of response status codes.",
          "group": null,
          "default": true
        },
        "coredns_dns_response_size_bytes": {
          "type": "cumulative",
          "description": "Size of the returned response in bytes. (sum)",
          "group": null,
          "default": false
        },
        "coredns_dns_response_size_bytes_bucket": {
          "type": "cumulative",
          "description": "Size of the returned response in bytes. (bucket)",
          "group": null,
          "default": false
        },
        "coredns_dns_response_size_bytes_count": {
          "type": "cumulative",
          "description": "Size of the returned response in bytes. (count)",
          "group": null,
          "default": false
        },
        "coredns_health_request_duration_seconds": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (sum)",
          "group": null,
          "default": false
        },
        "coredns_health_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (bucket)",
          "group": null,
          "default": false
        },
        "coredns_health_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (count)",
          "group": null,
          "default": false
        },
        "coredns_panic_count_total": {
          "type": "cumulative",
          "description": "A metrics that counts the number of panics.",
          "group": null,
          "default": false
        },
        "coredns_proxy_request_count_total": {
          "type": "cumulative",
          "description": "Counter of requests made per protocol, proxy protocol, family and upstream.",
          "group": null,
          "default": false
        },
        "coredns_proxy_request_duration_seconds": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (sum)",
          "group": null,
          "default": false
        },
        "coredns_proxy_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (bucket)",
          "group": null,
          "default": false
        },
        "coredns_proxy_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Histogram of the time (in seconds) each request took. (count)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (sum)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (count)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_quantile": {
          "type": "gauge",
          "description": "A summary of the GC invocation durations. (quantized)",
          "group": null,
          "default": false
        },
        "go_goroutines": {
          "type": "gauge",
          "description": "Number of goroutines that currently exist.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed.",
          "group": null,
          "default": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table.",
          "group": null,
          "default": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_released_bytes_total": {
          "type": "cumulative",
          "description": "Total number of heap bytes released to OS.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Number of seconds since 1970 of last garbage collection.",
          "group": null,
          "default": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups.",
          "group": null,
          "default": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place.",
          "group": null,
          "default": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained by system. Sum of all system allocations.",
          "group": null,
          "default": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent in seconds.",
          "group": null,
          "default": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/coredns",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "cpu",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports cpu metrics.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: cpu\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "cpu.utilization",
            "cpu.utilization_per_core"
          ]
        }
      },
      "metrics": {
        "cpu.utilization": {
          "type": "gauge",
          "description": "Percent of CPU used on this host. This metric is emitted with a plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "default": true
        },
        "cpu.utilization_per_core": {
          "type": "gauge",
          "description": "Percent of CPU used on each core. This metric is emitted with the plugin dimension set to \"signalfx-metadata\"",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/cpu",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "disk-io",
      "sendAll": false,
      "dimensions": {
        "disk": {
          "description": "The name of the disk that the metric describes"
        }
      },
      "doc": "This monitor reports I/O metrics about disks.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: disk-io\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "disk_merged.read",
            "disk_merged.write",
            "disk_octets.avg_read",
            "disk_octets.avg_write",
            "disk_octets.read",
            "disk_octets.write",
            "disk_ops.avg_read",
            "disk_ops.avg_write",
            "disk_ops.read",
            "disk_ops.total",
            "disk_ops.write",
            "disk_time.avg_read",
            "disk_time.avg_write",
            "disk_time.read",
            "disk_time.write"
          ]
        }
      },
      "metrics": {
        "disk_merged.read": {
          "type": "cumulative",
          "description": "(Linux Only) The number of disk reads merged into single physical disk access operations.",
          "group": null,
          "default": false
        },
        "disk_merged.write": {
          "type": "cumulative",
          "description": "(Linux Only) The number of disk writes merged into single physical disk access operations.",
          "group": null,
          "default": false
        },
        "disk_octets.avg_read": {
          "type": "gauge",
          "description": "(Windows Only) The average number of octets (bytes) read.",
          "group": null,
          "default": false
        },
        "disk_octets.avg_write": {
          "type": "gauge",
          "description": "(Windows Only) The average number of octets (bytes) written.",
          "group": null,
          "default": false
        },
        "disk_octets.read": {
          "type": "cumulative",
          "description": "(Linux Only) The number of bytes (octets) read from a disk.",
          "group": null,
          "default": false
        },
        "disk_octets.write": {
          "type": "cumulative",
          "description": "(Linux Only) The number of bytes (octets) written to a disk.",
          "group": null,
          "default": false
        },
        "disk_ops.avg_read": {
          "type": "gauge",
          "description": "(Windows Only) The average disk read queue length.",
          "group": null,
          "default": true
        },
        "disk_ops.avg_write": {
          "type": "gauge",
          "description": "(Windows Only) The average disk write queue length.",
          "group": null,
          "default": true
        },
        "disk_ops.read": {
          "type": "cumulative",
          "description": "(Linux Only) The number of disk read operations.",
          "group": null,
          "default": true
        },
        "disk_ops.total": {
          "type": "gauge",
          "description": "(Linux Only) The number of both read and write disk operations across all disks in the last reporting interval.",
          "group": null,
          "default": true
        },
        "disk_ops.write": {
          "type": "cumulative",
          "description": "(Linux Only) The number of disk write operations.",
          "group": null,
          "default": true
        },
        "disk_time.avg_read": {
          "type": "gauge",
          "description": "(Windows Only) The average time spent reading from the disk.",
          "group": null,
          "default": false
        },
        "disk_time.avg_write": {
          "type": "gauge",
          "description": "(Windows Only) The average time spent writing to the disk",
          "group": null,
          "default": false
        },
        "disk_time.read": {
          "type": "cumulative",
          "description": "(Linux Only) The average amount of time it took to do a read operation.",
          "group": null,
          "default": false
        },
        "disk_time.write": {
          "type": "cumulative",
          "description": "(Linux Only) The average amount of time it took to do a write operation.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/diskio",
        "fields": [
          {
            "yamlName": "disks",
            "doc": "The devices to include/exclude. This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters).",
            "default": [
              "*",
              "!/^loop[0-9]+$/",
              "!/^dm-[0-9]+$/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) The frequency that wildcards in counter paths should be expanded and how often to refresh counters from configuration. This is expressed as a duration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "docker-container-stats",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reads container stats from a\nDocker API server.  It is meant as a metric-compatible replacement of our\n[docker-collectd](https://github.com/signalfx/docker-collectd-plugin)\nplugin, which scales rather poorly against a large number of containers.\n\nThis currently does not support CPU share/quota metrics.\n\nFor more information on block IO metrics, see [the Linux cgroup block io\ncontroller\ndoc](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).\n\nIf you are running the agent directly on a host (outside of a container\nitself) and you are using the default Docker UNIX socket URL, you will\nprobably need to add the `signalfx-agent` user to the `docker` group in\norder to have permission to access the Docker API via the socket.\n\nRequires Docker API version 1.22+.\n",
      "groups": {
        "blkio": {
          "description": "BlockIO metrics",
          "metrics": [
            "blkio.io_merged_recursive.async",
            "blkio.io_merged_recursive.read",
            "blkio.io_merged_recursive.sync",
            "blkio.io_merged_recursive.total",
            "blkio.io_merged_recursive.write",
            "blkio.io_queue_recursive.async",
            "blkio.io_queue_recursive.read",
            "blkio.io_queue_recursive.sync",
            "blkio.io_queue_recursive.total",
            "blkio.io_queue_recursive.write",
            "blkio.io_service_bytes_recursive.async",
            "blkio.io_service_bytes_recursive.read",
            "blkio.io_service_bytes_recursive.sync",
            "blkio.io_service_bytes_recursive.total",
            "blkio.io_service_bytes_recursive.write",
            "blkio.io_service_time_recursive.async",
            "blkio.io_service_time_recursive.read",
            "blkio.io_service_time_recursive.sync",
            "blkio.io_service_time_recursive.total",
            "blkio.io_service_time_recursive.write",
            "blkio.io_serviced_recursive.async",
            "blkio.io_serviced_recursive.read",
            "blkio.io_serviced_recursive.sync",
            "blkio.io_serviced_recursive.total",
            "blkio.io_serviced_recursive.write",
            "blkio.io_time_recursive.async",
            "blkio.io_time_recursive.read",
            "blkio.io_time_recursive.sync",
            "blkio.io_time_recursive.total",
            "blkio.io_time_recursive.write",
            "blkio.io_wait_time_recursive.async",
            "blkio.io_wait_time_recursive.read",
            "blkio.io_wait_time_recursive.sync",
            "blkio.io_wait_time_recursive.total",
            "blkio.io_wait_time_recursive.write"
          ]
        },
        "cpu": {
          "description": "CPU metrics",
          "metrics": [
            "cpu.percent",
            "cpu.percpu.usage",
            "cpu.throttling_data.periods",
            "cpu.throttling_data.throttled_periods",
            "cpu.throttling_data.throttled_time",
            "cpu.usage.kernelmode",
            "cpu.usage.system",
            "cpu.usage.total",
            "cpu.usage.usermode"
          ]
        },
        "memory": {
          "description": "Memory metrics",
          "metrics": [
            "memory.percent",
            "memory.stats.active_anon",
            "memory.stats.active_file",
            "memory.stats.cache",
            "memory.stats.dirty",
            "memory.stats.hierarchical_memory_limit",
            "memory.stats.hierarchical_memsw_limit",
            "memory.stats.inactive_anon",
            "memory.stats.inactive_file",
            "memory.stats.mapped_file",
            "memory.stats.pgfault",
            "memory.stats.pgmajfault",
            "memory.stats.pgpgin",
            "memory.stats.pgpgout",
            "memory.stats.rss",
            "memory.stats.rss_huge",
            "memory.stats.shmem",
            "memory.stats.swap",
            "memory.stats.total_active_anon",
            "memory.stats.total_active_file",
            "memory.stats.total_cache",
            "memory.stats.total_dirty",
            "memory.stats.total_inactive_anon",
            "memory.stats.total_inactive_file",
            "memory.stats.total_mapped_file",
            "memory.stats.total_pgfault",
            "memory.stats.total_pgmajfault",
            "memory.stats.total_pgpgin",
            "memory.stats.total_pgpgout",
            "memory.stats.total_rss",
            "memory.stats.total_rss_huge",
            "memory.stats.total_shmem",
            "memory.stats.total_swap",
            "memory.stats.total_unevictable",
            "memory.stats.total_writeback",
            "memory.stats.unevictable",
            "memory.stats.writeback",
            "memory.usage.limit",
            "memory.usage.max",
            "memory.usage.total"
          ]
        },
        "network": {
          "description": "Network metrics",
          "metrics": [
            "network.usage.rx_bytes",
            "network.usage.rx_dropped",
            "network.usage.rx_errors",
            "network.usage.rx_packets",
            "network.usage.tx_bytes",
            "network.usage.tx_dropped",
            "network.usage.tx_errors",
            "network.usage.tx_packets"
          ]
        }
      },
      "metrics": {
        "blkio.io_merged_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_merged_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_merged_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_merged_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_merged_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_queue_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_queue_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_queue_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_queue_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_queue_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_bytes_recursive.async": {
          "type": "cumulative",
          "description": "Volume, in bytes, of asynchronous block I/O",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_bytes_recursive.read": {
          "type": "cumulative",
          "description": "Volume, in bytes, of reads from block devices",
          "group": "blkio",
          "default": true
        },
        "blkio.io_service_bytes_recursive.sync": {
          "type": "cumulative",
          "description": "Volume, in bytes, of synchronous block I/O",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_bytes_recursive.total": {
          "type": "cumulative",
          "description": "Total volume, in bytes, of all block I/O",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_bytes_recursive.write": {
          "type": "cumulative",
          "description": "Volume, in bytes, of writes to block devices",
          "group": "blkio",
          "default": true
        },
        "blkio.io_service_time_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_time_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_time_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_time_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_time_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.async": {
          "type": "cumulative",
          "description": "Number of asynchronous block I/O requests",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.read": {
          "type": "cumulative",
          "description": "Number of reads requests from block devices",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.sync": {
          "type": "cumulative",
          "description": "Number of synchronous block I/O requests",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.total": {
          "type": "cumulative",
          "description": "Total number of block I/O requests",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.write": {
          "type": "cumulative",
          "description": "Number of write requests to block devices",
          "group": "blkio",
          "default": false
        },
        "blkio.io_time_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_time_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_time_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_time_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_time_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_wait_time_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_wait_time_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_wait_time_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_wait_time_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "blkio.io_wait_time_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "default": false
        },
        "cpu.percent": {
          "type": "gauge",
          "description": "Percentage of host CPU resources used by the container",
          "group": "cpu",
          "default": false
        },
        "cpu.percpu.usage": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent by the container, per CPU core",
          "group": "cpu",
          "default": false
        },
        "cpu.throttling_data.periods": {
          "type": "cumulative",
          "description": "Number of periods",
          "group": "cpu",
          "default": false
        },
        "cpu.throttling_data.throttled_periods": {
          "type": "cumulative",
          "description": "Number of periods throttled",
          "group": "cpu",
          "default": false
        },
        "cpu.throttling_data.throttled_time": {
          "type": "cumulative",
          "description": "Throttling time in nano seconds",
          "group": "cpu",
          "default": false
        },
        "cpu.usage.kernelmode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in kernel mode by the container",
          "group": "cpu",
          "default": false
        },
        "cpu.usage.system": {
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the system",
          "group": "cpu",
          "default": true
        },
        "cpu.usage.total": {
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the container",
          "group": "cpu",
          "default": true
        },
        "cpu.usage.usermode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in user mode by the container",
          "group": "cpu",
          "default": false
        },
        "memory.percent": {
          "type": "gauge",
          "description": "Percent of memory (0-100) used by the container relative to its limit (excludes page cache usage)",
          "group": "memory",
          "default": false
        },
        "memory.stats.active_anon": {
          "type": "gauge",
          "description": "Amount of memory that has been identified as active by the kernel. Anonymous memory is memory that is not linked to disk pages.",
          "group": "memory",
          "default": false
        },
        "memory.stats.active_file": {
          "type": "gauge",
          "description": "Amount of active file cache memory. Cache memory = active_file + inactive_file + tmpfs",
          "group": "memory",
          "default": false
        },
        "memory.stats.cache": {
          "type": "gauge",
          "description": "The amount of memory used by the processes of this control group that can be associated with a block on a block device. Also accounts for memory used by tmpfs.",
          "group": "memory",
          "default": false
        },
        "memory.stats.dirty": {
          "type": "gauge",
          "description": "The amount of memory waiting to get written to disk",
          "group": "memory",
          "default": false
        },
        "memory.stats.hierarchical_memory_limit": {
          "type": "gauge",
          "description": "The memory limit in place by the hierarchy cgroup",
          "group": "memory",
          "default": false
        },
        "memory.stats.hierarchical_memsw_limit": {
          "type": "gauge",
          "description": "The memory+swap limit in place by the hierarchy cgroup",
          "group": "memory",
          "default": false
        },
        "memory.stats.inactive_anon": {
          "type": "gauge",
          "description": "Amount of memory that has been identified as inactive by the kernel. Anonymous memory is memory that is not linked to disk pages.",
          "group": "memory",
          "default": false
        },
        "memory.stats.inactive_file": {
          "type": "gauge",
          "description": "Amount of inactive file cache memory. Cache memory = active_file + inactive_file + tmpfs",
          "group": "memory",
          "default": false
        },
        "memory.stats.mapped_file": {
          "type": "gauge",
          "description": "Indicates the amount of memory mapped by the processes in the control group. It doesn’t give you information about how much memory is used; it rather tells you how it is used.",
          "group": "memory",
          "default": false
        },
        "memory.stats.pgfault": {
          "type": "cumulative",
          "description": "Number of times that a process of the cgroup triggered a page fault. Page faults occur when a process accesses part of its virtual memory space which is nonexistent or protected. See https://docs.docker.com/config/containers/runmetrics for more info.",
          "group": "memory",
          "default": false
        },
        "memory.stats.pgmajfault": {
          "type": "cumulative",
          "description": "Number of times that a process of the cgroup triggered a major page fault. Page faults occur when a process accesses part of its virtual memory space which is nonexistent or protected. See https://docs.docker.com/config/containers/runmetrics for more info.",
          "group": "memory",
          "default": false
        },
        "memory.stats.pgpgin": {
          "type": "cumulative",
          "description": "Number of charging events to the memory cgroup. Charging events happen each time a page is accounted as either mapped anon page(RSS) or cache page to the cgroup.",
          "group": "memory",
          "default": false
        },
        "memory.stats.pgpgout": {
          "type": "cumulative",
          "description": "Number of uncharging events to the memory cgroup. Uncharging events happen each time a page is unaccounted from the cgroup.",
          "group": "memory",
          "default": false
        },
        "memory.stats.rss": {
          "type": "gauge",
          "description": "The amount of memory that doesn’t correspond to anything on disk: stacks, heaps, and anonymous memory maps.",
          "group": "memory",
          "default": false
        },
        "memory.stats.rss_huge": {
          "type": "gauge",
          "description": "Amount of memory due to anonymous transparent hugepages.",
          "group": "memory",
          "default": false
        },
        "memory.stats.shmem": {
          "type": "gauge",
          "description": "Amount of [Shared Memory](https://www.kernel.org/doc/gorman/html/understand/understand015.html) used by the container, in bytes.",
          "group": "memory",
          "default": false
        },
        "memory.stats.swap": {
          "type": "gauge",
          "description": "Bytes of swap memory used by container",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_active_anon": {
          "type": "gauge",
          "description": "Total amount of memory that has been identified as active by the kernel. Anonymous memory is memory that is not linked to disk pages.",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_active_file": {
          "type": "gauge",
          "description": "Total amount of active file cache memory. Cache memory = active_file + inactive_file + tmpfs",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_cache": {
          "type": "gauge",
          "description": "Total amount of memory used by the processes of this control group that can be associated with a block on a block device. Also accounts for memory used by tmpfs.",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_dirty": {
          "type": "gauge",
          "description": "Total amount of memory waiting to get written to disk",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_inactive_anon": {
          "type": "gauge",
          "description": "Total amount of memory that has been identified as inactive by the kernel. Anonymous memory is memory that is not linked to disk pages.",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_inactive_file": {
          "type": "gauge",
          "description": "Total amount of inactive file cache memory. Cache memory = active_file + inactive_file + tmpfs",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_mapped_file": {
          "type": "gauge",
          "description": "Total amount of memory mapped by the processes in the control group. It doesn’t give you information about how much memory is used; it rather tells you how it is used.",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_pgfault": {
          "type": "cumulative",
          "description": "Total number of page faults",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_pgmajfault": {
          "type": "cumulative",
          "description": "Total number of major page faults",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_pgpgin": {
          "type": "cumulative",
          "description": "Total number of charging events",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_pgpgout": {
          "type": "cumulative",
          "description": "Total number of uncharging events",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_rss": {
          "type": "gauge",
          "description": "Total amount of memory that doesn’t correspond to anything on disk: stacks, heaps, and anonymous memory maps.",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_rss_huge": {
          "type": "gauge",
          "description": "Total amount of memory due to anonymous transparent hugepages.",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_shmem": {
          "type": "gauge",
          "description": "Available amount of [Shared Memory](https://www.kernel.org/doc/gorman/html/understand/understand015.html) used by the container, in bytes.",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_swap": {
          "type": "gauge",
          "description": "Total amount of swap memory available to this container",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_unevictable": {
          "type": "gauge",
          "description": "Total amount of memory that can not be reclaimed",
          "group": "memory",
          "default": false
        },
        "memory.stats.total_writeback": {
          "type": "gauge",
          "description": "Total amount of memory from file/anon cache that are queued for syncing to the disk",
          "group": "memory",
          "default": false
        },
        "memory.stats.unevictable": {
          "type": "gauge",
          "description": "The amount of memory that cannot be reclaimed.",
          "group": "memory",
          "default": false
        },
        "memory.stats.writeback": {
          "type": "gauge",
          "description": "The amount of memory from file/anon cache that are queued for syncing to the disk",
          "group": "memory",
          "default": false
        },
        "memory.usage.limit": {
          "type": "gauge",
          "description": "Memory usage limit of the container, in bytes",
          "group": "memory",
          "default": true
        },
        "memory.usage.max": {
          "type": "gauge",
          "description": "Maximum measured memory usage of the container, in bytes",
          "group": "memory",
          "default": false
        },
        "memory.usage.total": {
          "type": "gauge",
          "description": "Bytes of memory used by the container. Note that this **includes the\nbuffer cache** attributed to the process by the kernel from files that\nhave been read by processes in the container.  If you don't want to\ncount that when monitoring containers, enable the metric\n`memory.stats.total_cache` and subtract that metric from this one.\n",
          "group": "memory",
          "default": true
        },
        "network.usage.rx_bytes": {
          "type": "cumulative",
          "description": "Bytes received by the container via its network interface",
          "group": "network",
          "default": true
        },
        "network.usage.rx_dropped": {
          "type": "cumulative",
          "description": "Number of inbound network packets dropped by the container",
          "group": "network",
          "default": false
        },
        "network.usage.rx_errors": {
          "type": "cumulative",
          "description": "Errors receiving network packets",
          "group": "network",
          "default": false
        },
        "network.usage.rx_packets": {
          "type": "cumulative",
          "description": "Network packets received by the container via its network interface",
          "group": "network",
          "default": false
        },
        "network.usage.tx_bytes": {
          "type": "cumulative",
          "description": "Bytes sent by the container via its network interface",
          "group": "network",
          "default": true
        },
        "network.usage.tx_dropped": {
          "type": "cumulative",
          "description": "Number of outbound network packets dropped by the container",
          "group": "network",
          "default": false
        },
        "network.usage.tx_errors": {
          "type": "cumulative",
          "description": "Errors sending network packets",
          "group": "network",
          "default": false
        },
        "network.usage.tx_packets": {
          "type": "cumulative",
          "description": "Network packets sent by the container via its network interface",
          "group": "network",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/docker",
        "fields": [
          {
            "yamlName": "enableExtraBlockIOMetrics",
            "doc": "Whether it will send all extra block IO metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraCPUMetrics",
            "doc": "Whether it will send all extra CPU metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraMemoryMetrics",
            "doc": "Whether it will send all extra memory metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraNetworkMetrics",
            "doc": "Whether it will send all extra network metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "dockerURL",
            "doc": "The URL of the docker server",
            "default": "unix:///var/run/docker.sock",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "timeoutSeconds",
            "doc": "The maximum amount of time to wait for docker API requests",
            "default": 5,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "labelsToDimensions",
            "doc": "A mapping of container label names to dimension names. The corresponding label values will become the dimension value for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "envToDimensions",
            "doc": "A mapping of container environment variable names to dimension names.  The corresponding env var values become the dimension values on the emitted metrics.  E.g. `APP_VERSION: version` would result in datapoints having a dimension called `version` whose value is the value of the `APP_VERSION` envvar configured for that particular container, if present.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedImages",
            "doc": "A list of filters of images to exclude.  Supports literals, globs, and regex.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "dotnet",
      "sendAll": true,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics for .NET applications.\n\nThe most critical .NET performance counters\n* exceptions\n* logical threads\n* physical threads\n* heap bytes\n* time in GC\n* committed bytes\n* pinned objects\n\n## Windows Performance Counters\nThe underlying source for these metrics are Windows Performance Counters.\nMost of the performance counters that we query in this monitor are actually Gauges\nthat represent rates per second and percentages.\n\nThis monitor reports the instantaneous values for these Windows Performance Counters.\nThis means that in between a collection interval, spikes could occur on the\nPerformance Counters.  The best way to mitigate this limitation is to increase\nthe reporting interval on this monitor to collect more frequently.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: dotnet\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "net_clr_exceptions.num_exceps_thrown_sec",
            "net_clr_locksandthreads.contention_rate_sec",
            "net_clr_locksandthreads.current_queue_length",
            "net_clr_locksandthreads.num_of_current_logical_threads",
            "net_clr_locksandthreads.num_of_current_physical_threads",
            "net_clr_memory.num_bytes_in_all_heaps",
            "net_clr_memory.num_gc_handles",
            "net_clr_memory.num_of_pinned_objects",
            "net_clr_memory.num_total_committed_bytes",
            "net_clr_memory.num_total_reserved_bytes",
            "net_clr_memory.pct_time_in_gc"
          ]
        }
      },
      "metrics": {
        "net_clr_exceptions.num_exceps_thrown_sec": {
          "type": "gauge",
          "description": "The number of exceptions thrown by .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_locksandthreads.contention_rate_sec": {
          "type": "gauge",
          "description": "The rate of thread of thread contention per second for .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_locksandthreads.current_queue_length": {
          "type": "gauge",
          "description": "The current thread queue length for .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_locksandthreads.num_of_current_logical_threads": {
          "type": "gauge",
          "description": "The number of current logical threads for .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_locksandthreads.num_of_current_physical_threads": {
          "type": "gauge",
          "description": "The number of current physical threads for .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_memory.num_bytes_in_all_heaps": {
          "type": "gauge",
          "description": "The number of bytes in all heaps for .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_memory.num_gc_handles": {
          "type": "gauge",
          "description": "The number of garbage collection handles held by .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_memory.num_of_pinned_objects": {
          "type": "gauge",
          "description": "The number of objects pinned in memory by .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_memory.num_total_committed_bytes": {
          "type": "gauge",
          "description": "The total number of bytes committed to memory by .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_memory.num_total_reserved_bytes": {
          "type": "gauge",
          "description": "The total number of bytes reserved by .NET applications.",
          "group": null,
          "default": false
        },
        "net_clr_memory.pct_time_in_gc": {
          "type": "gauge",
          "description": "The percentage of time spent garbage collecting by .NET applications.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/dotnet",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) Number of seconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "ecs-metadata",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reads container stats from a\n[ECS Task Metadata Endpoint version 2](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v2.html).\n\nThis currently does not support CPU share/quota metrics.\n",
      "groups": {
        "blkio": {
          "description": "BlockIO metrics",
          "metrics": [
            "blkio.io_service_bytes_recursive.async",
            "blkio.io_service_bytes_recursive.read",
            "blkio.io_service_bytes_recursive.sync",
            "blkio.io_service_bytes_recursive.total",
            "blkio.io_service_bytes_recursive.write",
            "blkio.io_serviced_recursive.async",
            "blkio.io_serviced_recursive.read",
            "blkio.io_serviced_recursive.sync",
            "blkio.io_serviced_recursive.total",
            "blkio.io_serviced_recursive.write"
          ]
        },
        "cpu": {
          "description": "CPU metrics",
          "metrics": [
            "cpu.limit",
            "cpu.percent",
            "cpu.percpu.usage",
            "cpu.throttling_data.periods",
            "cpu.throttling_data.throttled_periods",
            "cpu.throttling_data.throttled_time",
            "cpu.usage.kernelmode",
            "cpu.usage.system",
            "cpu.usage.total",
            "cpu.usage.usermode"
          ]
        },
        "memory": {
          "description": "Memory metrics",
          "metrics": [
            "memory.percent",
            "memory.stats.swap",
            "memory.usage.limit",
            "memory.usage.max",
            "memory.usage.total"
          ]
        },
        "network": {
          "description": "Network metrics",
          "metrics": [
            "network.usage.rx_bytes",
            "network.usage.rx_dropped",
            "network.usage.rx_errors",
            "network.usage.rx_packets",
            "network.usage.tx_bytes",
            "network.usage.tx_dropped",
            "network.usage.tx_errors",
            "network.usage.tx_packets"
          ]
        }
      },
      "metrics": {
        "blkio.io_service_bytes_recursive.async": {
          "type": "cumulative",
          "description": "Volume, in bytes, of asynchronous block I/O",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_bytes_recursive.read": {
          "type": "cumulative",
          "description": "Volume, in bytes, of reads from block devices",
          "group": "blkio",
          "default": true
        },
        "blkio.io_service_bytes_recursive.sync": {
          "type": "cumulative",
          "description": "Volume, in bytes, of synchronous block I/O",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_bytes_recursive.total": {
          "type": "cumulative",
          "description": "Total volume, in bytes, of all block I/O",
          "group": "blkio",
          "default": false
        },
        "blkio.io_service_bytes_recursive.write": {
          "type": "cumulative",
          "description": "Volume, in bytes, of writes to block devices",
          "group": "blkio",
          "default": true
        },
        "blkio.io_serviced_recursive.async": {
          "type": "cumulative",
          "description": "Number of asynchronous block I/O requests",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.read": {
          "type": "cumulative",
          "description": "Number of reads requests from block devices",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.sync": {
          "type": "cumulative",
          "description": "Number of synchronous block I/O requests",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.total": {
          "type": "cumulative",
          "description": "Total number of block I/O requests",
          "group": "blkio",
          "default": false
        },
        "blkio.io_serviced_recursive.write": {
          "type": "cumulative",
          "description": "Number of write requests to block devices",
          "group": "blkio",
          "default": false
        },
        "cpu.limit": {
          "type": "gauge",
          "description": "CPU usage limit of the container, in ECS vCPU units",
          "group": "cpu",
          "default": false
        },
        "cpu.percent": {
          "type": "gauge",
          "description": "Percentage of host CPU resources used by the container",
          "group": "cpu",
          "default": false
        },
        "cpu.percpu.usage": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent by the container, per CPU core",
          "group": "cpu",
          "default": false
        },
        "cpu.throttling_data.periods": {
          "type": "cumulative",
          "description": "Number of periods",
          "group": "cpu",
          "default": false
        },
        "cpu.throttling_data.throttled_periods": {
          "type": "cumulative",
          "description": "Number of periods throttled",
          "group": "cpu",
          "default": false
        },
        "cpu.throttling_data.throttled_time": {
          "type": "cumulative",
          "description": "Throttling time in nano seconds",
          "group": "cpu",
          "default": false
        },
        "cpu.usage.kernelmode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in kernel mode by the container",
          "group": "cpu",
          "default": false
        },
        "cpu.usage.system": {
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the system",
          "group": "cpu",
          "default": true
        },
        "cpu.usage.total": {
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the container",
          "group": "cpu",
          "default": true
        },
        "cpu.usage.usermode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in user mode by the container",
          "group": "cpu",
          "default": false
        },
        "memory.percent": {
          "type": "gauge",
          "description": "Percent of memory (0-100) used by the container relative to its limit (excludes page cache usage)",
          "group": "memory",
          "default": false
        },
        "memory.stats.swap": {
          "type": "gauge",
          "description": "Bytes of swap memory used by container",
          "group": "memory",
          "default": false
        },
        "memory.usage.limit": {
          "type": "gauge",
          "description": "Memory usage limit of the container, in bytes",
          "group": "memory",
          "default": true
        },
        "memory.usage.max": {
          "type": "gauge",
          "description": "Maximum measured memory usage of the container, in bytes",
          "group": "memory",
          "default": false
        },
        "memory.usage.total": {
          "type": "gauge",
          "description": "Bytes of memory used by the container",
          "group": "memory",
          "default": true
        },
        "network.usage.rx_bytes": {
          "type": "cumulative",
          "description": "Bytes received by the container via its network interface",
          "group": "network",
          "default": true
        },
        "network.usage.rx_dropped": {
          "type": "cumulative",
          "description": "Number of inbound network packets dropped by the container",
          "group": "network",
          "default": false
        },
        "network.usage.rx_errors": {
          "type": "cumulative",
          "description": "Errors receiving network packets",
          "group": "network",
          "default": false
        },
        "network.usage.rx_packets": {
          "type": "cumulative",
          "description": "Network packets received by the container via its network interface",
          "group": "network",
          "default": false
        },
        "network.usage.tx_bytes": {
          "type": "cumulative",
          "description": "Bytes sent by the container via its network interface",
          "group": "network",
          "default": true
        },
        "network.usage.tx_dropped": {
          "type": "cumulative",
          "description": "Number of outbound network packets dropped by the container",
          "group": "network",
          "default": false
        },
        "network.usage.tx_errors": {
          "type": "cumulative",
          "description": "Errors sending network packets",
          "group": "network",
          "default": false
        },
        "network.usage.tx_packets": {
          "type": "cumulative",
          "description": "Network packets sent by the container via its network interface",
          "group": "network",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/ecs",
        "fields": [
          {
            "yamlName": "enableExtraBlockIOMetrics",
            "doc": "Whether it will send all extra block IO metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraCPUMetrics",
            "doc": "Whether it will send all extra CPU metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraMemoryMetrics",
            "doc": "Whether it will send all extra memory metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraNetworkMetrics",
            "doc": "Whether it will send all extra network metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metadataEndpoint",
            "doc": "The URL of the ECS task metadata. Default is http://169.254.170.2/v2/metadata, which is hardcoded by AWS for version 2.",
            "default": "http://169.254.170.2/v2/metadata",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "statsEndpoint",
            "doc": "The URL of the ECS container stats. Default is http://169.254.170.2/v2/stats, which is hardcoded by AWS for version 2.",
            "default": "http://169.254.170.2/v2/stats",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "timeoutSeconds",
            "doc": "The maximum amount of time to wait for API requests",
            "default": 5,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "labelsToDimensions",
            "doc": "A mapping of container label names to dimension names. The corresponding label values will become the dimension value for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedImages",
            "doc": "A list of filters of images to exclude.  Supports literals, globs, and regex.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "elasticsearch",
      "sendAll": false,
      "dimensions": {
        "aggregation": {
          "description": "Aggregation of index metrics. Whether the value of the metric is from the primary shard only or across all shards. Valid values - primaries, total respectively (only on index stats)"
        },
        "cluster": {
          "description": "Name of Elasticsearch the cluster."
        },
        "index": {
          "description": "Name of index (only on per index mertics)"
        },
        "node_id": {
          "description": "ID of a Elasticsearch node (only on node mertics)"
        },
        "node_name": {
          "description": "Human readable name of a node (only on node mertics)"
        },
        "plugin_instance": {
          "description": "Name of the Elasticsearch cluster. For compatibility with collectd/elasticsearch built-in content"
        },
        "thread_pool": {
          "description": "Name of thread pool (only on thread pool mertics)"
        }
      },
      "doc": "This monitor collects stats from Elasticsearch. It collects node, cluster\nand index level stats. This monitor is compatible with the current collectd\nplugin found [here] (https://github.com/signalfx/collectd-elasticsearch) in\nterms of metric naming.\n\nThis monitor collects cluster level and index level stats only from the current master\nin an Elasticsearch cluster by default. It is possible to override this with the\n`clusterHealthStatsMasterOnly` and `indexStatsMasterOnly` config options respectively.\n\nA simple configuration that collects only default (non-custom) metrics\nlooks like the following:\n\n```yaml\nmonitors:\n- type: elasticsearch\n  host: localhost\n  port: 9200\n```\n\n## Enhanced (custom) metrics\n\nThe monitor collects a subset of node stats of JVM, process, HTTP,\ntransport, indices and thread pool stats. It is possible to enable\nenhanced stats for each stat group separately.  Note that these metrics\nget categorized under the _custom_ group if you are on host-based\npricing. Here's an example:\n\n```yaml\nmonitors:\n- type: elasticsearch\n  host: localhost\n  port: 9200\n  enableEnhancedHTTPStats: true\n  enableEnhancedJVMStats: true\n  enableEnhancedProcessStats: true\n  enableEnhancedThreadPoolStats: true\n  enableEnhancedTransportStats: true\n  enableEnhancedNodeIndicesStats:\n   - indexing\n   - warmer\n   - get\n\n```\n\nThe `enableEnhancedNodeIndicesStats` option takes a list of index stats groups\nfor which enhanced stats will be collected. A comprehensive list of all\nsuch available groups can be found [here](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html#node-indices-stats).\n\nNote that the `enableEnhancedIndexStatsForIndexGroups` is similar to\n`enableEnhancedNodeIndicesStats`, but for index level stats.\n\n## Thread Pools\n\nBy default thread pool stats from the \"search\" and \"index\" thread pools are collected. To collect\nstats from other thread pools specify the `threadPools` config option:\n\n```yaml\nmonitors:\n- type: elasticsearch\n  host: localhost\n  port: 9200\n  threadPools:\n  - bulk\n  - warmer\n  - listener\n```\n\nHere is a list of valid thread pools by Elasticsearch version:\n\n| thread pool name | ES 1.x | ES 2.0 | ES 2.1+ |\n|------------------|--------|--------|--------|\n| merge            | \u0026#x2713;      |        |        |\n| optimize         |\u0026#x2713;     |        |        |\n| bulk             |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| flush            |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| generic          |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| get              |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| snapshot         |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| warmer           |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| refresh          |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| fetch\\_shard\\_started|      |\u0026#x2713;     |\u0026#x2713;     |\n| fetch\\_shard\\_store|        |\u0026#x2713;     |\u0026#x2713;     |\n| listener         |        |\u0026#x2713;     |\u0026#x2713;     |\n| management       |        |\u0026#x2713;     |\u0026#x2713;     |\n| percolate        |        |\u0026#x2713;     |\u0026#x2713;     |\n| suggest          |        |\u0026#x2713;     |\u0026#x2713;     |\n| force\\_merge      |        |        |\u0026#x2713;     |\n\n\n## Collecting index statistics\n\nBy default, the configuration parameter `indexes` is empty, which means\ncollect stats on all indexes. To collect statistics from a subset of\nindexes, set the configuration parameter `indexes` to a list of the index\nnames you want to collect stats for.\n\nThe call to collect index statistics can be CPU-intensive. For this reason\nSignalFx recommends using the `indexStatsIntervalSeconds` configuration\nparameter to decrease the reporting interval for nodes that report index\nstatistics.\n\n### Primaries vs total\nBy default the monitor collects a subset of index stats of total aggregation\ntype (see docs for details). It is possible to enable index stats of primaries\naggregation type too. Total for an index stat aggregates across all shards.\nWhereas, Primaries only reflect the stats from primary shards. An example\nconfiguration to enable index stats from Primary shards too:\n\n```yaml\nmonitors:\n- type: elasticsearch\n  host: localhost\n  port: 9200\n  enableIndexStatsPrimaries: true\n```\n",
      "groups": {
        "cluster": {
          "description": "",
          "metrics": [
            "elasticsearch.cluster.active-primary-shards",
            "elasticsearch.cluster.active-shards",
            "elasticsearch.cluster.active-shards-percent",
            "elasticsearch.cluster.delayed-unassigned-shards",
            "elasticsearch.cluster.in-flight-fetches",
            "elasticsearch.cluster.initializing-shards",
            "elasticsearch.cluster.number-of-data_nodes",
            "elasticsearch.cluster.number-of-nodes",
            "elasticsearch.cluster.pending-tasks",
            "elasticsearch.cluster.relocating-shards",
            "elasticsearch.cluster.status",
            "elasticsearch.cluster.task-max-wait-time",
            "elasticsearch.cluster.unassigned-shards"
          ]
        },
        "indices/completion": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.completion.size"
          ]
        },
        "indices/docs": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.docs.count",
            "elasticsearch.indices.docs.deleted"
          ]
        },
        "indices/fielddata": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.fielddata.evictions",
            "elasticsearch.indices.fielddata.memory-size"
          ]
        },
        "indices/filter-cache": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.filter-cache.evictions",
            "elasticsearch.indices.filter-cache.memory-size"
          ]
        },
        "indices/flush": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.flush.periodic",
            "elasticsearch.indices.flush.total",
            "elasticsearch.indices.flush.total-time"
          ]
        },
        "indices/get": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.get.current",
            "elasticsearch.indices.get.exists-time",
            "elasticsearch.indices.get.exists-total",
            "elasticsearch.indices.get.missing-time",
            "elasticsearch.indices.get.missing-total",
            "elasticsearch.indices.get.time",
            "elasticsearch.indices.get.total"
          ]
        },
        "indices/id-cache": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.id-cache.memory-size"
          ]
        },
        "indices/indexing": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.indexing.delete-current",
            "elasticsearch.indices.indexing.delete-time",
            "elasticsearch.indices.indexing.delete-total",
            "elasticsearch.indices.indexing.index-current",
            "elasticsearch.indices.indexing.index-failed",
            "elasticsearch.indices.indexing.index-time",
            "elasticsearch.indices.indexing.index-total",
            "elasticsearch.indices.indexing.noop-update-total",
            "elasticsearch.indices.indexing.throttle-time"
          ]
        },
        "indices/merges": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.merges.auto-throttle-size",
            "elasticsearch.indices.merges.current",
            "elasticsearch.indices.merges.current-docs",
            "elasticsearch.indices.merges.current-size",
            "elasticsearch.indices.merges.stopped-time",
            "elasticsearch.indices.merges.throttle-time",
            "elasticsearch.indices.merges.total",
            "elasticsearch.indices.merges.total-docs",
            "elasticsearch.indices.merges.total-size",
            "elasticsearch.indices.merges.total-time"
          ]
        },
        "indices/percolate": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.percolate.current",
            "elasticsearch.indices.percolate.queries",
            "elasticsearch.indices.percolate.time",
            "elasticsearch.indices.percolate.total"
          ]
        },
        "indices/query-cache": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.query-cache.cache-count",
            "elasticsearch.indices.query-cache.cache-size",
            "elasticsearch.indices.query-cache.evictions",
            "elasticsearch.indices.query-cache.hit-count",
            "elasticsearch.indices.query-cache.memory-size",
            "elasticsearch.indices.query-cache.total-count"
          ]
        },
        "indices/recovery": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.recovery.current-as-source",
            "elasticsearch.indices.recovery.current-as-target",
            "elasticsearch.indices.recovery.throttle-time"
          ]
        },
        "indices/refresh": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.refresh.listeners",
            "elasticsearch.indices.refresh.total",
            "elasticsearch.indices.refresh.total-time"
          ]
        },
        "indices/request-cache": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.query-cache.miss-count",
            "elasticsearch.indices.request-cache.evictions",
            "elasticsearch.indices.request-cache.hit-count",
            "elasticsearch.indices.request-cache.memory-size",
            "elasticsearch.indices.request-cache.miss-count"
          ]
        },
        "indices/search": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.search.fetch-current",
            "elasticsearch.indices.search.fetch-time",
            "elasticsearch.indices.search.fetch-total",
            "elasticsearch.indices.search.open-contexts",
            "elasticsearch.indices.search.query-current",
            "elasticsearch.indices.search.query-time",
            "elasticsearch.indices.search.query-total",
            "elasticsearch.indices.search.scroll-current",
            "elasticsearch.indices.search.scroll-time",
            "elasticsearch.indices.search.scroll-total",
            "elasticsearch.indices.search.suggest-current",
            "elasticsearch.indices.search.suggest-time",
            "elasticsearch.indices.search.suggest-total"
          ]
        },
        "indices/segments": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.segments.count",
            "elasticsearch.indices.segments.doc-values-memory-size",
            "elasticsearch.indices.segments.fixed-bit-set-memory-size",
            "elasticsearch.indices.segments.index-writer-max-memory-size",
            "elasticsearch.indices.segments.index-writer-memory-size",
            "elasticsearch.indices.segments.memory-size",
            "elasticsearch.indices.segments.norms-memory-size",
            "elasticsearch.indices.segments.points-memory-size",
            "elasticsearch.indices.segments.stored-field-memory-size",
            "elasticsearch.indices.segments.term-vectors-memory-size",
            "elasticsearch.indices.segments.terms-memory-size",
            "elasticsearch.indices.segments.version-map-memory-size"
          ]
        },
        "indices/store": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.store.size",
            "elasticsearch.indices.store.throttle-time"
          ]
        },
        "indices/suggest": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.suggest.current",
            "elasticsearch.indices.suggest.time",
            "elasticsearch.indices.suggest.total"
          ]
        },
        "indices/translog": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.translog.earliest_last_modified_age",
            "elasticsearch.indices.translog.operations",
            "elasticsearch.indices.translog.size",
            "elasticsearch.indices.translog.uncommitted_operations",
            "elasticsearch.indices.translog.uncommitted_size_in_bytes"
          ]
        },
        "indices/warmer": {
          "description": "",
          "metrics": [
            "elasticsearch.indices.warmer.current",
            "elasticsearch.indices.warmer.total",
            "elasticsearch.indices.warmer.total-time"
          ]
        },
        "node/http": {
          "description": "",
          "metrics": [
            "elasticsearch.http.current_open",
            "elasticsearch.http.total_open"
          ]
        },
        "node/jvm": {
          "description": "",
          "metrics": [
            "elasticsearch.jvm.classes.current-loaded-count",
            "elasticsearch.jvm.classes.total-loaded-count",
            "elasticsearch.jvm.classes.total-unloaded-count",
            "elasticsearch.jvm.gc.count",
            "elasticsearch.jvm.gc.old-count",
            "elasticsearch.jvm.gc.old-time",
            "elasticsearch.jvm.gc.time",
            "elasticsearch.jvm.mem.buffer_pools.direct.count",
            "elasticsearch.jvm.mem.buffer_pools.direct.total_capacity_in_bytes",
            "elasticsearch.jvm.mem.buffer_pools.direct.used_in_bytes",
            "elasticsearch.jvm.mem.buffer_pools.mapped.count",
            "elasticsearch.jvm.mem.buffer_pools.mapped.total_capacity_in_bytes",
            "elasticsearch.jvm.mem.buffer_pools.mapped.used_in_bytes",
            "elasticsearch.jvm.mem.heap-committed",
            "elasticsearch.jvm.mem.heap-max",
            "elasticsearch.jvm.mem.heap-used",
            "elasticsearch.jvm.mem.heap-used-percent",
            "elasticsearch.jvm.mem.non-heap-committed",
            "elasticsearch.jvm.mem.non-heap-used",
            "elasticsearch.jvm.mem.pools.old.max_in_bytes",
            "elasticsearch.jvm.mem.pools.old.peak_max_in_bytes",
            "elasticsearch.jvm.mem.pools.old.peak_used_in_bytes",
            "elasticsearch.jvm.mem.pools.old.used_in_bytes",
            "elasticsearch.jvm.mem.pools.survivor.max_in_bytes",
            "elasticsearch.jvm.mem.pools.survivor.peak_max_in_bytes",
            "elasticsearch.jvm.mem.pools.survivor.peak_used_in_bytes",
            "elasticsearch.jvm.mem.pools.survivor.used_in_bytes",
            "elasticsearch.jvm.mem.pools.young.max_in_bytes",
            "elasticsearch.jvm.mem.pools.young.peak_max_in_bytes",
            "elasticsearch.jvm.mem.pools.young.peak_used_in_bytes",
            "elasticsearch.jvm.mem.pools.young.used_in_bytes",
            "elasticsearch.jvm.threads.count",
            "elasticsearch.jvm.threads.peak",
            "elasticsearch.jvm.uptime"
          ]
        },
        "node/process": {
          "description": "",
          "metrics": [
            "elasticsearch.process.cpu.percent",
            "elasticsearch.process.cpu.time",
            "elasticsearch.process.max_file_descriptors",
            "elasticsearch.process.mem.total-virtual-size",
            "elasticsearch.process.open_file_descriptors"
          ]
        },
        "node/thread-pool": {
          "description": "",
          "metrics": [
            "elasticsearch.thread_pool.active",
            "elasticsearch.thread_pool.completed",
            "elasticsearch.thread_pool.largest",
            "elasticsearch.thread_pool.queue",
            "elasticsearch.thread_pool.rejected",
            "elasticsearch.thread_pool.threads"
          ]
        },
        "node/transport": {
          "description": "",
          "metrics": [
            "elasticsearch.transport.rx.count",
            "elasticsearch.transport.rx.size",
            "elasticsearch.transport.server_open",
            "elasticsearch.transport.tx.count",
            "elasticsearch.transport.tx.size"
          ]
        }
      },
      "metrics": {
        "elasticsearch.cluster.active-primary-shards": {
          "type": "gauge",
          "description": "Number of active primary shards",
          "group": "cluster",
          "default": true
        },
        "elasticsearch.cluster.active-shards": {
          "type": "gauge",
          "description": "Number of active shards",
          "group": "cluster",
          "default": true
        },
        "elasticsearch.cluster.active-shards-percent": {
          "type": "gauge",
          "description": "Percentaage of shards active",
          "group": "cluster",
          "default": false
        },
        "elasticsearch.cluster.delayed-unassigned-shards": {
          "type": "gauge",
          "description": "Number of delayed unassigned shards",
          "group": "cluster",
          "default": false
        },
        "elasticsearch.cluster.in-flight-fetches": {
          "type": "gauge",
          "description": "Number of fetches in-flight",
          "group": "cluster",
          "default": false
        },
        "elasticsearch.cluster.initializing-shards": {
          "type": "gauge",
          "description": "Number of shards being initialized",
          "group": "cluster",
          "default": false
        },
        "elasticsearch.cluster.number-of-data_nodes": {
          "type": "gauge",
          "description": "Number of data nodes",
          "group": "cluster",
          "default": true
        },
        "elasticsearch.cluster.number-of-nodes": {
          "type": "gauge",
          "description": "Number of nodes",
          "group": "cluster",
          "default": true
        },
        "elasticsearch.cluster.pending-tasks": {
          "type": "gauge",
          "description": "Number of pending tasks",
          "group": "cluster",
          "default": false
        },
        "elasticsearch.cluster.relocating-shards": {
          "type": "gauge",
          "description": "Number of shards being relocated",
          "group": "cluster",
          "default": true
        },
        "elasticsearch.cluster.status": {
          "type": "gauge",
          "description": "Cluster stats (0, 1, 2 for green, yellow and red respectively)",
          "group": "cluster",
          "default": false
        },
        "elasticsearch.cluster.task-max-wait-time": {
          "type": "gauge",
          "description": "Max time a task has to wait",
          "group": "cluster",
          "default": false
        },
        "elasticsearch.cluster.unassigned-shards": {
          "type": "gauge",
          "description": "Number of unassigned shards",
          "group": "cluster",
          "default": true
        },
        "elasticsearch.http.current_open": {
          "type": "gauge",
          "description": "Number of currently open HTTP connections",
          "group": "node/http",
          "default": false
        },
        "elasticsearch.http.total_open": {
          "type": "cumulative",
          "description": "Total number of opened HTTP connections",
          "group": "node/http",
          "default": false
        },
        "elasticsearch.indices.completion.size": {
          "type": "gauge",
          "description": "Size used by suggest completion (in bytes)",
          "group": "indices/completion",
          "default": false
        },
        "elasticsearch.indices.docs.count": {
          "type": "gauge",
          "description": "Number of docs",
          "group": "indices/docs",
          "default": true
        },
        "elasticsearch.indices.docs.deleted": {
          "type": "gauge",
          "description": "Number of docs deleted",
          "group": "indices/docs",
          "default": true
        },
        "elasticsearch.indices.fielddata.evictions": {
          "type": "cumulative",
          "description": "Number of evictions from fielddata cache",
          "group": "indices/fielddata",
          "default": false
        },
        "elasticsearch.indices.fielddata.memory-size": {
          "type": "gauge",
          "description": "Size of fielddata cache (in bytes)",
          "group": "indices/fielddata",
          "default": false
        },
        "elasticsearch.indices.filter-cache.evictions": {
          "type": "cumulative",
          "description": "Number of evicttions from filter cache",
          "group": "indices/filter-cache",
          "default": false
        },
        "elasticsearch.indices.filter-cache.memory-size": {
          "type": "gauge",
          "description": "Filter cache size (in bytes)",
          "group": "indices/filter-cache",
          "default": false
        },
        "elasticsearch.indices.flush.periodic": {
          "type": "gauge",
          "description": "How long to wait before triggering a flush regardless of translog size",
          "group": "indices/flush",
          "default": false
        },
        "elasticsearch.indices.flush.total": {
          "type": "cumulative",
          "description": "Number of index flushes to disk",
          "group": "indices/flush",
          "default": false
        },
        "elasticsearch.indices.flush.total-time": {
          "type": "cumulative",
          "description": "Time spent flushing the index to disk",
          "group": "indices/flush",
          "default": false
        },
        "elasticsearch.indices.get.current": {
          "type": "gauge",
          "description": "Number of get requests running",
          "group": "indices/get",
          "default": false
        },
        "elasticsearch.indices.get.exists-time": {
          "type": "cumulative",
          "description": "Time spent on get requests where the document existed",
          "group": "indices/get",
          "default": false
        },
        "elasticsearch.indices.get.exists-total": {
          "type": "cumulative",
          "description": "Number of get requests where the document existed",
          "group": "indices/get",
          "default": false
        },
        "elasticsearch.indices.get.missing-time": {
          "type": "cumulative",
          "description": "Time spent on get requests where the document was missing",
          "group": "indices/get",
          "default": false
        },
        "elasticsearch.indices.get.missing-total": {
          "type": "cumulative",
          "description": "Number of get requests where the document was missing",
          "group": "indices/get",
          "default": false
        },
        "elasticsearch.indices.get.time": {
          "type": "cumulative",
          "description": "Time spent on get requests",
          "group": "indices/get",
          "default": false
        },
        "elasticsearch.indices.get.total": {
          "type": "cumulative",
          "description": "Total number of get requests",
          "group": "indices/get",
          "default": true
        },
        "elasticsearch.indices.id-cache.memory-size": {
          "type": "gauge",
          "description": "Size of id cache (in bytes)",
          "group": "indices/id-cache",
          "default": false
        },
        "elasticsearch.indices.indexing.delete-current": {
          "type": "gauge",
          "description": "Number of documents currently being deleted from an index",
          "group": "indices/indexing",
          "default": false
        },
        "elasticsearch.indices.indexing.delete-time": {
          "type": "cumulative",
          "description": "Time spent deleting documents from an index",
          "group": "indices/indexing",
          "default": false
        },
        "elasticsearch.indices.indexing.delete-total": {
          "type": "cumulative",
          "description": "Number of documents deleted from an index",
          "group": "indices/indexing",
          "default": false
        },
        "elasticsearch.indices.indexing.index-current": {
          "type": "gauge",
          "description": "Number of documents currently being indexed to an index",
          "group": "indices/indexing",
          "default": false
        },
        "elasticsearch.indices.indexing.index-failed": {
          "type": "gauge",
          "description": "Number of failed indices",
          "group": "indices/indexing",
          "default": false
        },
        "elasticsearch.indices.indexing.index-time": {
          "type": "cumulative",
          "description": "Time spent indexing documents to an index",
          "group": "indices/indexing",
          "default": false
        },
        "elasticsearch.indices.indexing.index-total": {
          "type": "cumulative",
          "description": "Total number of documents indexed to an index",
          "group": "indices/indexing",
          "default": true
        },
        "elasticsearch.indices.indexing.noop-update-total": {
          "type": "cumulative",
          "description": "Number of noop updates",
          "group": "indices/indexing",
          "default": false
        },
        "elasticsearch.indices.indexing.throttle-time": {
          "type": "cumulative",
          "description": "Throttle time",
          "group": "indices/indexing",
          "default": false
        },
        "elasticsearch.indices.merges.auto-throttle-size": {
          "type": "cumulative",
          "description": "Merging throttled due to auto-throttling (in bytes)",
          "group": "indices/merges",
          "default": false
        },
        "elasticsearch.indices.merges.current": {
          "type": "gauge",
          "description": "Number of currently active segment merges",
          "group": "indices/merges",
          "default": true
        },
        "elasticsearch.indices.merges.current-docs": {
          "type": "gauge",
          "description": "Number of docs currently being merged",
          "group": "indices/merges",
          "default": false
        },
        "elasticsearch.indices.merges.current-size": {
          "type": "gauge",
          "description": "Size of the segments currently being merged",
          "group": "indices/merges",
          "default": false
        },
        "elasticsearch.indices.merges.stopped-time": {
          "type": "cumulative",
          "description": "Total time merges were stopped for",
          "group": "indices/merges",
          "default": false
        },
        "elasticsearch.indices.merges.throttle-time": {
          "type": "cumulative",
          "description": "Total time merges spent waiting due to throttling",
          "group": "indices/merges",
          "default": false
        },
        "elasticsearch.indices.merges.total": {
          "type": "cumulative",
          "description": "Number of segment merges",
          "group": "indices/merges",
          "default": true
        },
        "elasticsearch.indices.merges.total-docs": {
          "type": "cumulative",
          "description": "Number of merged docs across merged segments",
          "group": "indices/merges",
          "default": false
        },
        "elasticsearch.indices.merges.total-size": {
          "type": "cumulative",
          "description": "Total size of merged segments",
          "group": "indices/merges",
          "default": false
        },
        "elasticsearch.indices.merges.total-time": {
          "type": "cumulative",
          "description": "Total time spent on merging",
          "group": "indices/merges",
          "default": false
        },
        "elasticsearch.indices.percolate.current": {
          "type": "gauge",
          "description": "Number of percolator queries currently running",
          "group": "indices/percolate",
          "default": false
        },
        "elasticsearch.indices.percolate.queries": {
          "type": "cumulative",
          "description": "Number of percolator queries",
          "group": "indices/percolate",
          "default": false
        },
        "elasticsearch.indices.percolate.time": {
          "type": "cumulative",
          "description": "Total time spent on percolate requests",
          "group": "indices/percolate",
          "default": false
        },
        "elasticsearch.indices.percolate.total": {
          "type": "cumulative",
          "description": "Total number of suggest requests",
          "group": "indices/percolate",
          "default": false
        },
        "elasticsearch.indices.query-cache.cache-count": {
          "type": "gauge",
          "description": "Number of items in query cache",
          "group": "indices/query-cache",
          "default": false
        },
        "elasticsearch.indices.query-cache.cache-size": {
          "type": "gauge",
          "description": "Size of query cache (in bytes)",
          "group": "indices/query-cache",
          "default": false
        },
        "elasticsearch.indices.query-cache.evictions": {
          "type": "cumulative",
          "description": "Number of query cache evictions",
          "group": "indices/query-cache",
          "default": false
        },
        "elasticsearch.indices.query-cache.hit-count": {
          "type": "cumulative",
          "description": "Number of query cache hits",
          "group": "indices/query-cache",
          "default": false
        },
        "elasticsearch.indices.query-cache.memory-size": {
          "type": "gauge",
          "description": "Size of query cache (in bytes)",
          "group": "indices/query-cache",
          "default": false
        },
        "elasticsearch.indices.query-cache.miss-count": {
          "type": "cumulative",
          "description": "Number of query cache misses",
          "group": "indices/request-cache",
          "default": false
        },
        "elasticsearch.indices.query-cache.total-count": {
          "type": "cumulative",
          "description": "Total number of items in the query cache",
          "group": "indices/query-cache",
          "default": false
        },
        "elasticsearch.indices.recovery.current-as-source": {
          "type": "gauge",
          "description": "Number of ongoing recoveries for which a shard serves as a source",
          "group": "indices/recovery",
          "default": false
        },
        "elasticsearch.indices.recovery.current-as-target": {
          "type": "gauge",
          "description": "Number of ongoing recoveries for which a shard serves as a target",
          "group": "indices/recovery",
          "default": false
        },
        "elasticsearch.indices.recovery.throttle-time": {
          "type": "cumulative",
          "description": "Total time recoveries waited due to throttling",
          "group": "indices/recovery",
          "default": false
        },
        "elasticsearch.indices.refresh.listeners": {
          "type": "gauge",
          "description": "Number of listeners waiting for a refresh",
          "group": "indices/refresh",
          "default": false
        },
        "elasticsearch.indices.refresh.total": {
          "type": "cumulative",
          "description": "Total number of index refreshes",
          "group": "indices/refresh",
          "default": false
        },
        "elasticsearch.indices.refresh.total-time": {
          "type": "cumulative",
          "description": "Total time spent on index refreshes",
          "group": "indices/refresh",
          "default": false
        },
        "elasticsearch.indices.request-cache.evictions": {
          "type": "cumulative",
          "description": "Number of request cache evictions",
          "group": "indices/request-cache",
          "default": false
        },
        "elasticsearch.indices.request-cache.hit-count": {
          "type": "cumulative",
          "description": "Number of request cache hits",
          "group": "indices/request-cache",
          "default": false
        },
        "elasticsearch.indices.request-cache.memory-size": {
          "type": "gauge",
          "description": "Memory used by request cache (in bytes)",
          "group": "indices/request-cache",
          "default": false
        },
        "elasticsearch.indices.request-cache.miss-count": {
          "type": "cumulative",
          "description": "Number of request cache misses",
          "group": "indices/request-cache",
          "default": false
        },
        "elasticsearch.indices.search.fetch-current": {
          "type": "gauge",
          "description": "Number of query fetches currently running",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.fetch-time": {
          "type": "cumulative",
          "description": "Total time spent on query fetches",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.fetch-total": {
          "type": "cumulative",
          "description": "Total number of query feches",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.open-contexts": {
          "type": "gauge",
          "description": "Number of open contexts",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.query-current": {
          "type": "gauge",
          "description": "Number of currently active queries",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.query-time": {
          "type": "cumulative",
          "description": "Total time spent querying on the primary",
          "group": "indices/search",
          "default": true
        },
        "elasticsearch.indices.search.query-total": {
          "type": "cumulative",
          "description": "Total number of queries",
          "group": "indices/search",
          "default": true
        },
        "elasticsearch.indices.search.scroll-current": {
          "type": "gauge",
          "description": "Currently active scroll queries count",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.scroll-time": {
          "type": "cumulative",
          "description": "Total time spent on scroll queries",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.scroll-total": {
          "type": "cumulative",
          "description": "Total number of scroll queries",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.suggest-current": {
          "type": "gauge",
          "description": "Number of suggest requests currently active",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.suggest-time": {
          "type": "cumulative",
          "description": "Total time spent on search suggest",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.search.suggest-total": {
          "type": "cumulative",
          "description": "Total number of suggest requests",
          "group": "indices/search",
          "default": false
        },
        "elasticsearch.indices.segments.count": {
          "type": "gauge",
          "description": "Number of segments in an index shard",
          "group": "indices/segments",
          "default": true
        },
        "elasticsearch.indices.segments.doc-values-memory-size": {
          "type": "gauge",
          "description": "Memory used by doc values",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.fixed-bit-set-memory-size": {
          "type": "gauge",
          "description": "Memory used by fixed bit set",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.index-writer-max-memory-size": {
          "type": "gauge",
          "description": "Maximum memory used by the index writer",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.index-writer-memory-size": {
          "type": "gauge",
          "description": "Memory used by the index writer",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.memory-size": {
          "type": "gauge",
          "description": "Memory used by index segments (in bytes)",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.norms-memory-size": {
          "type": "gauge",
          "description": "Memory used by norms (in bytes)",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.points-memory-size": {
          "type": "gauge",
          "description": "Memory used by points",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.stored-field-memory-size": {
          "type": "gauge",
          "description": "Memory used by stored fields (in bytes)",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.term-vectors-memory-size": {
          "type": "gauge",
          "description": "Memory used by term vectors (in bytes)",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.terms-memory-size": {
          "type": "gauge",
          "description": "Memory used by terms (in bytes)",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.segments.version-map-memory-size": {
          "type": "gauge",
          "description": "Memory used by segment version map (in bytes)",
          "group": "indices/segments",
          "default": false
        },
        "elasticsearch.indices.store.size": {
          "type": "gauge",
          "description": "Total size (in bytes)",
          "group": "indices/store",
          "default": false
        },
        "elasticsearch.indices.store.throttle-time": {
          "type": "cumulative",
          "description": "Total time requests are throttled for",
          "group": "indices/store",
          "default": false
        },
        "elasticsearch.indices.suggest.current": {
          "type": "gauge",
          "description": "Number of currently active suggest requests",
          "group": "indices/suggest",
          "default": false
        },
        "elasticsearch.indices.suggest.time": {
          "type": "cumulative",
          "description": "Total time spent in suggest requests",
          "group": "indices/suggest",
          "default": false
        },
        "elasticsearch.indices.suggest.total": {
          "type": "cumulative",
          "description": "Total number of suggest requests",
          "group": "indices/suggest",
          "default": false
        },
        "elasticsearch.indices.translog.earliest_last_modified_age": {
          "type": "gauge",
          "description": "Earliest last modified age on transaction logs",
          "group": "indices/translog",
          "default": false
        },
        "elasticsearch.indices.translog.operations": {
          "type": "gauge",
          "description": "Number of operations in the transaction log",
          "group": "indices/translog",
          "default": false
        },
        "elasticsearch.indices.translog.size": {
          "type": "gauge",
          "description": "Size of the transaction log",
          "group": "indices/translog",
          "default": false
        },
        "elasticsearch.indices.translog.uncommitted_operations": {
          "type": "gauge",
          "description": "Number of uncommitted operations in the transaction log",
          "group": "indices/translog",
          "default": false
        },
        "elasticsearch.indices.translog.uncommitted_size_in_bytes": {
          "type": "gauge",
          "description": "Size of uncommitted transaction logs (in bytes)",
          "group": "indices/translog",
          "default": false
        },
        "elasticsearch.indices.warmer.current": {
          "type": "gauge",
          "description": "Number of currently active warmers",
          "group": "indices/warmer",
          "default": false
        },
        "elasticsearch.indices.warmer.total": {
          "type": "cumulative",
          "description": "Total number of warmers",
          "group": "indices/warmer",
          "default": false
        },
        "elasticsearch.indices.warmer.total-time": {
          "type": "cumulative",
          "description": "Total time spent by warmers",
          "group": "indices/warmer",
          "default": false
        },
        "elasticsearch.jvm.classes.current-loaded-count": {
          "type": "gauge",
          "description": "Number of classes currently loaded",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.classes.total-loaded-count": {
          "type": "cumulative",
          "description": "Number of classes loaded",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.classes.total-unloaded-count": {
          "type": "cumulative",
          "description": "Total number of classes unloaded",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.gc.count": {
          "type": "cumulative",
          "description": "Total number of garbage collections",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.gc.old-count": {
          "type": "cumulative",
          "description": "Total number of garbage collections on Old Gen",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.gc.old-time": {
          "type": "cumulative",
          "description": "Total time spent in garbage collections on Old Gen",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.gc.time": {
          "type": "cumulative",
          "description": "Total time spent on GC",
          "group": "node/jvm",
          "default": true
        },
        "elasticsearch.jvm.mem.buffer_pools.direct.count": {
          "type": "gauge",
          "description": "Number of direct buffer pools",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.buffer_pools.direct.total_capacity_in_bytes": {
          "type": "gauge",
          "description": "Total capacity of direct buffer pools",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.buffer_pools.direct.used_in_bytes": {
          "type": "gauge",
          "description": "Memory used by direct buffer pools (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.buffer_pools.mapped.count": {
          "type": "gauge",
          "description": "Number of buffers in the mapped pool",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.buffer_pools.mapped.total_capacity_in_bytes": {
          "type": "gauge",
          "description": "Total capacity of the buffers in the mapped pool",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.buffer_pools.mapped.used_in_bytes": {
          "type": "gauge",
          "description": "Memory used by mapped buffer pools (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.heap-committed": {
          "type": "gauge",
          "description": "Memory guaranteed to be available to JVM heap",
          "group": "node/jvm",
          "default": true
        },
        "elasticsearch.jvm.mem.heap-max": {
          "type": "gauge",
          "description": "Max memory that can be used by JVM heap (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.heap-used": {
          "type": "gauge",
          "description": "Memory current being used by JVM heap (in bytes)",
          "group": "node/jvm",
          "default": true
        },
        "elasticsearch.jvm.mem.heap-used-percent": {
          "type": "gauge",
          "description": "Percent of heap being used",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.non-heap-committed": {
          "type": "gauge",
          "description": "Memory guaranteed to be available to JVM non-heap",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.non-heap-used": {
          "type": "gauge",
          "description": "Memory current being used by JVM non-heap (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.old.max_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Old Gen (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.old.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory pool Old Gen peak max (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.old.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Peak memory used by Old Gen (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.old.used_in_bytes": {
          "type": "gauge",
          "description": "Memory being used by Old Gen (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.survivor.max_in_bytes": {
          "type": "gauge",
          "description": "Max memory that can be used by Survivor space (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.survivor.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Survivor space (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.survivor.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Peak memory used by Survivor space (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.survivor.used_in_bytes": {
          "type": "gauge",
          "description": "Memory being used currently by Survivor space (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.young.max_in_bytes": {
          "type": "gauge",
          "description": "Max memory (in bytes) that can be used by Young Gen",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.young.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory pool Young Gen peak max (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.young.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Memory pool Young Gen peak used (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.mem.pools.young.used_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Young Gen (in bytes)",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of active threads in the JVM",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.threads.peak": {
          "type": "gauge",
          "description": "Peak number of threads used",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.jvm.uptime": {
          "type": "cumulative",
          "description": "Uptime of JVM",
          "group": "node/jvm",
          "default": false
        },
        "elasticsearch.process.cpu.percent": {
          "type": "gauge",
          "description": "CPU usage in percent",
          "group": "node/process",
          "default": false
        },
        "elasticsearch.process.cpu.time": {
          "type": "cumulative",
          "description": "CPU time (in milliseconds) used by the process on which the Java virtual machine is running",
          "group": "node/process",
          "default": false
        },
        "elasticsearch.process.max_file_descriptors": {
          "type": "gauge",
          "description": "Number of opened file descriptors associated with the current process",
          "group": "node/process",
          "default": false
        },
        "elasticsearch.process.mem.total-virtual-size": {
          "type": "cumulative",
          "description": "Size in bytes of virtual memory that is guaranteed to be available to the running process",
          "group": "node/process",
          "default": false
        },
        "elasticsearch.process.open_file_descriptors": {
          "type": "gauge",
          "description": "Number of currently open file descriptors",
          "group": "node/process",
          "default": true
        },
        "elasticsearch.thread_pool.active": {
          "type": "gauge",
          "description": "Number of active threads",
          "group": "node/thread-pool",
          "default": false
        },
        "elasticsearch.thread_pool.completed": {
          "type": "cumulative",
          "description": "Number of threads completed in thread pool",
          "group": "node/thread-pool",
          "default": false
        },
        "elasticsearch.thread_pool.largest": {
          "type": "gauge",
          "description": "Highest active threads in thread pool",
          "group": "node/thread-pool",
          "default": false
        },
        "elasticsearch.thread_pool.queue": {
          "type": "gauge",
          "description": "Number of Tasks in thread pool",
          "group": "node/thread-pool",
          "default": false
        },
        "elasticsearch.thread_pool.rejected": {
          "type": "cumulative",
          "description": "Number of rejected threads in thread pool",
          "group": "node/thread-pool",
          "default": true
        },
        "elasticsearch.thread_pool.threads": {
          "type": "cumulative",
          "description": "Number of Threads in thread pool",
          "group": "node/thread-pool",
          "default": false
        },
        "elasticsearch.transport.rx.count": {
          "type": "cumulative",
          "description": "Total size of data received in cluster communication (in bytes)",
          "group": "node/transport",
          "default": false
        },
        "elasticsearch.transport.rx.size": {
          "type": "cumulative",
          "description": "Total size of data received in cluster communication",
          "group": "node/transport",
          "default": false
        },
        "elasticsearch.transport.server_open": {
          "type": "gauge",
          "description": "Total number of connections opened for cluster communication",
          "group": "node/transport",
          "default": false
        },
        "elasticsearch.transport.tx.count": {
          "type": "cumulative",
          "description": "Total number of packets sent in cluster communication",
          "group": "node/transport",
          "default": false
        },
        "elasticsearch.transport.tx.size": {
          "type": "cumulative",
          "description": "Total size of data sent in cluster communication",
          "group": "node/transport",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/elasticsearch/stats",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "cluster",
            "doc": "Cluster name to which the node belongs. This is an optional config that will override the cluster name fetched from a node and will be used to populate the plugin_instance dimension",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "enableIndexStats",
            "doc": "Enable Index stats. If set to true, by default the a subset of index stats will be collected (see docs for list of default index metrics collected).",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "indexes",
            "doc": "Indexes to collect stats from (by default stats from all indexes are collected)",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "indexStatsIntervalSeconds",
            "doc": "Interval to report IndexStats on",
            "default": 60,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "indexSummaryOnly",
            "doc": "Collect only aggregated index stats across all indexes",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "indexStatsMasterOnly",
            "doc": "Collect index stats only from Master node",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableClusterHealth",
            "doc": "EnableClusterHealth enables reporting on the cluster health",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "clusterHealthStatsMasterOnly",
            "doc": "Whether or not non master nodes should report cluster health",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedHTTPStats",
            "doc": "Enable enhanced HTTP stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedJVMStats",
            "doc": "Enable enhanced JVM stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedProcessStats",
            "doc": "Enable enhanced Process stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedThreadPoolStats",
            "doc": "Enable enhanced ThreadPool stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedTransportStats",
            "doc": "Enable enhanced Transport stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedNodeIndicesStats",
            "doc": "Enable enhanced node level index stats groups. A list of index stats groups for which to collect enhanced stats",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "threadPools",
            "doc": "ThreadPools to report threadpool node stats on",
            "default": [
              "search",
              "index"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "enableEnhancedClusterHealthStats",
            "doc": "Enable Cluster level stats. These stats report only from master Elasticserach nodes",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedIndexStatsForIndexGroups",
            "doc": "Enable enhanced index level index stats groups. A list of index stats groups for which to collect enhanced stats",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "enableIndexStatsPrimaries",
            "doc": "To enable index stats from only primary shards. By default the index stats collected are aggregated across all shards",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metadataRefreshIntervalSeconds",
            "doc": "How often to refresh metadata about the node and cluster",
            "default": 30,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "elasticsearch-query",
      "sendAll": false,
      "dimensions": null,
      "doc": "",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/elasticsearch/query",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "index",
            "doc": "Index that's being queried. If none is provided, given query will be applied across all indexes. To apply the search query to multiple indices, provide a comma separated list of indices",
            "default": "_all",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "elasticsearchRequest",
            "doc": "Takes in an elasticsearch request body search request. See [here] (https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html) for details.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "etcd",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports etcd server metrics under the `/metrics` path on its\nclient port and optionally on locations given by `--listen-metrics-urls`.\nNote that this monitor collects metrics solely from the prometheus endpoint,\nunlike the `collectd/etcd` monitor which collects  metrics from the `/stats`\nendpoint.\n\nAn example configuration for this monitor:\n\n```yaml\nmonitors:\n- type: etcd\n  discoveryRule: kubernetes_pod_name =~ \"etcd\" \u0026\u0026 target == \"pod\"\n  port: 2379\n  useHTTPS: true\n  skipVerify: true\n  sendAllMetrics: true\n  clientCertPath: /var/lib/minikube/certs/etcd/server.crt\n  clientKeyPath: /var/lib/minikube/certs/etcd/server.key\n  extraDimensions:\n    metric_source: etcd\n```\n\nNote that the above config assumes that the client certificate and key are accessible\nby the SignalFx Agent in the specified path.",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "etcd_cluster_version",
            "etcd_debugging_disk_backend_commit_rebalance_duration_seconds",
            "etcd_debugging_disk_backend_commit_rebalance_duration_seconds_bucket",
            "etcd_debugging_disk_backend_commit_rebalance_duration_seconds_count",
            "etcd_debugging_disk_backend_commit_spill_duration_seconds",
            "etcd_debugging_disk_backend_commit_spill_duration_seconds_bucket",
            "etcd_debugging_disk_backend_commit_spill_duration_seconds_count",
            "etcd_debugging_disk_backend_commit_write_duration_seconds",
            "etcd_debugging_disk_backend_commit_write_duration_seconds_bucket",
            "etcd_debugging_disk_backend_commit_write_duration_seconds_count",
            "etcd_debugging_lease_granted_total",
            "etcd_debugging_lease_renewed_total",
            "etcd_debugging_lease_revoked_total",
            "etcd_debugging_lease_ttl_total",
            "etcd_debugging_lease_ttl_total_bucket",
            "etcd_debugging_lease_ttl_total_count",
            "etcd_debugging_mvcc_compact_revision",
            "etcd_debugging_mvcc_current_revision",
            "etcd_debugging_mvcc_db_compaction_keys_total",
            "etcd_debugging_mvcc_db_compaction_pause_duration_milliseconds",
            "etcd_debugging_mvcc_db_compaction_pause_duration_milliseconds_bucket",
            "etcd_debugging_mvcc_db_compaction_pause_duration_milliseconds_count",
            "etcd_debugging_mvcc_db_compaction_total_duration_milliseconds",
            "etcd_debugging_mvcc_db_compaction_total_duration_milliseconds_bucket",
            "etcd_debugging_mvcc_db_compaction_total_duration_milliseconds_count",
            "etcd_debugging_mvcc_db_total_size_in_bytes",
            "etcd_debugging_mvcc_delete_total",
            "etcd_debugging_mvcc_events_total",
            "etcd_debugging_mvcc_index_compaction_pause_duration_milliseconds",
            "etcd_debugging_mvcc_index_compaction_pause_duration_milliseconds_bucket",
            "etcd_debugging_mvcc_index_compaction_pause_duration_milliseconds_count",
            "etcd_debugging_mvcc_keys_total",
            "etcd_debugging_mvcc_pending_events_total",
            "etcd_debugging_mvcc_put_total",
            "etcd_debugging_mvcc_range_total",
            "etcd_debugging_mvcc_slow_watcher_total",
            "etcd_debugging_mvcc_txn_total",
            "etcd_debugging_mvcc_watch_stream_total",
            "etcd_debugging_mvcc_watcher_total",
            "etcd_debugging_server_lease_expired_total",
            "etcd_debugging_snap_save_marshalling_duration_seconds",
            "etcd_debugging_snap_save_marshalling_duration_seconds_bucket",
            "etcd_debugging_snap_save_marshalling_duration_seconds_count",
            "etcd_debugging_snap_save_total_duration_seconds",
            "etcd_debugging_snap_save_total_duration_seconds_bucket",
            "etcd_debugging_snap_save_total_duration_seconds_count",
            "etcd_debugging_store_expires_total",
            "etcd_debugging_store_reads_total",
            "etcd_debugging_store_watch_requests_total",
            "etcd_debugging_store_watchers",
            "etcd_debugging_store_writes_total",
            "etcd_disk_backend_commit_duration_seconds",
            "etcd_disk_backend_commit_duration_seconds_bucket",
            "etcd_disk_backend_commit_duration_seconds_count",
            "etcd_disk_backend_defrag_duration_seconds",
            "etcd_disk_backend_defrag_duration_seconds_bucket",
            "etcd_disk_backend_defrag_duration_seconds_count",
            "etcd_disk_backend_snapshot_duration_seconds",
            "etcd_disk_backend_snapshot_duration_seconds_bucket",
            "etcd_disk_backend_snapshot_duration_seconds_count",
            "etcd_disk_wal_fsync_duration_seconds",
            "etcd_disk_wal_fsync_duration_seconds_bucket",
            "etcd_disk_wal_fsync_duration_seconds_count",
            "etcd_grpc_proxy_cache_hits_total",
            "etcd_grpc_proxy_cache_keys_total",
            "etcd_grpc_proxy_cache_misses_total",
            "etcd_grpc_proxy_events_coalescing_total",
            "etcd_grpc_proxy_watchers_coalescing_total",
            "etcd_mvcc_db_open_read_transactions",
            "etcd_mvcc_db_total_size_in_bytes",
            "etcd_mvcc_db_total_size_in_use_in_bytes",
            "etcd_mvcc_delete_total",
            "etcd_mvcc_hash_duration_seconds",
            "etcd_mvcc_hash_duration_seconds_bucket",
            "etcd_mvcc_hash_duration_seconds_count",
            "etcd_mvcc_hash_rev_duration_seconds",
            "etcd_mvcc_hash_rev_duration_seconds_bucket",
            "etcd_mvcc_hash_rev_duration_seconds_count",
            "etcd_mvcc_put_total",
            "etcd_mvcc_range_total",
            "etcd_mvcc_txn_total",
            "etcd_network_client_grpc_received_bytes_total",
            "etcd_network_client_grpc_sent_bytes_total",
            "etcd_server_file_descriptors_used_total",
            "etcd_server_go_version",
            "etcd_server_has_leader",
            "etcd_server_health_failures_total",
            "etcd_server_health_success_total",
            "etcd_server_heartbeat_send_failures_total",
            "etcd_server_id",
            "etcd_server_is_leader",
            "etcd_server_is_learner",
            "etcd_server_leader_changes_seen_total",
            "etcd_server_learner_promote_successes_total",
            "etcd_server_pending_proposal_total",
            "etcd_server_proposal_durations_seconds",
            "etcd_server_proposal_durations_seconds_bucket",
            "etcd_server_proposal_durations_seconds_count",
            "etcd_server_proposal_failed_total",
            "etcd_server_proposals_applied_total",
            "etcd_server_proposals_committed_total",
            "etcd_server_proposals_failed_total",
            "etcd_server_proposals_pending",
            "etcd_server_quota_backend_bytes",
            "etcd_server_read_indexes_failed_total",
            "etcd_server_slow_apply_total",
            "etcd_server_slow_read_indexes_total",
            "etcd_server_snapshot_apply_in_progress_total",
            "etcd_server_version",
            "etcd_snap_db_fsync_duration_seconds",
            "etcd_snap_db_fsync_duration_seconds_bucket",
            "etcd_snap_db_fsync_duration_seconds_count",
            "etcd_snap_db_save_total_duration_seconds",
            "etcd_snap_db_save_total_duration_seconds_bucket",
            "etcd_snap_db_save_total_duration_seconds_count",
            "etcd_snap_fsync_duration_seconds",
            "etcd_snap_fsync_duration_seconds_bucket",
            "etcd_snap_fsync_duration_seconds_count",
            "etcd_snapshot_save_marshalling_durations_seconds",
            "etcd_snapshot_save_marshalling_durations_seconds_bucket",
            "etcd_snapshot_save_marshalling_durations_seconds_count",
            "etcd_snapshot_save_total_durations_seconds",
            "etcd_snapshot_save_total_durations_seconds_bucket",
            "etcd_snapshot_save_total_durations_seconds_count",
            "etcd_storage_db_compaction_pause_duration_milliseconds",
            "etcd_storage_db_compaction_pause_duration_milliseconds_bucket",
            "etcd_storage_db_compaction_pause_duration_milliseconds_count",
            "etcd_storage_db_compaction_total_duration_milliseconds",
            "etcd_storage_db_compaction_total_duration_milliseconds_bucket",
            "etcd_storage_db_compaction_total_duration_milliseconds_count",
            "etcd_storage_db_total_size_in_bytes",
            "etcd_storage_delete_total",
            "etcd_storage_events_total",
            "etcd_storage_index_compaction_pause_duration_milliseconds",
            "etcd_storage_index_compaction_pause_duration_milliseconds_bucket",
            "etcd_storage_index_compaction_pause_duration_milliseconds_count",
            "etcd_storage_keys_total",
            "etcd_storage_pending_events_total",
            "etcd_storage_put_total",
            "etcd_storage_range_total",
            "etcd_storage_slow_watcher_total",
            "etcd_storage_txn_total",
            "etcd_storage_watch_stream_total",
            "etcd_storage_watcher_total",
            "etcd_store_expires_total",
            "etcd_store_reads_total",
            "etcd_store_watch_requests_total",
            "etcd_store_watchers",
            "etcd_store_writes_total",
            "etcd_wal_fsync_durations_seconds",
            "etcd_wal_fsync_durations_seconds_bucket",
            "etcd_wal_fsync_durations_seconds_count",
            "etcd_wal_last_index_saved",
            "go_gc_duration_seconds",
            "go_gc_duration_seconds_count",
            "go_gc_duration_seconds_quantile",
            "go_goroutines",
            "go_info",
            "go_memstats_alloc_bytes",
            "go_memstats_alloc_bytes_total",
            "go_memstats_buck_hash_sys_bytes",
            "go_memstats_frees_total",
            "go_memstats_gc_cpu_fraction",
            "go_memstats_gc_sys_bytes",
            "go_memstats_heap_alloc_bytes",
            "go_memstats_heap_idle_bytes",
            "go_memstats_heap_inuse_bytes",
            "go_memstats_heap_objects",
            "go_memstats_heap_released_bytes",
            "go_memstats_heap_released_bytes_total",
            "go_memstats_heap_sys_bytes",
            "go_memstats_last_gc_time_seconds",
            "go_memstats_lookups_total",
            "go_memstats_mallocs_total",
            "go_memstats_mcache_inuse_bytes",
            "go_memstats_mcache_sys_bytes",
            "go_memstats_mspan_inuse_bytes",
            "go_memstats_mspan_sys_bytes",
            "go_memstats_next_gc_bytes",
            "go_memstats_other_sys_bytes",
            "go_memstats_stack_inuse_bytes",
            "go_memstats_stack_sys_bytes",
            "go_memstats_sys_bytes",
            "go_threads",
            "grpc_server_handled_total",
            "grpc_server_msg_received_total",
            "grpc_server_msg_sent_total",
            "grpc_server_started_total",
            "http_request_duration_microseconds",
            "http_request_duration_microseconds_count",
            "http_request_duration_microseconds_quantile",
            "http_request_size_bytes",
            "http_request_size_bytes_count",
            "http_request_size_bytes_quantile",
            "http_requests_total",
            "http_response_size_bytes",
            "http_response_size_bytes_count",
            "http_response_size_bytes_quantile",
            "process_cpu_seconds_total",
            "process_max_fds",
            "process_open_fds",
            "process_resident_memory_bytes",
            "process_start_time_seconds",
            "process_virtual_memory_bytes",
            "process_virtual_memory_max_bytes",
            "promhttp_metric_handler_requests_in_flight",
            "promhttp_metric_handler_requests_total"
          ]
        }
      },
      "metrics": {
        "etcd_cluster_version": {
          "type": "gauge",
          "description": "Which version is running. 1 for 'cluster_version' label with current cluster version",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_rebalance_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of commit.rebalance called by bboltdb backend. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_rebalance_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of commit.rebalance called by bboltdb backend. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_rebalance_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of commit.rebalance called by bboltdb backend. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_spill_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of commit.spill called by bboltdb backend. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_spill_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of commit.spill called by bboltdb backend. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_spill_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of commit.spill called by bboltdb backend. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_write_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of commit.write called by bboltdb backend. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_write_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of commit.write called by bboltdb backend. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_disk_backend_commit_write_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of commit.write called by bboltdb backend. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_lease_granted_total": {
          "type": "cumulative",
          "description": "The total number of granted leases.",
          "group": null,
          "default": false
        },
        "etcd_debugging_lease_renewed_total": {
          "type": "cumulative",
          "description": "The number of renewed leases seen by the leader.",
          "group": null,
          "default": false
        },
        "etcd_debugging_lease_revoked_total": {
          "type": "cumulative",
          "description": "The total number of revoked leases.",
          "group": null,
          "default": false
        },
        "etcd_debugging_lease_ttl_total": {
          "type": "cumulative",
          "description": "Bucketed histogram of lease TTLs. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_lease_ttl_total_bucket": {
          "type": "cumulative",
          "description": "Bucketed histogram of lease TTLs. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_lease_ttl_total_count": {
          "type": "cumulative",
          "description": "Bucketed histogram of lease TTLs. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_compact_revision": {
          "type": "gauge",
          "description": "The revision of the last compaction in store.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_current_revision": {
          "type": "gauge",
          "description": "The current revision of store.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_db_compaction_keys_total": {
          "type": "cumulative",
          "description": "Total number of db keys compacted.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_db_compaction_pause_duration_milliseconds": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction pause duration. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_db_compaction_pause_duration_milliseconds_bucket": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction pause duration. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_db_compaction_pause_duration_milliseconds_count": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction pause duration. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_db_compaction_total_duration_milliseconds": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction total duration. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_db_compaction_total_duration_milliseconds_bucket": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction total duration. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_db_compaction_total_duration_milliseconds_count": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction total duration. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_db_total_size_in_bytes": {
          "type": "gauge",
          "description": "Total size of the underlying database physically allocated in bytes.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_delete_total": {
          "type": "cumulative",
          "description": "Total number of deletes seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_events_total": {
          "type": "cumulative",
          "description": "Total number of events sent by this member.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_index_compaction_pause_duration_milliseconds": {
          "type": "cumulative",
          "description": "Bucketed histogram of index compaction pause duration. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_index_compaction_pause_duration_milliseconds_bucket": {
          "type": "cumulative",
          "description": "Bucketed histogram of index compaction pause duration. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_index_compaction_pause_duration_milliseconds_count": {
          "type": "cumulative",
          "description": "Bucketed histogram of index compaction pause duration. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_keys_total": {
          "type": "gauge",
          "description": "Total number of keys.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_pending_events_total": {
          "type": "gauge",
          "description": "Total number of pending events to be sent.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_put_total": {
          "type": "cumulative",
          "description": "Total number of puts seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_range_total": {
          "type": "cumulative",
          "description": "Total number of ranges seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_slow_watcher_total": {
          "type": "gauge",
          "description": "Total number of unsynced slow watchers.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_txn_total": {
          "type": "cumulative",
          "description": "Total number of txns seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_watch_stream_total": {
          "type": "gauge",
          "description": "Total number of watch streams.",
          "group": null,
          "default": false
        },
        "etcd_debugging_mvcc_watcher_total": {
          "type": "gauge",
          "description": "Total number of watchers.",
          "group": null,
          "default": false
        },
        "etcd_debugging_server_lease_expired_total": {
          "type": "cumulative",
          "description": "The total number of expired leases.",
          "group": null,
          "default": false
        },
        "etcd_debugging_snap_save_marshalling_duration_seconds": {
          "type": "cumulative",
          "description": "The marshalling cost distributions of save called by snapshot. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_snap_save_marshalling_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The marshalling cost distributions of save called by snapshot. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_snap_save_marshalling_duration_seconds_count": {
          "type": "cumulative",
          "description": "The marshalling cost distributions of save called by snapshot. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_snap_save_total_duration_seconds": {
          "type": "cumulative",
          "description": "The total latency distributions of save called by snapshot. (sum)",
          "group": null,
          "default": false
        },
        "etcd_debugging_snap_save_total_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The total latency distributions of save called by snapshot. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_debugging_snap_save_total_duration_seconds_count": {
          "type": "cumulative",
          "description": "The total latency distributions of save called by snapshot. (count)",
          "group": null,
          "default": false
        },
        "etcd_debugging_store_expires_total": {
          "type": "cumulative",
          "description": "Total number of expired keys.",
          "group": null,
          "default": false
        },
        "etcd_debugging_store_reads_total": {
          "type": "cumulative",
          "description": "Total number of reads action by (get/getRecursive), local to this member.",
          "group": null,
          "default": false
        },
        "etcd_debugging_store_watch_requests_total": {
          "type": "cumulative",
          "description": "Total number of incoming watch requests (new or reestablished).",
          "group": null,
          "default": false
        },
        "etcd_debugging_store_watchers": {
          "type": "gauge",
          "description": "Count of currently active watchers.",
          "group": null,
          "default": false
        },
        "etcd_debugging_store_writes_total": {
          "type": "cumulative",
          "description": "Total number of writes (e.g. set/compareAndDelete) seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_commit_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of commit called by backend. (sum)",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_commit_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of commit called by backend. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_commit_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of commit called by backend. (count)",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_defrag_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distribution of backend defragmentation. (sum)",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_defrag_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distribution of backend defragmentation. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_defrag_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distribution of backend defragmentation. (count)",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_snapshot_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distribution of backend snapshots. (sum)",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_snapshot_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distribution of backend snapshots. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_disk_backend_snapshot_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distribution of backend snapshots. (count)",
          "group": null,
          "default": false
        },
        "etcd_disk_wal_fsync_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by WAL. (sum)",
          "group": null,
          "default": false
        },
        "etcd_disk_wal_fsync_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by WAL. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_disk_wal_fsync_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by WAL. (count)",
          "group": null,
          "default": false
        },
        "etcd_grpc_proxy_cache_hits_total": {
          "type": "gauge",
          "description": "Total number of cache hits",
          "group": null,
          "default": false
        },
        "etcd_grpc_proxy_cache_keys_total": {
          "type": "gauge",
          "description": "Total number of keys/ranges cached",
          "group": null,
          "default": false
        },
        "etcd_grpc_proxy_cache_misses_total": {
          "type": "gauge",
          "description": "Total number of cache misses",
          "group": null,
          "default": false
        },
        "etcd_grpc_proxy_events_coalescing_total": {
          "type": "cumulative",
          "description": "Total number of events coalescing",
          "group": null,
          "default": false
        },
        "etcd_grpc_proxy_watchers_coalescing_total": {
          "type": "gauge",
          "description": "Total number of current watchers coalescing",
          "group": null,
          "default": false
        },
        "etcd_mvcc_db_open_read_transactions": {
          "type": "gauge",
          "description": "The number of currently open read transactions",
          "group": null,
          "default": false
        },
        "etcd_mvcc_db_total_size_in_bytes": {
          "type": "gauge",
          "description": "Total size of the underlying database physically allocated in bytes.",
          "group": null,
          "default": false
        },
        "etcd_mvcc_db_total_size_in_use_in_bytes": {
          "type": "gauge",
          "description": "Total size of the underlying database logically in use in bytes.",
          "group": null,
          "default": false
        },
        "etcd_mvcc_delete_total": {
          "type": "cumulative",
          "description": "Total number of deletes seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_mvcc_hash_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distribution of storage hash operation. (sum)",
          "group": null,
          "default": false
        },
        "etcd_mvcc_hash_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distribution of storage hash operation. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_mvcc_hash_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distribution of storage hash operation. (count)",
          "group": null,
          "default": false
        },
        "etcd_mvcc_hash_rev_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distribution of storage hash by revision operation. (sum)",
          "group": null,
          "default": false
        },
        "etcd_mvcc_hash_rev_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distribution of storage hash by revision operation. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_mvcc_hash_rev_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distribution of storage hash by revision operation. (count)",
          "group": null,
          "default": false
        },
        "etcd_mvcc_put_total": {
          "type": "cumulative",
          "description": "Total number of puts seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_mvcc_range_total": {
          "type": "cumulative",
          "description": "Total number of ranges seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_mvcc_txn_total": {
          "type": "cumulative",
          "description": "Total number of txns seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_network_client_grpc_received_bytes_total": {
          "type": "cumulative",
          "description": "The total number of bytes received from grpc clients.",
          "group": null,
          "default": false
        },
        "etcd_network_client_grpc_sent_bytes_total": {
          "type": "cumulative",
          "description": "The total number of bytes sent to grpc clients.",
          "group": null,
          "default": false
        },
        "etcd_server_file_descriptors_used_total": {
          "type": "gauge",
          "description": "The total number of file descriptors used.",
          "group": null,
          "default": false
        },
        "etcd_server_go_version": {
          "type": "gauge",
          "description": "Which Go version server is running with. 1 for 'server_go_version' label with current version.",
          "group": null,
          "default": false
        },
        "etcd_server_has_leader": {
          "type": "gauge",
          "description": "Whether or not a leader exists. 1 is existence, 0 is not.",
          "group": null,
          "default": true
        },
        "etcd_server_health_failures_total": {
          "type": "cumulative",
          "description": "The total number of failed health checks",
          "group": null,
          "default": false
        },
        "etcd_server_health_success_total": {
          "type": "cumulative",
          "description": "The total number of successful health checks",
          "group": null,
          "default": false
        },
        "etcd_server_heartbeat_send_failures_total": {
          "type": "cumulative",
          "description": "The total number of leader heartbeat send failures (likely overloaded from slow disk).",
          "group": null,
          "default": false
        },
        "etcd_server_id": {
          "type": "gauge",
          "description": "Server or member ID in hexadecimal format. 1 for 'server_id' label with current ID.",
          "group": null,
          "default": false
        },
        "etcd_server_is_leader": {
          "type": "gauge",
          "description": "Whether or not this member is a leader. 1 if is, 0 otherwise.",
          "group": null,
          "default": false
        },
        "etcd_server_is_learner": {
          "type": "gauge",
          "description": "Whether or not this member is a learner. 1 if is, 0 otherwise.",
          "group": null,
          "default": false
        },
        "etcd_server_leader_changes_seen_total": {
          "type": "cumulative",
          "description": "The number of leader changes seen.",
          "group": null,
          "default": true
        },
        "etcd_server_learner_promote_successes_total": {
          "type": "cumulative",
          "description": "The total number of successful learner promotions while this member is leader.",
          "group": null,
          "default": false
        },
        "etcd_server_pending_proposal_total": {
          "type": "gauge",
          "description": "The total number of pending proposals.",
          "group": null,
          "default": false
        },
        "etcd_server_proposal_durations_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of committing proposal. (sum)",
          "group": null,
          "default": false
        },
        "etcd_server_proposal_durations_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of committing proposal. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_server_proposal_durations_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of committing proposal. (count)",
          "group": null,
          "default": false
        },
        "etcd_server_proposal_failed_total": {
          "type": "cumulative",
          "description": "The total number of failed proposals.",
          "group": null,
          "default": false
        },
        "etcd_server_proposals_applied_total": {
          "type": "gauge",
          "description": "The total number of consensus proposals applied.",
          "group": null,
          "default": false
        },
        "etcd_server_proposals_committed_total": {
          "type": "gauge",
          "description": "The total number of consensus proposals committed.",
          "group": null,
          "default": false
        },
        "etcd_server_proposals_failed_total": {
          "type": "cumulative",
          "description": "The total number of failed proposals seen.",
          "group": null,
          "default": true
        },
        "etcd_server_proposals_pending": {
          "type": "gauge",
          "description": "The current number of pending proposals to commit.",
          "group": null,
          "default": false
        },
        "etcd_server_quota_backend_bytes": {
          "type": "gauge",
          "description": "Current backend storage quota size in bytes.",
          "group": null,
          "default": false
        },
        "etcd_server_read_indexes_failed_total": {
          "type": "cumulative",
          "description": "The total number of failed read indexes seen.",
          "group": null,
          "default": false
        },
        "etcd_server_slow_apply_total": {
          "type": "cumulative",
          "description": "The total number of slow apply requests (likely overloaded from slow disk).",
          "group": null,
          "default": false
        },
        "etcd_server_slow_read_indexes_total": {
          "type": "cumulative",
          "description": "The total number of pending read indexes not in sync with leader's or timed out read index requests.",
          "group": null,
          "default": false
        },
        "etcd_server_snapshot_apply_in_progress_total": {
          "type": "gauge",
          "description": "1 if the server is applying the incoming snapshot. 0 if none.",
          "group": null,
          "default": false
        },
        "etcd_server_version": {
          "type": "gauge",
          "description": "Which version is running. 1 for 'server_version' label with current version.",
          "group": null,
          "default": false
        },
        "etcd_snap_db_fsync_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of fsyncing .snap.db file (sum)",
          "group": null,
          "default": false
        },
        "etcd_snap_db_fsync_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of fsyncing .snap.db file (bucket)",
          "group": null,
          "default": false
        },
        "etcd_snap_db_fsync_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of fsyncing .snap.db file (count)",
          "group": null,
          "default": false
        },
        "etcd_snap_db_save_total_duration_seconds": {
          "type": "cumulative",
          "description": "The total latency distributions of v3 snapshot save (sum)",
          "group": null,
          "default": false
        },
        "etcd_snap_db_save_total_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The total latency distributions of v3 snapshot save (bucket)",
          "group": null,
          "default": false
        },
        "etcd_snap_db_save_total_duration_seconds_count": {
          "type": "cumulative",
          "description": "The total latency distributions of v3 snapshot save (count)",
          "group": null,
          "default": false
        },
        "etcd_snap_fsync_duration_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by snap. (sum)",
          "group": null,
          "default": false
        },
        "etcd_snap_fsync_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by snap. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_snap_fsync_duration_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by snap. (count)",
          "group": null,
          "default": false
        },
        "etcd_snapshot_save_marshalling_durations_seconds": {
          "type": "cumulative",
          "description": "The marshalling cost distributions of save called by snapshot. (sum)",
          "group": null,
          "default": false
        },
        "etcd_snapshot_save_marshalling_durations_seconds_bucket": {
          "type": "cumulative",
          "description": "The marshalling cost distributions of save called by snapshot. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_snapshot_save_marshalling_durations_seconds_count": {
          "type": "cumulative",
          "description": "The marshalling cost distributions of save called by snapshot. (count)",
          "group": null,
          "default": false
        },
        "etcd_snapshot_save_total_durations_seconds": {
          "type": "cumulative",
          "description": "The total latency distributions of save called by snapshot. (sum)",
          "group": null,
          "default": false
        },
        "etcd_snapshot_save_total_durations_seconds_bucket": {
          "type": "cumulative",
          "description": "The total latency distributions of save called by snapshot. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_snapshot_save_total_durations_seconds_count": {
          "type": "cumulative",
          "description": "The total latency distributions of save called by snapshot. (count)",
          "group": null,
          "default": false
        },
        "etcd_storage_db_compaction_pause_duration_milliseconds": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction pause duration. (sum)",
          "group": null,
          "default": false
        },
        "etcd_storage_db_compaction_pause_duration_milliseconds_bucket": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction pause duration. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_storage_db_compaction_pause_duration_milliseconds_count": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction pause duration. (count)",
          "group": null,
          "default": false
        },
        "etcd_storage_db_compaction_total_duration_milliseconds": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction total duration. (sum)",
          "group": null,
          "default": false
        },
        "etcd_storage_db_compaction_total_duration_milliseconds_bucket": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction total duration. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_storage_db_compaction_total_duration_milliseconds_count": {
          "type": "cumulative",
          "description": "Bucketed histogram of db compaction total duration. (count)",
          "group": null,
          "default": false
        },
        "etcd_storage_db_total_size_in_bytes": {
          "type": "gauge",
          "description": "Total size of the underlying database in bytes.",
          "group": null,
          "default": false
        },
        "etcd_storage_delete_total": {
          "type": "cumulative",
          "description": "Total number of deletes seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_storage_events_total": {
          "type": "cumulative",
          "description": "Total number of events sent by this member.",
          "group": null,
          "default": false
        },
        "etcd_storage_index_compaction_pause_duration_milliseconds": {
          "type": "cumulative",
          "description": "Bucketed histogram of index compaction pause duration. (sum)",
          "group": null,
          "default": false
        },
        "etcd_storage_index_compaction_pause_duration_milliseconds_bucket": {
          "type": "cumulative",
          "description": "Bucketed histogram of index compaction pause duration. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_storage_index_compaction_pause_duration_milliseconds_count": {
          "type": "cumulative",
          "description": "Bucketed histogram of index compaction pause duration. (count)",
          "group": null,
          "default": false
        },
        "etcd_storage_keys_total": {
          "type": "gauge",
          "description": "Total number of keys.",
          "group": null,
          "default": false
        },
        "etcd_storage_pending_events_total": {
          "type": "gauge",
          "description": "Total number of pending events to be sent.",
          "group": null,
          "default": false
        },
        "etcd_storage_put_total": {
          "type": "cumulative",
          "description": "Total number of puts seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_storage_range_total": {
          "type": "cumulative",
          "description": "Total number of ranges seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_storage_slow_watcher_total": {
          "type": "gauge",
          "description": "Total number of unsynced slow watchers.",
          "group": null,
          "default": false
        },
        "etcd_storage_txn_total": {
          "type": "cumulative",
          "description": "Total number of txns seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_storage_watch_stream_total": {
          "type": "gauge",
          "description": "Total number of watch streams.",
          "group": null,
          "default": false
        },
        "etcd_storage_watcher_total": {
          "type": "gauge",
          "description": "Total number of watchers.",
          "group": null,
          "default": false
        },
        "etcd_store_expires_total": {
          "type": "cumulative",
          "description": "Total number of expired keys.",
          "group": null,
          "default": false
        },
        "etcd_store_reads_total": {
          "type": "cumulative",
          "description": "Total number of reads action by (get/getRecursive), local to this member.",
          "group": null,
          "default": false
        },
        "etcd_store_watch_requests_total": {
          "type": "cumulative",
          "description": "Total number of incoming watch requests (new or reestablished).",
          "group": null,
          "default": false
        },
        "etcd_store_watchers": {
          "type": "gauge",
          "description": "Count of currently active watchers.",
          "group": null,
          "default": false
        },
        "etcd_store_writes_total": {
          "type": "cumulative",
          "description": "Total number of writes (e.g. set/compareAndDelete) seen by this member.",
          "group": null,
          "default": false
        },
        "etcd_wal_fsync_durations_seconds": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by wal. (sum)",
          "group": null,
          "default": false
        },
        "etcd_wal_fsync_durations_seconds_bucket": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by wal. (bucket)",
          "group": null,
          "default": false
        },
        "etcd_wal_fsync_durations_seconds_count": {
          "type": "cumulative",
          "description": "The latency distributions of fsync called by wal. (count)",
          "group": null,
          "default": false
        },
        "etcd_wal_last_index_saved": {
          "type": "gauge",
          "description": "The index of the last entry saved by wal.",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (sum)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (count)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_quantile": {
          "type": "gauge",
          "description": "A summary of the GC invocation durations. (quantized)",
          "group": null,
          "default": false
        },
        "go_goroutines": {
          "type": "gauge",
          "description": "Number of goroutines that currently exist.",
          "group": null,
          "default": false
        },
        "go_info": {
          "type": "gauge",
          "description": "Information about the Go environment.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed.",
          "group": null,
          "default": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table.",
          "group": null,
          "default": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_released_bytes_total": {
          "type": "cumulative",
          "description": "Total number of heap bytes released to OS.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Number of seconds since 1970 of last garbage collection.",
          "group": null,
          "default": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups.",
          "group": null,
          "default": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place.",
          "group": null,
          "default": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created.",
          "group": null,
          "default": false
        },
        "grpc_server_handled_total": {
          "type": "cumulative",
          "description": "Total number of RPCs completed on the server, regardless of success or failure.",
          "group": null,
          "default": true
        },
        "grpc_server_msg_received_total": {
          "type": "cumulative",
          "description": "Total number of RPC stream messages received on the server.",
          "group": null,
          "default": false
        },
        "grpc_server_msg_sent_total": {
          "type": "cumulative",
          "description": "Total number of gRPC stream messages sent by the server.",
          "group": null,
          "default": false
        },
        "grpc_server_started_total": {
          "type": "cumulative",
          "description": "Total number of RPCs started on the server.",
          "group": null,
          "default": true
        },
        "http_request_duration_microseconds": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (sum)",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds_count": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (count)",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds_quantile": {
          "type": "gauge",
          "description": "The HTTP request latencies in microseconds. (quantized)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (sum)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (count)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes_quantile": {
          "type": "gauge",
          "description": "The HTTP request sizes in bytes. (quantized)",
          "group": null,
          "default": false
        },
        "http_requests_total": {
          "type": "cumulative",
          "description": "Total number of HTTP requests made.",
          "group": null,
          "default": false
        },
        "http_response_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (sum)",
          "group": null,
          "default": false
        },
        "http_response_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (count)",
          "group": null,
          "default": false
        },
        "http_response_size_bytes_quantile": {
          "type": "gauge",
          "description": "The HTTP response sizes in bytes. (quantized)",
          "group": null,
          "default": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent in seconds.",
          "group": null,
          "default": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_max_bytes": {
          "type": "gauge",
          "description": "Maximum amount of virtual memory available in bytes.",
          "group": null,
          "default": false
        },
        "promhttp_metric_handler_requests_in_flight": {
          "type": "gauge",
          "description": "Current number of scrapes being served.",
          "group": null,
          "default": false
        },
        "promhttp_metric_handler_requests_total": {
          "type": "cumulative",
          "description": "Total number of scrapes by HTTP status code.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/etcd",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "expvar",
      "sendAll": false,
      "dimensions": null,
      "doc": "The expvar monitor is a SignalFx Smart Agent monitor that scrapes metrics from variables exposed in JSON\nformat at an HTTP endpoint by [expvar](https://golang.org/pkg/expvar/). The monitor uses configured paths\nto get metric and dimension values from fetched JSON objects.\n\nThe Metrics section in this document shows metrics derived from expvar variable\n[memstats](https://golang.org/pkg/runtime/). The memstat variable is exposed by default. These memstat\nmetrics are referred to as standard or default metrics. The configuration examples shown are excerpts\nlimited to the monitor configuration section of the SignalFx Smart Agent configuration file `agent.yml`.\n\nBelow is an example showing the minimal required expvar monitor configuration for exporting\nthe default metrics from endpoint `http://172.17.0.3:8000/debug/vars`. `/debug/vars` is the default path.\n```\nmonitors:\n- type: expvar\n  host: 172.17.0.3\n  path: /debug/vars\n  port: 8000\n```\nWe recommend you include the extra dimension `metric_source` with a meaningful value in order to facilitate\nfiltering in the SignalFx app. See below.\n```\nmonitors:\n- type: expvar\n  host: 172.17.0.3\n  path: /debug/vars\n  port: 8000\n  extraDimensions:\n    metric_source: expvar\n```\nBelow is an example showing part of a JSON payload containing the exposed variable `requestsPerSecond` containing\nrequests per second metric information.\n```\n{\n  ...\n  \"requestsPerSecond\": 919,\n  ...\n}\n```\nSuppose that the payload is emanating from endpoint `http://172.17.0.4:6000/appmetrics`. The monitor can be\nconfigured as shown below in order to scrape `requestsPerSecond`. The metric name is optional. If not provided,\nthe JSONPath value `requestsPerSecond` snake cased to `requests_per_second` will be used instead.\n```\nmonitors:\n- type: expvar\n  host: 172.17.0.4\n  path: /debug/vars\n  port: 6000\n  metrics:\n    - name: requests.sec\n      JSONPath: requestsPerSecond\n      type: gauge\n  extraDimensions:\n    metric_source: expvar-aws\n```\nThe expvar monitor can be configured to extract metric values from complex JSON objects such as the one shown\nbelow. Suppose the `memstats` variable shown below is exposed at endpoint `http://172.17.0.5:5000/debug/vars`\nand you want to extract the cumulative `Mallocs` values.\n```\n{\n  ...\n  \"memstats\": {\n                ...\n                \"GCCPUFraction\": 0.0000032707490586459204,\n                \"BySize\": [\n                  {\n                      \"Size\": 32,\n                      \"Mallocs\": 35387,\n                      \"Frees\": 35021\n                  },\n                  {\n                      \"Size\": 48,\n                      \"Mallocs\": 35387,\n                      \"Frees\": 63283\n                  }\n                ]\n                \"HeapAlloc\": 2138088,\n                ...\n              }\n  ...\n}\n```\nTo fetch the first cumulative `Mallocs` value in the `BySize` array configure the monitor as shown below. The\nconfigured path (JSONPath) contains character delimited keys of metric values in the JSON object. The path must\nbe defined fully, terminating on primitive values or array of primitive values. The path should not terminated\non embedded object(s). No metric name was provided for this configuration so the metric name defaults to\n`memstats.by_size.mallocs`. Also, a dimension named `memstats_by_size_index` containing the array index 0 is\ncreated.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.0.Mallocs\n      type: cumulative\n  extraDimensions:\n    metric_source: expvar\n```\n`.` is the default path separator character and thus no need to specify. Below is the same configuration using\n `/` as the path separator character.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats/BySize/0/Mallocs\n      pathSeparator: /\n      type: cumulative\n  extraDimensions:\n    metric_source: expvar\n```\nTo fetch all `Mallocs` values or a combination thereof, configure JSONPath with regular expression. The\nconfiguration below configures the monitor to fetch all 2 `Mallocs` values (35387 and 35387). Two data points\nfor metric `memstats.by_size.mallocs` containing the values will be fetched. The datapoints will have dimension\n`memstats_by_size_index` containing their respective array index. Note that the escape character `\\` is used to\nescape character `.` of regex `.*` in order take `.` literally as opposed to a path separator character.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.\\\\.*.Mallocs\n      type: cumulative\n  extraDimensions:\n    metric_source: expvar\n```\nThe configuration below will fetch all the `BySize` values.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.\\\\.*.\\\\.*\n      type: cumulative\n  extraDimensions:\n    metric_source: expvar\n```\nThe configuration below will also fetch all the `BySize` values.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.\\\\d+.\\\\.*\n      type: cumulative\n  extraDimensions:\n    metric_source: expvar\n```\nCustom dimensions can be added to metrics as shown below. The dimension name is required if a dimension\nvalue is provided. The dimension name is optional when JSONPath for the dimension is provided.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.\\\\.*.Mallocs\n      type: cumulative\n      - dimensions:\n        name: physical_memory\n        value: 4GiB\n      - name: app_mem\n        value: \"10 MiB\"\n  extraDimensions:\n    metric_source: expvar\n```\nThe dimension JSONPathcan be configured as shown below. If the dimension name is not provided the dimension\nname is constructed from snake casing the JSONPath. The dimension JSONPath must be shorter than the metric JSONPath\nand start at same root. So, for the configuration below, dimensions `memory_stats` and `memstats_by_size` will\ncontain values `BySize` and `0` respectively.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.0.Mallocs\n      type: cumulative\n      - dimensions:\n        name: memory_stats\n        JSONPath: memstats\n      - dimensions:\n        JSONPath: memstats/BySize\n  extraDimensions:\n    metric_source: expvar\n```\n DO NOT\nconfigure the monitor for memstats metrics because they are standard metrics provided by default. We use memstats\nhere to provide a realistic example.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "memstats.alloc",
            "memstats.buck_hash_sys",
            "memstats.by_size.frees",
            "memstats.by_size.mallocs",
            "memstats.by_size.size",
            "memstats.debug_gc",
            "memstats.enable_gc",
            "memstats.frees",
            "memstats.gc_sys",
            "memstats.gccpu_fraction",
            "memstats.heap_alloc",
            "memstats.heap_idle",
            "memstats.heap_inuse",
            "memstats.heap_objects",
            "memstats.heap_released",
            "memstats.heap_sys",
            "memstats.last_gc",
            "memstats.lookups",
            "memstats.m_cache_inuse",
            "memstats.m_cache_sys",
            "memstats.m_span_inuse",
            "memstats.m_span_sys",
            "memstats.mallocs",
            "memstats.most_recent_gc_pause_end",
            "memstats.most_recent_gc_pause_ns",
            "memstats.next_gc",
            "memstats.num_forced_gc",
            "memstats.num_gc",
            "memstats.other_sys",
            "memstats.pause_total_ns",
            "memstats.stack_inuse",
            "memstats.stack_sys",
            "memstats.sys",
            "memstats.total_alloc"
          ]
        }
      },
      "metrics": {
        "memstats.alloc": {
          "type": "gauge",
          "description": "Bytes of allocated heap objects. Same as memstats.heap_alloc",
          "group": null,
          "default": false
        },
        "memstats.buck_hash_sys": {
          "type": "gauge",
          "description": "Bytes of memory in profiling bucket hash tables",
          "group": null,
          "default": true
        },
        "memstats.by_size.frees": {
          "type": "counter",
          "description": "Cumulative count of heap objects freed in a class. The class is identified by dimension class and it is as described for metric memstats.by_size.size",
          "group": null,
          "default": false
        },
        "memstats.by_size.mallocs": {
          "type": "counter",
          "description": "Cumulative count of heap objects allocated in a class. The class is identified by dimension class and it is as described for metric memstats.by_size.size",
          "group": null,
          "default": false
        },
        "memstats.by_size.size": {
          "type": "counter",
          "description": "The maximum byte size of a class as identified by dimension class. It is the class interval upper limit. The values of dimension class are numbers between 0 and 60 inclusive. Consecutive classes are of consecutive dimension class values. The lower limit of a class is the upper limit of the consecutive class below. Metrics memstats.by_size.size, memstats.by_size.mallocs and memstats.by_size.frees of the same class are related",
          "group": null,
          "default": false
        },
        "memstats.debug_gc": {
          "type": "gauge",
          "description": "memstats.debug_gc is currently unused",
          "group": null,
          "default": false
        },
        "memstats.enable_gc": {
          "type": "gauge",
          "description": "Boolean that indicates that GC is enabled. It is always true, even if GOGC=off",
          "group": null,
          "default": false
        },
        "memstats.frees": {
          "type": "counter",
          "description": "Cumulative count of heap objects freed",
          "group": null,
          "default": true
        },
        "memstats.gc_sys": {
          "type": "gauge",
          "description": "Bytes of memory in garbage collection metadata",
          "group": null,
          "default": true
        },
        "memstats.gccpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started",
          "group": null,
          "default": true
        },
        "memstats.heap_alloc": {
          "type": "gauge",
          "description": "Bytes of allocated heap objects",
          "group": null,
          "default": true
        },
        "memstats.heap_idle": {
          "type": "gauge",
          "description": "Bytes in idle (unused) spans",
          "group": null,
          "default": true
        },
        "memstats.heap_inuse": {
          "type": "gauge",
          "description": "Bytes in in-use spans",
          "group": null,
          "default": true
        },
        "memstats.heap_objects": {
          "type": "gauge",
          "description": "Number of allocated heap objects",
          "group": null,
          "default": true
        },
        "memstats.heap_released": {
          "type": "gauge",
          "description": "Bytes of physical memory returned to the OS",
          "group": null,
          "default": true
        },
        "memstats.heap_sys": {
          "type": "gauge",
          "description": "Bytes of heap memory obtained from the OS",
          "group": null,
          "default": true
        },
        "memstats.last_gc": {
          "type": "gauge",
          "description": "The time the last garbage collection finished, as nanoseconds since 1970 (the UNIX epoch)",
          "group": null,
          "default": false
        },
        "memstats.lookups": {
          "type": "counter",
          "description": "Number of pointer lookups performed by the runtime",
          "group": null,
          "default": false
        },
        "memstats.m_cache_inuse": {
          "type": "gauge",
          "description": "Bytes of allocated mcache structures",
          "group": null,
          "default": true
        },
        "memstats.m_cache_sys": {
          "type": "gauge",
          "description": "Bytes of memory obtained from the OS for mcache structures",
          "group": null,
          "default": true
        },
        "memstats.m_span_inuse": {
          "type": "gauge",
          "description": "Bytes of allocated mspan structures",
          "group": null,
          "default": true
        },
        "memstats.m_span_sys": {
          "type": "gauge",
          "description": "Bytes of memory obtained from the OS for mspan",
          "group": null,
          "default": true
        },
        "memstats.mallocs": {
          "type": "counter",
          "description": "Cumulative count of heap objects allocated",
          "group": null,
          "default": true
        },
        "memstats.most_recent_gc_pause_end": {
          "type": "gauge",
          "description": "Most recent GC pause end time, as nanoseconds since 1970 (the UNIX epoch)",
          "group": null,
          "default": false
        },
        "memstats.most_recent_gc_pause_ns": {
          "type": "gauge",
          "description": "Most recent GC stop-the-world pause time in nanoseconds",
          "group": null,
          "default": true
        },
        "memstats.next_gc": {
          "type": "gauge",
          "description": "Target heap size of the next GC cycle",
          "group": null,
          "default": true
        },
        "memstats.num_forced_gc": {
          "type": "counter",
          "description": "Number of GC cycles that were forced by the application calling the GC function",
          "group": null,
          "default": true
        },
        "memstats.num_gc": {
          "type": "counter",
          "description": "Number of completed GC cycles",
          "group": null,
          "default": true
        },
        "memstats.other_sys": {
          "type": "gauge",
          "description": "Bytes of memory in miscellaneous off-heap runtime allocations",
          "group": null,
          "default": true
        },
        "memstats.pause_total_ns": {
          "type": "counter",
          "description": "Cumulative nanoseconds in GC stop-the-world pauses since the program started",
          "group": null,
          "default": false
        },
        "memstats.stack_inuse": {
          "type": "gauge",
          "description": "Bytes in stack spans",
          "group": null,
          "default": true
        },
        "memstats.stack_sys": {
          "type": "gauge",
          "description": "Bytes of stack memory obtained from the OS",
          "group": null,
          "default": true
        },
        "memstats.sys": {
          "type": "gauge",
          "description": "total bytes of memory obtained from the OS",
          "group": null,
          "default": true
        },
        "memstats.total_alloc": {
          "type": "counter",
          "description": "Cumulative bytes allocated for heap objects",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for monitor configuration",
        "package": "pkg/monitors/expvar",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the expvar endpoint",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the expvar endpoint",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the host using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the host's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "path",
            "doc": "Path to the expvar endpoint, usually `/debug/vars` (the default).",
            "default": "/debug/vars",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "If true, sends metrics memstats.alloc, memstats.by_size.size, memstats.by_size.mallocs and memstats.by_size.frees",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metrics",
            "doc": "Metrics configurations",
            "default": "",
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MetricConfig",
              "doc": "MetricConfig for metric configuration",
              "package": "pkg/monitors/expvar",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "Metric name",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONPath",
                  "doc": "JSON path of the metric value",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "type",
                  "doc": "SignalFx metric type. Possible values are \"gauge\" or \"cumulative\"",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dimensions",
                  "doc": "Metric dimensions",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "DimensionConfig",
                    "doc": "DimensionConfig for metric dimension configuration",
                    "package": "pkg/monitors/expvar",
                    "fields": [
                      {
                        "yamlName": "name",
                        "doc": "Dimension name",
                        "default": null,
                        "required": true,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "JSONPath",
                        "doc": "JSON path of the dimension value",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "value",
                        "doc": "Dimension value",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "pathSeparator",
                  "doc": "Path separator character of metric value in JSON object",
                  "default": ".",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "filesystems",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports metrics about free disk space on mounted devices.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /hostfs/proc\nmonitors:\n - type: filesystems\n   hostFSPath: /hostfs\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "df_complex.free",
            "df_complex.used",
            "disk.summary_utilization",
            "disk.utilization"
          ]
        },
        "inodes": {
          "description": "",
          "metrics": [
            "df_inodes.free",
            "df_inodes.used",
            "percent_inodes.free",
            "percent_inodes.used"
          ]
        },
        "logical": {
          "description": "",
          "metrics": [
            "percent_bytes.free",
            "percent_bytes.used"
          ]
        }
      },
      "metrics": {
        "df_complex.free": {
          "type": "gauge",
          "description": "Free disk space in bytes",
          "group": null,
          "default": true
        },
        "df_complex.used": {
          "type": "gauge",
          "description": "Used disk space in bytes",
          "group": null,
          "default": true
        },
        "df_inodes.free": {
          "type": "gauge",
          "description": "(Linux Only) Number of inodes that are free.  This is is only reported if the configuration option `inodes` is set to `true`.",
          "group": "inodes",
          "default": false
        },
        "df_inodes.used": {
          "type": "gauge",
          "description": "(Linux Only) Number of inodes that are used.  This is only reported if the configuration option `inodes` is set to `true`.",
          "group": "inodes",
          "default": false
        },
        "disk.summary_utilization": {
          "type": "gauge",
          "description": "Percent of disk space utilized on all volumes on this host. This metric reports with plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "default": true
        },
        "disk.utilization": {
          "type": "gauge",
          "description": "Percent of disk used on this volume. This metric reports with plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "default": true
        },
        "percent_bytes.free": {
          "type": "gauge",
          "description": "Free disk space on the file system, expressed as a percentage.",
          "group": "logical",
          "default": false
        },
        "percent_bytes.used": {
          "type": "gauge",
          "description": "Used disk space on the file system, expressed as a percentage.",
          "group": "logical",
          "default": false
        },
        "percent_inodes.free": {
          "type": "gauge",
          "description": "(Linux Only) Free inodes on the file system, expressed as a percentage.  This is only reported if the configuration option `inodes` is set to `true`.",
          "group": "inodes",
          "default": false
        },
        "percent_inodes.used": {
          "type": "gauge",
          "description": "(Linux Only) Used inodes on the file system, expressed as a percentage.  This is only reported if the configuration option `inodes` is set to `true`.",
          "group": "inodes",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/filesystems",
        "fields": [
          {
            "yamlName": "hostFSPath",
            "doc": "Path to the root of the host filesystem.  Useful when running in a container and the host filesystem is mounted in some subdirectory under /.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "fsTypes",
            "doc": "The filesystem types to include/exclude.  This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters).",
            "default": [
              "*",
              "!aufs",
              "!overlay",
              "!tmpfs",
              "!proc",
              "!sysfs",
              "!nsfs",
              "!cgroup",
              "!devpts",
              "!selinuxfs",
              "!devtmpfs",
              "!debugfs",
              "!mqueue",
              "!hugetlbfs",
              "!securityfs",
              "!pstore",
              "!binfmt_misc",
              "!autofs"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mountPoints",
            "doc": "The mount paths to include/exclude. This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters). NOTE: If you are using the hostFSPath option you should not include the `/hostfs/` mount in the filter.",
            "default": [
              "*",
              "!/^/var/lib/docker/containers/",
              "!/^/var/lib/rkt/pods/",
              "!/^/net//",
              "!/^/smb//",
              "!/^/tmp/scratch/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "includeLogical",
            "doc": "(Linux Only) If true, then metrics will be reported about logical devices.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportByDevice",
            "doc": "If true, then metrics will report with their plugin_instance set to the device's name instead of the mountpoint.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportInodes",
            "doc": "(Linux Only) If true metrics will be reported about inodes.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab",
      "sendAll": false,
      "dimensions": null,
      "doc": "GitLab is an open-source web-based git repository manager developed by\nGitLab Inc. GitLab has built-in features for creating wiki pages,\nissue-tracking and CI/CD pipelines. GitLab is bundled with [Prometheus\nexporters](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html)\nthat can be configured to export performance metrics of itself and that of\nthe bundled software that GitLab depends on. These exporters publish\nPrometheus metrics at endpoints are scraped by this monitor.\n\n### REQUIREMENTS AND DEPENDENCIES\n\n| Software | Version |\n|----------|---------|\n| GitLab   | 9.3+    |\n\n### INSTALLATION\n\n### CONFIGURATION\n#### GitLab Configuration\n\nFollow the instructions\n[here](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html)\nto configure the GitLab's Prometheus exporters to expose metric endpoint\ntargets. For GitLab Runner monitoring configuration go\n[here](https://docs.gitlab.com/runner/monitoring/README.html).\n\nNote that configuring GitLab by editing `/etc/gitlab/gitlab.rb` should be\naccompanied by running the command `gitlab-ctl reconfigure` in order for\nthe changes to take effect.\n\nAlso, configuring Nginx by editing the file\n`/var/opt/gitlab/nginx/conf/nginx-status.conf`, for instance, should be\naccompanied by running command `gitlab-ctl restart`. Note that changes to\nthe configuration file `/var/opt/gitlab/nginx/conf/nginx-status.conf` in\nparticular are erased by subsequent runs of command `gitlab-ctl\nreconfigure` because `gitlab-ctl reconfigure` restores the original\nconfiguration file.\n\nBelow is a list of some of the Prometheus endpoint targets with links to\ntheir respective configuration pages. Note that target `gitlab_monitor`\nmetrics are just targets `gitlab_monitor_database`,\n`gitlab_monitor_process` and `gitlab_monitor_sidekiq` metrics combined.\n\n| Agent Monitor Type    |     Gitlab Doc                           | Standard Port | Standard Path |\n|-----------------------|------------------------------------------|---------------|---------------|\n| gitlab | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/gitlab_exporter.html) | 9168 | /metrics |\n| [gitlab-gitaly](./gitlab-gitaly.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/gitaly/#doc-nav) | 9236 | /metrics |\n| [gitlab-sidekiq](./gitlab-sidekiq.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 8082 | /metrics |\n| [gitlab-unicorn](./gitlab-unicorn.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/gitlab_metrics.html#unicorn-metrics-available) | 8080 | /-/metrics |\n| [gitlab-workhorse](./gitlab-workhorse.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 9229 | /metrics |\n| [prometheus/nginx-vts](./prometheus-nginx-vts.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 8060 | /metrics |\n| [prometheus/node](./prometheus-node.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/node_exporter.html) | 9100 | /metrics |\n| [promteheus/postgres](./prometheus-postgres.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/postgres_exporter.html) | 9187 | /metrics |\n| [prometheus/prometheus](./prometheus-prometheus.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 9090 | /metrics |\n| [prometheus/redis](./prometheus-redis.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/redis_exporter.html) | 9121 | /metrics |\n| [gitlab-runner](./gitlab-runner.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 9252 | /metrics |\n\nGitLab Prometheus exporters, Nginx and GitLab Runner must be configured to\nlisten to IP address(es) that include the IP address of the host or docker\ncontainer of the SignalFx Smart Agent. For example, the configuration below\nin `/etc/gitlab/gitlab.rb` configures the GitLab Postgres Prometheus\nexporter to allow network connections on port `9187` from any IP address.\n\n```\npostgres_exporter['listen_address'] = '0.0.0.0:9187'\n```\n\nThe above configuration can also be written as:\n\n```\npostgres_exporter['listen_address'] = ':9187'\n```\n\nBelow is part of file `/var/opt/gitlab/nginx/conf/nginx-status.conf`\nshowing the `location /metrics` block for metric related configuration.\nThis file configures Nginx. The statement `allow 172.17.0.0/16;` allows\nnetwork connection in the `172.17.0.0/16` IP range. The assumption is that\nthe IP address associated with the SignalFx Smart Agent is in that IP\nrange.\n\n```\nserver {\n    ...\n    location /metrics {\n    ...\n    allow 172.17.0.0/16;\n    deny all;\n    }\n}\n```\n\nBelow is part of the global section of `/etc/gitlab-runner/config.toml`. This file configures GitLab Runner. The statement below configures GitLab Runner's Prometheus metrics HTTP server to allows network connection on port `9252` from any IP address.\n\n```\nlisten_address = \"0.0.0.0:9252\"\n...\n\n```\n\n#### Sample Config\n\nTo monitor everything we support in Gitlab, use the following configuration in the Smart Agent config:\n\n```\nmonitors:\n - type: gitlab-unicorn\n   host: localhost\n   port: 8080\n\n - type: gitlab\n   host: localhost\n   port: 9168\n\n - type: gitlab-runner\n   host: localhost\n   port: 9252\n\n - type: gitlab-workhorse\n   host: localhost\n   port: 9229\n\n - type: gitlab-sidekiq\n   host: localhost\n   port: 8082\n\n - type: gitlab-gitaly\n   host: localhost\n   port: 9236\n\n - type: prometheus/postgres\n   host: localhost\n   port: 9187\n\n - type: prometheus/nginx-vts\n   host: localhost\n   port: 8060\n\n```\n\nYou can, of course, use auto-discovery by specifying a `discoveryRule` instead of `host` and `port`.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "ci_stale_builds",
            "gitlab_cache_misses_total",
            "gitlab_database_rows",
            "gitlab_projects_with_jid",
            "gitlab_projects_without_jid",
            "gitlab_stuck_import_jobs_worker_runs_total",
            "http_request_duration_seconds",
            "http_request_duration_seconds_bucket",
            "http_request_duration_seconds_count",
            "pg_stat_table_idx_tup_fetch",
            "pg_stat_table_n_dead_tup",
            "pg_stat_table_n_tup_del",
            "pg_stat_table_n_tup_hot_upd",
            "pg_stat_table_n_tup_ins",
            "pg_stat_table_n_tup_upd",
            "pg_stat_table_seq_scan",
            "pg_stat_table_seq_tup_read",
            "process_age_seconds",
            "process_count",
            "process_memory_bytes",
            "ruby_file_descriptors",
            "ruby_gc_duration_seconds_total",
            "ruby_gc_stat_count",
            "ruby_gc_stat_heap_allocatable_pages",
            "ruby_gc_stat_heap_allocated_pages",
            "ruby_gc_stat_heap_available_slots",
            "ruby_gc_stat_heap_eden_pages",
            "ruby_gc_stat_heap_final_slots",
            "ruby_gc_stat_heap_free_slots",
            "ruby_gc_stat_heap_live_slots",
            "ruby_gc_stat_heap_marked_slots",
            "ruby_gc_stat_heap_sorted_length",
            "ruby_gc_stat_heap_tomb_pages",
            "ruby_gc_stat_major_gc_count",
            "ruby_gc_stat_malloc_increase_bytes",
            "ruby_gc_stat_malloc_increase_bytes_limit",
            "ruby_gc_stat_minor_gc_count",
            "ruby_gc_stat_old_objects",
            "ruby_gc_stat_old_objects_limit",
            "ruby_gc_stat_oldmalloc_increase_bytes",
            "ruby_gc_stat_oldmalloc_increase_bytes_limit",
            "ruby_gc_stat_remembered_wb_unprotected_objects",
            "ruby_gc_stat_remembered_wb_unprotected_objects_limit",
            "ruby_gc_stat_total_allocated_objects",
            "ruby_gc_stat_total_allocated_pages",
            "ruby_gc_stat_total_freed_objects",
            "ruby_gc_stat_total_freed_pages",
            "ruby_memory_bytes",
            "ruby_sampler_duration_seconds_total",
            "sidekiq_dead_jobs_total",
            "sidekiq_queue_latency",
            "sidekiq_queue_size"
          ]
        }
      },
      "metrics": {
        "ci_stale_builds": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_misses_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_database_rows": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_projects_with_jid": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_projects_without_jid": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_stuck_import_jobs_worker_runs_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "http_request_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "http_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "http_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "pg_stat_table_idx_tup_fetch": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "pg_stat_table_n_dead_tup": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "pg_stat_table_n_tup_del": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "pg_stat_table_n_tup_hot_upd": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "pg_stat_table_n_tup_ins": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "pg_stat_table_n_tup_upd": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "pg_stat_table_seq_scan": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "pg_stat_table_seq_tup_read": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "process_age_seconds": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "process_count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "process_memory_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_file_descriptors": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_duration_seconds_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_allocatable_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_allocated_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_available_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_eden_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_final_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_free_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_live_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_marked_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_sorted_length": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_heap_tomb_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_major_gc_count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_malloc_increase_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_malloc_increase_bytes_limit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_minor_gc_count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_old_objects": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_old_objects_limit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_oldmalloc_increase_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_oldmalloc_increase_bytes_limit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_remembered_wb_unprotected_objects": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_remembered_wb_unprotected_objects_limit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_total_allocated_objects": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_total_allocated_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_total_freed_objects": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_gc_stat_total_freed_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_memory_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "ruby_sampler_duration_seconds_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "sidekiq_dead_jobs_total": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "sidekiq_queue_latency": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "sidekiq_queue_size": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/gitlab",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-gitaly",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes the [Gitlab Gitaly GRPC server](https://docs.gitlab.com/ee/administration/gitaly/).  See the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gitaly_authentications",
            "gitaly_connections_total",
            "gitaly_service_client_requests",
            "gitaly_smarthttp_deepen_count",
            "gitaly_spawn_timeout_count",
            "gitaly_supervisor_health_checks",
            "gitaly_supervisor_rss_bytes",
            "gitaly_supervisor_starts_total",
            "gitlab_build_info",
            "grpc_server_handled_total",
            "grpc_server_msg_received_total",
            "grpc_server_msg_sent_total",
            "grpc_server_started_total"
          ]
        }
      },
      "metrics": {
        "gitaly_authentications": {
          "type": "cumulative",
          "description": "Counts of of Gitaly request authentication attempts",
          "group": null,
          "default": false
        },
        "gitaly_connections_total": {
          "type": "cumulative",
          "description": "Total number of connections accepted by this Gitaly process",
          "group": null,
          "default": false
        },
        "gitaly_service_client_requests": {
          "type": "cumulative",
          "description": "Counter of client requests received by client, call_site, auth version, and response code",
          "group": null,
          "default": false
        },
        "gitaly_smarthttp_deepen_count": {
          "type": "cumulative",
          "description": "Number of git-upload-pack requests processed that contained a 'deepen' message",
          "group": null,
          "default": false
        },
        "gitaly_spawn_timeout_count": {
          "type": "cumulative",
          "description": "Number of process spawn timeouts",
          "group": null,
          "default": false
        },
        "gitaly_supervisor_health_checks": {
          "type": "cumulative",
          "description": "Count of Gitaly supervisor health checks",
          "group": null,
          "default": true
        },
        "gitaly_supervisor_rss_bytes": {
          "type": "gauge",
          "description": "Resident set size of supervised processes, in bytes",
          "group": null,
          "default": false
        },
        "gitaly_supervisor_starts_total": {
          "type": "cumulative",
          "description": "Number of starts of supervised processes",
          "group": null,
          "default": false
        },
        "gitlab_build_info": {
          "type": "gauge",
          "description": "Current build info for this GitLab Service",
          "group": null,
          "default": false
        },
        "grpc_server_handled_total": {
          "type": "cumulative",
          "description": "Total number of RPCs completed on the server, regardless of success or failure",
          "group": null,
          "default": true
        },
        "grpc_server_msg_received_total": {
          "type": "cumulative",
          "description": "Total number of RPC stream messages received on the server",
          "group": null,
          "default": false
        },
        "grpc_server_msg_sent_total": {
          "type": "cumulative",
          "description": "Total number of gRPC stream messages sent by the server",
          "group": null,
          "default": false
        },
        "grpc_server_started_total": {
          "type": "cumulative",
          "description": "Total number of RPCs started on the server",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/gitlab",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-runner",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitor for the [Gitlab runner service](https://docs.gitlab.com/runner/).  This usually runs on port 9252, so to monitor an instance on the same host as the agent, you can do:\n\n```yaml\nmonitors:\n- type: gitlab-runner\n  host: localhost\n  port: 9252\n```\n\nFor more information on configuring monitoring within Gitlab runner itself, see https://docs.gitlab.com/runner/monitoring/README.html.\n\nSee the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gitlab_runner_api_request_statuses_total",
            "gitlab_runner_autoscaling_machine_creation_duration_seconds",
            "gitlab_runner_autoscaling_machine_creation_duration_seconds_bucket",
            "gitlab_runner_autoscaling_machine_creation_duration_seconds_count",
            "gitlab_runner_autoscaling_machine_states",
            "gitlab_runner_concurrent",
            "gitlab_runner_errors_total",
            "gitlab_runner_limit",
            "gitlab_runner_request_concurrency",
            "gitlab_runner_request_concurrency_exceeded_total",
            "gitlab_runner_version_info"
          ]
        }
      },
      "metrics": {
        "gitlab_runner_api_request_statuses_total": {
          "type": "cumulative",
          "description": "The total number of API requests, partitioned by runner, endpoint and status",
          "group": null,
          "default": false
        },
        "gitlab_runner_autoscaling_machine_creation_duration_seconds": {
          "type": "cumulative",
          "description": "Histogram of machine creation time",
          "group": null,
          "default": false
        },
        "gitlab_runner_autoscaling_machine_creation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Histogram of machine creation time",
          "group": null,
          "default": false
        },
        "gitlab_runner_autoscaling_machine_creation_duration_seconds_count": {
          "type": "cumulative",
          "description": "Histogram of machine creation time",
          "group": null,
          "default": false
        },
        "gitlab_runner_autoscaling_machine_states": {
          "type": "gauge",
          "description": "The current number of machines per state in this provider",
          "group": null,
          "default": false
        },
        "gitlab_runner_concurrent": {
          "type": "gauge",
          "description": "The current value of concurrent setting",
          "group": null,
          "default": false
        },
        "gitlab_runner_errors_total": {
          "type": "cumulative",
          "description": "The number of catched errors",
          "group": null,
          "default": true
        },
        "gitlab_runner_limit": {
          "type": "gauge",
          "description": "The current value of concurrent setting",
          "group": null,
          "default": false
        },
        "gitlab_runner_request_concurrency": {
          "type": "gauge",
          "description": "The current number of concurrent requests for a new job",
          "group": null,
          "default": true
        },
        "gitlab_runner_request_concurrency_exceeded_total": {
          "type": "cumulative",
          "description": "Counter tracking exceeding of request concurrency",
          "group": null,
          "default": false
        },
        "gitlab_runner_version_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by different build stats fields",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/gitlab",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-sidekiq",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes the Gitlab Sidekiq Prometheus Exporter.  See the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gitaly_controller_action_duration_seconds",
            "gitaly_controller_action_duration_seconds_bucket",
            "gitaly_controller_action_duration_seconds_count",
            "gitlab_cache_misses_total",
            "gitlab_cache_operation_duration_seconds",
            "gitlab_cache_operation_duration_seconds_bucket",
            "gitlab_cache_operation_duration_seconds_count",
            "gitlab_repository_archive_clean_up_real_duration_seconds",
            "gitlab_repository_archive_clean_up_real_duration_seconds_bucket",
            "gitlab_repository_archive_clean_up_real_duration_seconds_count",
            "gitlab_sql_duration_seconds",
            "gitlab_sql_duration_seconds_bucket",
            "gitlab_sql_duration_seconds_count",
            "gitlab_transaction_cache_read_hit_count_total",
            "gitlab_transaction_cache_read_miss_count_total",
            "gitlab_transaction_duration_seconds",
            "gitlab_transaction_duration_seconds_bucket",
            "gitlab_transaction_duration_seconds_count",
            "gitlab_transaction_sidekiq_queue_duration_total"
          ]
        }
      },
      "metrics": {
        "gitaly_controller_action_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitaly_controller_action_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitaly_controller_action_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_misses_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_operation_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_operation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_operation_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_repository_archive_clean_up_real_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_repository_archive_clean_up_real_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_repository_archive_clean_up_real_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_sql_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_sql_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_sql_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_cache_read_hit_count_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_cache_read_miss_count_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_sidekiq_queue_duration_total": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/gitlab",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-unicorn",
      "sendAll": false,
      "dimensions": null,
      "doc": "This is a monitor for GitLab's Unicorn server.  The Unicorn server comes\nwith a Prometheus exporter that runs by default on port 8080 at the path\n`/-/metrics`.  The IP address of the SignalFx Smart Agent container or\nhost, **needs to be whitelisted** as described\n[here](https://docs.gitlab.com/ee/administration/monitoring/ip_whitelist.html)\nin order for the agent to access the endpoint.\n\nTo monitor GitLab's Unicorn server using its Prometheus exporter, use a\nmonitor configuration similar to:\n\n```yaml\nmonitors:\n  - type: gitlab-unicorn\n    discoveryRule: port == 8080  # \u0026\u0026 \u003cother expressions to avoid false-positives on port alone\u003e\n    metricPath: /-/metrics\n```\n\nThe available metrics are [documented by GitLab](https://gitlab.com/gitlab-org/gitlab-ee/blob/master/doc/administration/monitoring/prometheus/gitlab_metrics.md#unicorn-metrics-available).\n\nSee the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gitlab_auth_user_authenticated_total",
            "gitlab_auth_user_unauthenticated_total",
            "gitlab_banzai_cacheless_render_real_duration_seconds",
            "gitlab_banzai_cacheless_render_real_duration_seconds_bucket",
            "gitlab_banzai_cacheless_render_real_duration_seconds_count",
            "gitlab_cache_misses_total",
            "gitlab_cache_operation_duration_seconds",
            "gitlab_cache_operation_duration_seconds_bucket",
            "gitlab_cache_operation_duration_seconds_count",
            "gitlab_rails_queue_duration_seconds",
            "gitlab_rails_queue_duration_seconds_bucket",
            "gitlab_rails_queue_duration_seconds_count",
            "gitlab_sql_duration_seconds",
            "gitlab_sql_duration_seconds_bucket",
            "gitlab_sql_duration_seconds_count",
            "gitlab_transaction_cache_read_hit_count_total",
            "gitlab_transaction_cache_read_miss_count_total",
            "gitlab_transaction_duration_seconds",
            "gitlab_transaction_duration_seconds_bucket",
            "gitlab_transaction_duration_seconds_count",
            "gitlab_transaction_new_redis_connections_total",
            "gitlab_transaction_rails_queue_duration_total",
            "gitlab_transaction_sidekiq_queue_duration_total",
            "gitlab_transaction_view_duration_total",
            "http_requests_total",
            "job_register_attempts_failed_total",
            "job_register_attempts_total",
            "unicorn_active_connections",
            "unicorn_queued_connections",
            "user_session_logins_total"
          ]
        }
      },
      "metrics": {
        "gitlab_auth_user_authenticated_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_auth_user_unauthenticated_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_banzai_cacheless_render_real_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_banzai_cacheless_render_real_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_banzai_cacheless_render_real_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_misses_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_operation_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_operation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_cache_operation_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_rails_queue_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_rails_queue_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_rails_queue_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_sql_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_sql_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_sql_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_cache_read_hit_count_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_cache_read_miss_count_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_new_redis_connections_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_rails_queue_duration_total": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "gitlab_transaction_sidekiq_queue_duration_total": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": true
        },
        "gitlab_transaction_view_duration_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "http_requests_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "job_register_attempts_failed_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "job_register_attempts_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        },
        "unicorn_active_connections": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "unicorn_queued_connections": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "user_session_logins_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/gitlab",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-workhorse",
      "sendAll": false,
      "dimensions": null,
      "doc": "This is a monitor for [GitLab\nWorkhorse](https://gitlab.com/gitlab-org/gitlab-workhorse), the GitLab\nservice that handles slow HTTP requests.  Workhorse includes a built-in\nPrometheus exporter that this monitor will hit to gather metrics.  By\ndefault, the exporter runs on port 9229.\n\nTo monitor Workhorse using its Prometheus exporter, use a monitor configuration similar to:\n\n```yaml\nmonitors:\n  - type: gitlab-workhorse\n    discoveryRule: port == 9229  # \u0026\u0026 \u003cother expressions to avoid false-positives on port alone\u003e\n```\n\nSee the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "gitlab_workhorse_builds_register_handler_open",
            "gitlab_workhorse_builds_register_handler_requests",
            "gitlab_workhorse_git_http_sessions_active",
            "gitlab_workhorse_http_in_flight_requests",
            "gitlab_workhorse_http_request_duration_seconds",
            "gitlab_workhorse_http_request_duration_seconds_bucket",
            "gitlab_workhorse_http_request_duration_seconds_count",
            "gitlab_workhorse_http_request_size_bytes",
            "gitlab_workhorse_http_request_size_bytes_bucket",
            "gitlab_workhorse_http_request_size_bytes_count",
            "gitlab_workhorse_http_requests_total",
            "gitlab_workhorse_http_time_to_write_header_seconds",
            "gitlab_workhorse_http_time_to_write_header_seconds_bucket",
            "gitlab_workhorse_http_time_to_write_header_seconds_count",
            "gitlab_workhorse_internal_api_failure_response_bytes",
            "gitlab_workhorse_keywatcher_keywatchers",
            "gitlab_workhorse_keywather_total_messages",
            "gitlab_workhorse_object_storage_upload_bytes",
            "gitlab_workhorse_object_storage_upload_open",
            "gitlab_workhorse_object_storage_upload_requests",
            "gitlab_workhorse_redis_errors",
            "gitlab_workhorse_redis_total_connections",
            "gitlab_workhorse_send_url_bytes",
            "gitlab_workhorse_send_url_open_requests",
            "gitlab_workhorse_send_url_requests",
            "gitlab_workhorse_static_error_responses"
          ]
        }
      },
      "metrics": {
        "gitlab_workhorse_builds_register_handler_open": {
          "type": "gauge",
          "description": "Describes how many requests is currently open in given state",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_builds_register_handler_requests": {
          "type": "cumulative",
          "description": "Describes how many requests in different states hit a register handler",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_git_http_sessions_active": {
          "type": "gauge",
          "description": "Number of Git HTTP request-response cycles currently being handled by gitlab-workhorse",
          "group": null,
          "default": true
        },
        "gitlab_workhorse_http_in_flight_requests": {
          "type": "gauge",
          "description": "A gauge of requests currently being served by workhorse",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_http_request_duration_seconds": {
          "type": "cumulative",
          "description": "A histogram of latencies for requests to workhorse",
          "group": null,
          "default": true
        },
        "gitlab_workhorse_http_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "A histogram of latencies for requests to workhorse",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_http_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "A histogram of latencies for requests to workhorse",
          "group": null,
          "default": true
        },
        "gitlab_workhorse_http_request_size_bytes": {
          "type": "cumulative",
          "description": "A histogram of sizes of requests to workhorse",
          "group": null,
          "default": true
        },
        "gitlab_workhorse_http_request_size_bytes_bucket": {
          "type": "cumulative",
          "description": "A histogram of sizes of requests to workhorse",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_http_request_size_bytes_count": {
          "type": "cumulative",
          "description": "A histogram of sizes of requests to workhorse",
          "group": null,
          "default": true
        },
        "gitlab_workhorse_http_requests_total": {
          "type": "cumulative",
          "description": "A counter for requests to workhorse",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_http_time_to_write_header_seconds": {
          "type": "cumulative",
          "description": "A histogram of request durations until the response headers are written",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_http_time_to_write_header_seconds_bucket": {
          "type": "cumulative",
          "description": "A histogram of request durations until the response headers are written",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_http_time_to_write_header_seconds_count": {
          "type": "cumulative",
          "description": "A histogram of request durations until the response headers are written",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_internal_api_failure_response_bytes": {
          "type": "cumulative",
          "description": "How many bytes have been returned by upstream GitLab in API failure/rejection response bodies",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_keywatcher_keywatchers": {
          "type": "gauge",
          "description": "The number of keys that is being watched by gitlab-workhorse",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_keywather_total_messages": {
          "type": "cumulative",
          "description": "How many messages gitlab-workhorse has received in total on pubsub",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_object_storage_upload_bytes": {
          "type": "cumulative",
          "description": "How many bytes were sent to object storage",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_object_storage_upload_open": {
          "type": "gauge",
          "description": "Describes many object storage requests are open now",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_object_storage_upload_requests": {
          "type": "cumulative",
          "description": "How many object storage requests have been processed",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_redis_errors": {
          "type": "cumulative",
          "description": "Counts different types of Redis errors encountered by workhorse, by type and destination (redis, sentinel)",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_redis_total_connections": {
          "type": "cumulative",
          "description": "How many connections gitlab-workhorse has opened in total. Can be used to track Redis connection rate for this process",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_send_url_bytes": {
          "type": "cumulative",
          "description": "How many bytes were passed with send URL",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_send_url_open_requests": {
          "type": "gauge",
          "description": "Describes how many send URL requests are open now",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_send_url_requests": {
          "type": "cumulative",
          "description": "How many send URL requests have been processed",
          "group": null,
          "default": false
        },
        "gitlab_workhorse_static_error_responses": {
          "type": "cumulative",
          "description": "How many HTTP responses have been changed to a static error page, by HTTP status code.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/gitlab",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "haproxy",
      "sendAll": false,
      "dimensions": {
        "process_id": {
          "description": "A number assigned to an HAProxy process instance (1 for first instance, 2 for second, ...)."
        },
        "proxy_name": {
          "description": "HAProxy configured proxy name. Possible values for listeners, frontends, backends, and servers."
        },
        "server_id": {
          "description": "Server id (unique inside a proxy)"
        },
        "service_name": {
          "description": "HAProxy configured service name. Possible values are FRONTEND for frontend, BACKEND for backend, configured name for server/listener."
        },
        "type": {
          "description": "Proxy type id (0=frontend, 1=backend, 2=server, 3=socket/listener)."
        },
        "unique_proxy_id": {
          "description": "A unique proxy id"
        }
      },
      "doc": "This monitor scrapes [HAProxy](http://www.haproxy.org/) statistics (i.e. metrics) from a configured\nHTTP endpoint or UNIX socket. It requires HAProxy 1.8+ and supports scraping metrics for HAProxy running in\nmulti-process mode. In multi-process mode, HAProxy must be configured to enable stats on different URLs/socket\npaths for the processes and for each URL/path a monitor instance needs to be defined and configured.\n\n\u003c!--- SETUP ---\u003e\n### HTTP Endpoint Config\nHAProxy stats must be enabled as described [here](https://www.haproxy.com/blog/exploring-the-haproxy-stats-page/).\nDefine the HAProxy monitor in the agent configuration file and provide the `csv export` URL where HAProxy\nstats are served in CSV format. This monitor supports basic HTTP authentication. Simply provide the\nusername and password. In multi-process mode, declare and configure monitors for each stats HTTP endpoint. Below\nbelow is an example showing stats enable on 2 URLs.\n```\n...\nmonitors:\n  - type: haproxy\n    url: \"http://localhost:8404/stats?stats;csv\"\n    username: \"your username here\"\n    password: \"your password here\"\n  - type: haproxy\n    url: \"http://localhost:6000/stats?stats;csv\"\n...\n```\nNote: Only stats pertaining to the configured proxies (i.e. listeners, frontends, backends, and servers)\nare available from the HTTP url. HAProxy process level stats given by command [show info](https://cbonte.github.io/haproxy-dconv/1.8/management.html#9.3-show%20info)\nare not available. The `show info` stats can only be scraped from a UNIX socket.\n\n### UNIX Socket Config\nThe location of the HAProxy socket file is defined in the HAProxy config file. For example:\n```\nglobal\n    daemon\n    stats socket /var/run/haproxy.sock\n    stats timeout 2m\n```\nFor the above location of the socket file, configure the monitor URL as shown below:\n```\n...\nmonitors:\n  - type: haproxy\n    url: \"unix:///var/run/haproxy.sock\"\n...\n```\nNote: The agent process needs read/write permissions to the HAProxy socket file.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "haproxy_active_servers",
            "haproxy_backup_servers",
            "haproxy_bytes_in",
            "haproxy_bytes_out",
            "haproxy_check_duration",
            "haproxy_client_aborts",
            "haproxy_compress_bits_per_second_in",
            "haproxy_compress_bits_per_second_out",
            "haproxy_compress_bypass",
            "haproxy_compress_in",
            "haproxy_compress_out",
            "haproxy_compress_responses",
            "haproxy_connection_rate",
            "haproxy_connection_rate_all",
            "haproxy_connection_rate_max",
            "haproxy_connection_total",
            "haproxy_connections",
            "haproxy_current_connections",
            "haproxy_current_ssl_connections",
            "haproxy_denied_request",
            "haproxy_denied_response",
            "haproxy_denied_tcp_connections",
            "haproxy_denied_tcp_sessions",
            "haproxy_downtime",
            "haproxy_error_connections",
            "haproxy_error_request",
            "haproxy_error_response",
            "haproxy_failed_checks",
            "haproxy_idle_percent",
            "haproxy_intercepted_requests",
            "haproxy_last_session",
            "haproxy_max_connection_rate",
            "haproxy_max_connections",
            "haproxy_max_pipes",
            "haproxy_max_session_rate",
            "haproxy_max_ssl_connections",
            "haproxy_pipes_free",
            "haproxy_pipes_used",
            "haproxy_queue_current",
            "haproxy_queue_limit",
            "haproxy_queue_max",
            "haproxy_queue_time_average",
            "haproxy_redispatched",
            "haproxy_request_rate",
            "haproxy_request_rate_max",
            "haproxy_request_total",
            "haproxy_requests",
            "haproxy_response_1xx",
            "haproxy_response_2xx",
            "haproxy_response_3xx",
            "haproxy_response_4xx",
            "haproxy_response_5xx",
            "haproxy_response_other",
            "haproxy_response_time_average",
            "haproxy_retries",
            "haproxy_run_queue",
            "haproxy_server_aborts",
            "haproxy_server_selected_total",
            "haproxy_session_current",
            "haproxy_session_rate",
            "haproxy_session_rate_all",
            "haproxy_session_rate_limit",
            "haproxy_session_rate_max",
            "haproxy_session_time_average",
            "haproxy_session_total",
            "haproxy_ssl_backend_key_rate",
            "haproxy_ssl_cache_lookups",
            "haproxy_ssl_cache_misses",
            "haproxy_ssl_connections",
            "haproxy_ssl_frontend_key_rate",
            "haproxy_ssl_rate",
            "haproxy_status",
            "haproxy_tasks",
            "haproxy_throttle",
            "haproxy_uptime_seconds",
            "haproxy_zlib_memory_usage"
          ]
        }
      },
      "metrics": {
        "haproxy_active_servers": {
          "type": "gauge",
          "description": "Number of active servers (backend), server is active (server). Values reported for backends and servers.",
          "group": null,
          "default": false
        },
        "haproxy_backup_servers": {
          "type": "gauge",
          "description": "Number of backup servers (backend), server is backup (server). Values reported for backends and servers.",
          "group": null,
          "default": false
        },
        "haproxy_bytes_in": {
          "type": "cumulative",
          "description": "Total number of incoming bytes. Values reported for listeners, frontends, backends, and servers.",
          "group": null,
          "default": true
        },
        "haproxy_bytes_out": {
          "type": "cumulative",
          "description": "Total number of outgoing bytes. Values reported for listeners, frontends, backends, and servers.",
          "group": null,
          "default": true
        },
        "haproxy_check_duration": {
          "type": "gauge",
          "description": "Time in ms took to finish last health check. Values reported for servers.",
          "group": null,
          "default": false
        },
        "haproxy_client_aborts": {
          "type": "cumulative",
          "description": "Number of data transfers aborted by the client. Values reported for backends and servers.",
          "group": null,
          "default": false
        },
        "haproxy_compress_bits_per_second_in": {
          "type": "cumulative",
          "description": "Corresponds to the HAProxy process `CompressBpsIn` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_compress_bits_per_second_out": {
          "type": "cumulative",
          "description": "Corresponds to the HAProxy process `CompressBpsOut` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_compress_bypass": {
          "type": "cumulative",
          "description": "Number of bytes that bypassed the HTTP compressor (CPU/BW limit). Values reported for frontends and backends.",
          "group": null,
          "default": false
        },
        "haproxy_compress_in": {
          "type": "cumulative",
          "description": "Number of HTTP response bytes fed to the compressor. Values reported for frontends and backends.",
          "group": null,
          "default": false
        },
        "haproxy_compress_out": {
          "type": "cumulative",
          "description": "Number of HTTP response bytes emitted by the compressor. Values reported for frontends and backends.",
          "group": null,
          "default": false
        },
        "haproxy_compress_responses": {
          "type": "cumulative",
          "description": "Number of HTTP responses that were compressed. Values reported for frontends and backends.",
          "group": null,
          "default": false
        },
        "haproxy_connection_rate": {
          "type": "gauge",
          "description": "Number of connections over the last elapsed second. Values reported for frontends.",
          "group": null,
          "default": false
        },
        "haproxy_connection_rate_all": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `ConnRate` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": true
        },
        "haproxy_connection_rate_max": {
          "type": "gauge",
          "description": "Highest known conn_rate. Values reported for frontends.",
          "group": null,
          "default": false
        },
        "haproxy_connection_total": {
          "type": "cumulative",
          "description": "Cumulative number of connections. Values reported for frontends.",
          "group": null,
          "default": false
        },
        "haproxy_connections": {
          "type": "cumulative",
          "description": "Corresponds to the HAProxy process `CumConns` value given by the `show info` command issued over UNIX socket. Cumulative number of connections.",
          "group": null,
          "default": false
        },
        "haproxy_current_connections": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `CurrConns` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_current_ssl_connections": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `CurrSslConns` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_denied_request": {
          "type": "cumulative",
          "description": "Number of requests denied because of security concerns. For tcp this is because of a matched tcp-request content rule. For http this is because of a matched http-request or tarpit rule. Values reported for listeners, frontends, and backends.",
          "group": null,
          "default": true
        },
        "haproxy_denied_response": {
          "type": "cumulative",
          "description": "Number of responses denied because of security concerns. For http this is because of a matched http-request rule, or \"option checkcache\". Values reported for listeners, frontends, backends, and servers.",
          "group": null,
          "default": true
        },
        "haproxy_denied_tcp_connections": {
          "type": "gauge",
          "description": "Requests denied by \"tcp-request connection\" rules. Values reported for listeners and frontends.",
          "group": null,
          "default": false
        },
        "haproxy_denied_tcp_sessions": {
          "type": "gauge",
          "description": "Requests denied by \"tcp-request session\" rules. Values reported for listeners and frontends.",
          "group": null,
          "default": false
        },
        "haproxy_downtime": {
          "type": "cumulative",
          "description": "Total downtime (in seconds). The value for the backend is the downtime for the whole backend, not the sum of the server downtime. Values reported for backends and servers.",
          "group": null,
          "default": false
        },
        "haproxy_error_connections": {
          "type": "cumulative",
          "description": "Number of requests that encountered an error trying to connect to a backend server. The backend stat is the sum of the stat for all servers of that backend, plus any connection errors not associated with a particular server (such as the backend having no active servers). Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_error_request": {
          "type": "cumulative",
          "description": "Number of request errors. Some of the possible causes are: early termination from the client, before the request has been sent, read error from the client, client timeout, client closed connection, various bad requests from the client, request was tarpitted. Values reported for listeners and frontends.",
          "group": null,
          "default": true
        },
        "haproxy_error_response": {
          "type": "cumulative",
          "description": "Number of response errors. haproxy_server_aborts will be counted here also. Some other errors are: write error on the client socket (won't be counted for the server stat), failure applying filters to the response. Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_failed_checks": {
          "type": "cumulative",
          "description": "Number of failed checks. (Only counts checks failed when the server is up.). Values reported for servers.",
          "group": null,
          "default": false
        },
        "haproxy_idle_percent": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `Idle_pct` value given by the `show info` command issued over UNIX socket. Ratio of system polling time versus total time.",
          "group": null,
          "default": true
        },
        "haproxy_intercepted_requests": {
          "type": "gauge",
          "description": "Cumulative number of intercepted requests (monitor, stats). Values reported for frontends and backends.",
          "group": null,
          "default": false
        },
        "haproxy_last_session": {
          "type": "gauge",
          "description": "Number of seconds since last session assigned to server/backend. Values reported for backends and servers.",
          "group": null,
          "default": false
        },
        "haproxy_max_connection_rate": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `MaxConnRate` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_max_connections": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `MaxConn` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_max_pipes": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `MaxPipes` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_max_session_rate": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `MaxSessRate` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_max_ssl_connections": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `MaxSslConns` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_pipes_free": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `PipesFree` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_pipes_used": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `PipesUsed` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_queue_current": {
          "type": "gauge",
          "description": "Number of current queued requests. For the backend this reports the number queued without a server assigned. Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_queue_limit": {
          "type": "gauge",
          "description": "Configured maxqueue for the server, or nothing in the value is 0 (default, meaning no limit). Values reported for servers.",
          "group": null,
          "default": false
        },
        "haproxy_queue_max": {
          "type": "gauge",
          "description": "The max value of qcur. Values reported for backends and servers.",
          "group": null,
          "default": false
        },
        "haproxy_queue_time_average": {
          "type": "gauge",
          "description": "The average queue time in ms over the 1024 last requests. Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_redispatched": {
          "type": "cumulative",
          "description": "Number of times a request was redispatched to another server. The server value counts the number of times that server was switched away from. Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_request_rate": {
          "type": "gauge",
          "description": "HTTP requests per second over last elapsed second. Values reported for frontends.",
          "group": null,
          "default": true
        },
        "haproxy_request_rate_max": {
          "type": "gauge",
          "description": "Max number of HTTP requests per second observed. Values reported for frontends.",
          "group": null,
          "default": false
        },
        "haproxy_request_total": {
          "type": "cumulative",
          "description": "Total number of HTTP requests received. Values reported for frontends and backends.",
          "group": null,
          "default": false
        },
        "haproxy_requests": {
          "type": "cumulative",
          "description": "Corresponds to the HAProxy process `CumReq` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": true
        },
        "haproxy_response_1xx": {
          "type": "cumulative",
          "description": "HTTP responses with 1xx code. Values reported for frontends, backends, and servers.",
          "group": null,
          "default": false
        },
        "haproxy_response_2xx": {
          "type": "cumulative",
          "description": "HTTP responses with 2xx code. Values reported for frontends, backends, and servers.",
          "group": null,
          "default": true
        },
        "haproxy_response_3xx": {
          "type": "cumulative",
          "description": "HTTP responses with 3xx code. Values reported for frontends, backends, and servers.",
          "group": null,
          "default": false
        },
        "haproxy_response_4xx": {
          "type": "cumulative",
          "description": "HTTP responses with 4xx code. Values reported for frontends, backends, and servers.",
          "group": null,
          "default": true
        },
        "haproxy_response_5xx": {
          "type": "cumulative",
          "description": "HTTP responses with 5xx code. Values reported for frontends, backends, and servers.",
          "group": null,
          "default": true
        },
        "haproxy_response_other": {
          "type": "cumulative",
          "description": "HTTP responses with other codes (protocol error). Values reported for frontends, backends, and servers.",
          "group": null,
          "default": false
        },
        "haproxy_response_time_average": {
          "type": "gauge",
          "description": "The average response time in ms over the 1024 last requests (0 for TCP). Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_retries": {
          "type": "cumulative",
          "description": "Number of times a connection to a server was retried. Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_run_queue": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `Run_queue` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_server_aborts": {
          "type": "cumulative",
          "description": "Number of data transfers aborted by the server (inc. in eresp). Values reported for backends and servers.",
          "group": null,
          "default": false
        },
        "haproxy_server_selected_total": {
          "type": "cumulative",
          "description": "Total number of times a server was selected, either for new sessions, or when re-dispatching. The server counter is the number of times that server was selected. Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_session_current": {
          "type": "gauge",
          "description": "Number current sessions. Values reported for listeners, frontends, backends, and servers.",
          "group": null,
          "default": true
        },
        "haproxy_session_rate": {
          "type": "gauge",
          "description": "Number of sessions per second over last elapsed second. Values reported for frontends, backends, and servers.",
          "group": null,
          "default": true
        },
        "haproxy_session_rate_all": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `SessRate` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": true
        },
        "haproxy_session_rate_limit": {
          "type": "gauge",
          "description": "Configured limit on new sessions per second. Values reported for frontends.",
          "group": null,
          "default": false
        },
        "haproxy_session_rate_max": {
          "type": "gauge",
          "description": "Max number of new sessions per second. Values reported for frontends, backends, and servers.",
          "group": null,
          "default": false
        },
        "haproxy_session_time_average": {
          "type": "gauge",
          "description": "The average total session time in ms over the 1024 last requests. Values reported for backends and servers.",
          "group": null,
          "default": true
        },
        "haproxy_session_total": {
          "type": "cumulative",
          "description": "The cumulative number of sessions. Values reported for listeners, frontends, backends, and servers.",
          "group": null,
          "default": false
        },
        "haproxy_ssl_backend_key_rate": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `SslBackendKeyRate` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_ssl_cache_lookups": {
          "type": "cumulative",
          "description": "Corresponds to the HAProxy process `SslCacheLookups` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_ssl_cache_misses": {
          "type": "cumulative",
          "description": "Corresponds to the HAProxy process `SslCacheMisses` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_ssl_connections": {
          "type": "cumulative",
          "description": "Corresponds to the HAProxy process `CumSslConns` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_ssl_frontend_key_rate": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `SslFrontendKeyRate` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_ssl_rate": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `SslRate` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_status": {
          "type": "gauge",
          "description": "HAProxy status values derived from the status stat. Status stat values `UP`, `UP 1/3`, `UP 2/3`, `OPEN` and `no check` are assigned 1. Values `DOWN`, `DOWN 1/2`, `NOLB` and `MAINT` are assigned 0. Values reported for listeners, frontends, backends and servers.",
          "group": null,
          "default": false
        },
        "haproxy_tasks": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `Tasks` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_throttle": {
          "type": "gauge",
          "description": "Current throttle percentage for the server, when slowstart is active, or no value if not in slowstart. Values reported for servers.",
          "group": null,
          "default": false
        },
        "haproxy_uptime_seconds": {
          "type": "cumulative",
          "description": "Corresponds to the HAProxy process `Uptime_sec` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        },
        "haproxy_zlib_memory_usage": {
          "type": "gauge",
          "description": "Corresponds to the HAProxy process `ZlibMemUsage` value given by the `show info` command issued over UNIX socket.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the config for this monitor.",
        "package": "pkg/monitors/haproxy",
        "fields": [
          {
            "yamlName": "host",
            "doc": "The host/ip address of the HAProxy instance. This is used to construct the `url` option if not provided.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "The port of the HAProxy instance's stats endpoint (if using HTTP). This is used to construct the `url` option if not provided.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "path",
            "doc": "The path to HAProxy stats. The default is `stats?stats;csv`. This is used to construct the `url` option if not provided.",
            "default": "stats?stats;csv",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "Whether to connect on HTTPS or HTTP. If you want to use a UNIX socket, then specify the `url` config option with the format `unix://...` and omit `host`, `port` and `useHTTPS`.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "url",
            "doc": "URL on which to scrape HAProxy. Scheme `http://` for http-type and `unix://` socket-type urls. If this is not provided, it will be derive from the `host`, `port`, `path`, and `useHTTPS` options.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslVerify",
            "doc": "Flag that enables SSL certificate verification for the scrape URL.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timeout",
            "doc": "Timeout for trying to get stats from HAProxy. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "5s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "proxies",
            "doc": "A list of the pxname(s) and svname(s) to monitor (e.g. `[\"http-in\", \"server1\", \"backend\"]`). If empty then metrics for all proxies will be reported.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "heroku-metadata",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor collects metadata from a Heroku dyno and syncs them as properties\nto `dyno_id` dimension, which is synced by datapoints emitted by the\n[Heroku SignalFx Collector (https://github.com/signalfx/heroku-signalfx-collector).\n\nMetadata on Heroku dyno's need to be enabled explicitly. For information about this,\nsee [here] (https://devcenter.heroku.com/articles/dyno-metadata).\n",
      "groups": {},
      "metrics": null,
      "properties": {
        "heroku_app_id": {
          "dimension": "dyno_id",
          "description": "The unique identifier for the application"
        },
        "heroku_app_name": {
          "dimension": "dyno_id",
          "description": "The application name"
        },
        "heroku_release_creation_timestamp": {
          "dimension": "dyno_id",
          "description": "The time and date the release was createde"
        },
        "heroku_release_version": {
          "dimension": "dyno_id",
          "description": "The identifier for the current release"
        },
        "heroku_slug_commit": {
          "dimension": "dyno_id",
          "description": "The commit hash for the current release"
        }
      },
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/heroku",
        "fields": []
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "host-metadata",
      "sendAll": false,
      "dimensions": {
        "collectd": {
          "description": "The version of collectd in the signalfx-agent"
        },
        "kernel_name": {
          "description": "The name of the host kernel."
        },
        "kernel_release": {
          "description": "The release of the host kernel."
        },
        "kernel_version": {
          "description": "The version of the host kernel."
        },
        "os_version": {
          "description": "The version of the os on the host."
        },
        "signalfx_agent": {
          "description": "The version of the signalfx-agent"
        }
      },
      "doc": "This monitor collects metadata properties about a\nhost.  It is required for some views in SignalFx to operate.\n\n```yaml\nmonitors:\n  - type: host-metadata\n```\n\nIn containerized environments host `/etc` and `/proc` may not be located\ndirectly under the root path.  You can specify the path to `proc` and `etc`\nusing the top level agent configurations `procPath` and `etcPath`\n\n```yaml\nprocPath: /proc\netcPath: /etc\nmonitors:\n  - type: host-metadata\n```\n\nMetadata updates occur on a sparse interval of approximately\n1m, 1m, 1h, 1d and continues repeating once per day.\nSetting the `Interval` configuration for this monitor will not affect the\nsparse interval on which metadata is collected.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "sfxagent.hostmetadata"
          ]
        }
      },
      "metrics": {
        "sfxagent.hostmetadata": {
          "type": "gauge",
          "description": "The time the hostmetadata monitor has been running in seconds.  It includes dimensional metadata about the host and agent.",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/metadata/hostmetadata",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "internal-metrics",
      "sendAll": false,
      "dimensions": null,
      "doc": "Emits metrics about the internal state of the\nagent.  Useful for debugging performance issues with the agent and to ensure\nthe agent isn't overloaded.\n\nThis can also scrape any HTTP endpoint that exposes metrics as a JSON array\ncontaining JSON-formatted SignalFx datapoint objects.  It is roughly\nanalogous to the `prometheus-exporter` monitor except for SignalFx\ndatapoints.\n\n```yaml\nmonitors:\n  - type: internal-metrics\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "sfxagent.active_monitors",
            "sfxagent.active_observers",
            "sfxagent.configured_monitors",
            "sfxagent.datapoint_channel_len",
            "sfxagent.datapoint_requests_active",
            "sfxagent.datapoints_failed",
            "sfxagent.datapoints_filtered",
            "sfxagent.datapoints_in_flight",
            "sfxagent.datapoints_received",
            "sfxagent.datapoints_sent",
            "sfxagent.datapoints_waiting",
            "sfxagent.dim_request_senders",
            "sfxagent.dim_updates_completed",
            "sfxagent.dim_updates_currently_delayed",
            "sfxagent.dim_updates_dropped",
            "sfxagent.dim_updates_failed",
            "sfxagent.dim_updates_flappy_total",
            "sfxagent.dim_updates_started",
            "sfxagent.discovered_endpoints",
            "sfxagent.events_buffered",
            "sfxagent.events_sent",
            "sfxagent.go_frees",
            "sfxagent.go_heap_alloc",
            "sfxagent.go_heap_idle",
            "sfxagent.go_heap_inuse",
            "sfxagent.go_heap_released",
            "sfxagent.go_heap_sys",
            "sfxagent.go_mallocs",
            "sfxagent.go_next_gc",
            "sfxagent.go_num_gc",
            "sfxagent.go_stack_inuse",
            "sfxagent.go_total_alloc",
            "sfxgent.go_num_goroutine"
          ]
        }
      },
      "metrics": {
        "sfxagent.active_monitors": {
          "type": "gauge",
          "description": "The total number of monitor instances actively working",
          "group": null,
          "default": true
        },
        "sfxagent.active_observers": {
          "type": "gauge",
          "description": "The number of observers configured and running",
          "group": null,
          "default": true
        },
        "sfxagent.configured_monitors": {
          "type": "gauge",
          "description": "The total number of monitor configurations",
          "group": null,
          "default": true
        },
        "sfxagent.datapoint_channel_len": {
          "type": "gauge",
          "description": "The total number of datapoints that have been emitted by monitors but have yet to be accepted by the writer. This number should be 0 most of the time.  This will max out at 3000, at which point no datapoints will be generated by monitors.  If it does max out, it indicates a bug or extreme CPU starvation of the agent.",
          "group": null,
          "default": true
        },
        "sfxagent.datapoint_requests_active": {
          "type": "gauge",
          "description": "The total number of outstanding requests to ingest currently active.  If this is consistently hovering around the `writer.maxRequests` setting, that setting should probably be increased to give the agent more bandwidth to send datapoints.",
          "group": null,
          "default": true
        },
        "sfxagent.datapoints_failed": {
          "type": "cumulative",
          "description": "The total number of datapoints that tried to be sent but could not be\nby the agent writer since it last started.  This can be due to network\nfailures or an incorrect access token, among other things.\n",
          "group": null,
          "default": true
        },
        "sfxagent.datapoints_filtered": {
          "type": "cumulative",
          "description": "The total number of datapoints that were filtered out in the writer.  This does not include datapoints filtered by monitor-specific filters.",
          "group": null,
          "default": true
        },
        "sfxagent.datapoints_in_flight": {
          "type": "gauge",
          "description": "The total number of datapoints that have been sent out in a request to ingest but have yet to receive confirmation from ingest that they have been received (i.e. the HTTP response hasn't been gotten).",
          "group": null,
          "default": true
        },
        "sfxagent.datapoints_received": {
          "type": "cumulative",
          "description": "The total number of non-filtered datapoints received by the agent writer since it last started.  This number should generally equal `sfxagent.datapoints_sent + sfxagent.datapoints_waiting + sfxagent.datapoints_in_flight`, although sampling timing issues might cause it to temporarily not be.",
          "group": null,
          "default": true
        },
        "sfxagent.datapoints_sent": {
          "type": "cumulative",
          "description": "The total number of datapoints sent by the agent writer since it last started",
          "group": null,
          "default": true
        },
        "sfxagent.datapoints_waiting": {
          "type": "gauge",
          "description": "The total number of datapoints that have been accepted by the writer but have yet to be sent out to ingest over HTTP.  If this continues to grow it indicates that datapoints are not being sent out fast enough and the `writer.maxRequests` setting should be increased.",
          "group": null,
          "default": true
        },
        "sfxagent.dim_request_senders": {
          "type": "gauge",
          "description": "Current number of worker goroutines active that can send dimension updates.",
          "group": null,
          "default": true
        },
        "sfxagent.dim_updates_completed": {
          "type": "cumulative",
          "description": "Total number of dimension property updates successfully completed",
          "group": null,
          "default": true
        },
        "sfxagent.dim_updates_currently_delayed": {
          "type": "gauge",
          "description": "Current number of dimension updates that are being delayed to avoid sending spurious updates due to flappy dimension property sets.",
          "group": null,
          "default": true
        },
        "sfxagent.dim_updates_dropped": {
          "type": "cumulative",
          "description": "Total number of dimension property updates that were dropped, due to an overfull buffer of dimension updates pending.",
          "group": null,
          "default": true
        },
        "sfxagent.dim_updates_failed": {
          "type": "cumulative",
          "description": "Total number of dimension property updates that failed for some reason.  The failures should be logged.",
          "group": null,
          "default": true
        },
        "sfxagent.dim_updates_flappy_total": {
          "type": "cumulative",
          "description": "Total number of dimension property updates that ended up replacing a dimension property set that was being delayed.",
          "group": null,
          "default": true
        },
        "sfxagent.dim_updates_started": {
          "type": "cumulative",
          "description": "Total number of dimension property updates requests started, but not necessarily completed or failed.",
          "group": null,
          "default": true
        },
        "sfxagent.discovered_endpoints": {
          "type": "gauge",
          "description": "The number of discovered service endpoints.  This includes endpoints that do not have any matching monitor configuration discovery rule.",
          "group": null,
          "default": true
        },
        "sfxagent.events_buffered": {
          "type": "gauge",
          "description": "The total number of events that have been emitted by monitors but have yet to be sent to SignalFx",
          "group": null,
          "default": true
        },
        "sfxagent.events_sent": {
          "type": "cumulative",
          "description": "The total number of events sent by the agent since it last started",
          "group": null,
          "default": true
        },
        "sfxagent.go_frees": {
          "type": "cumulative",
          "description": "Total number of heap objects freed throughout the lifetime of the agent",
          "group": null,
          "default": true
        },
        "sfxagent.go_heap_alloc": {
          "type": "gauge",
          "description": "Bytes of live heap memory (memory that has been allocated but not freed)",
          "group": null,
          "default": true
        },
        "sfxagent.go_heap_idle": {
          "type": "gauge",
          "description": "Bytes of memory that consist of idle spans (that is, completely empty spans of memory)",
          "group": null,
          "default": true
        },
        "sfxagent.go_heap_inuse": {
          "type": "gauge",
          "description": "Size in bytes of in use spans",
          "group": null,
          "default": true
        },
        "sfxagent.go_heap_released": {
          "type": "gauge",
          "description": "Bytes of memory that have been returned to the OS.  This is quite often 0.  `sfxagent.go_heap_idle - sfxagent.go_heap_release` is the memory that Go is retaining for future heap allocations.",
          "group": null,
          "default": true
        },
        "sfxagent.go_heap_sys": {
          "type": "gauge",
          "description": "Virtual memory size in bytes of the agent.  This will generally reflect the largest heap size the agent has ever had in its lifetime.",
          "group": null,
          "default": true
        },
        "sfxagent.go_mallocs": {
          "type": "cumulative",
          "description": "Total number of heap objects allocated throughout the lifetime of the agent",
          "group": null,
          "default": true
        },
        "sfxagent.go_next_gc": {
          "type": "gauge",
          "description": "The target heap size -- GC tries to keep the heap smaller than this",
          "group": null,
          "default": true
        },
        "sfxagent.go_num_gc": {
          "type": "gauge",
          "description": "The number of GC cycles that have happened in the agent since it started",
          "group": null,
          "default": true
        },
        "sfxagent.go_stack_inuse": {
          "type": "gauge",
          "description": "Size in bytes of spans that have at least one goroutine stack in them",
          "group": null,
          "default": true
        },
        "sfxagent.go_total_alloc": {
          "type": "cumulative",
          "description": "Total number of bytes allocated to the heap throughout the lifetime of the agent",
          "group": null,
          "default": true
        },
        "sfxgent.go_num_goroutine": {
          "type": "gauge",
          "description": "Number of goroutines in the agent",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for internal metric monitoring",
        "package": "pkg/monitors/internalmetrics",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Defaults to the top-level `internalStatusHost` option",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Defaults to the top-level `internalStatusPort` option",
            "default": null,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "path",
            "doc": "The HTTP request path to use to retrieve the metrics",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "jaeger-grpc",
      "sendAll": false,
      "dimensions": null,
      "doc": "Runs a GRPC server that listens for Jaeger trace batches\nand forwards them to SignalFx (or the configured ingest host in the\n`writer` section of the agent config).  By default, the server listens on\nlocalhost port 14250 but can be configured to anything.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/jaegergrpc",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host:port on which to listen for traces.",
            "default": "0.0.0.0:14250",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tls",
            "doc": "TLS are optional tls credential settings to configure the GRPC server with",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "TLSCreds",
              "doc": "TLSCreds is a configuration struct for specifying a cert file and key file for tls",
              "package": "pkg/monitors/jaegergrpc",
              "fields": [
                {
                  "yamlName": "certFile",
                  "doc": "The cert file to use for tls",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "keyFile",
                  "doc": "The key file to use for tls",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "java-monitor",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor allows you to generate metrics from a Java application.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config specifies configurations that are specific to the individual Java based monitor",
        "package": "pkg/monitors/subproc/signalfx/java",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host will be filled in by auto-discovery if this monitor has a discovery rule.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port will be filled in by auto-discovery if this monitor has a discovery rule.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "jarFilePath",
            "doc": "Path to the .jar file that implements the monitoring logic.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "javaBinary",
            "doc": "By default, the agent will use its bundled Java runtime (Java 8) If you wish to use a Java runtime that already exists on the system, specify the full path to the `java` binary here, e.g. `/usr/bin/java`.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "mainClass",
            "doc": "The class within the specified `jarFilePath` that contains a main method to execute.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "classPath",
            "doc": "Additional class paths to set on the invoked Java subprocess.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "extraJavaArgs",
            "doc": "Additional flags to the Java subprocess",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "jmx",
      "sendAll": false,
      "dimensions": null,
      "doc": "This montior allows you to run an arbitrary Groovy script to convert JMX\nMBeans fetched from a remote Java application to SignalFx datapoints.\nThis is a much more powerful and flexible alternative to the\n[collectd/genericjmx](./collectd-genericjmx.md) monitor.\n\nThe following utility helpers are available to use in the Groovy script\nwithin the `util` variable that will be set in the script's context:\n\n- `util.queryJMX(String objectName)`: This helper will\n  query the pre-configured JMX application for the given `objectName`,\n  which can include wildcards.  In any case, the return value will be a\n  `List` of zero or more `GroovyMBean` objects, which are a convenience\n  wrapper that Groovy provides to make accessing attribute on the MBean\n  simple. See http://groovy-lang.org/jmx.html for more information about\n  the `GroovyMBean` object.  You can use the Groovy `.first()` method on\n  the returned list to access the first MBean is you are only expecting\n  one.\n\n- `util.makeGauge(String name, double val, Map\u003cString, String\u003e\n  dimensions)`: A convenience function to create a SignalFx gauge\n  datapoint. This creates a `DataPoint` instance that can be fed to\n  `output.sendDatapoint[s]`.  This **does not send** the datapoint, only\n  creates it.\n\n- `util.makeCumulative(String name, double val, Map\u003cString, String\u003e dimensions)`:\n  A convenience function to create a SignalFx cumulative counter\n  datapoint.  This creates a `DataPoint` instance that can be fed to\n  `output.sendDatapoint[s]`.  This **does not send** the datapoint, only\n  creates it.\n\nThe `output` instance available in the script context is what is used to\nsend data to SignalFx.  It contains the following methods:\n\n- `output.sendDatapoint(DataPoint dp)` - Emit the given datapoint to\n  SignalFx.  We recommend using the `util.make[Gauge|Cumulative]` helpers\n  to create the `DataPoint` instance.\n\n- `output.sendDatapoints(List\u003cDataPoint\u003e dp)` - Emit the given datapoints\n  to SignalFx. We recommend using the `util.make[Gauge|Cumulative]`\n  helpers to create the `DataPoint` instance. It is slightly more\n  efficient to send multiple datapoints at once, but doesn't matter that\n  much unless sending very high volumes.\n\nHere is an example Groovy script that replicates some of the data\npresented by the Cassandra `nodetool status` utility:\n\n```groovy\n// Query the JMX endpoint for a single MBean.\nss = util.queryJMX(\"org.apache.cassandra.db:type=StorageService\").first()\n\n// Copied and modified from https://github.com/apache/cassandra\ndef parseFileSize(String value) {\n\tif (!value.matches(\"\\\\d+(\\\\.\\\\d+)? (GiB|KiB|MiB|TiB|bytes)\")) {\n\t\tthrow new IllegalArgumentException(\n\t\t\tString.format(\"value %s is not a valid human-readable file size\", value));\n\t}\n\tif (value.endsWith(\" TiB\")) {\n\t\treturn Math.round(Double.valueOf(value.replace(\" TiB\", \"\")) * 1e12);\n\t}\n\telse if (value.endsWith(\" GiB\")) {\n\t\treturn Math.round(Double.valueOf(value.replace(\" GiB\", \"\")) * 1e9);\n\t}\n\telse if (value.endsWith(\" KiB\")) {\n\t\treturn Math.round(Double.valueOf(value.replace(\" KiB\", \"\")) * 1e3);\n\t}\n\telse if (value.endsWith(\" MiB\")) {\n\t\treturn Math.round(Double.valueOf(value.replace(\" MiB\", \"\")) * 1e6);\n\t}\n\telse if (value.endsWith(\" bytes\")) {\n\t\treturn Math.round(Double.valueOf(value.replace(\" bytes\", \"\")));\n\t}\n\telse {\n\t\tthrow new IllegalStateException(String.format(\"FileUtils.parseFileSize() reached an illegal state parsing %s\", value));\n\t}\n}\n\nlocalEndpoint = ss.HostIdToEndpoint.get(ss.LocalHostId)\ndims = [host_id: ss.LocalHostId, cluster_name: ss.ClusterName]\n\noutput.sendDatapoints([\n\t// Equivalent of \"Up/Down\" in the `nodetool status` output.\n\t// 1 = Live; 0 = Dead; -1 = Unknown\n\tutil.makeGauge(\n\t\t\"cassandra.status\",\n\t\tss.LiveNodes.contains(localEndpoint) ? 1 : (ss.DeadNodes.contains(localEndpoint) ? 0 : -1),\n\t\tdims),\n\n\tutil.makeGauge(\n\t\t\"cassandra.state\",\n\t\tss.JoiningNodes.contains(localEndpoint) ? 3 : (ss.LeavingNodes.contains(localEndpoint) ? 2 : 1),\n\t\tdims),\n\n\tutil.makeGauge(\n\t\t\"cassandra.load\",\n\t\tparseFileSize(ss.LoadString),\n\t\tdims),\n\n\tutil.makeGauge(\n\t\t\"cassandra.ownership\",\n\t\tss.Ownership.get(InetAddress.getByName(localEndpoint)),\n\t\tdims)\n\t])\n\n```\n\nBe careful that your script is carefully tested before using it to monitor\na production JMX service.  The script can do anything exposed via JMX,\nincluding writing attributes and running methods via JMX. In general\nscripts should only read attributes, but nothing enforces that.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the JMX Monitor",
        "package": "pkg/monitors/jmx",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host will be filled in by auto-discovery if this monitor has a discovery rule.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port will be filled in by auto-discovery if this monitor has a discovery rule.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The service URL for the JMX RMI endpoint.  If empty it will be filled in with values from `host` and `port` using a standard template: service:jmx:rmi:///jndi/rmi://\u003chost\u003e:\u003cport\u003e/jmxrmi.  If overridden, `host` and `port` will have no effect.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "groovyScript",
            "doc": "A literal Groovy script that generates datapoints from JMX MBeans.  See the top-level `jmx` monitor doc for more information on how to write this script. You can put the Groovy script in a separate file and refer to it here with the [remote config reference](https://docs.signalfx.com/en/latest/integrations/agent/remote-config.html) `{\"#from\": \"/path/to/file.groovy\", raw: true}`, or you can put it straight in YAML by using the `|` heredoc syntax.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username for JMX authentication, if applicable.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password for JMX autentication, if applicable.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "kube-controller-manager",
      "sendAll": false,
      "dimensions": null,
      "doc": "Exports Prometheus metrics from the [kube-controller-manager]\n(https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/).\nThe monitor queries path `/metrics` by default when no path is configured. The monitor converts\nthe Prometheus metric types to SignalFx metric types as described [here](prometheus-exporter.md)\n\nAn example configuration\n\n```yaml\nmonitors:\n- type: kube-controller-manager\n  discoveryRule: kubernetes_pod_name =~ \"kube-controller-manager\" \u0026\u0026 target == \"pod\"\n  port: 10252\n  extraDimensions:\n    metric_source: kube-controller-manager\n```\n\nNote that all metrics of this monitor are non-default and will be emitted only\nif specified explicitly.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "ClusterRoleAggregator_adds_total",
            "ClusterRoleAggregator_depth",
            "ClusterRoleAggregator_longest_running_processor_microseconds",
            "ClusterRoleAggregator_queue_latency",
            "ClusterRoleAggregator_queue_latency_count",
            "ClusterRoleAggregator_queue_latency_quantile",
            "ClusterRoleAggregator_retries_total",
            "ClusterRoleAggregator_unfinished_work_seconds",
            "ClusterRoleAggregator_work_duration",
            "ClusterRoleAggregator_work_duration_count",
            "ClusterRoleAggregator_work_duration_quantile",
            "apiserver_audit_event_total",
            "apiserver_audit_requests_rejected_total",
            "apiserver_client_certificate_expiration_seconds",
            "apiserver_client_certificate_expiration_seconds_bucket",
            "apiserver_client_certificate_expiration_seconds_count",
            "apiserver_storage_data_key_generation_duration_seconds",
            "apiserver_storage_data_key_generation_duration_seconds_bucket",
            "apiserver_storage_data_key_generation_duration_seconds_count",
            "apiserver_storage_data_key_generation_failures_total",
            "apiserver_storage_data_key_generation_latencies_microseconds",
            "apiserver_storage_data_key_generation_latencies_microseconds_bucket",
            "apiserver_storage_data_key_generation_latencies_microseconds_count",
            "apiserver_storage_envelope_transformation_cache_misses_total",
            "attachdetach_controller_forced_detaches_total",
            "authenticated_user_requests_total",
            "bootstrap_signer_queue_adds_total",
            "bootstrap_signer_queue_depth",
            "bootstrap_signer_queue_longest_running_processor_microseconds",
            "bootstrap_signer_queue_queue_latency",
            "bootstrap_signer_queue_queue_latency_count",
            "bootstrap_signer_queue_queue_latency_quantile",
            "bootstrap_signer_queue_retries_total",
            "bootstrap_signer_queue_unfinished_work_seconds",
            "bootstrap_signer_queue_work_duration",
            "bootstrap_signer_queue_work_duration_count",
            "bootstrap_signer_queue_work_duration_quantile",
            "bootstrap_signer_rate_limiter_use",
            "certificate_adds_total",
            "certificate_depth",
            "certificate_longest_running_processor_microseconds",
            "certificate_queue_latency",
            "certificate_queue_latency_count",
            "certificate_queue_latency_quantile",
            "certificate_retries_total",
            "certificate_unfinished_work_seconds",
            "certificate_work_duration",
            "certificate_work_duration_count",
            "certificate_work_duration_quantile",
            "claims_adds_total",
            "claims_depth",
            "claims_longest_running_processor_microseconds",
            "claims_queue_latency",
            "claims_queue_latency_count",
            "claims_queue_latency_quantile",
            "claims_unfinished_work_seconds",
            "claims_work_duration",
            "claims_work_duration_count",
            "claims_work_duration_quantile",
            "cronjob_controller_rate_limiter_use",
            "daemon_controller_rate_limiter_use",
            "daemonset_adds_total",
            "daemonset_depth",
            "daemonset_longest_running_processor_microseconds",
            "daemonset_queue_latency",
            "daemonset_queue_latency_count",
            "daemonset_queue_latency_quantile",
            "daemonset_retries_total",
            "daemonset_unfinished_work_seconds",
            "daemonset_work_duration",
            "daemonset_work_duration_count",
            "daemonset_work_duration_quantile",
            "deployment_adds_total",
            "deployment_controller_rate_limiter_use",
            "deployment_depth",
            "deployment_longest_running_processor_microseconds",
            "deployment_queue_latency",
            "deployment_queue_latency_count",
            "deployment_queue_latency_quantile",
            "deployment_retries_total",
            "deployment_unfinished_work_seconds",
            "deployment_work_duration",
            "deployment_work_duration_count",
            "deployment_work_duration_quantile",
            "disruption_adds_total",
            "disruption_depth",
            "disruption_longest_running_processor_microseconds",
            "disruption_queue_latency",
            "disruption_queue_latency_count",
            "disruption_queue_latency_quantile",
            "disruption_recheck_adds_total",
            "disruption_recheck_depth",
            "disruption_recheck_longest_running_processor_microseconds",
            "disruption_recheck_queue_latency",
            "disruption_recheck_queue_latency_count",
            "disruption_recheck_queue_latency_quantile",
            "disruption_recheck_retries_total",
            "disruption_recheck_unfinished_work_seconds",
            "disruption_recheck_work_duration",
            "disruption_recheck_work_duration_count",
            "disruption_recheck_work_duration_quantile",
            "disruption_retries_total",
            "disruption_unfinished_work_seconds",
            "disruption_work_duration",
            "disruption_work_duration_count",
            "disruption_work_duration_quantile",
            "endpoint_adds_total",
            "endpoint_controller_rate_limiter_use",
            "endpoint_depth",
            "endpoint_longest_running_processor_microseconds",
            "endpoint_queue_latency",
            "endpoint_queue_latency_count",
            "endpoint_queue_latency_quantile",
            "endpoint_retries_total",
            "endpoint_unfinished_work_seconds",
            "endpoint_work_duration",
            "endpoint_work_duration_count",
            "endpoint_work_duration_quantile",
            "garbage_collector_attempt_to_delete_adds_total",
            "garbage_collector_attempt_to_delete_depth",
            "garbage_collector_attempt_to_delete_longest_running_processor_microseconds",
            "garbage_collector_attempt_to_delete_queue_latency",
            "garbage_collector_attempt_to_delete_queue_latency_count",
            "garbage_collector_attempt_to_delete_queue_latency_quantile",
            "garbage_collector_attempt_to_delete_retries_total",
            "garbage_collector_attempt_to_delete_unfinished_work_seconds",
            "garbage_collector_attempt_to_delete_work_duration",
            "garbage_collector_attempt_to_delete_work_duration_count",
            "garbage_collector_attempt_to_delete_work_duration_quantile",
            "garbage_collector_attempt_to_orphan_adds_total",
            "garbage_collector_attempt_to_orphan_depth",
            "garbage_collector_attempt_to_orphan_longest_running_processor_microseconds",
            "garbage_collector_attempt_to_orphan_queue_latency",
            "garbage_collector_attempt_to_orphan_queue_latency_count",
            "garbage_collector_attempt_to_orphan_queue_latency_quantile",
            "garbage_collector_attempt_to_orphan_retries_total",
            "garbage_collector_attempt_to_orphan_unfinished_work_seconds",
            "garbage_collector_attempt_to_orphan_work_duration",
            "garbage_collector_attempt_to_orphan_work_duration_count",
            "garbage_collector_attempt_to_orphan_work_duration_quantile",
            "garbage_collector_graph_changes_adds_total",
            "garbage_collector_graph_changes_depth",
            "garbage_collector_graph_changes_longest_running_processor_microseconds",
            "garbage_collector_graph_changes_queue_latency",
            "garbage_collector_graph_changes_queue_latency_count",
            "garbage_collector_graph_changes_queue_latency_quantile",
            "garbage_collector_graph_changes_retries_total",
            "garbage_collector_graph_changes_unfinished_work_seconds",
            "garbage_collector_graph_changes_work_duration",
            "garbage_collector_graph_changes_work_duration_count",
            "garbage_collector_graph_changes_work_duration_quantile",
            "gc_controller_rate_limiter_use",
            "get_token_count_total",
            "get_token_fail_count_total",
            "go_gc_duration_seconds",
            "go_gc_duration_seconds_count",
            "go_gc_duration_seconds_quantile",
            "go_goroutines",
            "go_info",
            "go_memstats_alloc_bytes",
            "go_memstats_alloc_bytes_total",
            "go_memstats_buck_hash_sys_bytes",
            "go_memstats_frees_total",
            "go_memstats_gc_cpu_fraction",
            "go_memstats_gc_sys_bytes",
            "go_memstats_heap_alloc_bytes",
            "go_memstats_heap_idle_bytes",
            "go_memstats_heap_inuse_bytes",
            "go_memstats_heap_objects",
            "go_memstats_heap_released_bytes",
            "go_memstats_heap_sys_bytes",
            "go_memstats_last_gc_time_seconds",
            "go_memstats_lookups_total",
            "go_memstats_mallocs_total",
            "go_memstats_mcache_inuse_bytes",
            "go_memstats_mcache_sys_bytes",
            "go_memstats_mspan_inuse_bytes",
            "go_memstats_mspan_sys_bytes",
            "go_memstats_next_gc_bytes",
            "go_memstats_other_sys_bytes",
            "go_memstats_stack_inuse_bytes",
            "go_memstats_stack_sys_bytes",
            "go_memstats_sys_bytes",
            "go_threads",
            "horizontalpodautoscaler_adds_total",
            "horizontalpodautoscaler_depth",
            "horizontalpodautoscaler_longest_running_processor_microseconds",
            "horizontalpodautoscaler_queue_latency",
            "horizontalpodautoscaler_queue_latency_count",
            "horizontalpodautoscaler_queue_latency_quantile",
            "horizontalpodautoscaler_retries_total",
            "horizontalpodautoscaler_unfinished_work_seconds",
            "horizontalpodautoscaler_work_duration",
            "horizontalpodautoscaler_work_duration_count",
            "horizontalpodautoscaler_work_duration_quantile",
            "http_request_duration_microseconds",
            "http_request_duration_microseconds_count",
            "http_request_duration_microseconds_quantile",
            "http_request_size_bytes",
            "http_request_size_bytes_count",
            "http_request_size_bytes_quantile",
            "http_requests_total",
            "http_response_size_bytes",
            "http_response_size_bytes_count",
            "http_response_size_bytes_quantile",
            "job_adds_total",
            "job_controller_rate_limiter_use",
            "job_depth",
            "job_longest_running_processor_microseconds",
            "job_queue_latency",
            "job_queue_latency_count",
            "job_queue_latency_quantile",
            "job_retries_total",
            "job_unfinished_work_seconds",
            "job_work_duration",
            "job_work_duration_count",
            "job_work_duration_quantile",
            "kubernetes_build_info",
            "leader_election_master_status",
            "namespace_adds_total",
            "namespace_controller_rate_limiter_use",
            "namespace_depth",
            "namespace_longest_running_processor_microseconds",
            "namespace_queue_latency",
            "namespace_queue_latency_count",
            "namespace_queue_latency_quantile",
            "namespace_retries_total",
            "namespace_unfinished_work_seconds",
            "namespace_work_duration",
            "namespace_work_duration_count",
            "namespace_work_duration_quantile",
            "node_collector_evictions_number_total",
            "node_collector_unhealthy_nodes_in_zone",
            "node_collector_zone_health",
            "node_collector_zone_size",
            "node_lifecycle_controller_adds_total",
            "node_lifecycle_controller_depth",
            "node_lifecycle_controller_longest_running_processor_microseconds",
            "node_lifecycle_controller_queue_latency",
            "node_lifecycle_controller_queue_latency_count",
            "node_lifecycle_controller_queue_latency_quantile",
            "node_lifecycle_controller_rate_limiter_use",
            "node_lifecycle_controller_unfinished_work_seconds",
            "node_lifecycle_controller_work_duration",
            "node_lifecycle_controller_work_duration_count",
            "node_lifecycle_controller_work_duration_quantile",
            "noexec_taint_node_adds_total",
            "noexec_taint_node_depth",
            "noexec_taint_node_longest_running_processor_microseconds",
            "noexec_taint_node_queue_latency",
            "noexec_taint_node_queue_latency_count",
            "noexec_taint_node_queue_latency_quantile",
            "noexec_taint_node_unfinished_work_seconds",
            "noexec_taint_node_work_duration",
            "noexec_taint_node_work_duration_count",
            "noexec_taint_node_work_duration_quantile",
            "noexec_taint_pod_adds_total",
            "noexec_taint_pod_depth",
            "noexec_taint_pod_longest_running_processor_microseconds",
            "noexec_taint_pod_queue_latency",
            "noexec_taint_pod_queue_latency_count",
            "noexec_taint_pod_queue_latency_quantile",
            "noexec_taint_pod_unfinished_work_seconds",
            "noexec_taint_pod_work_duration",
            "noexec_taint_pod_work_duration_count",
            "noexec_taint_pod_work_duration_quantile",
            "persistentvolume_protection_controller_rate_limiter_use",
            "persistentvolumeclaim_protection_controller_rate_limiter_use",
            "process_cpu_seconds_total",
            "process_max_fds",
            "process_open_fds",
            "process_resident_memory_bytes",
            "process_start_time_seconds",
            "process_virtual_memory_bytes",
            "process_virtual_memory_max_bytes",
            "pvcprotection_adds_total",
            "pvcprotection_depth",
            "pvcprotection_longest_running_processor_microseconds",
            "pvcprotection_queue_latency",
            "pvcprotection_queue_latency_count",
            "pvcprotection_queue_latency_quantile",
            "pvcprotection_retries_total",
            "pvcprotection_unfinished_work_seconds",
            "pvcprotection_work_duration",
            "pvcprotection_work_duration_count",
            "pvcprotection_work_duration_quantile",
            "pvcs_adds_total",
            "pvcs_depth",
            "pvcs_longest_running_processor_microseconds",
            "pvcs_queue_latency",
            "pvcs_queue_latency_count",
            "pvcs_queue_latency_quantile",
            "pvcs_retries_total",
            "pvcs_unfinished_work_seconds",
            "pvcs_work_duration",
            "pvcs_work_duration_count",
            "pvcs_work_duration_quantile",
            "pvprotection_adds_total",
            "pvprotection_depth",
            "pvprotection_longest_running_processor_microseconds",
            "pvprotection_queue_latency",
            "pvprotection_queue_latency_count",
            "pvprotection_queue_latency_quantile",
            "pvprotection_retries_total",
            "pvprotection_unfinished_work_seconds",
            "pvprotection_work_duration",
            "pvprotection_work_duration_count",
            "pvprotection_work_duration_quantile",
            "replicaset_adds_total",
            "replicaset_controller_rate_limiter_use",
            "replicaset_depth",
            "replicaset_longest_running_processor_microseconds",
            "replicaset_queue_latency",
            "replicaset_queue_latency_count",
            "replicaset_queue_latency_quantile",
            "replicaset_retries_total",
            "replicaset_unfinished_work_seconds",
            "replicaset_work_duration",
            "replicaset_work_duration_count",
            "replicaset_work_duration_quantile",
            "replication_controller_rate_limiter_use",
            "replicationmanager_adds_total",
            "replicationmanager_depth",
            "replicationmanager_longest_running_processor_microseconds",
            "replicationmanager_queue_latency",
            "replicationmanager_queue_latency_count",
            "replicationmanager_queue_latency_quantile",
            "replicationmanager_retries_total",
            "replicationmanager_unfinished_work_seconds",
            "replicationmanager_work_duration",
            "replicationmanager_work_duration_count",
            "replicationmanager_work_duration_quantile",
            "resource_quota_controller_rate_limiter_use",
            "resource_quota_controller_resource_changes_adds_total",
            "resource_quota_controller_resource_changes_depth",
            "resource_quota_controller_resource_changes_longest_running_processor_microseconds",
            "resource_quota_controller_resource_changes_queue_latency",
            "resource_quota_controller_resource_changes_queue_latency_count",
            "resource_quota_controller_resource_changes_queue_latency_quantile",
            "resource_quota_controller_resource_changes_retries_total",
            "resource_quota_controller_resource_changes_unfinished_work_seconds",
            "resource_quota_controller_resource_changes_work_duration",
            "resource_quota_controller_resource_changes_work_duration_count",
            "resource_quota_controller_resource_changes_work_duration_quantile",
            "resourcequota_primary_adds_total",
            "resourcequota_primary_depth",
            "resourcequota_primary_longest_running_processor_microseconds",
            "resourcequota_primary_queue_latency",
            "resourcequota_primary_queue_latency_count",
            "resourcequota_primary_queue_latency_quantile",
            "resourcequota_primary_retries_total",
            "resourcequota_primary_unfinished_work_seconds",
            "resourcequota_primary_work_duration",
            "resourcequota_primary_work_duration_count",
            "resourcequota_primary_work_duration_quantile",
            "resourcequota_priority_adds_total",
            "resourcequota_priority_depth",
            "resourcequota_priority_longest_running_processor_microseconds",
            "resourcequota_priority_queue_latency",
            "resourcequota_priority_queue_latency_count",
            "resourcequota_priority_queue_latency_quantile",
            "resourcequota_priority_retries_total",
            "resourcequota_priority_unfinished_work_seconds",
            "resourcequota_priority_work_duration",
            "resourcequota_priority_work_duration_count",
            "resourcequota_priority_work_duration_quantile",
            "rest_client_request_duration_seconds",
            "rest_client_request_duration_seconds_bucket",
            "rest_client_request_duration_seconds_count",
            "rest_client_request_latency_seconds",
            "rest_client_request_latency_seconds_bucket",
            "rest_client_request_latency_seconds_count",
            "rest_client_requests_total",
            "service_adds_total",
            "service_controller_rate_limiter_use",
            "service_depth",
            "service_longest_running_processor_microseconds",
            "service_queue_latency",
            "service_queue_latency_count",
            "service_queue_latency_quantile",
            "service_retries_total",
            "service_unfinished_work_seconds",
            "service_work_duration",
            "service_work_duration_count",
            "service_work_duration_quantile",
            "serviceaccount_adds_total",
            "serviceaccount_controller_rate_limiter_use",
            "serviceaccount_depth",
            "serviceaccount_longest_running_processor_microseconds",
            "serviceaccount_queue_latency",
            "serviceaccount_queue_latency_count",
            "serviceaccount_queue_latency_quantile",
            "serviceaccount_retries_total",
            "serviceaccount_tokens_controller_rate_limiter_use",
            "serviceaccount_tokens_secret_adds_total",
            "serviceaccount_tokens_secret_depth",
            "serviceaccount_tokens_secret_longest_running_processor_microseconds",
            "serviceaccount_tokens_secret_queue_latency",
            "serviceaccount_tokens_secret_queue_latency_count",
            "serviceaccount_tokens_secret_queue_latency_quantile",
            "serviceaccount_tokens_secret_retries_total",
            "serviceaccount_tokens_secret_unfinished_work_seconds",
            "serviceaccount_tokens_secret_work_duration",
            "serviceaccount_tokens_secret_work_duration_count",
            "serviceaccount_tokens_secret_work_duration_quantile",
            "serviceaccount_tokens_service_adds_total",
            "serviceaccount_tokens_service_depth",
            "serviceaccount_tokens_service_longest_running_processor_microseconds",
            "serviceaccount_tokens_service_queue_latency",
            "serviceaccount_tokens_service_queue_latency_count",
            "serviceaccount_tokens_service_queue_latency_quantile",
            "serviceaccount_tokens_service_retries_total",
            "serviceaccount_tokens_service_unfinished_work_seconds",
            "serviceaccount_tokens_service_work_duration",
            "serviceaccount_tokens_service_work_duration_count",
            "serviceaccount_tokens_service_work_duration_quantile",
            "serviceaccount_unfinished_work_seconds",
            "serviceaccount_work_duration",
            "serviceaccount_work_duration_count",
            "serviceaccount_work_duration_quantile",
            "statefulset_adds_total",
            "statefulset_depth",
            "statefulset_longest_running_processor_microseconds",
            "statefulset_queue_latency",
            "statefulset_queue_latency_count",
            "statefulset_queue_latency_quantile",
            "statefulset_retries_total",
            "statefulset_unfinished_work_seconds",
            "statefulset_work_duration",
            "statefulset_work_duration_count",
            "statefulset_work_duration_quantile",
            "token_cleaner_adds_total",
            "token_cleaner_depth",
            "token_cleaner_longest_running_processor_microseconds",
            "token_cleaner_queue_latency",
            "token_cleaner_queue_latency_count",
            "token_cleaner_queue_latency_quantile",
            "token_cleaner_rate_limiter_use",
            "token_cleaner_retries_total",
            "token_cleaner_unfinished_work_seconds",
            "token_cleaner_work_duration",
            "token_cleaner_work_duration_count",
            "token_cleaner_work_duration_quantile",
            "ttlcontroller_adds_total",
            "ttlcontroller_depth",
            "ttlcontroller_longest_running_processor_microseconds",
            "ttlcontroller_queue_latency",
            "ttlcontroller_queue_latency_count",
            "ttlcontroller_queue_latency_quantile",
            "ttlcontroller_retries_total",
            "ttlcontroller_unfinished_work_seconds",
            "ttlcontroller_work_duration",
            "ttlcontroller_work_duration_count",
            "ttlcontroller_work_duration_quantile",
            "volume_expand_adds_total",
            "volume_expand_depth",
            "volume_expand_longest_running_processor_microseconds",
            "volume_expand_queue_latency",
            "volume_expand_queue_latency_count",
            "volume_expand_queue_latency_quantile",
            "volume_expand_retries_total",
            "volume_expand_unfinished_work_seconds",
            "volume_expand_work_duration",
            "volume_expand_work_duration_count",
            "volume_expand_work_duration_quantile",
            "volumes_adds_total",
            "volumes_depth",
            "volumes_longest_running_processor_microseconds",
            "volumes_queue_latency",
            "volumes_queue_latency_count",
            "volumes_queue_latency_quantile",
            "volumes_unfinished_work_seconds",
            "volumes_work_duration",
            "volumes_work_duration_count",
            "volumes_work_duration_quantile",
            "workqueue_adds_total",
            "workqueue_depth",
            "workqueue_longest_running_processor_seconds",
            "workqueue_queue_duration_seconds",
            "workqueue_queue_duration_seconds_bucket",
            "workqueue_queue_duration_seconds_count",
            "workqueue_retries_total",
            "workqueue_unfinished_work_seconds",
            "workqueue_work_duration_seconds",
            "workqueue_work_duration_seconds_bucket",
            "workqueue_work_duration_seconds_count"
          ]
        }
      },
      "metrics": {
        "ClusterRoleAggregator_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: ClusterRoleAggregator",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: ClusterRoleAggregator",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for ClusterRoleAggregator been running.",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueClusterRoleAggregator before being requested. (sum)",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueClusterRoleAggregator before being requested. (count)",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueClusterRoleAggregator before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: ClusterRoleAggregator",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work ClusterRoleAggregator has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueClusterRoleAggregator takes. (sum)",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueClusterRoleAggregator takes. (count)",
          "group": null,
          "default": false
        },
        "ClusterRoleAggregator_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueClusterRoleAggregator takes. (quantized)",
          "group": null,
          "default": false
        },
        "apiserver_audit_event_total": {
          "type": "cumulative",
          "description": "Counter of audit events generated and sent to the audit backend.",
          "group": null,
          "default": false
        },
        "apiserver_audit_requests_rejected_total": {
          "type": "cumulative",
          "description": "Counter of apiserver requests rejected due to an error in audit logging backend.",
          "group": null,
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (sum)",
          "group": null,
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds_bucket": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (bucket)",
          "group": null,
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds_count": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (count)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (sum)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (bucket)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds_count": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (count)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_failures_total": {
          "type": "cumulative",
          "description": "Total number of failed data encryption key(DEK) generation operations.",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (sum)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (bucket)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (count)",
          "group": null,
          "default": false
        },
        "apiserver_storage_envelope_transformation_cache_misses_total": {
          "type": "cumulative",
          "description": "Total number of cache misses while accessing key decryption key(KEK).",
          "group": null,
          "default": false
        },
        "attachdetach_controller_forced_detaches_total": {
          "type": "cumulative",
          "description": "Number of times the A/D Controller performed a forced detach",
          "group": null,
          "default": false
        },
        "authenticated_user_requests_total": {
          "type": "cumulative",
          "description": "Counter of authenticated requests broken out by username.",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: bootstrap_signer_queue",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: bootstrap_signer_queue",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for bootstrap_signer_queue been running.",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuebootstrap_signer_queue before being requested. (sum)",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuebootstrap_signer_queue before being requested. (count)",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuebootstrap_signer_queue before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: bootstrap_signer_queue",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work bootstrap_signer_queue has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuebootstrap_signer_queue takes. (sum)",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuebootstrap_signer_queue takes. (count)",
          "group": null,
          "default": false
        },
        "bootstrap_signer_queue_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuebootstrap_signer_queue takes. (quantized)",
          "group": null,
          "default": false
        },
        "bootstrap_signer_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for bootstrap_signer",
          "group": null,
          "default": false
        },
        "certificate_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: certificate",
          "group": null,
          "default": false
        },
        "certificate_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: certificate",
          "group": null,
          "default": false
        },
        "certificate_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for certificate been running.",
          "group": null,
          "default": false
        },
        "certificate_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecertificate before being requested. (sum)",
          "group": null,
          "default": false
        },
        "certificate_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecertificate before being requested. (count)",
          "group": null,
          "default": false
        },
        "certificate_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuecertificate before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "certificate_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: certificate",
          "group": null,
          "default": false
        },
        "certificate_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work certificate has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "certificate_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecertificate takes. (sum)",
          "group": null,
          "default": false
        },
        "certificate_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecertificate takes. (count)",
          "group": null,
          "default": false
        },
        "certificate_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuecertificate takes. (quantized)",
          "group": null,
          "default": false
        },
        "claims_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: claims",
          "group": null,
          "default": false
        },
        "claims_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: claims",
          "group": null,
          "default": false
        },
        "claims_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for claims been running.",
          "group": null,
          "default": false
        },
        "claims_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueclaims before being requested. (sum)",
          "group": null,
          "default": false
        },
        "claims_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueclaims before being requested. (count)",
          "group": null,
          "default": false
        },
        "claims_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueclaims before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "claims_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work claims has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "claims_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueclaims takes. (sum)",
          "group": null,
          "default": false
        },
        "claims_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueclaims takes. (count)",
          "group": null,
          "default": false
        },
        "claims_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueclaims takes. (quantized)",
          "group": null,
          "default": false
        },
        "cronjob_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for cronjob_controller",
          "group": null,
          "default": false
        },
        "daemon_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for daemon_controller",
          "group": null,
          "default": false
        },
        "daemonset_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: daemonset",
          "group": null,
          "default": false
        },
        "daemonset_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: daemonset",
          "group": null,
          "default": false
        },
        "daemonset_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for daemonset been running.",
          "group": null,
          "default": false
        },
        "daemonset_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuedaemonset before being requested. (sum)",
          "group": null,
          "default": false
        },
        "daemonset_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuedaemonset before being requested. (count)",
          "group": null,
          "default": false
        },
        "daemonset_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuedaemonset before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "daemonset_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: daemonset",
          "group": null,
          "default": false
        },
        "daemonset_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work daemonset has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "daemonset_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuedaemonset takes. (sum)",
          "group": null,
          "default": false
        },
        "daemonset_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuedaemonset takes. (count)",
          "group": null,
          "default": false
        },
        "daemonset_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuedaemonset takes. (quantized)",
          "group": null,
          "default": false
        },
        "deployment_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: deployment",
          "group": null,
          "default": false
        },
        "deployment_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for deployment_controller",
          "group": null,
          "default": false
        },
        "deployment_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: deployment",
          "group": null,
          "default": false
        },
        "deployment_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for deployment been running.",
          "group": null,
          "default": false
        },
        "deployment_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuedeployment before being requested. (sum)",
          "group": null,
          "default": false
        },
        "deployment_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuedeployment before being requested. (count)",
          "group": null,
          "default": false
        },
        "deployment_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuedeployment before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "deployment_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: deployment",
          "group": null,
          "default": false
        },
        "deployment_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work deployment has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "deployment_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuedeployment takes. (sum)",
          "group": null,
          "default": false
        },
        "deployment_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuedeployment takes. (count)",
          "group": null,
          "default": false
        },
        "deployment_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuedeployment takes. (quantized)",
          "group": null,
          "default": false
        },
        "disruption_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: disruption",
          "group": null,
          "default": false
        },
        "disruption_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: disruption",
          "group": null,
          "default": false
        },
        "disruption_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for disruption been running.",
          "group": null,
          "default": false
        },
        "disruption_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuedisruption before being requested. (sum)",
          "group": null,
          "default": false
        },
        "disruption_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuedisruption before being requested. (count)",
          "group": null,
          "default": false
        },
        "disruption_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuedisruption before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "disruption_recheck_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: disruption_recheck",
          "group": null,
          "default": false
        },
        "disruption_recheck_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: disruption_recheck",
          "group": null,
          "default": false
        },
        "disruption_recheck_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for disruption_recheck been running.",
          "group": null,
          "default": false
        },
        "disruption_recheck_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuedisruption_recheck before being requested. (sum)",
          "group": null,
          "default": false
        },
        "disruption_recheck_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuedisruption_recheck before being requested. (count)",
          "group": null,
          "default": false
        },
        "disruption_recheck_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuedisruption_recheck before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "disruption_recheck_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: disruption_recheck",
          "group": null,
          "default": false
        },
        "disruption_recheck_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work disruption_recheck has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "disruption_recheck_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuedisruption_recheck takes. (sum)",
          "group": null,
          "default": false
        },
        "disruption_recheck_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuedisruption_recheck takes. (count)",
          "group": null,
          "default": false
        },
        "disruption_recheck_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuedisruption_recheck takes. (quantized)",
          "group": null,
          "default": false
        },
        "disruption_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: disruption",
          "group": null,
          "default": false
        },
        "disruption_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work disruption has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "disruption_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuedisruption takes. (sum)",
          "group": null,
          "default": false
        },
        "disruption_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuedisruption takes. (count)",
          "group": null,
          "default": false
        },
        "disruption_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuedisruption takes. (quantized)",
          "group": null,
          "default": false
        },
        "endpoint_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: endpoint",
          "group": null,
          "default": false
        },
        "endpoint_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for endpoint_controller",
          "group": null,
          "default": false
        },
        "endpoint_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: endpoint",
          "group": null,
          "default": false
        },
        "endpoint_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for endpoint been running.",
          "group": null,
          "default": false
        },
        "endpoint_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueendpoint before being requested. (sum)",
          "group": null,
          "default": false
        },
        "endpoint_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueendpoint before being requested. (count)",
          "group": null,
          "default": false
        },
        "endpoint_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueendpoint before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "endpoint_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: endpoint",
          "group": null,
          "default": false
        },
        "endpoint_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work endpoint has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "endpoint_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueendpoint takes. (sum)",
          "group": null,
          "default": false
        },
        "endpoint_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueendpoint takes. (count)",
          "group": null,
          "default": false
        },
        "endpoint_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueendpoint takes. (quantized)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: garbage_collector_attempt_to_delete",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: garbage_collector_attempt_to_delete",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for garbage_collector_attempt_to_delete been running.",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_attempt_to_delete before being requested. (sum)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_attempt_to_delete before being requested. (count)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_attempt_to_delete before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: garbage_collector_attempt_to_delete",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work garbage_collector_attempt_to_delete has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_attempt_to_delete takes. (sum)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_attempt_to_delete takes. (count)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_delete_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_attempt_to_delete takes. (quantized)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: garbage_collector_attempt_to_orphan",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: garbage_collector_attempt_to_orphan",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for garbage_collector_attempt_to_orphan been running.",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_attempt_to_orphan before being requested. (sum)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_attempt_to_orphan before being requested. (count)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_attempt_to_orphan before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: garbage_collector_attempt_to_orphan",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work garbage_collector_attempt_to_orphan has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_attempt_to_orphan takes. (sum)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_attempt_to_orphan takes. (count)",
          "group": null,
          "default": false
        },
        "garbage_collector_attempt_to_orphan_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_attempt_to_orphan takes. (quantized)",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: garbage_collector_graph_changes",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: garbage_collector_graph_changes",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for garbage_collector_graph_changes been running.",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_graph_changes before being requested. (sum)",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_graph_changes before being requested. (count)",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuegarbage_collector_graph_changes before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: garbage_collector_graph_changes",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work garbage_collector_graph_changes has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_graph_changes takes. (sum)",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_graph_changes takes. (count)",
          "group": null,
          "default": false
        },
        "garbage_collector_graph_changes_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuegarbage_collector_graph_changes takes. (quantized)",
          "group": null,
          "default": false
        },
        "gc_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for gc_controller",
          "group": null,
          "default": false
        },
        "get_token_count_total": {
          "type": "cumulative",
          "description": "Counter of total Token() requests to the alternate token source",
          "group": null,
          "default": false
        },
        "get_token_fail_count_total": {
          "type": "cumulative",
          "description": "Counter of failed Token() requests to the alternate token source",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (sum)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (count)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_quantile": {
          "type": "gauge",
          "description": "A summary of the GC invocation durations. (quantized)",
          "group": null,
          "default": false
        },
        "go_goroutines": {
          "type": "gauge",
          "description": "Number of goroutines that currently exist.",
          "group": null,
          "default": false
        },
        "go_info": {
          "type": "gauge",
          "description": "Information about the Go environment.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed.",
          "group": null,
          "default": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table.",
          "group": null,
          "default": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Number of seconds since 1970 of last garbage collection.",
          "group": null,
          "default": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups.",
          "group": null,
          "default": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place.",
          "group": null,
          "default": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created.",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: horizontalpodautoscaler",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: horizontalpodautoscaler",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for horizontalpodautoscaler been running.",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuehorizontalpodautoscaler before being requested. (sum)",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuehorizontalpodautoscaler before being requested. (count)",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuehorizontalpodautoscaler before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: horizontalpodautoscaler",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work horizontalpodautoscaler has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuehorizontalpodautoscaler takes. (sum)",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuehorizontalpodautoscaler takes. (count)",
          "group": null,
          "default": false
        },
        "horizontalpodautoscaler_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuehorizontalpodautoscaler takes. (quantized)",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (sum)",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds_count": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (count)",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds_quantile": {
          "type": "gauge",
          "description": "The HTTP request latencies in microseconds. (quantized)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (sum)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (count)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes_quantile": {
          "type": "gauge",
          "description": "The HTTP request sizes in bytes. (quantized)",
          "group": null,
          "default": false
        },
        "http_requests_total": {
          "type": "cumulative",
          "description": "Total number of HTTP requests made.",
          "group": null,
          "default": false
        },
        "http_response_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (sum)",
          "group": null,
          "default": false
        },
        "http_response_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (count)",
          "group": null,
          "default": false
        },
        "http_response_size_bytes_quantile": {
          "type": "gauge",
          "description": "The HTTP response sizes in bytes. (quantized)",
          "group": null,
          "default": false
        },
        "job_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: job",
          "group": null,
          "default": false
        },
        "job_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for job_controller",
          "group": null,
          "default": false
        },
        "job_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: job",
          "group": null,
          "default": false
        },
        "job_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for job been running.",
          "group": null,
          "default": false
        },
        "job_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuejob before being requested. (sum)",
          "group": null,
          "default": false
        },
        "job_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuejob before being requested. (count)",
          "group": null,
          "default": false
        },
        "job_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuejob before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "job_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: job",
          "group": null,
          "default": false
        },
        "job_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work job has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "job_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuejob takes. (sum)",
          "group": null,
          "default": false
        },
        "job_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuejob takes. (count)",
          "group": null,
          "default": false
        },
        "job_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuejob takes. (quantized)",
          "group": null,
          "default": false
        },
        "kubernetes_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by major, minor, git version, git commit, git tree state, build date, Go version, and compiler from which Kubernetes was built, and platform on which it is running.",
          "group": null,
          "default": false
        },
        "leader_election_master_status": {
          "type": "gauge",
          "description": "Gauge of if the reporting system is master of the relevant lease, 0 indicates backup, 1 indicates master. 'name' is the string used to identify the lease. Please make sure to group by name.",
          "group": null,
          "default": false
        },
        "namespace_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: namespace",
          "group": null,
          "default": false
        },
        "namespace_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for namespace_controller",
          "group": null,
          "default": false
        },
        "namespace_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: namespace",
          "group": null,
          "default": false
        },
        "namespace_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for namespace been running.",
          "group": null,
          "default": false
        },
        "namespace_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuenamespace before being requested. (sum)",
          "group": null,
          "default": false
        },
        "namespace_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuenamespace before being requested. (count)",
          "group": null,
          "default": false
        },
        "namespace_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuenamespace before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "namespace_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: namespace",
          "group": null,
          "default": false
        },
        "namespace_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work namespace has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "namespace_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuenamespace takes. (sum)",
          "group": null,
          "default": false
        },
        "namespace_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuenamespace takes. (count)",
          "group": null,
          "default": false
        },
        "namespace_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuenamespace takes. (quantized)",
          "group": null,
          "default": false
        },
        "node_collector_evictions_number_total": {
          "type": "cumulative",
          "description": "Number of Node evictions that happened since current instance of NodeController started.",
          "group": null,
          "default": false
        },
        "node_collector_unhealthy_nodes_in_zone": {
          "type": "gauge",
          "description": "Gauge measuring number of not Ready Nodes per zones.",
          "group": null,
          "default": false
        },
        "node_collector_zone_health": {
          "type": "gauge",
          "description": "Gauge measuring percentage of healthy nodes per zone.",
          "group": null,
          "default": false
        },
        "node_collector_zone_size": {
          "type": "gauge",
          "description": "Gauge measuring number of registered Nodes per zones.",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: node_lifecycle_controller",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: node_lifecycle_controller",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for node_lifecycle_controller been running.",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuenode_lifecycle_controller before being requested. (sum)",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuenode_lifecycle_controller before being requested. (count)",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuenode_lifecycle_controller before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for node_lifecycle_controller",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work node_lifecycle_controller has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuenode_lifecycle_controller takes. (sum)",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuenode_lifecycle_controller takes. (count)",
          "group": null,
          "default": false
        },
        "node_lifecycle_controller_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuenode_lifecycle_controller takes. (quantized)",
          "group": null,
          "default": false
        },
        "noexec_taint_node_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: noexec_taint_node",
          "group": null,
          "default": false
        },
        "noexec_taint_node_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: noexec_taint_node",
          "group": null,
          "default": false
        },
        "noexec_taint_node_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for noexec_taint_node been running.",
          "group": null,
          "default": false
        },
        "noexec_taint_node_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuenoexec_taint_node before being requested. (sum)",
          "group": null,
          "default": false
        },
        "noexec_taint_node_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuenoexec_taint_node before being requested. (count)",
          "group": null,
          "default": false
        },
        "noexec_taint_node_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuenoexec_taint_node before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "noexec_taint_node_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work noexec_taint_node has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "noexec_taint_node_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuenoexec_taint_node takes. (sum)",
          "group": null,
          "default": false
        },
        "noexec_taint_node_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuenoexec_taint_node takes. (count)",
          "group": null,
          "default": false
        },
        "noexec_taint_node_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuenoexec_taint_node takes. (quantized)",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: noexec_taint_pod",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: noexec_taint_pod",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for noexec_taint_pod been running.",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuenoexec_taint_pod before being requested. (sum)",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuenoexec_taint_pod before being requested. (count)",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuenoexec_taint_pod before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work noexec_taint_pod has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuenoexec_taint_pod takes. (sum)",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuenoexec_taint_pod takes. (count)",
          "group": null,
          "default": false
        },
        "noexec_taint_pod_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuenoexec_taint_pod takes. (quantized)",
          "group": null,
          "default": false
        },
        "persistentvolume_protection_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for persistentvolume_protection_controller",
          "group": null,
          "default": false
        },
        "persistentvolumeclaim_protection_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for persistentvolumeclaim_protection_controller",
          "group": null,
          "default": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent in seconds.",
          "group": null,
          "default": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_max_bytes": {
          "type": "gauge",
          "description": "Maximum amount of virtual memory available in bytes.",
          "group": null,
          "default": false
        },
        "pvcprotection_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: pvcprotection",
          "group": null,
          "default": false
        },
        "pvcprotection_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: pvcprotection",
          "group": null,
          "default": false
        },
        "pvcprotection_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for pvcprotection been running.",
          "group": null,
          "default": false
        },
        "pvcprotection_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuepvcprotection before being requested. (sum)",
          "group": null,
          "default": false
        },
        "pvcprotection_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuepvcprotection before being requested. (count)",
          "group": null,
          "default": false
        },
        "pvcprotection_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuepvcprotection before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "pvcprotection_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: pvcprotection",
          "group": null,
          "default": false
        },
        "pvcprotection_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work pvcprotection has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "pvcprotection_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuepvcprotection takes. (sum)",
          "group": null,
          "default": false
        },
        "pvcprotection_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuepvcprotection takes. (count)",
          "group": null,
          "default": false
        },
        "pvcprotection_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuepvcprotection takes. (quantized)",
          "group": null,
          "default": false
        },
        "pvcs_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: pvcs",
          "group": null,
          "default": false
        },
        "pvcs_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: pvcs",
          "group": null,
          "default": false
        },
        "pvcs_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for pvcs been running.",
          "group": null,
          "default": false
        },
        "pvcs_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuepvcs before being requested. (sum)",
          "group": null,
          "default": false
        },
        "pvcs_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuepvcs before being requested. (count)",
          "group": null,
          "default": false
        },
        "pvcs_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuepvcs before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "pvcs_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: pvcs",
          "group": null,
          "default": false
        },
        "pvcs_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work pvcs has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "pvcs_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuepvcs takes. (sum)",
          "group": null,
          "default": false
        },
        "pvcs_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuepvcs takes. (count)",
          "group": null,
          "default": false
        },
        "pvcs_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuepvcs takes. (quantized)",
          "group": null,
          "default": false
        },
        "pvprotection_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: pvprotection",
          "group": null,
          "default": false
        },
        "pvprotection_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: pvprotection",
          "group": null,
          "default": false
        },
        "pvprotection_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for pvprotection been running.",
          "group": null,
          "default": false
        },
        "pvprotection_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuepvprotection before being requested. (sum)",
          "group": null,
          "default": false
        },
        "pvprotection_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuepvprotection before being requested. (count)",
          "group": null,
          "default": false
        },
        "pvprotection_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuepvprotection before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "pvprotection_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: pvprotection",
          "group": null,
          "default": false
        },
        "pvprotection_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work pvprotection has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "pvprotection_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuepvprotection takes. (sum)",
          "group": null,
          "default": false
        },
        "pvprotection_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuepvprotection takes. (count)",
          "group": null,
          "default": false
        },
        "pvprotection_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuepvprotection takes. (quantized)",
          "group": null,
          "default": false
        },
        "replicaset_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: replicaset",
          "group": null,
          "default": false
        },
        "replicaset_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for replicaset_controller",
          "group": null,
          "default": false
        },
        "replicaset_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: replicaset",
          "group": null,
          "default": false
        },
        "replicaset_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for replicaset been running.",
          "group": null,
          "default": false
        },
        "replicaset_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuereplicaset before being requested. (sum)",
          "group": null,
          "default": false
        },
        "replicaset_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuereplicaset before being requested. (count)",
          "group": null,
          "default": false
        },
        "replicaset_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuereplicaset before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "replicaset_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: replicaset",
          "group": null,
          "default": false
        },
        "replicaset_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work replicaset has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "replicaset_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuereplicaset takes. (sum)",
          "group": null,
          "default": false
        },
        "replicaset_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuereplicaset takes. (count)",
          "group": null,
          "default": false
        },
        "replicaset_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuereplicaset takes. (quantized)",
          "group": null,
          "default": false
        },
        "replication_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for replication_controller",
          "group": null,
          "default": false
        },
        "replicationmanager_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: replicationmanager",
          "group": null,
          "default": false
        },
        "replicationmanager_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: replicationmanager",
          "group": null,
          "default": false
        },
        "replicationmanager_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for replicationmanager been running.",
          "group": null,
          "default": false
        },
        "replicationmanager_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuereplicationmanager before being requested. (sum)",
          "group": null,
          "default": false
        },
        "replicationmanager_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuereplicationmanager before being requested. (count)",
          "group": null,
          "default": false
        },
        "replicationmanager_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuereplicationmanager before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "replicationmanager_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: replicationmanager",
          "group": null,
          "default": false
        },
        "replicationmanager_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work replicationmanager has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "replicationmanager_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuereplicationmanager takes. (sum)",
          "group": null,
          "default": false
        },
        "replicationmanager_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuereplicationmanager takes. (count)",
          "group": null,
          "default": false
        },
        "replicationmanager_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuereplicationmanager takes. (quantized)",
          "group": null,
          "default": false
        },
        "resource_quota_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for resource_quota_controller",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: resource_quota_controller_resource_changes",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: resource_quota_controller_resource_changes",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for resource_quota_controller_resource_changes been running.",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueresource_quota_controller_resource_changes before being requested. (sum)",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueresource_quota_controller_resource_changes before being requested. (count)",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueresource_quota_controller_resource_changes before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: resource_quota_controller_resource_changes",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work resource_quota_controller_resource_changes has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueresource_quota_controller_resource_changes takes. (sum)",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueresource_quota_controller_resource_changes takes. (count)",
          "group": null,
          "default": false
        },
        "resource_quota_controller_resource_changes_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueresource_quota_controller_resource_changes takes. (quantized)",
          "group": null,
          "default": false
        },
        "resourcequota_primary_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: resourcequota_primary",
          "group": null,
          "default": false
        },
        "resourcequota_primary_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: resourcequota_primary",
          "group": null,
          "default": false
        },
        "resourcequota_primary_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for resourcequota_primary been running.",
          "group": null,
          "default": false
        },
        "resourcequota_primary_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueresourcequota_primary before being requested. (sum)",
          "group": null,
          "default": false
        },
        "resourcequota_primary_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueresourcequota_primary before being requested. (count)",
          "group": null,
          "default": false
        },
        "resourcequota_primary_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueresourcequota_primary before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "resourcequota_primary_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: resourcequota_primary",
          "group": null,
          "default": false
        },
        "resourcequota_primary_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work resourcequota_primary has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "resourcequota_primary_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueresourcequota_primary takes. (sum)",
          "group": null,
          "default": false
        },
        "resourcequota_primary_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueresourcequota_primary takes. (count)",
          "group": null,
          "default": false
        },
        "resourcequota_primary_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueresourcequota_primary takes. (quantized)",
          "group": null,
          "default": false
        },
        "resourcequota_priority_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: resourcequota_priority",
          "group": null,
          "default": false
        },
        "resourcequota_priority_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: resourcequota_priority",
          "group": null,
          "default": false
        },
        "resourcequota_priority_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for resourcequota_priority been running.",
          "group": null,
          "default": false
        },
        "resourcequota_priority_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueresourcequota_priority before being requested. (sum)",
          "group": null,
          "default": false
        },
        "resourcequota_priority_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueresourcequota_priority before being requested. (count)",
          "group": null,
          "default": false
        },
        "resourcequota_priority_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueresourcequota_priority before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "resourcequota_priority_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: resourcequota_priority",
          "group": null,
          "default": false
        },
        "resourcequota_priority_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work resourcequota_priority has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "resourcequota_priority_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueresourcequota_priority takes. (sum)",
          "group": null,
          "default": false
        },
        "resourcequota_priority_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueresourcequota_priority takes. (count)",
          "group": null,
          "default": false
        },
        "resourcequota_priority_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueresourcequota_priority takes. (quantized)",
          "group": null,
          "default": false
        },
        "rest_client_request_duration_seconds": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (sum)",
          "group": null,
          "default": false
        },
        "rest_client_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (bucket)",
          "group": null,
          "default": false
        },
        "rest_client_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (count)",
          "group": null,
          "default": false
        },
        "rest_client_request_latency_seconds": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (sum)",
          "group": null,
          "default": false
        },
        "rest_client_request_latency_seconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (bucket)",
          "group": null,
          "default": true
        },
        "rest_client_request_latency_seconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (count)",
          "group": null,
          "default": false
        },
        "rest_client_requests_total": {
          "type": "cumulative",
          "description": "Number of HTTP requests, partitioned by status code, method, and host.",
          "group": null,
          "default": true
        },
        "service_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: service",
          "group": null,
          "default": false
        },
        "service_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for service_controller",
          "group": null,
          "default": false
        },
        "service_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: service",
          "group": null,
          "default": false
        },
        "service_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for service been running.",
          "group": null,
          "default": false
        },
        "service_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueservice before being requested. (sum)",
          "group": null,
          "default": false
        },
        "service_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueservice before being requested. (count)",
          "group": null,
          "default": false
        },
        "service_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueservice before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "service_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: service",
          "group": null,
          "default": false
        },
        "service_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work service has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "service_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueservice takes. (sum)",
          "group": null,
          "default": false
        },
        "service_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueservice takes. (count)",
          "group": null,
          "default": false
        },
        "service_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueservice takes. (quantized)",
          "group": null,
          "default": false
        },
        "serviceaccount_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: serviceaccount",
          "group": null,
          "default": false
        },
        "serviceaccount_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for serviceaccount_controller",
          "group": null,
          "default": false
        },
        "serviceaccount_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: serviceaccount",
          "group": null,
          "default": false
        },
        "serviceaccount_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for serviceaccount been running.",
          "group": null,
          "default": false
        },
        "serviceaccount_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount before being requested. (sum)",
          "group": null,
          "default": false
        },
        "serviceaccount_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount before being requested. (count)",
          "group": null,
          "default": false
        },
        "serviceaccount_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "serviceaccount_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: serviceaccount",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_controller_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for serviceaccount_tokens_controller",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: serviceaccount_tokens_secret",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: serviceaccount_tokens_secret",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for serviceaccount_tokens_secret been running.",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount_tokens_secret before being requested. (sum)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount_tokens_secret before being requested. (count)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount_tokens_secret before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: serviceaccount_tokens_secret",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work serviceaccount_tokens_secret has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount_tokens_secret takes. (sum)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount_tokens_secret takes. (count)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_secret_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount_tokens_secret takes. (quantized)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: serviceaccount_tokens_service",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: serviceaccount_tokens_service",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for serviceaccount_tokens_service been running.",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount_tokens_service before being requested. (sum)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount_tokens_service before being requested. (count)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueserviceaccount_tokens_service before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: serviceaccount_tokens_service",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work serviceaccount_tokens_service has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount_tokens_service takes. (sum)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount_tokens_service takes. (count)",
          "group": null,
          "default": false
        },
        "serviceaccount_tokens_service_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount_tokens_service takes. (quantized)",
          "group": null,
          "default": false
        },
        "serviceaccount_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work serviceaccount has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "serviceaccount_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount takes. (sum)",
          "group": null,
          "default": false
        },
        "serviceaccount_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount takes. (count)",
          "group": null,
          "default": false
        },
        "serviceaccount_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueserviceaccount takes. (quantized)",
          "group": null,
          "default": false
        },
        "statefulset_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: statefulset",
          "group": null,
          "default": false
        },
        "statefulset_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: statefulset",
          "group": null,
          "default": false
        },
        "statefulset_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for statefulset been running.",
          "group": null,
          "default": false
        },
        "statefulset_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuestatefulset before being requested. (sum)",
          "group": null,
          "default": false
        },
        "statefulset_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuestatefulset before being requested. (count)",
          "group": null,
          "default": false
        },
        "statefulset_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuestatefulset before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "statefulset_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: statefulset",
          "group": null,
          "default": false
        },
        "statefulset_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work statefulset has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "statefulset_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuestatefulset takes. (sum)",
          "group": null,
          "default": false
        },
        "statefulset_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuestatefulset takes. (count)",
          "group": null,
          "default": false
        },
        "statefulset_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuestatefulset takes. (quantized)",
          "group": null,
          "default": false
        },
        "token_cleaner_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: token_cleaner",
          "group": null,
          "default": false
        },
        "token_cleaner_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: token_cleaner",
          "group": null,
          "default": false
        },
        "token_cleaner_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for token_cleaner been running.",
          "group": null,
          "default": false
        },
        "token_cleaner_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuetoken_cleaner before being requested. (sum)",
          "group": null,
          "default": false
        },
        "token_cleaner_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuetoken_cleaner before being requested. (count)",
          "group": null,
          "default": false
        },
        "token_cleaner_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuetoken_cleaner before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "token_cleaner_rate_limiter_use": {
          "type": "gauge",
          "description": "A metric measuring the saturation of the rate limiter for token_cleaner",
          "group": null,
          "default": false
        },
        "token_cleaner_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: token_cleaner",
          "group": null,
          "default": false
        },
        "token_cleaner_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work token_cleaner has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "token_cleaner_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuetoken_cleaner takes. (sum)",
          "group": null,
          "default": false
        },
        "token_cleaner_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuetoken_cleaner takes. (count)",
          "group": null,
          "default": false
        },
        "token_cleaner_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuetoken_cleaner takes. (quantized)",
          "group": null,
          "default": false
        },
        "ttlcontroller_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: ttlcontroller",
          "group": null,
          "default": false
        },
        "ttlcontroller_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: ttlcontroller",
          "group": null,
          "default": false
        },
        "ttlcontroller_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for ttlcontroller been running.",
          "group": null,
          "default": false
        },
        "ttlcontroller_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuettlcontroller before being requested. (sum)",
          "group": null,
          "default": false
        },
        "ttlcontroller_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuettlcontroller before being requested. (count)",
          "group": null,
          "default": false
        },
        "ttlcontroller_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuettlcontroller before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "ttlcontroller_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: ttlcontroller",
          "group": null,
          "default": false
        },
        "ttlcontroller_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work ttlcontroller has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "ttlcontroller_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuettlcontroller takes. (sum)",
          "group": null,
          "default": false
        },
        "ttlcontroller_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuettlcontroller takes. (count)",
          "group": null,
          "default": false
        },
        "ttlcontroller_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuettlcontroller takes. (quantized)",
          "group": null,
          "default": false
        },
        "volume_expand_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: volume_expand",
          "group": null,
          "default": false
        },
        "volume_expand_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: volume_expand",
          "group": null,
          "default": false
        },
        "volume_expand_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for volume_expand been running.",
          "group": null,
          "default": false
        },
        "volume_expand_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuevolume_expand before being requested. (sum)",
          "group": null,
          "default": false
        },
        "volume_expand_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuevolume_expand before being requested. (count)",
          "group": null,
          "default": false
        },
        "volume_expand_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuevolume_expand before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "volume_expand_retries_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: volume_expand",
          "group": null,
          "default": false
        },
        "volume_expand_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work volume_expand has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "volume_expand_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuevolume_expand takes. (sum)",
          "group": null,
          "default": false
        },
        "volume_expand_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuevolume_expand takes. (count)",
          "group": null,
          "default": false
        },
        "volume_expand_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuevolume_expand takes. (quantized)",
          "group": null,
          "default": false
        },
        "volumes_adds_total": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: volumes",
          "group": null,
          "default": false
        },
        "volumes_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: volumes",
          "group": null,
          "default": false
        },
        "volumes_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for volumes been running.",
          "group": null,
          "default": false
        },
        "volumes_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuevolumes before being requested. (sum)",
          "group": null,
          "default": false
        },
        "volumes_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuevolumes before being requested. (count)",
          "group": null,
          "default": false
        },
        "volumes_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuevolumes before being requested. (quantized)",
          "group": null,
          "default": false
        },
        "volumes_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work volumes has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "volumes_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuevolumes takes. (sum)",
          "group": null,
          "default": false
        },
        "volumes_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuevolumes takes. (count)",
          "group": null,
          "default": false
        },
        "volumes_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuevolumes takes. (quantized)",
          "group": null,
          "default": false
        },
        "workqueue_adds_total": {
          "type": "cumulative",
          "description": "Total number of adds handled by workqueue",
          "group": null,
          "default": true
        },
        "workqueue_depth": {
          "type": "gauge",
          "description": "Current depth of workqueue",
          "group": null,
          "default": true
        },
        "workqueue_longest_running_processor_seconds": {
          "type": "gauge",
          "description": "How many seconds has the longest running processor for workqueue been running.",
          "group": null,
          "default": false
        },
        "workqueue_queue_duration_seconds": {
          "type": "cumulative",
          "description": "How long in seconds an item stays in workqueue before being requested. (sum)",
          "group": null,
          "default": false
        },
        "workqueue_queue_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "How long in seconds an item stays in workqueue before being requested. (bucket)",
          "group": null,
          "default": true
        },
        "workqueue_queue_duration_seconds_count": {
          "type": "cumulative",
          "description": "How long in seconds an item stays in workqueue before being requested. (count)",
          "group": null,
          "default": false
        },
        "workqueue_retries_total": {
          "type": "cumulative",
          "description": "Total number of retries handled by workqueue",
          "group": null,
          "default": false
        },
        "workqueue_unfinished_work_seconds": {
          "type": "gauge",
          "description": "How many seconds of work has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": null,
          "default": false
        },
        "workqueue_work_duration_seconds": {
          "type": "cumulative",
          "description": "How long in seconds processing an item from workqueue takes. (sum)",
          "group": null,
          "default": false
        },
        "workqueue_work_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "How long in seconds processing an item from workqueue takes. (bucket)",
          "group": null,
          "default": false
        },
        "workqueue_work_duration_seconds_count": {
          "type": "cumulative",
          "description": "How long in seconds processing an item from workqueue takes. (count)",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/kubernetes/controllermanager",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "kubelet-stats",
      "sendAll": false,
      "dimensions": {
        "container_id": {
          "description": "The ID of the running container"
        },
        "container_image": {
          "description": "The container image name"
        },
        "container_name": {
          "description": "The container's name as it appears in the pod spec, the same as container_spec_name but retained for backwards compatibility."
        },
        "container_spec_name": {
          "description": "The container's name as it appears in the pod spec"
        },
        "kubernetes_namespace": {
          "description": "The K8s namespace the container is part of"
        },
        "kubernetes_pod_name": {
          "description": "The pod instance under which this container runs"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod instance under which this container runs"
        }
      },
      "doc": "This monitor pulls cadvisor metrics through a\nKubernetes kubelet instance via the `/stats/container` endpoint.\n\n### Pause Containers\nNetwork stats for a Kubernetes pod are traditionally accounted for on the\n\"pause\" container, which is the container responsible for \"owning\" the\nnetwork namespace that the other containers in the pod will use, among\nother things.  Therefore, the network stats are usually zero for all\nnon-pause containers and accounted for in an aggregated way via the pause\ncontainer.\n\nSince the only generally useful stats of the pause container are network\nstats, this montior will omit non-network metrics for any containers named\n`POD`. This is the standard name for the \"pause\" container in Kubernetes\nwhen using the Docker runtime, but the pause container has no name under\nother runtimes. Therefore, you need to explicitly filter out non-network\nmetrics from pause containers when using non-Docker runtimes.  The following\nconfiguration will do that:\n\n```yaml\nmonitors:\n- type: kubelet-stats\n  datapointsToExclude:\n  - dimensions:\n      container_image:\n       - '*pause-amd64*'\n       - 'k8s.gcr.io/pause*'\n    metricNames:\n      - '*'\n      - '!*network*'\n```\n\nIf your K8s deployment using an image name for the pause container that\ndoes not fit the given patterns, you should tweak it as needed.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "container_cpu_cfs_periods",
            "container_cpu_cfs_throttled_periods",
            "container_cpu_cfs_throttled_time",
            "container_cpu_percent",
            "container_cpu_system_seconds_total",
            "container_cpu_usage_seconds_total",
            "container_cpu_user_seconds_total",
            "container_cpu_utilization",
            "container_cpu_utilization_per_core",
            "container_fs_io_current",
            "container_fs_io_time_seconds_total",
            "container_fs_io_time_weighted_seconds_total",
            "container_fs_limit_bytes",
            "container_fs_read_seconds_total",
            "container_fs_reads_merged_total",
            "container_fs_reads_total",
            "container_fs_sector_reads_total",
            "container_fs_sector_writes_total",
            "container_fs_usage_bytes",
            "container_fs_write_seconds_total",
            "container_fs_writes_merged_total",
            "container_fs_writes_total",
            "container_last_seen",
            "container_memory_failcnt",
            "container_memory_failures_total",
            "container_memory_rss",
            "container_memory_usage_bytes",
            "container_memory_working_set_bytes",
            "container_spec_cpu_period",
            "container_spec_cpu_quota",
            "container_spec_cpu_shares",
            "container_spec_memory_limit_bytes",
            "container_spec_memory_swap_limit_bytes",
            "container_start_time_seconds",
            "container_tasks_state",
            "machine_cpu_cores",
            "machine_cpu_frequency_khz",
            "machine_memory_bytes",
            "pod_network_receive_bytes_total",
            "pod_network_receive_errors_total",
            "pod_network_receive_packets_dropped_total",
            "pod_network_receive_packets_total",
            "pod_network_transmit_bytes_total",
            "pod_network_transmit_errors_total",
            "pod_network_transmit_packets_dropped_total",
            "pod_network_transmit_packets_total"
          ]
        },
        "podEphemeralStats": {
          "description": "",
          "metrics": [
            "pod_ephemeral_storage_capacity_bytes",
            "pod_ephemeral_storage_used_bytes"
          ]
        }
      },
      "metrics": {
        "container_cpu_cfs_periods": {
          "type": "cumulative",
          "description": "Total number of elapsed CFS enforcement intervals",
          "group": null,
          "default": false
        },
        "container_cpu_cfs_throttled_periods": {
          "type": "cumulative",
          "description": "Total number of times tasks in the cgroup have been throttled",
          "group": null,
          "default": false
        },
        "container_cpu_cfs_throttled_time": {
          "type": "cumulative",
          "description": "Total time duration, in nanoseconds, for which tasks in the cgroup have been throttled",
          "group": null,
          "default": false
        },
        "container_cpu_percent": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization as a percentage of the total host CPU available.  This metric is equivalent to `container_cpu_utilization` / \u003c# of CPUs/cores on host\u003e.",
          "group": null,
          "default": true
        },
        "container_cpu_system_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative system cpu time consumed in nanoseconds",
          "group": null,
          "default": false
        },
        "container_cpu_usage_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative cpu time consumed per cpu in nanoseconds",
          "group": null,
          "default": false
        },
        "container_cpu_user_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative user cpu time consumed in nanoseconds",
          "group": null,
          "default": false
        },
        "container_cpu_utilization": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization in percentages.  This is equivalent to \"centicores\", or hundreths of CPU cores consumed.  This metric is **NOT** normalized by the total # of cores on the system.",
          "group": null,
          "default": true
        },
        "container_cpu_utilization_per_core": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization in percentages per core",
          "group": null,
          "default": false
        },
        "container_fs_io_current": {
          "type": "gauge",
          "description": "Number of I/Os currently in progress",
          "group": null,
          "default": false
        },
        "container_fs_io_time_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent doing I/Os",
          "group": null,
          "default": false
        },
        "container_fs_io_time_weighted_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative weighted I/O time in seconds",
          "group": null,
          "default": false
        },
        "container_fs_limit_bytes": {
          "type": "gauge",
          "description": "Number of bytes that the container may occupy on this filesystem",
          "group": null,
          "default": false
        },
        "container_fs_read_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent reading",
          "group": null,
          "default": true
        },
        "container_fs_reads_merged_total": {
          "type": "cumulative",
          "description": "Cumulative count of reads merged",
          "group": null,
          "default": false
        },
        "container_fs_reads_total": {
          "type": "cumulative",
          "description": "Cumulative count of reads completed",
          "group": null,
          "default": true
        },
        "container_fs_sector_reads_total": {
          "type": "cumulative",
          "description": "Cumulative count of sector reads completed",
          "group": null,
          "default": false
        },
        "container_fs_sector_writes_total": {
          "type": "cumulative",
          "description": "Cumulative count of sector writes completed",
          "group": null,
          "default": false
        },
        "container_fs_usage_bytes": {
          "type": "gauge",
          "description": "Number of bytes that are consumed by the container on this filesystem",
          "group": null,
          "default": true
        },
        "container_fs_write_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent writing",
          "group": null,
          "default": true
        },
        "container_fs_writes_merged_total": {
          "type": "cumulative",
          "description": "Cumulative count of writes merged",
          "group": null,
          "default": false
        },
        "container_fs_writes_total": {
          "type": "cumulative",
          "description": "Cumulative count of writes completed",
          "group": null,
          "default": true
        },
        "container_last_seen": {
          "type": "gauge",
          "description": "Last time a container was seen by the exporter",
          "group": null,
          "default": false
        },
        "container_memory_failcnt": {
          "type": "cumulative",
          "description": "Number of memory usage hits limits",
          "group": null,
          "default": false
        },
        "container_memory_failures_total": {
          "type": "cumulative",
          "description": "Cumulative count of memory allocation failures",
          "group": null,
          "default": true
        },
        "container_memory_rss": {
          "type": "gauge",
          "description": "Current RSS memory usage in bytes",
          "group": null,
          "default": false
        },
        "container_memory_usage_bytes": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": null,
          "default": true
        },
        "container_memory_working_set_bytes": {
          "type": "gauge",
          "description": "Current working set in bytes",
          "group": null,
          "default": false
        },
        "container_spec_cpu_period": {
          "type": "gauge",
          "description": "The number of microseconds that the [CFS scheduler](https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) uses as a window when limiting container processes",
          "group": null,
          "default": true
        },
        "container_spec_cpu_quota": {
          "type": "gauge",
          "description": "In CPU quota for the CFS process scheduler. In K8s this is equal to the containers's CPU limit as a fraction of 1 core and multiplied by the `container_spec_cpu_period`.  So if the CPU limit is `500m` (500 millicores) for a container and the `container_spec_cpu_period` is set to 100,000, this value will be 50,000.",
          "group": null,
          "default": true
        },
        "container_spec_cpu_shares": {
          "type": "gauge",
          "description": "CPU share of the container",
          "group": null,
          "default": false
        },
        "container_spec_memory_limit_bytes": {
          "type": "gauge",
          "description": "Memory limit for the container.",
          "group": null,
          "default": true
        },
        "container_spec_memory_swap_limit_bytes": {
          "type": "gauge",
          "description": "Memory swap limit for the container.",
          "group": null,
          "default": false
        },
        "container_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the container since unix epoch in seconds.",
          "group": null,
          "default": false
        },
        "container_tasks_state": {
          "type": "gauge",
          "description": "Number of tasks in given state",
          "group": null,
          "default": false
        },
        "machine_cpu_cores": {
          "type": "gauge",
          "description": "Number of CPU cores on the node.",
          "group": null,
          "default": true
        },
        "machine_cpu_frequency_khz": {
          "type": "gauge",
          "description": "Node's CPU frequency.",
          "group": null,
          "default": false
        },
        "machine_memory_bytes": {
          "type": "gauge",
          "description": "Amount of memory installed on the node.",
          "group": null,
          "default": true
        },
        "pod_ephemeral_storage_capacity_bytes": {
          "type": "gauge",
          "description": "Represents the storage space available (bytes) for the filesystem. This value is a combination of total filesystem usage for the containers and emptyDir-backed volumes in the measured Pod. See more about emptyDir-backed volumes https://kubernetes.io/docs/concepts/storage/volumes/#emptydir",
          "group": "podEphemeralStats",
          "default": false
        },
        "pod_ephemeral_storage_used_bytes": {
          "type": "gauge",
          "description": "Represents the bytes used on the filesystem. This value is a total filesystem usage for the containers and emptyDir-backed volumes in the measured Pod. See more about emptyDir-backed volumes https://kubernetes.io/docs/concepts/storage/volumes/#emptydir",
          "group": "podEphemeralStats",
          "default": false
        },
        "pod_network_receive_bytes_total": {
          "type": "cumulative",
          "description": "Cumulative count of bytes received. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": true
        },
        "pod_network_receive_errors_total": {
          "type": "cumulative",
          "description": "Cumulative count of errors encountered while receiving. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": true
        },
        "pod_network_receive_packets_dropped_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets dropped while receiving. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": false
        },
        "pod_network_receive_packets_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets received. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": false
        },
        "pod_network_transmit_bytes_total": {
          "type": "cumulative",
          "description": "Cumulative count of bytes transmitted. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": true
        },
        "pod_network_transmit_errors_total": {
          "type": "cumulative",
          "description": "Cumulative count of errors encountered while transmitting. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": true
        },
        "pod_network_transmit_packets_dropped_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets dropped while transmitting. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": false
        },
        "pod_network_transmit_packets_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets transmitted. **Note that this metric is not emitted when using the cri-o container runtime.**",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "KubeletStatsConfig",
        "doc": "KubeletStatsConfig respresents config for the Kubelet stats monitor",
        "package": "pkg/monitors/cadvisor",
        "fields": [
          {
            "yamlName": "kubeletAPI",
            "doc": "Kubelet client configuration",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains config specific to the KubeletAPI",
              "package": "pkg/core/common/kubelet",
              "fields": [
                {
                  "yamlName": "url",
                  "doc": "URL of the Kubelet instance.  This will default to `http://\u003ccurrent node hostname\u003e:10255` if not provided.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "authType",
                  "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                  "default": "none",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verification of the Kubelet's TLS cert",
                  "default": true,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "logResponses",
                  "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-apiserver",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor queries the Kubernetes API server for kube-apiserver metrics in Prometheus format.\nThe monitor queries path `/metrics` by default when no path is configured. The monitor converts\nthe Prometheus metric types to SignalFx metric types as described [here](prometheus-exporter.md)\n\nExample YAML Configuration\n\n```yaml\nmonitors:\n- type: kubernetes-apiserver\n  discoveryRule: Get(container_labels, \"component\") == \"kube-apiserver\"\n  extraDimensions:\n    metric_source: kubernetes-apiserver\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "apiserver_current_inflight_requests",
            "apiserver_init_events",
            "apiserver_longrunning_gauge",
            "apiserver_registered_watchers",
            "authenticated_user_requests",
            "kubernetes_build_info"
          ]
        },
        "admission_quota_controller": {
          "description": "",
          "metrics": [
            "admission_quota_controller_adds",
            "admission_quota_controller_depth",
            "admission_quota_controller_longest_running_processor_microseconds",
            "admission_quota_controller_queue_latency",
            "admission_quota_controller_queue_latency_count",
            "admission_quota_controller_queue_latency_quantile",
            "admission_quota_controller_unfinished_work_seconds",
            "admission_quota_controller_work_duration",
            "admission_quota_controller_work_duration_count",
            "admission_quota_controller_work_duration_quantile"
          ]
        },
        "api_service_open_api_aggregation_controller": {
          "description": "",
          "metrics": [
            "APIServiceOpenAPIAggregationControllerQueue1_adds",
            "APIServiceOpenAPIAggregationControllerQueue1_depth",
            "APIServiceOpenAPIAggregationControllerQueue1_longest_running_processor_microseconds",
            "APIServiceOpenAPIAggregationControllerQueue1_queue_latency",
            "APIServiceOpenAPIAggregationControllerQueue1_queue_latency_count",
            "APIServiceOpenAPIAggregationControllerQueue1_queue_latency_quantile",
            "APIServiceOpenAPIAggregationControllerQueue1_retries",
            "APIServiceOpenAPIAggregationControllerQueue1_unfinished_work_seconds",
            "APIServiceOpenAPIAggregationControllerQueue1_work_duration",
            "APIServiceOpenAPIAggregationControllerQueue1_work_duration_count",
            "APIServiceOpenAPIAggregationControllerQueue1_work_duration_quantile"
          ]
        },
        "api_service_registration_controller": {
          "description": "",
          "metrics": [
            "APIServiceRegistrationController_adds",
            "APIServiceRegistrationController_depth",
            "APIServiceRegistrationController_longest_running_processor_microseconds",
            "APIServiceRegistrationController_queue_latency",
            "APIServiceRegistrationController_queue_latency_count",
            "APIServiceRegistrationController_queue_latency_quantile",
            "APIServiceRegistrationController_retries",
            "APIServiceRegistrationController_unfinished_work_seconds",
            "APIServiceRegistrationController_work_duration",
            "APIServiceRegistrationController_work_duration_count",
            "APIServiceRegistrationController_work_duration_quantile"
          ]
        },
        "apiserver_admission_controller": {
          "description": "",
          "metrics": [
            "apiserver_admission_controller_admission_duration_seconds",
            "apiserver_admission_controller_admission_duration_seconds_bucket",
            "apiserver_admission_controller_admission_duration_seconds_count",
            "apiserver_admission_controller_admission_latencies_milliseconds",
            "apiserver_admission_controller_admission_latencies_milliseconds_bucket",
            "apiserver_admission_controller_admission_latencies_milliseconds_count"
          ]
        },
        "apiserver_admission_step_admission": {
          "description": "",
          "metrics": [
            "apiserver_admission_step_admission_duration_seconds",
            "apiserver_admission_step_admission_duration_seconds_bucket",
            "apiserver_admission_step_admission_duration_seconds_count",
            "apiserver_admission_step_admission_duration_seconds_summary",
            "apiserver_admission_step_admission_duration_seconds_summary_count",
            "apiserver_admission_step_admission_duration_seconds_summary_quantile",
            "apiserver_admission_step_admission_latencies_milliseconds",
            "apiserver_admission_step_admission_latencies_milliseconds_bucket",
            "apiserver_admission_step_admission_latencies_milliseconds_count",
            "apiserver_admission_step_admission_latencies_milliseconds_summary",
            "apiserver_admission_step_admission_latencies_milliseconds_summary_count",
            "apiserver_admission_step_admission_latencies_milliseconds_summary_quantile"
          ]
        },
        "apiserver_audit": {
          "description": "",
          "metrics": [
            "apiserver_audit_event",
            "apiserver_audit_requests_rejected"
          ]
        },
        "apiserver_client": {
          "description": "",
          "metrics": [
            "apiserver_client_certificate_expiration_seconds",
            "apiserver_client_certificate_expiration_seconds_bucket",
            "apiserver_client_certificate_expiration_seconds_count"
          ]
        },
        "apiserver_request": {
          "description": "",
          "metrics": [
            "apiserver_request",
            "apiserver_request_count",
            "apiserver_request_duration_seconds",
            "apiserver_request_duration_seconds_bucket",
            "apiserver_request_duration_seconds_count",
            "apiserver_request_latencies",
            "apiserver_request_latencies_bucket",
            "apiserver_request_latencies_count",
            "apiserver_request_latencies_summary",
            "apiserver_request_latencies_summary_count",
            "apiserver_request_latencies_summary_quantile"
          ]
        },
        "apiserver_response": {
          "description": "",
          "metrics": [
            "apiserver_response_sizes",
            "apiserver_response_sizes_bucket",
            "apiserver_response_sizes_count"
          ]
        },
        "apiserver_storage": {
          "description": "",
          "metrics": [
            "apiserver_storage_data_key_generation_duration_seconds",
            "apiserver_storage_data_key_generation_duration_seconds_bucket",
            "apiserver_storage_data_key_generation_duration_seconds_count",
            "apiserver_storage_data_key_generation_failures",
            "apiserver_storage_data_key_generation_latencies_microseconds",
            "apiserver_storage_data_key_generation_latencies_microseconds_bucket",
            "apiserver_storage_data_key_generation_latencies_microseconds_count",
            "apiserver_storage_envelope_transformation_cache_misses"
          ]
        },
        "autoregister": {
          "description": "",
          "metrics": [
            "autoregister_adds",
            "autoregister_depth",
            "autoregister_longest_running_processor_microseconds",
            "autoregister_queue_latency",
            "autoregister_queue_latency_count",
            "autoregister_queue_latency_quantile",
            "autoregister_retries",
            "autoregister_unfinished_work_seconds",
            "autoregister_work_duration",
            "autoregister_work_duration_count",
            "autoregister_work_duration_quantile"
          ]
        },
        "available_condition_controller": {
          "description": "",
          "metrics": [
            "AvailableConditionController_adds",
            "AvailableConditionController_depth",
            "AvailableConditionController_longest_running_processor_microseconds",
            "AvailableConditionController_queue_latency",
            "AvailableConditionController_queue_latency_count",
            "AvailableConditionController_queue_latency_quantile",
            "AvailableConditionController_retries",
            "AvailableConditionController_unfinished_work_seconds",
            "AvailableConditionController_work_duration",
            "AvailableConditionController_work_duration_count",
            "AvailableConditionController_work_duration_quantile"
          ]
        },
        "crd_autoregistration_controller": {
          "description": "",
          "metrics": [
            "crd_autoregistration_controller_adds",
            "crd_autoregistration_controller_depth",
            "crd_autoregistration_controller_longest_running_processor_microseconds",
            "crd_autoregistration_controller_queue_latency",
            "crd_autoregistration_controller_queue_latency_count",
            "crd_autoregistration_controller_queue_latency_quantile",
            "crd_autoregistration_controller_retries",
            "crd_autoregistration_controller_unfinished_work_seconds",
            "crd_autoregistration_controller_work_duration",
            "crd_autoregistration_controller_work_duration_count",
            "crd_autoregistration_controller_work_duration_quantile"
          ]
        },
        "crd_establishing": {
          "description": "",
          "metrics": [
            "crdEstablishing_adds",
            "crdEstablishing_depth",
            "crdEstablishing_longest_running_processor_microseconds",
            "crdEstablishing_queue_latency",
            "crdEstablishing_queue_latency_count",
            "crdEstablishing_queue_latency_quantile",
            "crdEstablishing_retries",
            "crdEstablishing_unfinished_work_seconds",
            "crdEstablishing_work_duration",
            "crdEstablishing_work_duration_count",
            "crdEstablishing_work_duration_quantile"
          ]
        },
        "crd_finalizer": {
          "description": "",
          "metrics": [
            "crd_finalizer_adds",
            "crd_finalizer_depth",
            "crd_finalizer_longest_running_processor_microseconds",
            "crd_finalizer_queue_latency",
            "crd_finalizer_queue_latency_count",
            "crd_finalizer_queue_latency_quantile",
            "crd_finalizer_retries",
            "crd_finalizer_unfinished_work_seconds",
            "crd_finalizer_work_duration",
            "crd_finalizer_work_duration_count",
            "crd_finalizer_work_duration_quantile"
          ]
        },
        "crd_naming_condition_controller": {
          "description": "",
          "metrics": [
            "crd_naming_condition_controller_adds",
            "crd_naming_condition_controller_depth",
            "crd_naming_condition_controller_longest_running_processor_microseconds",
            "crd_naming_condition_controller_queue_latency",
            "crd_naming_condition_controller_queue_latency_count",
            "crd_naming_condition_controller_queue_latency_quantile",
            "crd_naming_condition_controller_retries",
            "crd_naming_condition_controller_unfinished_work_seconds",
            "crd_naming_condition_controller_work_duration",
            "crd_naming_condition_controller_work_duration_count",
            "crd_naming_condition_controller_work_duration_quantile"
          ]
        },
        "discovery_controller": {
          "description": "",
          "metrics": [
            "DiscoveryController_adds",
            "DiscoveryController_depth",
            "DiscoveryController_longest_running_processor_microseconds",
            "DiscoveryController_queue_latency",
            "DiscoveryController_queue_latency_count",
            "DiscoveryController_queue_latency_quantile",
            "DiscoveryController_retries",
            "DiscoveryController_unfinished_work_seconds",
            "DiscoveryController_work_duration",
            "DiscoveryController_work_duration_count",
            "DiscoveryController_work_duration_quantile"
          ]
        },
        "etcd": {
          "description": "",
          "metrics": [
            "etcd_helper_cache_entry",
            "etcd_helper_cache_entry_count",
            "etcd_helper_cache_hit",
            "etcd_helper_cache_hit_count",
            "etcd_helper_cache_miss",
            "etcd_helper_cache_miss_count",
            "etcd_object_counts",
            "etcd_request_cache_add_duration_seconds",
            "etcd_request_cache_add_duration_seconds_bucket",
            "etcd_request_cache_add_duration_seconds_count",
            "etcd_request_cache_add_latencies_summary",
            "etcd_request_cache_add_latencies_summary_count",
            "etcd_request_cache_add_latencies_summary_quantile",
            "etcd_request_cache_get_duration_seconds",
            "etcd_request_cache_get_duration_seconds_bucket",
            "etcd_request_cache_get_duration_seconds_count",
            "etcd_request_cache_get_latencies_summary",
            "etcd_request_cache_get_latencies_summary_count",
            "etcd_request_cache_get_latencies_summary_quantile"
          ]
        },
        "grpc_client": {
          "description": "",
          "metrics": [
            "grpc_client_handled",
            "grpc_client_msg_received",
            "grpc_client_msg_sent",
            "grpc_client_started"
          ]
        },
        "http_request": {
          "description": "",
          "metrics": [
            "http_request_duration_microseconds",
            "http_request_duration_microseconds_count",
            "http_request_duration_microseconds_quantile",
            "http_request_size_bytes",
            "http_request_size_bytes_count",
            "http_request_size_bytes_quantile",
            "http_requests"
          ]
        },
        "http_response": {
          "description": "",
          "metrics": [
            "http_response_size_bytes",
            "http_response_size_bytes_count",
            "http_response_size_bytes_quantile"
          ]
        },
        "prometheus_go": {
          "description": "",
          "metrics": [
            "go_gc_duration_seconds",
            "go_gc_duration_seconds_count",
            "go_gc_duration_seconds_quantile",
            "go_goroutines",
            "go_info",
            "go_memstats_alloc_bytes",
            "go_memstats_buck_hash_sys_bytes",
            "go_memstats_frees",
            "go_memstats_gc_cpu_fraction",
            "go_memstats_gc_sys_bytes",
            "go_memstats_heap_alloc_bytes",
            "go_memstats_heap_idle_bytes",
            "go_memstats_heap_inuse_bytes",
            "go_memstats_heap_objects",
            "go_memstats_heap_released_bytes",
            "go_memstats_heap_sys_bytes",
            "go_memstats_last_gc_time_seconds",
            "go_memstats_lookups",
            "go_memstats_mallocs",
            "go_memstats_mcache_inuse_bytes",
            "go_memstats_mcache_sys_bytes",
            "go_memstats_mspan_inuse_bytes",
            "go_memstats_mspan_sys_bytes",
            "go_memstats_next_gc_bytes",
            "go_memstats_other_sys_bytes",
            "go_memstats_stack_inuse_bytes",
            "go_memstats_stack_sys_bytes",
            "go_memstats_sys_bytes",
            "go_threads"
          ]
        },
        "prometheus_process": {
          "description": "",
          "metrics": [
            "process_cpu_seconds",
            "process_max_fds",
            "process_open_fds",
            "process_resident_memory_bytes",
            "process_start_time_seconds",
            "process_virtual_memory_bytes",
            "process_virtual_memory_max_bytes"
          ]
        },
        "rest_client": {
          "description": "",
          "metrics": [
            "rest_client_request_duration_seconds",
            "rest_client_request_duration_seconds_bucket",
            "rest_client_request_duration_seconds_count",
            "rest_client_request_latency_seconds",
            "rest_client_request_latency_seconds_bucket",
            "rest_client_request_latency_seconds_count",
            "rest_client_requests"
          ]
        },
        "ssh_tunnel": {
          "description": "",
          "metrics": [
            "ssh_tunnel_open_count",
            "ssh_tunnel_open_fail_count"
          ]
        },
        "token": {
          "description": "",
          "metrics": [
            "get_token_count",
            "get_token_fail_count"
          ]
        },
        "workqueue": {
          "description": "",
          "metrics": [
            "workqueue_adds",
            "workqueue_depth",
            "workqueue_longest_running_processor_seconds",
            "workqueue_queue_duration_seconds",
            "workqueue_queue_duration_seconds_bucket",
            "workqueue_queue_duration_seconds_count",
            "workqueue_retries",
            "workqueue_unfinished_work_seconds",
            "workqueue_work_duration_seconds",
            "workqueue_work_duration_seconds_bucket",
            "workqueue_work_duration_seconds_count"
          ]
        }
      },
      "metrics": {
        "APIServiceOpenAPIAggregationControllerQueue1_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: APIServiceOpenAPIAggregationControllerQueue1",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: APIServiceOpenAPIAggregationControllerQueue1",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for APIServiceOpenAPIAggregationControllerQueue1 been running.",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueAPIServiceOpenAPIAggregationControllerQueue1 before being requested. (sum)",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueAPIServiceOpenAPIAggregationControllerQueue1 before being requested. (count)",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueAPIServiceOpenAPIAggregationControllerQueue1 before being requested. (quantized)",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: APIServiceOpenAPIAggregationControllerQueue1",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work APIServiceOpenAPIAggregationControllerQueue1 has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueAPIServiceOpenAPIAggregationControllerQueue1 takes. (sum)",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueAPIServiceOpenAPIAggregationControllerQueue1 takes. (count)",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceOpenAPIAggregationControllerQueue1_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueAPIServiceOpenAPIAggregationControllerQueue1 takes. (quantized)",
          "group": "api_service_open_api_aggregation_controller",
          "default": false
        },
        "APIServiceRegistrationController_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: APIServiceRegistrationController",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: APIServiceRegistrationController",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for APIServiceRegistrationController been running.",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueAPIServiceRegistrationController before being requested. (sum)",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueAPIServiceRegistrationController before being requested. (count)",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueAPIServiceRegistrationController before being requested. (quantized)",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: APIServiceRegistrationController",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work APIServiceRegistrationController has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueAPIServiceRegistrationController takes. (sum)",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueAPIServiceRegistrationController takes. (count)",
          "group": "api_service_registration_controller",
          "default": false
        },
        "APIServiceRegistrationController_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueAPIServiceRegistrationController takes. (quantized)",
          "group": "api_service_registration_controller",
          "default": false
        },
        "AvailableConditionController_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: AvailableConditionController",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: AvailableConditionController",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for AvailableConditionController been running.",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueAvailableConditionController before being requested. (sum)",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueAvailableConditionController before being requested. (count)",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueAvailableConditionController before being requested. (quantized)",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: AvailableConditionController",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work AvailableConditionController has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueAvailableConditionController takes. (sum)",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueAvailableConditionController takes. (count)",
          "group": "available_condition_controller",
          "default": false
        },
        "AvailableConditionController_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueAvailableConditionController takes. (quantized)",
          "group": "available_condition_controller",
          "default": false
        },
        "DiscoveryController_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: DiscoveryController",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: DiscoveryController",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for DiscoveryController been running.",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueDiscoveryController before being requested. (sum)",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueDiscoveryController before being requested. (count)",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueDiscoveryController before being requested. (quantized)",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: DiscoveryController",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work DiscoveryController has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueDiscoveryController takes. (sum)",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueDiscoveryController takes. (count)",
          "group": "discovery_controller",
          "default": false
        },
        "DiscoveryController_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueDiscoveryController takes. (quantized)",
          "group": "discovery_controller",
          "default": false
        },
        "admission_quota_controller_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: admission_quota_controller",
          "group": "admission_quota_controller",
          "default": true
        },
        "admission_quota_controller_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: admission_quota_controller",
          "group": "admission_quota_controller",
          "default": false
        },
        "admission_quota_controller_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for admission_quota_controller been running.",
          "group": "admission_quota_controller",
          "default": false
        },
        "admission_quota_controller_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueadmission_quota_controller before being requested. (sum)",
          "group": "admission_quota_controller",
          "default": false
        },
        "admission_quota_controller_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueadmission_quota_controller before being requested. (count)",
          "group": "admission_quota_controller",
          "default": false
        },
        "admission_quota_controller_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueadmission_quota_controller before being requested. (quantized)",
          "group": "admission_quota_controller",
          "default": false
        },
        "admission_quota_controller_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work admission_quota_controller has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "admission_quota_controller",
          "default": false
        },
        "admission_quota_controller_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueadmission_quota_controller takes. (sum)",
          "group": "admission_quota_controller",
          "default": false
        },
        "admission_quota_controller_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueadmission_quota_controller takes. (count)",
          "group": "admission_quota_controller",
          "default": false
        },
        "admission_quota_controller_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueadmission_quota_controller takes. (quantized)",
          "group": "admission_quota_controller",
          "default": false
        },
        "apiserver_admission_controller_admission_duration_seconds": {
          "type": "cumulative",
          "description": "Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). (sum)",
          "group": "apiserver_admission_controller",
          "default": false
        },
        "apiserver_admission_controller_admission_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). (bucket)",
          "group": "apiserver_admission_controller",
          "default": false
        },
        "apiserver_admission_controller_admission_duration_seconds_count": {
          "type": "cumulative",
          "description": "Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). (count)",
          "group": "apiserver_admission_controller",
          "default": false
        },
        "apiserver_admission_controller_admission_latencies_milliseconds": {
          "type": "cumulative",
          "description": "(Deprecated) Admission controller latency histogram in milliseconds, identified by name and broken out for each operation and API resource and type (validate or admit). (sum)",
          "group": "apiserver_admission_controller",
          "default": false
        },
        "apiserver_admission_controller_admission_latencies_milliseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Admission controller latency histogram in milliseconds, identified by name and broken out for each operation and API resource and type (validate or admit). (bucket)",
          "group": "apiserver_admission_controller",
          "default": false
        },
        "apiserver_admission_controller_admission_latencies_milliseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Admission controller latency histogram in milliseconds, identified by name and broken out for each operation and API resource and type (validate or admit). (count)",
          "group": "apiserver_admission_controller",
          "default": false
        },
        "apiserver_admission_step_admission_duration_seconds": {
          "type": "cumulative",
          "description": "Admission sub-step latency histogram in seconds, broken out for each operation and API resource and step type (validate or admit). (sum)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Admission sub-step latency histogram in seconds, broken out for each operation and API resource and step type (validate or admit). (bucket)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_duration_seconds_count": {
          "type": "cumulative",
          "description": "Admission sub-step latency histogram in seconds, broken out for each operation and API resource and step type (validate or admit). (count)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_duration_seconds_summary": {
          "type": "cumulative",
          "description": "Admission sub-step latency summary in seconds, broken out for each operation and API resource and step type (validate or admit). (sum)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_duration_seconds_summary_count": {
          "type": "cumulative",
          "description": "Admission sub-step latency summary in seconds, broken out for each operation and API resource and step type (validate or admit). (count)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_duration_seconds_summary_quantile": {
          "type": "gauge",
          "description": "Admission sub-step latency summary in seconds, broken out for each operation and API resource and step type (validate or admit). (quantized)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_latencies_milliseconds": {
          "type": "cumulative",
          "description": "(Deprecated) Admission sub-step latency histogram in milliseconds, broken out for each operation and API resource and step type (validate or admit). (sum)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_latencies_milliseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Admission sub-step latency histogram in milliseconds, broken out for each operation and API resource and step type (validate or admit). (bucket)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_latencies_milliseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Admission sub-step latency histogram in milliseconds, broken out for each operation and API resource and step type (validate or admit). (count)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_latencies_milliseconds_summary": {
          "type": "cumulative",
          "description": "(Deprecated) Admission sub-step latency summary in milliseconds, broken out for each operation and API resource and step type (validate or admit). (sum)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_latencies_milliseconds_summary_count": {
          "type": "cumulative",
          "description": "(Deprecated) Admission sub-step latency summary in milliseconds, broken out for each operation and API resource and step type (validate or admit). (count)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_admission_step_admission_latencies_milliseconds_summary_quantile": {
          "type": "gauge",
          "description": "(Deprecated) Admission sub-step latency summary in milliseconds, broken out for each operation and API resource and step type (validate or admit). (quantized)",
          "group": "apiserver_admission_step_admission",
          "default": false
        },
        "apiserver_audit_event": {
          "type": "cumulative",
          "description": "Counter of audit events generated and sent to the audit backend.",
          "group": "apiserver_audit",
          "default": false
        },
        "apiserver_audit_requests_rejected": {
          "type": "cumulative",
          "description": "Counter of apiserver requests rejected due to an error in audit logging backend.",
          "group": "apiserver_audit",
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (sum)",
          "group": "apiserver_client",
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds_bucket": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (bucket)",
          "group": "apiserver_client",
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds_count": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (count)",
          "group": "apiserver_client",
          "default": false
        },
        "apiserver_current_inflight_requests": {
          "type": "gauge",
          "description": "Maximal number of currently used inflight request limit of this apiserver per request kind in last second.",
          "group": null,
          "default": false
        },
        "apiserver_init_events": {
          "type": "cumulative",
          "description": "Counter of init events processed in watchcache broken by resource type",
          "group": null,
          "default": false
        },
        "apiserver_longrunning_gauge": {
          "type": "gauge",
          "description": "Gauge of all active long-running apiserver requests broken out by verb, group, version, resource, scope and component. Not all requests are tracked this way.",
          "group": null,
          "default": false
        },
        "apiserver_registered_watchers": {
          "type": "gauge",
          "description": "Number of currently registered watchers for a given resources",
          "group": null,
          "default": false
        },
        "apiserver_request": {
          "type": "cumulative",
          "description": "Counter of apiserver requests broken out for each verb, dry run value, group, version, resource, scope, component, client, and HTTP response contentType and code.",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_request_count": {
          "type": "cumulative",
          "description": "(Deprecated) Counter of apiserver requests broken out for each verb, group, version, resource, scope, component, client, and HTTP response contentType and code.",
          "group": "apiserver_request",
          "default": true
        },
        "apiserver_request_duration_seconds": {
          "type": "cumulative",
          "description": "Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope and component. (sum)",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope and component. (bucket)",
          "group": "apiserver_request",
          "default": true
        },
        "apiserver_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope and component. (count)",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_request_latencies": {
          "type": "cumulative",
          "description": "(Deprecated) Response latency distribution in microseconds for each verb, group, version, resource, subresource, scope and component. (sum)",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_request_latencies_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Response latency distribution in microseconds for each verb, group, version, resource, subresource, scope and component. (bucket)",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_request_latencies_count": {
          "type": "cumulative",
          "description": "(Deprecated) Response latency distribution in microseconds for each verb, group, version, resource, subresource, scope and component. (count)",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_request_latencies_summary": {
          "type": "cumulative",
          "description": "(Deprecated) Response latency summary in microseconds for each verb, group, version, resource, subresource, scope and component. (sum)",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_request_latencies_summary_count": {
          "type": "cumulative",
          "description": "(Deprecated) Response latency summary in microseconds for each verb, group, version, resource, subresource, scope and component. (count)",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_request_latencies_summary_quantile": {
          "type": "gauge",
          "description": "(Deprecated) Response latency summary in microseconds for each verb, group, version, resource, subresource, scope and component. (quantized)",
          "group": "apiserver_request",
          "default": false
        },
        "apiserver_response_sizes": {
          "type": "cumulative",
          "description": "Response size distribution in bytes for each group, version, verb, resource, subresource, scope and component. (sum)",
          "group": "apiserver_response",
          "default": false
        },
        "apiserver_response_sizes_bucket": {
          "type": "cumulative",
          "description": "Response size distribution in bytes for each group, version, verb, resource, subresource, scope and component. (bucket)",
          "group": "apiserver_response",
          "default": false
        },
        "apiserver_response_sizes_count": {
          "type": "cumulative",
          "description": "Response size distribution in bytes for each group, version, verb, resource, subresource, scope and component. (count)",
          "group": "apiserver_response",
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (sum)",
          "group": "apiserver_storage",
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (bucket)",
          "group": "apiserver_storage",
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds_count": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (count)",
          "group": "apiserver_storage",
          "default": false
        },
        "apiserver_storage_data_key_generation_failures": {
          "type": "cumulative",
          "description": "Total number of failed data encryption key(DEK) generation operations.",
          "group": "apiserver_storage",
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (sum)",
          "group": "apiserver_storage",
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (bucket)",
          "group": "apiserver_storage",
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (count)",
          "group": "apiserver_storage",
          "default": false
        },
        "apiserver_storage_envelope_transformation_cache_misses": {
          "type": "cumulative",
          "description": "Total number of cache misses while accessing key decryption key(KEK).",
          "group": "apiserver_storage",
          "default": false
        },
        "authenticated_user_requests": {
          "type": "cumulative",
          "description": "Counter of authenticated requests broken out by username.",
          "group": null,
          "default": false
        },
        "autoregister_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: autoregister",
          "group": "autoregister",
          "default": false
        },
        "autoregister_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: autoregister",
          "group": "autoregister",
          "default": false
        },
        "autoregister_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for autoregister been running.",
          "group": "autoregister",
          "default": false
        },
        "autoregister_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueautoregister before being requested. (sum)",
          "group": "autoregister",
          "default": false
        },
        "autoregister_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueueautoregister before being requested. (count)",
          "group": "autoregister",
          "default": false
        },
        "autoregister_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueueautoregister before being requested. (quantized)",
          "group": "autoregister",
          "default": false
        },
        "autoregister_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: autoregister",
          "group": "autoregister",
          "default": false
        },
        "autoregister_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work autoregister has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "autoregister",
          "default": false
        },
        "autoregister_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueautoregister takes. (sum)",
          "group": "autoregister",
          "default": false
        },
        "autoregister_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueueautoregister takes. (count)",
          "group": "autoregister",
          "default": false
        },
        "autoregister_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueueautoregister takes. (quantized)",
          "group": "autoregister",
          "default": false
        },
        "crdEstablishing_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: crdEstablishing",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: crdEstablishing",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for crdEstablishing been running.",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecrdEstablishing before being requested. (sum)",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecrdEstablishing before being requested. (count)",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuecrdEstablishing before being requested. (quantized)",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: crdEstablishing",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work crdEstablishing has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecrdEstablishing takes. (sum)",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecrdEstablishing takes. (count)",
          "group": "crd_establishing",
          "default": false
        },
        "crdEstablishing_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuecrdEstablishing takes. (quantized)",
          "group": "crd_establishing",
          "default": false
        },
        "crd_autoregistration_controller_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: crd_autoregistration_controller",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: crd_autoregistration_controller",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for crd_autoregistration_controller been running.",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecrd_autoregistration_controller before being requested. (sum)",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecrd_autoregistration_controller before being requested. (count)",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuecrd_autoregistration_controller before being requested. (quantized)",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: crd_autoregistration_controller",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work crd_autoregistration_controller has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecrd_autoregistration_controller takes. (sum)",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecrd_autoregistration_controller takes. (count)",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_autoregistration_controller_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuecrd_autoregistration_controller takes. (quantized)",
          "group": "crd_autoregistration_controller",
          "default": false
        },
        "crd_finalizer_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: crd_finalizer",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: crd_finalizer",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for crd_finalizer been running.",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecrd_finalizer before being requested. (sum)",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecrd_finalizer before being requested. (count)",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuecrd_finalizer before being requested. (quantized)",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: crd_finalizer",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work crd_finalizer has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecrd_finalizer takes. (sum)",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecrd_finalizer takes. (count)",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_finalizer_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuecrd_finalizer takes. (quantized)",
          "group": "crd_finalizer",
          "default": false
        },
        "crd_naming_condition_controller_adds": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of adds handled by workqueue: crd_naming_condition_controller",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_depth": {
          "type": "gauge",
          "description": "(Deprecated) Current depth of workqueue: crd_naming_condition_controller",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_longest_running_processor_microseconds": {
          "type": "gauge",
          "description": "(Deprecated) How many microseconds has the longest running processor for crd_naming_condition_controller been running.",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_queue_latency": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecrd_naming_condition_controller before being requested. (sum)",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_queue_latency_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long an item stays in workqueuecrd_naming_condition_controller before being requested. (count)",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_queue_latency_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long an item stays in workqueuecrd_naming_condition_controller before being requested. (quantized)",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_retries": {
          "type": "cumulative",
          "description": "(Deprecated) Total number of retries handled by workqueue: crd_naming_condition_controller",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_unfinished_work_seconds": {
          "type": "gauge",
          "description": "(Deprecated) How many seconds of work crd_naming_condition_controller has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_work_duration": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecrd_naming_condition_controller takes. (sum)",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_work_duration_count": {
          "type": "cumulative",
          "description": "(Deprecated) How long processing an item from workqueuecrd_naming_condition_controller takes. (count)",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "crd_naming_condition_controller_work_duration_quantile": {
          "type": "gauge",
          "description": "(Deprecated) How long processing an item from workqueuecrd_naming_condition_controller takes. (quantized)",
          "group": "crd_naming_condition_controller",
          "default": false
        },
        "etcd_helper_cache_entry": {
          "type": "cumulative",
          "description": "Counter of etcd helper cache entries. This can be different from etcd_helper_cache_miss_count because two concurrent threads can miss the cache and generate the same entry twice.",
          "group": "etcd",
          "default": false
        },
        "etcd_helper_cache_entry_count": {
          "type": "cumulative",
          "description": "(Deprecated) Counter of etcd helper cache entries. This can be different from etcd_helper_cache_miss_count because two concurrent threads can miss the cache and generate the same entry twice.",
          "group": "etcd",
          "default": false
        },
        "etcd_helper_cache_hit": {
          "type": "cumulative",
          "description": "Counter of etcd helper cache hits.",
          "group": "etcd",
          "default": false
        },
        "etcd_helper_cache_hit_count": {
          "type": "cumulative",
          "description": "(Deprecated) Counter of etcd helper cache hits.",
          "group": "etcd",
          "default": false
        },
        "etcd_helper_cache_miss": {
          "type": "cumulative",
          "description": "Counter of etcd helper cache miss.",
          "group": "etcd",
          "default": false
        },
        "etcd_helper_cache_miss_count": {
          "type": "cumulative",
          "description": "(Deprecated) Counter of etcd helper cache miss.",
          "group": "etcd",
          "default": false
        },
        "etcd_object_counts": {
          "type": "gauge",
          "description": "Number of stored objects at the time of last check split by kind.",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_add_duration_seconds": {
          "type": "cumulative",
          "description": "Latency in seconds of adding an object to etcd cache (sum)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_add_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Latency in seconds of adding an object to etcd cache (bucket)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_add_duration_seconds_count": {
          "type": "cumulative",
          "description": "Latency in seconds of adding an object to etcd cache (count)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_add_latencies_summary": {
          "type": "cumulative",
          "description": "(Deprecated) Latency in microseconds of adding an object to etcd cache (sum)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_add_latencies_summary_count": {
          "type": "cumulative",
          "description": "(Deprecated) Latency in microseconds of adding an object to etcd cache (count)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_add_latencies_summary_quantile": {
          "type": "gauge",
          "description": "(Deprecated) Latency in microseconds of adding an object to etcd cache (quantized)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_get_duration_seconds": {
          "type": "cumulative",
          "description": "Latency in seconds of getting an object from etcd cache (sum)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_get_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Latency in seconds of getting an object from etcd cache (bucket)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_get_duration_seconds_count": {
          "type": "cumulative",
          "description": "Latency in seconds of getting an object from etcd cache (count)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_get_latencies_summary": {
          "type": "cumulative",
          "description": "(Deprecated) Latency in microseconds of getting an object from etcd cache (sum)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_get_latencies_summary_count": {
          "type": "cumulative",
          "description": "(Deprecated) Latency in microseconds of getting an object from etcd cache (count)",
          "group": "etcd",
          "default": false
        },
        "etcd_request_cache_get_latencies_summary_quantile": {
          "type": "gauge",
          "description": "(Deprecated) Latency in microseconds of getting an object from etcd cache (quantized)",
          "group": "etcd",
          "default": false
        },
        "get_token_count": {
          "type": "cumulative",
          "description": "Counter of total Token() requests to the alternate token source",
          "group": "token",
          "default": false
        },
        "get_token_fail_count": {
          "type": "cumulative",
          "description": "Counter of failed Token() requests to the alternate token source",
          "group": "token",
          "default": false
        },
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (sum)",
          "group": "prometheus_go",
          "default": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (count)",
          "group": "prometheus_go",
          "default": false
        },
        "go_gc_duration_seconds_quantile": {
          "type": "gauge",
          "description": "A summary of the GC invocation durations. (quantized)",
          "group": "prometheus_go",
          "default": false
        },
        "go_goroutines": {
          "type": "gauge",
          "description": "Number of goroutines that currently exist.",
          "group": "prometheus_go",
          "default": false
        },
        "go_info": {
          "type": "gauge",
          "description": "Information about the Go environment.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_alloc_bytes": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_frees": {
          "type": "cumulative",
          "description": "Total number of frees.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Number of seconds since 1970 of last garbage collection.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_lookups": {
          "type": "cumulative",
          "description": "Total number of pointer lookups.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_mallocs": {
          "type": "cumulative",
          "description": "Total number of mallocs.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator.",
          "group": "prometheus_go",
          "default": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system.",
          "group": "prometheus_go",
          "default": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created.",
          "group": "prometheus_go",
          "default": false
        },
        "grpc_client_handled": {
          "type": "cumulative",
          "description": "Total number of RPCs completed by the client, regardless of success or failure.",
          "group": "grpc_client",
          "default": false
        },
        "grpc_client_msg_received": {
          "type": "cumulative",
          "description": "Total number of RPC stream messages received by the client.",
          "group": "grpc_client",
          "default": false
        },
        "grpc_client_msg_sent": {
          "type": "cumulative",
          "description": "Total number of gRPC stream messages sent by the client.",
          "group": "grpc_client",
          "default": false
        },
        "grpc_client_started": {
          "type": "cumulative",
          "description": "Total number of RPCs started on the client.",
          "group": "grpc_client",
          "default": false
        },
        "http_request_duration_microseconds": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (sum)",
          "group": "http_request",
          "default": false
        },
        "http_request_duration_microseconds_count": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (count)",
          "group": "http_request",
          "default": false
        },
        "http_request_duration_microseconds_quantile": {
          "type": "gauge",
          "description": "The HTTP request latencies in microseconds. (quantized)",
          "group": "http_request",
          "default": false
        },
        "http_request_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (sum)",
          "group": "http_request",
          "default": false
        },
        "http_request_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (count)",
          "group": "http_request",
          "default": false
        },
        "http_request_size_bytes_quantile": {
          "type": "gauge",
          "description": "The HTTP request sizes in bytes. (quantized)",
          "group": "http_request",
          "default": false
        },
        "http_requests": {
          "type": "cumulative",
          "description": "Total number of HTTP requests made.",
          "group": "http_request",
          "default": false
        },
        "http_response_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (sum)",
          "group": "http_response",
          "default": false
        },
        "http_response_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (count)",
          "group": "http_response",
          "default": false
        },
        "http_response_size_bytes_quantile": {
          "type": "gauge",
          "description": "The HTTP response sizes in bytes. (quantized)",
          "group": "http_response",
          "default": false
        },
        "kubernetes_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by major, minor, git version, git commit, git tree state, build date, Go version, and compiler from which Kubernetes was built, and platform on which it is running.",
          "group": null,
          "default": false
        },
        "process_cpu_seconds": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent in seconds.",
          "group": "prometheus_process",
          "default": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors.",
          "group": "prometheus_process",
          "default": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors.",
          "group": "prometheus_process",
          "default": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes.",
          "group": "prometheus_process",
          "default": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds.",
          "group": "prometheus_process",
          "default": false
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes.",
          "group": "prometheus_process",
          "default": false
        },
        "process_virtual_memory_max_bytes": {
          "type": "gauge",
          "description": "Maximum amount of virtual memory available in bytes.",
          "group": "prometheus_process",
          "default": false
        },
        "rest_client_request_duration_seconds": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (sum)",
          "group": "rest_client",
          "default": false
        },
        "rest_client_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (bucket)",
          "group": "rest_client",
          "default": false
        },
        "rest_client_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (count)",
          "group": "rest_client",
          "default": false
        },
        "rest_client_request_latency_seconds": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (sum)",
          "group": "rest_client",
          "default": false
        },
        "rest_client_request_latency_seconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (bucket)",
          "group": "rest_client",
          "default": false
        },
        "rest_client_request_latency_seconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (count)",
          "group": "rest_client",
          "default": false
        },
        "rest_client_requests": {
          "type": "cumulative",
          "description": "Number of HTTP requests, partitioned by status code, method, and host.",
          "group": "rest_client",
          "default": false
        },
        "ssh_tunnel_open_count": {
          "type": "cumulative",
          "description": "Counter of ssh tunnel total open attempts",
          "group": "ssh_tunnel",
          "default": false
        },
        "ssh_tunnel_open_fail_count": {
          "type": "cumulative",
          "description": "Counter of ssh tunnel failed open attempts",
          "group": "ssh_tunnel",
          "default": false
        },
        "workqueue_adds": {
          "type": "cumulative",
          "description": "Total number of adds handled by workqueue",
          "group": "workqueue",
          "default": true
        },
        "workqueue_depth": {
          "type": "gauge",
          "description": "Current depth of workqueue",
          "group": "workqueue",
          "default": true
        },
        "workqueue_longest_running_processor_seconds": {
          "type": "gauge",
          "description": "How many seconds has the longest running processor for workqueue been running.",
          "group": "workqueue",
          "default": false
        },
        "workqueue_queue_duration_seconds": {
          "type": "cumulative",
          "description": "How long in seconds an item stays in workqueue before being requested. (sum)",
          "group": "workqueue",
          "default": false
        },
        "workqueue_queue_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "How long in seconds an item stays in workqueue before being requested. (bucket)",
          "group": "workqueue",
          "default": false
        },
        "workqueue_queue_duration_seconds_count": {
          "type": "cumulative",
          "description": "How long in seconds an item stays in workqueue before being requested. (count)",
          "group": "workqueue",
          "default": false
        },
        "workqueue_retries": {
          "type": "cumulative",
          "description": "Total number of retries handled by workqueue",
          "group": "workqueue",
          "default": false
        },
        "workqueue_unfinished_work_seconds": {
          "type": "gauge",
          "description": "How many seconds of work has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.",
          "group": "workqueue",
          "default": false
        },
        "workqueue_work_duration_seconds": {
          "type": "cumulative",
          "description": "How long in seconds processing an item from workqueue takes. (sum)",
          "group": "workqueue",
          "default": false
        },
        "workqueue_work_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "How long in seconds processing an item from workqueue takes. (bucket)",
          "group": "workqueue",
          "default": false
        },
        "workqueue_work_duration_seconds_count": {
          "type": "cumulative",
          "description": "How long in seconds processing an item from workqueue takes. (count)",
          "group": "workqueue",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/kubernetes/apiserver",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-cluster",
      "sendAll": false,
      "dimensions": {
        "kubernetes_name": {
          "description": "The name of the resource that the metric describes"
        },
        "kubernetes_namespace": {
          "description": "The namespace of the resource that the metric describes"
        },
        "kubernetes_node": {
          "description": "The name of the node, as defined by the `name` field of the node resource."
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that the metric describes"
        },
        "machine_id": {
          "description": "The machine ID from /etc/machine-id.  This should be unique across all nodes in your cluster, but some cluster deployment tools don't guarantee this.  This will not be sent if the `useNodeName` config option is set to true."
        },
        "metric_source": {
          "description": "This is always set to `kubernetes`"
        },
        "quota_name": {
          "description": "The name of the k8s ResourceQuota object that the quota is part of"
        },
        "resource": {
          "description": "The k8s resource that the quota applies to"
        }
      },
      "doc": "*If you are using OpenShift there is an* [openshift-cluster](openshift-cluster.md)\n*monitor to be used instead of this monitor that contains additional OpenShift metrics.*\n\nCollects cluster-level metrics from the Kubernetes API server.  It uses the\n_watch_ functionality of the K8s API to listen for updates about the cluster\nand maintains a cache of metrics that get sent on a regular interval.\n\nSince the agent is generally running in multiple places in a K8s cluster and\nsince it is generally more convenient to share the same configuration across\nall agent instances, this monitor by default makes use of a leader election\nprocess to ensure that it is the only agent sending metrics in a cluster.\nAll of the agents running in the same namespace that have this monitor\nconfigured will decide amongst themselves which should send metrics for this\nmonitor, and the rest will stand by ready to activate if the leader agent\ndies.  You can override leader election by setting the config option\n`alwaysClusterReporter` to true, which will make the monitor always report\nmetrics.\n\nThis monitor is similar to\n[kube-state-metrics](https://github.com/kubernetes/kube-state-metrics), and\nsends many of the same metrics, but in a way that is less verbose and better\nfitted for the SignalFx backend.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "kubernetes.container_cpu_limit",
            "kubernetes.container_cpu_request",
            "kubernetes.container_ephemeral_storage_limit",
            "kubernetes.container_ephemeral_storage_request",
            "kubernetes.container_memory_limit",
            "kubernetes.container_memory_request",
            "kubernetes.container_ready",
            "kubernetes.container_restart_count",
            "kubernetes.cronjob.active",
            "kubernetes.daemon_set.current_scheduled",
            "kubernetes.daemon_set.desired_scheduled",
            "kubernetes.daemon_set.misscheduled",
            "kubernetes.daemon_set.ready",
            "kubernetes.deployment.available",
            "kubernetes.deployment.desired",
            "kubernetes.job.active",
            "kubernetes.job.completions",
            "kubernetes.job.failed",
            "kubernetes.job.parallelism",
            "kubernetes.job.succeeded",
            "kubernetes.namespace_phase",
            "kubernetes.node_ready",
            "kubernetes.pod_phase",
            "kubernetes.replica_set.available",
            "kubernetes.replica_set.desired",
            "kubernetes.replication_controller.available",
            "kubernetes.replication_controller.desired",
            "kubernetes.resource_quota_hard",
            "kubernetes.resource_quota_used",
            "kubernetes.stateful_set.current",
            "kubernetes.stateful_set.desired",
            "kubernetes.stateful_set.ready",
            "kubernetes.stateful_set.updated"
          ]
        },
        "hpa": {
          "description": "",
          "metrics": [
            "kubernetes.hpa.spec.max_replicas",
            "kubernetes.hpa.spec.min_replicas",
            "kubernetes.hpa.status.condition.able_to_scale",
            "kubernetes.hpa.status.condition.scaling_active",
            "kubernetes.hpa.status.condition.scaling_limited",
            "kubernetes.hpa.status.current_replicas",
            "kubernetes.hpa.status.desired_replicas"
          ]
        }
      },
      "metrics": {
        "kubernetes.container_cpu_limit": {
          "type": "gauge",
          "description": "Maximum CPU limit set for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available.",
          "group": null,
          "default": false
        },
        "kubernetes.container_cpu_request": {
          "type": "gauge",
          "description": "CPU requested for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available.",
          "group": null,
          "default": false
        },
        "kubernetes.container_ephemeral_storage_limit": {
          "type": "gauge",
          "description": "Maximum ephemeral storage set for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available. See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#local-ephemeral-storage for details.",
          "group": null,
          "default": false
        },
        "kubernetes.container_ephemeral_storage_request": {
          "type": "gauge",
          "description": "Ephemeral storage requested for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available. See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#local-ephemeral-storage for details",
          "group": null,
          "default": false
        },
        "kubernetes.container_memory_limit": {
          "type": "gauge",
          "description": "Maximum memory limit set for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available.",
          "group": null,
          "default": false
        },
        "kubernetes.container_memory_request": {
          "type": "gauge",
          "description": "Memory requested for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available.",
          "group": null,
          "default": false
        },
        "kubernetes.container_ready": {
          "type": "gauge",
          "description": "Whether a container has passed its readiness probe (0 for no, 1 for yes)",
          "group": null,
          "default": true
        },
        "kubernetes.container_restart_count": {
          "type": "gauge",
          "description": "How many times the container has restarted in the recent past.  This value is pulled directly from [the K8s API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#containerstatus-v1-core) and the value can go indefinitely high and be reset to 0 at any time depending on how your [kubelet is configured to prune dead containers](https://kubernetes.io/docs/concepts/cluster-administration/kubelet-garbage-collection/). It is best to not depend too much on the exact value but rather look at it as either `== 0`, in which case you can conclude there were no restarts in the recent past, or `\u003e 0`, in which case you can conclude there were restarts in the recent past, and not try and analyze the value beyond that.",
          "group": null,
          "default": true
        },
        "kubernetes.cronjob.active": {
          "type": "gauge",
          "description": "The number of actively running jobs for a cronjob.",
          "group": null,
          "default": false
        },
        "kubernetes.daemon_set.current_scheduled": {
          "type": "gauge",
          "description": "The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod",
          "group": null,
          "default": true
        },
        "kubernetes.daemon_set.desired_scheduled": {
          "type": "gauge",
          "description": "The total number of nodes that should be running the daemon pod (including nodes currently running the daemon pod)",
          "group": null,
          "default": true
        },
        "kubernetes.daemon_set.misscheduled": {
          "type": "gauge",
          "description": "The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod",
          "group": null,
          "default": true
        },
        "kubernetes.daemon_set.ready": {
          "type": "gauge",
          "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready",
          "group": null,
          "default": true
        },
        "kubernetes.deployment.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.",
          "group": null,
          "default": true
        },
        "kubernetes.deployment.desired": {
          "type": "gauge",
          "description": "Number of desired pods in this deployment",
          "group": null,
          "default": true
        },
        "kubernetes.hpa.spec.max_replicas": {
          "type": "gauge",
          "description": "The upper limit for the number of replicas to which the autoscaler can scale up. It cannot be less that minReplicas.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.spec.min_replicas": {
          "type": "gauge",
          "description": "The lower limit for the number of replicas to which the autoscaler can scale down. It defaults to 1 pod.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.condition.able_to_scale": {
          "type": "gauge",
          "description": "A status value that indicates the autoscaler status in reference to the AbleToScale condition. A value of 1 means that the autoscaler is in the AbleToScale condition, a 0 value means that it is not, and -1 means that the status of the AbleToScale condition is unknown. AbleToScale indicates a lack of transient issues which prevent scaling from occurring, such as being in a backoff window, or being unable to access/update the target scale.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.condition.scaling_active": {
          "type": "gauge",
          "description": "A status value that indicates the autoscaler status in reference to the ScalingActive condition. A value of 1 means that the autoscaler is in the ScalingActive condition, a 0 value means that it is not, and -1 means that the status of the ScalingActive condition is unknown. ScalingActive indicates that the HPA controller is able to scale if necessary.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.condition.scaling_limited": {
          "type": "gauge",
          "description": "A status value that indicates the autoscaler status in reference to the ScalingLimited condition. A value of 1 means that the autoscaler is in the ScalingLimited condition, a 0 value means that it is not, and -1 means that the status of the ScalingLimited condition is unknown. ScalingLimited indicates that the calculated scale based on metrics would be above or below the range for the HPA, and has thus been capped.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.current_replicas": {
          "type": "gauge",
          "description": "The current number of pod replicas managed by this autoscaler.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.desired_replicas": {
          "type": "gauge",
          "description": "The desired number of pod replicas managed by this autoscaler.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.job.active": {
          "type": "gauge",
          "description": "The number of actively running pods for a job.",
          "group": null,
          "default": false
        },
        "kubernetes.job.completions": {
          "type": "gauge",
          "description": "The desired number of successfully finished pods the job should be run with.",
          "group": null,
          "default": false
        },
        "kubernetes.job.failed": {
          "type": "counter",
          "description": "The number of pods which reased phase Failed for a job.",
          "group": null,
          "default": false
        },
        "kubernetes.job.parallelism": {
          "type": "gauge",
          "description": "The max desired number of pods the job should run at any given time.",
          "group": null,
          "default": false
        },
        "kubernetes.job.succeeded": {
          "type": "counter",
          "description": "The number of pods which reached phase Succeeded for a job.",
          "group": null,
          "default": false
        },
        "kubernetes.namespace_phase": {
          "type": "gauge",
          "description": "The current phase of namespaces (`1` for _active_ and `0` for _terminating_)",
          "group": null,
          "default": true
        },
        "kubernetes.node_ready": {
          "type": "gauge",
          "description": "Whether this node is ready (1), not ready (0) or in an unknown state (-1)",
          "group": null,
          "default": true
        },
        "kubernetes.pod_phase": {
          "type": "gauge",
          "description": "Current phase of the pod (1 - Pending, 2 - Running, 3 - Succeeded, 4 - Failed, 5 - Unknown)",
          "group": null,
          "default": true
        },
        "kubernetes.replica_set.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replica set",
          "group": null,
          "default": true
        },
        "kubernetes.replica_set.desired": {
          "type": "gauge",
          "description": "Number of desired pods in this replica set",
          "group": null,
          "default": true
        },
        "kubernetes.replication_controller.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replication controller.",
          "group": null,
          "default": true
        },
        "kubernetes.replication_controller.desired": {
          "type": "gauge",
          "description": "Number of desired pods (the `spec.replicas` field)",
          "group": null,
          "default": true
        },
        "kubernetes.resource_quota_hard": {
          "type": "gauge",
          "description": "The upper limit for a particular resource in a specific namespace.  Will only be sent if a quota is specified. CPU requests/limits will be sent as millicores.",
          "group": null,
          "default": true
        },
        "kubernetes.resource_quota_used": {
          "type": "gauge",
          "description": "The usage for a particular resource in a specific namespace.  Will only be sent if a quota is specified. CPU requests/limits will be sent as millicores.",
          "group": null,
          "default": true
        },
        "kubernetes.stateful_set.current": {
          "type": "gauge",
          "description": "The number of pods created by the StatefulSet controller from the\nStatefulSet version indicated by `current_revision` property on the\n`kubernetes_uid` dimension for this StatefulSet.\n",
          "group": null,
          "default": false
        },
        "kubernetes.stateful_set.desired": {
          "type": "gauge",
          "description": "Number of desired pods in the stateful set (the `spec.replicas` field)",
          "group": null,
          "default": false
        },
        "kubernetes.stateful_set.ready": {
          "type": "gauge",
          "description": "Number of pods created by the stateful set that have the `Ready` condition",
          "group": null,
          "default": false
        },
        "kubernetes.stateful_set.updated": {
          "type": "gauge",
          "description": "The number of pods created by the StatefulSet controller from the\nStatefulSet version indicated by the `update_revision` property on the\n`kubernetes_uid` dimension for this StatefulSet.\n",
          "group": null,
          "default": false
        }
      },
      "properties": {
        "\u003cnode label\u003e": {
          "dimension": "machine_id/kubernetes_node",
          "description": "All non-blank labels on a given node will be synced as properties to the `machine_id` or `kubernetes_node` dimension value for that node.  Which dimension gets the properties is determined by the `useNodeName` config option.  Any blank values will be synced as tags on that same dimension."
        },
        "\u003cpod label\u003e": {
          "dimension": "kubernetes_pod_uid",
          "description": "Any labels with non-blank values on the pod will be synced as properties to the `kubernetes_pod_uid` dimension. Any blank labels will be synced as tags on that same dimension."
        },
        "container_status": {
          "dimension": "container_id",
          "description": "Status of the container such as `running`, `waiting` or `terminated` are synced to the `container_id` dimension."
        },
        "container_status_reason": {
          "dimension": "container_id",
          "description": "Reason why a container is in a particular state. This property is synced to `container_id` only if the value of `cotnainer_status` is either `waiting` or `terminated`."
        },
        "cronjob_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the cron job was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "daemonset_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the daemon set was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "deployment_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the deployment was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "job_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the job was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "pod_creation_timestamp": {
          "dimension": "kubernetes_pod_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the pod was created and is in UTC. This property is synced onto `kubernetes_pod_uid`."
        },
        "replicaset_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the replica set was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "statefulset_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the stateful set was created and is in UTC. This property is synced onto `kubernetes_uid`."
        }
      },
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the K8s monitor",
        "package": "pkg/monitors/kubernetes/cluster",
        "fields": [
          {
            "yamlName": "alwaysClusterReporter",
            "doc": "If `true`, leader election is skipped and metrics are always reported.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "namespace",
            "doc": "If specified, only resources within the given namespace will be monitored.  If omitted (blank) all supported resources across all namespaces will be monitored.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useNodeName",
            "doc": "If set to true, the Kubernetes node name will be used as the dimension to which to sync properties about each respective node.  This is necessary if your cluster's machines do not have unique machine-id values, as can happen when machine images are improperly cloned.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "kubernetesAPI",
            "doc": "Config for the K8s API client",
            "default": "",
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains options relevant to connecting to the K8s API",
              "package": "pkg/core/common/kubernetes",
              "fields": [
                {
                  "yamlName": "authType",
                  "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                  "default": "serviceAccount",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "nodeConditionTypesToReport",
            "doc": "A list of node status condition types to report as metrics.  The metrics will be reported as datapoints of the form `kubernetes.node_\u003ctype_snake_cased\u003e` with a value of `0` corresponding to \"False\", `1` to \"True\", and `-1` to \"Unknown\".",
            "default": [
              "Ready"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-events",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor sends Kubernetes events as SignalFx\nevents.  Upon startup, it will send all of the events that K8s has that are\nstill persisted and then send any new events that come in.  The various\nagents perform leader election amongst themselves to decide which instance\nwill send events, unless the `alwaysClusterReporter` config option is set to\ntrue.\n\nTo use this monitor, will need to configure which events to send. You can\nsee the types of events happening in your cluster with\n`kubectl get events -o yaml --all-namespaces`.\nFrom the output, you can select which events you would like to send by picking\nout the Reason (Started, Created, Scheduled...) and\nKind (Pod, ReplicaSet, Deployment...) combinations. These are placed in the\nwhitelistedEvents configuration option as a list of events you want to send.\n\nExample YAML Configuration\n\n```\n- type: kubernetes-events\n  whitelistedEvents:\n    - reason: Created\n      involvedObjectKind: Pod\n    - reason: SuccessfulCreate\n      involvedObjectKind: ReplicaSet\n```\n\nEvent names will match the `reason` name.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the K8s event monitor",
        "package": "pkg/monitors/kubernetes/events",
        "fields": [
          {
            "yamlName": "kubernetesAPI",
            "doc": "Configuration of the Kubernetes API client",
            "default": "",
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains options relevant to connecting to the K8s API",
              "package": "pkg/core/common/kubernetes",
              "fields": [
                {
                  "yamlName": "authType",
                  "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                  "default": "serviceAccount",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "whitelistedEvents",
            "doc": "A list of event types to send events for.  Only events matching these items will be sent.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "EventInclusionSpec",
              "doc": "EventInclusionSpec specifies a type of event to send",
              "package": "pkg/monitors/kubernetes/events",
              "fields": [
                {
                  "yamlName": "reason",
                  "doc": "",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "involvedObjectKind",
                  "doc": "",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "alwaysClusterReporter",
            "doc": "Whether to always send events from this agent instance or to do leader election to only send from one agent instance.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-proxy",
      "sendAll": false,
      "dimensions": null,
      "doc": "Exports Prometheus metrics from the [kube-proxy](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy)\nmetrics in Prometheus format. The monitor queries path `/metrics` by default when no path is configured. The monitor converts\nthe Prometheus metric types to SignalFx metric types as described [here](prometheus-exporter.md)\n\nExample YAML Configuration\n\n```yaml\nmonitors:\n- type: kubernetes-proxy\n  discoveryRule: kubernetes_pod_name =~ \"kube-proxy\" \u0026\u0026 target == \"pod\"\n  configEndpointMappings:\n    host: '\"127.0.0.1\"'\n  port: 10249\n  extraDimensions:\n    metric_source: kubernetes-proxy\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "apiserver_audit_event_total",
            "apiserver_audit_requests_rejected_total",
            "go_gc_duration_seconds",
            "go_gc_duration_seconds_count",
            "go_gc_duration_seconds_sum",
            "go_goroutines",
            "go_info",
            "go_memstats_alloc_bytes",
            "go_memstats_alloc_bytes_total",
            "go_memstats_buck_hash_sys_bytes",
            "go_memstats_frees_total",
            "go_memstats_gc_cpu_fraction",
            "go_memstats_gc_sys_bytes",
            "go_memstats_heap_alloc_bytes",
            "go_memstats_heap_idle_bytes",
            "go_memstats_heap_inuse_bytes",
            "go_memstats_heap_objects",
            "go_memstats_heap_released_bytes",
            "go_memstats_heap_sys_bytes",
            "go_memstats_last_gc_time_seconds",
            "go_memstats_lookups_total",
            "go_memstats_mallocs_total",
            "go_memstats_mcache_inuse_bytes",
            "go_memstats_mcache_sys_bytes",
            "go_memstats_mspan_inuse_bytes",
            "go_memstats_mspan_sys_bytes",
            "go_memstats_next_gc_bytes",
            "go_memstats_other_sys_bytes",
            "go_memstats_stack_inuse_bytes",
            "go_memstats_stack_sys_bytes",
            "go_memstats_sys_bytes",
            "go_threads",
            "http_request_duration_microseconds",
            "http_request_duration_microseconds_count",
            "http_request_duration_microseconds_sum",
            "http_request_size_bytes",
            "http_request_size_bytes_count",
            "http_request_size_bytes_sum",
            "http_requests_total",
            "http_response_size_bytes",
            "http_response_size_bytes_count",
            "http_response_size_bytes_sum",
            "kubeproxy_network_programming_duration_seconds_bucket",
            "kubeproxy_network_programming_duration_seconds_count",
            "kubeproxy_network_programming_duration_seconds_sum",
            "kubeproxy_sync_proxy_rules_duration_seconds_bucket",
            "kubeproxy_sync_proxy_rules_duration_seconds_count",
            "kubeproxy_sync_proxy_rules_duration_seconds_sum",
            "kubeproxy_sync_proxy_rules_endpoint_changes_pending",
            "kubeproxy_sync_proxy_rules_endpoint_changes_total",
            "kubeproxy_sync_proxy_rules_last_timestamp_seconds",
            "kubeproxy_sync_proxy_rules_latency_microseconds_bucket",
            "kubeproxy_sync_proxy_rules_latency_microseconds_count",
            "kubeproxy_sync_proxy_rules_latency_microseconds_sum",
            "kubeproxy_sync_proxy_rules_service_changes_pending",
            "kubeproxy_sync_proxy_rules_service_changes_total",
            "kubernetes_build_info",
            "process_cpu_seconds_total",
            "process_max_fds",
            "process_open_fds",
            "process_resident_memory_bytes",
            "process_start_time_seconds",
            "process_virtual_memory_bytes",
            "process_virtual_memory_max_bytes",
            "rest_client_request_duration_seconds_bucket",
            "rest_client_request_duration_seconds_sum",
            "rest_client_request_latency_seconds_bucket",
            "rest_client_request_latency_seconds_count",
            "rest_client_request_latency_seconds_sum",
            "rest_client_requests_total"
          ]
        }
      },
      "metrics": {
        "apiserver_audit_event_total": {
          "type": "cumulative",
          "description": "Counter of audit events generated and sent to the audit backend.",
          "group": null,
          "default": false
        },
        "apiserver_audit_requests_rejected_total": {
          "type": "cumulative",
          "description": "Counter of apiserver requests rejected due to an error in audit logging backend.",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations.",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (count)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_sum": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (sum)",
          "group": null,
          "default": false
        },
        "go_goroutines": {
          "type": "gauge",
          "description": "Number of goroutines that currently exist.",
          "group": null,
          "default": false
        },
        "go_info": {
          "type": "gauge",
          "description": "Information about the Go environment.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed. (total)",
          "group": null,
          "default": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table.",
          "group": null,
          "default": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Number of seconds since 1970 of last garbage collection.",
          "group": null,
          "default": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups.",
          "group": null,
          "default": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place.",
          "group": null,
          "default": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created.",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds.",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds_count": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (count)",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds_sum": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (sum)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes.",
          "group": null,
          "default": false
        },
        "http_request_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (count)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes_sum": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (sum)",
          "group": null,
          "default": false
        },
        "http_requests_total": {
          "type": "cumulative",
          "description": "Total number of HTTP requests made.",
          "group": null,
          "default": false
        },
        "http_response_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes.",
          "group": null,
          "default": false
        },
        "http_response_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (count)",
          "group": null,
          "default": false
        },
        "http_response_size_bytes_sum": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (sum)",
          "group": null,
          "default": false
        },
        "kubeproxy_network_programming_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "In Cluster Network Programming Latency in seconds (bucket)",
          "group": null,
          "default": true
        },
        "kubeproxy_network_programming_duration_seconds_count": {
          "type": "cumulative",
          "description": "In Cluster Network Programming Latency in seconds (count)",
          "group": null,
          "default": true
        },
        "kubeproxy_network_programming_duration_seconds_sum": {
          "type": "cumulative",
          "description": "In Cluster Network Programming Latency in seconds (sum)",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "SyncProxyRules latency in seconds (bucket)",
          "group": null,
          "default": true
        },
        "kubeproxy_sync_proxy_rules_duration_seconds_count": {
          "type": "cumulative",
          "description": "SyncProxyRules latency in seconds (count)",
          "group": null,
          "default": true
        },
        "kubeproxy_sync_proxy_rules_duration_seconds_sum": {
          "type": "cumulative",
          "description": "SyncProxyRules latency in seconds (sum)",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_endpoint_changes_pending": {
          "type": "gauge",
          "description": "Number of pending endpoint changes that have not yet been synced to the proxy",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_endpoint_changes_total": {
          "type": "gauge",
          "description": "Number of total endpoint changes that have not yet been synced to the proxy",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_last_timestamp_seconds": {
          "type": "gauge",
          "description": "",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_latency_microseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) SyncProxyRules latency in microseconds (bucket)",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_latency_microseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) SyncProxyRules latency in microseconds (count)",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_latency_microseconds_sum": {
          "type": "cumulative",
          "description": "(Deprecated) SyncProxyRules latency in microseconds (sum)",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_service_changes_pending": {
          "type": "gauge",
          "description": "Number of pending service changes that have not yet been synced to the proxy.",
          "group": null,
          "default": false
        },
        "kubeproxy_sync_proxy_rules_service_changes_total": {
          "type": "gauge",
          "description": "Number of total service changes that have not yet been synced to the proxy.",
          "group": null,
          "default": false
        },
        "kubernetes_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by major, minor, git version, git commit, git tree state, build date, Go version, and compiler from which Kubernetes was built, and platform on which it is running.",
          "group": null,
          "default": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent, in seconds.",
          "group": null,
          "default": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_max_bytes": {
          "type": "gauge",
          "description": "Maximum amount of virtual memory available in bytes.",
          "group": null,
          "default": false
        },
        "rest_client_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (bucket)",
          "group": null,
          "default": false
        },
        "rest_client_request_duration_seconds_sum": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (sum)",
          "group": null,
          "default": false
        },
        "rest_client_request_latency_seconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (bucket)",
          "group": null,
          "default": true
        },
        "rest_client_request_latency_seconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (count)",
          "group": null,
          "default": false
        },
        "rest_client_request_latency_seconds_sum": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (sum)",
          "group": null,
          "default": false
        },
        "rest_client_requests_total": {
          "type": "cumulative",
          "description": "Number of HTTP requests, partitioned by status code, method, and host.",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/kubernetes/proxy",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-scheduler",
      "sendAll": false,
      "dimensions": null,
      "doc": "Exports Prometheus metrics from the [kube-scheduler](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler).\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "apiserver_audit_event_total",
            "apiserver_audit_requests_rejected_total",
            "apiserver_client_certificate_expiration_seconds",
            "apiserver_client_certificate_expiration_seconds_bucket",
            "apiserver_client_certificate_expiration_seconds_count",
            "apiserver_storage_data_key_generation_duration_seconds",
            "apiserver_storage_data_key_generation_duration_seconds_bucket",
            "apiserver_storage_data_key_generation_duration_seconds_count",
            "apiserver_storage_data_key_generation_failures_total",
            "apiserver_storage_data_key_generation_latencies_microseconds",
            "apiserver_storage_data_key_generation_latencies_microseconds_bucket",
            "apiserver_storage_data_key_generation_latencies_microseconds_count",
            "apiserver_storage_envelope_transformation_cache_misses_total",
            "go_gc_duration_seconds",
            "go_gc_duration_seconds_count",
            "go_gc_duration_seconds_quantile",
            "go_goroutines",
            "go_info",
            "go_memstats_alloc_bytes",
            "go_memstats_alloc_bytes_total",
            "go_memstats_buck_hash_sys_bytes",
            "go_memstats_frees_total",
            "go_memstats_gc_cpu_fraction",
            "go_memstats_gc_sys_bytes",
            "go_memstats_heap_alloc_bytes",
            "go_memstats_heap_idle_bytes",
            "go_memstats_heap_inuse_bytes",
            "go_memstats_heap_objects",
            "go_memstats_heap_released_bytes",
            "go_memstats_heap_sys_bytes",
            "go_memstats_last_gc_time_seconds",
            "go_memstats_lookups_total",
            "go_memstats_mallocs_total",
            "go_memstats_mcache_inuse_bytes",
            "go_memstats_mcache_sys_bytes",
            "go_memstats_mspan_inuse_bytes",
            "go_memstats_mspan_sys_bytes",
            "go_memstats_next_gc_bytes",
            "go_memstats_other_sys_bytes",
            "go_memstats_stack_inuse_bytes",
            "go_memstats_stack_sys_bytes",
            "go_memstats_sys_bytes",
            "go_threads",
            "http_request_duration_microseconds",
            "http_request_duration_microseconds_count",
            "http_request_duration_microseconds_quantile",
            "http_request_size_bytes",
            "http_request_size_bytes_count",
            "http_request_size_bytes_quantile",
            "http_requests_total",
            "http_response_size_bytes",
            "http_response_size_bytes_count",
            "http_response_size_bytes_quantile",
            "kubernetes_build_info",
            "leader_election_master_status",
            "process_cpu_seconds_total",
            "process_max_fds",
            "process_open_fds",
            "process_resident_memory_bytes",
            "process_start_time_seconds",
            "process_virtual_memory_bytes",
            "process_virtual_memory_max_bytes",
            "rest_client_request_duration_seconds",
            "rest_client_request_duration_seconds_bucket",
            "rest_client_request_duration_seconds_count",
            "rest_client_request_latency_seconds",
            "rest_client_request_latency_seconds_bucket",
            "rest_client_request_latency_seconds_count",
            "rest_client_requests_total",
            "scheduler_binding_duration_seconds",
            "scheduler_binding_duration_seconds_bucket",
            "scheduler_binding_duration_seconds_count",
            "scheduler_binding_latency_microseconds",
            "scheduler_binding_latency_microseconds_bucket",
            "scheduler_binding_latency_microseconds_count",
            "scheduler_e2e_scheduling_duration_seconds",
            "scheduler_e2e_scheduling_duration_seconds_bucket",
            "scheduler_e2e_scheduling_duration_seconds_count",
            "scheduler_e2e_scheduling_latency_microseconds",
            "scheduler_e2e_scheduling_latency_microseconds_bucket",
            "scheduler_e2e_scheduling_latency_microseconds_count",
            "scheduler_pending_pods",
            "scheduler_pod_preemption_victims",
            "scheduler_schedule_attempts_total",
            "scheduler_scheduling_algorithm_duration_seconds",
            "scheduler_scheduling_algorithm_duration_seconds_bucket",
            "scheduler_scheduling_algorithm_duration_seconds_count",
            "scheduler_scheduling_algorithm_latency_microseconds",
            "scheduler_scheduling_algorithm_latency_microseconds_bucket",
            "scheduler_scheduling_algorithm_latency_microseconds_count",
            "scheduler_scheduling_algorithm_predicate_evaluation",
            "scheduler_scheduling_algorithm_predicate_evaluation_bucket",
            "scheduler_scheduling_algorithm_predicate_evaluation_count",
            "scheduler_scheduling_algorithm_predicate_evaluation_seconds",
            "scheduler_scheduling_algorithm_predicate_evaluation_seconds_bucket",
            "scheduler_scheduling_algorithm_predicate_evaluation_seconds_count",
            "scheduler_scheduling_algorithm_preemption_evaluation",
            "scheduler_scheduling_algorithm_preemption_evaluation_bucket",
            "scheduler_scheduling_algorithm_preemption_evaluation_count",
            "scheduler_scheduling_algorithm_preemption_evaluation_seconds",
            "scheduler_scheduling_algorithm_preemption_evaluation_seconds_bucket",
            "scheduler_scheduling_algorithm_preemption_evaluation_seconds_count",
            "scheduler_scheduling_algorithm_priority_evaluation",
            "scheduler_scheduling_algorithm_priority_evaluation_bucket",
            "scheduler_scheduling_algorithm_priority_evaluation_count",
            "scheduler_scheduling_algorithm_priority_evaluation_seconds",
            "scheduler_scheduling_algorithm_priority_evaluation_seconds_bucket",
            "scheduler_scheduling_algorithm_priority_evaluation_seconds_count",
            "scheduler_scheduling_duration_seconds",
            "scheduler_scheduling_duration_seconds_count",
            "scheduler_scheduling_duration_seconds_quantile",
            "scheduler_scheduling_latency_seconds",
            "scheduler_scheduling_latency_seconds_count",
            "scheduler_scheduling_latency_seconds_quantile",
            "scheduler_total_preemption_attempts",
            "scheduler_volume_scheduling_duration_seconds",
            "scheduler_volume_scheduling_duration_seconds_bucket",
            "scheduler_volume_scheduling_duration_seconds_count"
          ]
        }
      },
      "metrics": {
        "apiserver_audit_event_total": {
          "type": "cumulative",
          "description": "Counter of audit events generated and sent to the audit backend.",
          "group": null,
          "default": false
        },
        "apiserver_audit_requests_rejected_total": {
          "type": "cumulative",
          "description": "Counter of apiserver requests rejected due to an error in audit logging backend.",
          "group": null,
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (sum)",
          "group": null,
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds_bucket": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (bucket)",
          "group": null,
          "default": false
        },
        "apiserver_client_certificate_expiration_seconds_count": {
          "type": "cumulative",
          "description": "Distribution of the remaining lifetime on the certificate used to authenticate a request. (count)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (sum)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (bucket)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_duration_seconds_count": {
          "type": "cumulative",
          "description": "Latencies in seconds of data encryption key(DEK) generation operations. (count)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_failures_total": {
          "type": "cumulative",
          "description": "Total number of failed data encryption key(DEK) generation operations.",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (sum)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (bucket)",
          "group": null,
          "default": false
        },
        "apiserver_storage_data_key_generation_latencies_microseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Latencies in microseconds of data encryption key(DEK) generation operations. (count)",
          "group": null,
          "default": false
        },
        "apiserver_storage_envelope_transformation_cache_misses_total": {
          "type": "cumulative",
          "description": "Total number of cache misses while accessing key decryption key(KEK).",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (sum)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations. (count)",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_quantile": {
          "type": "gauge",
          "description": "A summary of the GC invocation durations. (quantized)",
          "group": null,
          "default": false
        },
        "go_goroutines": {
          "type": "gauge",
          "description": "Number of goroutines that currently exist.",
          "group": null,
          "default": false
        },
        "go_info": {
          "type": "gauge",
          "description": "Information about the Go environment.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed.",
          "group": null,
          "default": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table.",
          "group": null,
          "default": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Number of seconds since 1970 of last garbage collection.",
          "group": null,
          "default": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups.",
          "group": null,
          "default": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place.",
          "group": null,
          "default": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created.",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (sum)",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds_count": {
          "type": "cumulative",
          "description": "The HTTP request latencies in microseconds. (count)",
          "group": null,
          "default": false
        },
        "http_request_duration_microseconds_quantile": {
          "type": "gauge",
          "description": "The HTTP request latencies in microseconds. (quantized)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (sum)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP request sizes in bytes. (count)",
          "group": null,
          "default": false
        },
        "http_request_size_bytes_quantile": {
          "type": "gauge",
          "description": "The HTTP request sizes in bytes. (quantized)",
          "group": null,
          "default": false
        },
        "http_requests_total": {
          "type": "cumulative",
          "description": "Total number of HTTP requests made.",
          "group": null,
          "default": false
        },
        "http_response_size_bytes": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (sum)",
          "group": null,
          "default": false
        },
        "http_response_size_bytes_count": {
          "type": "cumulative",
          "description": "The HTTP response sizes in bytes. (count)",
          "group": null,
          "default": false
        },
        "http_response_size_bytes_quantile": {
          "type": "gauge",
          "description": "The HTTP response sizes in bytes. (quantized)",
          "group": null,
          "default": false
        },
        "kubernetes_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by major, minor, git version, git commit, git tree state, build date, Go version, and compiler from which Kubernetes was built, and platform on which it is running.",
          "group": null,
          "default": false
        },
        "leader_election_master_status": {
          "type": "gauge",
          "description": "Gauge of if the reporting system is master of the relevant lease, 0 indicates backup, 1 indicates master. 'name' is the string used to identify the lease. Please make sure to group by name.",
          "group": null,
          "default": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent in seconds.",
          "group": null,
          "default": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_virtual_memory_max_bytes": {
          "type": "gauge",
          "description": "Maximum amount of virtual memory available in bytes.",
          "group": null,
          "default": false
        },
        "rest_client_request_duration_seconds": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (sum)",
          "group": null,
          "default": false
        },
        "rest_client_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (bucket)",
          "group": null,
          "default": false
        },
        "rest_client_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Request latency in seconds. Broken down by verb and URL. (count)",
          "group": null,
          "default": false
        },
        "rest_client_request_latency_seconds": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (sum)",
          "group": null,
          "default": false
        },
        "rest_client_request_latency_seconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (bucket)",
          "group": null,
          "default": false
        },
        "rest_client_request_latency_seconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Request latency in seconds. Broken down by verb and URL. (count)",
          "group": null,
          "default": false
        },
        "rest_client_requests_total": {
          "type": "cumulative",
          "description": "Number of HTTP requests, partitioned by status code, method, and host.",
          "group": null,
          "default": true
        },
        "scheduler_binding_duration_seconds": {
          "type": "cumulative",
          "description": "Binding latency in seconds (sum)",
          "group": null,
          "default": true
        },
        "scheduler_binding_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Binding latency in seconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_binding_duration_seconds_count": {
          "type": "cumulative",
          "description": "Binding latency in seconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_binding_latency_microseconds": {
          "type": "cumulative",
          "description": "(Deprecated) Binding latency in microseconds (sum)",
          "group": null,
          "default": true
        },
        "scheduler_binding_latency_microseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Binding latency in microseconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_binding_latency_microseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Binding latency in microseconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_e2e_scheduling_duration_seconds": {
          "type": "cumulative",
          "description": "E2e scheduling latency in seconds (scheduling algorithm + binding) (sum)",
          "group": null,
          "default": true
        },
        "scheduler_e2e_scheduling_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "E2e scheduling latency in seconds (scheduling algorithm + binding) (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_e2e_scheduling_duration_seconds_count": {
          "type": "cumulative",
          "description": "E2e scheduling latency in seconds (scheduling algorithm + binding) (count)",
          "group": null,
          "default": false
        },
        "scheduler_e2e_scheduling_latency_microseconds": {
          "type": "cumulative",
          "description": "(Deprecated) E2e scheduling latency in microseconds (scheduling algorithm + binding) (sum)",
          "group": null,
          "default": true
        },
        "scheduler_e2e_scheduling_latency_microseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) E2e scheduling latency in microseconds (scheduling algorithm + binding) (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_e2e_scheduling_latency_microseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) E2e scheduling latency in microseconds (scheduling algorithm + binding) (count)",
          "group": null,
          "default": false
        },
        "scheduler_pending_pods": {
          "type": "gauge",
          "description": "Number of pending pods, by the queue type. 'active' means number of pods in activeQ; 'backoff' means number of pods in backoffQ; 'unschedulable' means number of pods in unschedulableQ.",
          "group": null,
          "default": false
        },
        "scheduler_pod_preemption_victims": {
          "type": "gauge",
          "description": "Number of selected preemption victims",
          "group": null,
          "default": false
        },
        "scheduler_schedule_attempts_total": {
          "type": "cumulative",
          "description": "Number of attempts to schedule pods, by the result. 'unschedulable' means a pod could not be scheduled, while 'error' means an internal scheduler problem.",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_duration_seconds": {
          "type": "cumulative",
          "description": "Scheduling algorithm latency in seconds (sum)",
          "group": null,
          "default": true
        },
        "scheduler_scheduling_algorithm_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Scheduling algorithm latency in seconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_duration_seconds_count": {
          "type": "cumulative",
          "description": "Scheduling algorithm latency in seconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_latency_microseconds": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm latency in microseconds (sum)",
          "group": null,
          "default": true
        },
        "scheduler_scheduling_algorithm_latency_microseconds_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm latency in microseconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_latency_microseconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm latency in microseconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_predicate_evaluation": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm predicate evaluation duration in microseconds (sum)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_predicate_evaluation_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm predicate evaluation duration in microseconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_predicate_evaluation_count": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm predicate evaluation duration in microseconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_predicate_evaluation_seconds": {
          "type": "cumulative",
          "description": "Scheduling algorithm predicate evaluation duration in seconds (sum)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_predicate_evaluation_seconds_bucket": {
          "type": "cumulative",
          "description": "Scheduling algorithm predicate evaluation duration in seconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_predicate_evaluation_seconds_count": {
          "type": "cumulative",
          "description": "Scheduling algorithm predicate evaluation duration in seconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_preemption_evaluation": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm preemption evaluation duration in microseconds (sum)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_preemption_evaluation_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm preemption evaluation duration in microseconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_preemption_evaluation_count": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm preemption evaluation duration in microseconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_preemption_evaluation_seconds": {
          "type": "cumulative",
          "description": "Scheduling algorithm preemption evaluation duration in seconds (sum)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_preemption_evaluation_seconds_bucket": {
          "type": "cumulative",
          "description": "Scheduling algorithm preemption evaluation duration in seconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_preemption_evaluation_seconds_count": {
          "type": "cumulative",
          "description": "Scheduling algorithm preemption evaluation duration in seconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_priority_evaluation": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm priority evaluation duration in microseconds (sum)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_priority_evaluation_bucket": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm priority evaluation duration in microseconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_priority_evaluation_count": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling algorithm priority evaluation duration in microseconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_priority_evaluation_seconds": {
          "type": "cumulative",
          "description": "Scheduling algorithm priority evaluation duration in seconds (sum)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_priority_evaluation_seconds_bucket": {
          "type": "cumulative",
          "description": "Scheduling algorithm priority evaluation duration in seconds (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_algorithm_priority_evaluation_seconds_count": {
          "type": "cumulative",
          "description": "Scheduling algorithm priority evaluation duration in seconds (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_duration_seconds": {
          "type": "cumulative",
          "description": "Scheduling latency in seconds split by sub-parts of the scheduling operation (sum)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_duration_seconds_count": {
          "type": "cumulative",
          "description": "Scheduling latency in seconds split by sub-parts of the scheduling operation (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_duration_seconds_quantile": {
          "type": "gauge",
          "description": "Scheduling latency in seconds split by sub-parts of the scheduling operation (quantized)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_latency_seconds": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling latency in seconds split by sub-parts of the scheduling operation (sum)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_latency_seconds_count": {
          "type": "cumulative",
          "description": "(Deprecated) Scheduling latency in seconds split by sub-parts of the scheduling operation (count)",
          "group": null,
          "default": false
        },
        "scheduler_scheduling_latency_seconds_quantile": {
          "type": "gauge",
          "description": "(Deprecated) Scheduling latency in seconds split by sub-parts of the scheduling operation (quantized)",
          "group": null,
          "default": false
        },
        "scheduler_total_preemption_attempts": {
          "type": "cumulative",
          "description": "Total preemption attempts in the cluster till now",
          "group": null,
          "default": false
        },
        "scheduler_volume_scheduling_duration_seconds": {
          "type": "cumulative",
          "description": "Volume scheduling stage latency (sum)",
          "group": null,
          "default": false
        },
        "scheduler_volume_scheduling_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Volume scheduling stage latency (bucket)",
          "group": null,
          "default": false
        },
        "scheduler_volume_scheduling_duration_seconds_count": {
          "type": "cumulative",
          "description": "Volume scheduling stage latency (count)",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/kubernetes/scheduler",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-volumes",
      "sendAll": true,
      "dimensions": {
        "VolumeId": {
          "description": "(*EBS volumes only*) The EBS volume id of the underlying volume source"
        },
        "endpoints_name": {
          "description": "(*GlusterFS volumes only*) The endpoint name used for the GlusterFS volume"
        },
        "glusterfs_path": {
          "description": "(*GlusterFS volumes only*) The GlusterFS volume path"
        },
        "kubernetes_namespace": {
          "description": "The namespace of the pod that has this volume"
        },
        "kubernetes_pod_name": {
          "description": "The name of the pod that has this volume"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that has this volume"
        },
        "partition": {
          "description": "(*EBS volumes only*) The partition number of the underlying EBS volume (`0` indicates the entire disk)"
        },
        "volume": {
          "description": "The volume name as given in the pod spec under `volumes`"
        },
        "volume_type": {
          "description": "The type of the underlying volume -- this will be the key used in the k8s volume config spec (e.g. awsElasticBlockStore, etc.)"
        }
      },
      "doc": "This monitor sends usage stats about volumes\nmounted to Kubernetes pods (e.g. free space/inodes).  This information is\ngotten from the Kubelet /stats/summary endpoint.  The normal `collectd/df`\nmonitor generally will not report Persistent Volume usage metrics because\nthose volumes are not seen by the agent since they can be mounted\ndynamically and older versions of K8s don't support mount propagation of\nthose mounts to the agent container.\n\nDimensions that identify the underlying volume source will be added for\n`awsElasticBlockStore` and `glusterfs` volumes.  Support for more can be\neasily added as needed.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "kubernetes.volume_available_bytes",
            "kubernetes.volume_capacity_bytes"
          ]
        }
      },
      "metrics": {
        "kubernetes.volume_available_bytes": {
          "type": "gauge",
          "description": "The number of available bytes in the volume",
          "group": null,
          "default": false
        },
        "kubernetes.volume_capacity_bytes": {
          "type": "gauge",
          "description": "The total capacity in bytes of the volume",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/kubernetes/volumes",
        "fields": [
          {
            "yamlName": "kubeletAPI",
            "doc": "Kubelet kubeletClient configuration",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains config specific to the KubeletAPI",
              "package": "pkg/core/common/kubelet",
              "fields": [
                {
                  "yamlName": "url",
                  "doc": "URL of the Kubelet instance.  This will default to `http://\u003ccurrent node hostname\u003e:10255` if not provided.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "authType",
                  "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                  "default": "none",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verification of the Kubelet's TLS cert",
                  "default": true,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "logResponses",
                  "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "kubernetesAPI",
            "doc": "Configuration of the Kubernetes API kubeletClient",
            "default": "",
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains options relevant to connecting to the K8s API",
              "package": "pkg/core/common/kubernetes",
              "fields": [
                {
                  "yamlName": "authType",
                  "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                  "default": "serviceAccount",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "load",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors process load on the host. Process load is the average number of\nrunning or waiting processes over a certain time period (1, 5, and 15\nminutes).\n\nSee http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html\nfor a good explanation of load on Linux.\n\nThis monitor is only available on Linux.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "load.longterm",
            "load.midterm",
            "load.shortterm"
          ]
        }
      },
      "metrics": {
        "load.longterm": {
          "type": "gauge",
          "description": "Average CPU load of the system over the last 15 minutes.  If the `perCPU` config option is `true`, this will be the average load per CPU.",
          "group": null,
          "default": true
        },
        "load.midterm": {
          "type": "gauge",
          "description": "Average CPU load of the system over the last 5 minutes.  If the `perCPU` config option is `true`, this will be the average load per CPU.",
          "group": null,
          "default": true
        },
        "load.shortterm": {
          "type": "gauge",
          "description": "Average CPU load of the system over the last minute.  If the `perCPU` config option is `true`, this will be the average load per CPU.",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/load",
        "fields": [
          {
            "yamlName": "perCPU",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "logstash",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors the health and performance of Logstash deployments through \nLogstash's [Monitoring APIs](https://www.elastic.co/guide/en/logstash/current/monitoring-logstash.html).\n",
      "groups": {
        "events": {
          "description": "Events metrics",
          "metrics": [
            "node.stats.events.events.duration_in_millis",
            "node.stats.events.events.filtered",
            "node.stats.events.events.in",
            "node.stats.events.events.out",
            "node.stats.events.events.queue_push_duration_in_millis"
          ]
        },
        "hot_threads": {
          "description": "Hot Threads metrics",
          "metrics": [
            "node.hot_threads.hot_threads.busiest_threads",
            "node.hot_threads.hot_threads.threads.percent_of_cpu_time"
          ]
        },
        "jvm": {
          "description": "JVM metrics",
          "metrics": [
            "node.stats.jvm.jvm.gc.collectors.old.collection_count",
            "node.stats.jvm.jvm.gc.collectors.old.collection_time_in_millis",
            "node.stats.jvm.jvm.gc.collectors.young.collection_count",
            "node.stats.jvm.jvm.gc.collectors.young.collection_time_in_millis",
            "node.stats.jvm.jvm.mem.heap_committed_in_bytes",
            "node.stats.jvm.jvm.mem.heap_max_in_bytes",
            "node.stats.jvm.jvm.mem.heap_used_in_bytes",
            "node.stats.jvm.jvm.mem.heap_used_percent",
            "node.stats.jvm.jvm.mem.non_heap_committed_in_bytes",
            "node.stats.jvm.jvm.mem.non_heap_used_in_bytes",
            "node.stats.jvm.jvm.mem.pools.old.committed_in_bytes",
            "node.stats.jvm.jvm.mem.pools.old.max_in_bytes",
            "node.stats.jvm.jvm.mem.pools.old.peak_max_in_bytes",
            "node.stats.jvm.jvm.mem.pools.old.peak_used_in_bytes",
            "node.stats.jvm.jvm.mem.pools.old.used_in_bytes",
            "node.stats.jvm.jvm.mem.pools.survivor.committed_in_bytes",
            "node.stats.jvm.jvm.mem.pools.survivor.max_in_bytes",
            "node.stats.jvm.jvm.mem.pools.survivor.peak_max_in_bytes",
            "node.stats.jvm.jvm.mem.pools.survivor.peak_used_in_bytes",
            "node.stats.jvm.jvm.mem.pools.survivor.used_in_bytes",
            "node.stats.jvm.jvm.mem.pools.young.committed_in_bytes",
            "node.stats.jvm.jvm.mem.pools.young.max_in_bytes",
            "node.stats.jvm.jvm.mem.pools.young.peak_max_in_bytes",
            "node.stats.jvm.jvm.mem.pools.young.peak_used_in_bytes",
            "node.stats.jvm.jvm.mem.pools.young.used_in_bytes",
            "node.stats.jvm.jvm.threads.count",
            "node.stats.jvm.jvm.threads.peak_count",
            "node.stats.jvm.jvm.uptime_in_millis"
          ]
        },
        "os": {
          "description": "OS metrics",
          "metrics": [
            "node.os.os.available_processors",
            "node.stats.os.os.cgroup.cpu.cfs_period_micros",
            "node.stats.os.os.cgroup.cpu.cfs_quota_micros",
            "node.stats.os.os.cgroup.cpu.stat.number_of_elapsed_periods",
            "node.stats.os.os.cgroup.cpu.stat.number_of_times_throttled",
            "node.stats.os.os.cgroup.cpu.stat.time_throttled_nanos",
            "node.stats.os.os.cgroup.cpuacct.usage_nanos"
          ]
        },
        "pipeline": {
          "description": "",
          "metrics": [
            "node.pipelines.batch_delay",
            "node.pipelines.batch_size",
            "node.pipelines.workers",
            "node.stats.pipelines.events.duration_in_millis",
            "node.stats.pipelines.events.filtered",
            "node.stats.pipelines.events.in",
            "node.stats.pipelines.events.out",
            "node.stats.pipelines.events.queue_push_duration_in_millis",
            "node.stats.pipelines.plugins.codecs.decode.duration_in_millis",
            "node.stats.pipelines.plugins.codecs.decode.out",
            "node.stats.pipelines.plugins.codecs.decode.writes_in",
            "node.stats.pipelines.plugins.codecs.encode.duration_in_millis",
            "node.stats.pipelines.plugins.codecs.encode.writes_in",
            "node.stats.pipelines.plugins.filters.events.duration_in_millis",
            "node.stats.pipelines.plugins.filters.events.in",
            "node.stats.pipelines.plugins.filters.events.out",
            "node.stats.pipelines.plugins.inputs.events.out",
            "node.stats.pipelines.plugins.inputs.events.queue_push_duration_in_millis",
            "node.stats.pipelines.plugins.outputs.events.duration_in_millis",
            "node.stats.pipelines.plugins.outputs.events.in",
            "node.stats.pipelines.plugins.outputs.events.out",
            "node.stats.pipelines.queue.events_count",
            "node.stats.pipelines.queue.max_queue_size_in_bytes",
            "node.stats.pipelines.queue.queue_size_in_bytes",
            "node.stats.pipelines.reloads.failures",
            "node.stats.pipelines.reloads.successes"
          ]
        },
        "pipelines": {
          "description": "Pipelines metrics",
          "metrics": null
        },
        "plugins": {
          "description": "Plugins metrics",
          "metrics": [
            "node.plugins.total"
          ]
        },
        "process": {
          "description": "Process metrics",
          "metrics": [
            "node.stats.process.process.cpu.load_average.15m",
            "node.stats.process.process.cpu.load_average.1m",
            "node.stats.process.process.cpu.load_average.5m",
            "node.stats.process.process.cpu.percent",
            "node.stats.process.process.cpu.total_in_millis",
            "node.stats.process.process.max_file_descriptors",
            "node.stats.process.process.mem.total_virtual_in_bytes",
            "node.stats.process.process.open_file_descriptors",
            "node.stats.process.process.peak_open_file_descriptors"
          ]
        },
        "reloads": {
          "description": "Reloads metrics",
          "metrics": [
            "node.stats.reloads.reloads.failures",
            "node.stats.reloads.reloads.successes"
          ]
        }
      },
      "metrics": {
        "node.hot_threads.hot_threads.busiest_threads": {
          "type": "gauge",
          "description": "",
          "group": "hot_threads",
          "default": false
        },
        "node.hot_threads.hot_threads.threads.percent_of_cpu_time": {
          "type": "gauge",
          "description": "",
          "group": "hot_threads",
          "default": false
        },
        "node.os.os.available_processors": {
          "type": "gauge",
          "description": "Number of available processors",
          "group": "os",
          "default": false
        },
        "node.pipelines.batch_delay": {
          "type": "gauge",
          "description": "",
          "group": "pipeline",
          "default": false
        },
        "node.pipelines.batch_size": {
          "type": "gauge",
          "description": "",
          "group": "pipeline",
          "default": false
        },
        "node.pipelines.workers": {
          "type": "gauge",
          "description": "Number of workers in pipelines",
          "group": "pipeline",
          "default": false
        },
        "node.plugins.total": {
          "type": "gauge",
          "description": "Number of plugins",
          "group": "plugins",
          "default": true
        },
        "node.stats.events.events.duration_in_millis": {
          "type": "cumulative",
          "description": "Duration of events",
          "group": "events",
          "default": true
        },
        "node.stats.events.events.filtered": {
          "type": "cumulative",
          "description": "Number of filtered events",
          "group": "events",
          "default": true
        },
        "node.stats.events.events.in": {
          "type": "cumulative",
          "description": "Number of received events",
          "group": "events",
          "default": true
        },
        "node.stats.events.events.out": {
          "type": "cumulative",
          "description": "Number of events sent out",
          "group": "events",
          "default": true
        },
        "node.stats.events.events.queue_push_duration_in_millis": {
          "type": "cumulative",
          "description": "Duration that events waited in queue before being processed",
          "group": "events",
          "default": true
        },
        "node.stats.jvm.jvm.gc.collectors.old.collection_count": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.gc.collectors.old.collection_time_in_millis": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.gc.collectors.young.collection_count": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.gc.collectors.young.collection_time_in_millis": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.heap_committed_in_bytes": {
          "type": "gauge",
          "description": "Total heap committed by the process",
          "group": "jvm",
          "default": true
        },
        "node.stats.jvm.jvm.mem.heap_max_in_bytes": {
          "type": "gauge",
          "description": "Max memory being used",
          "group": "jvm",
          "default": true
        },
        "node.stats.jvm.jvm.mem.heap_used_in_bytes": {
          "type": "gauge",
          "description": "Total heap used",
          "group": "jvm",
          "default": true
        },
        "node.stats.jvm.jvm.mem.heap_used_percent": {
          "type": "gauge",
          "description": "Total heap used in percentage",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.non_heap_committed_in_bytes": {
          "type": "gauge",
          "description": "Total non-heap memory committed by the process",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.non_heap_used_in_bytes": {
          "type": "gauge",
          "description": "Total non-heap memory used",
          "group": "jvm",
          "default": true
        },
        "node.stats.jvm.jvm.mem.pools.old.committed_in_bytes": {
          "type": "gauge",
          "description": "Memory guaranteed to be available to JVM non-heap by Old gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.old.max_in_bytes": {
          "type": "gauge",
          "description": "Max memory being used by Old Gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.old.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Old gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.old.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Peak memory used by Old gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.old.used_in_bytes": {
          "type": "gauge",
          "description": "Memory being used by Old Gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.survivor.committed_in_bytes": {
          "type": "gauge",
          "description": "Memory guaranteed to be available to JVM non-heap by Survivor space",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.survivor.max_in_bytes": {
          "type": "gauge",
          "description": "Max memory being used by Survivor space",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.survivor.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Survivor space",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.survivor.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Peak memory used by Survivor space",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.survivor.used_in_bytes": {
          "type": "gauge",
          "description": "Memory being used by Survivor space",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.young.committed_in_bytes": {
          "type": "gauge",
          "description": "Memory guaranteed to be available to JVM non-heap by Young gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.young.max_in_bytes": {
          "type": "gauge",
          "description": "Max memory being used by Young Gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.young.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Young gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.young.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Peak memory used by Young gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.mem.pools.young.used_in_bytes": {
          "type": "gauge",
          "description": "Memory being used by Young Gen",
          "group": "jvm",
          "default": false
        },
        "node.stats.jvm.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "node.stats.jvm.jvm.threads.peak_count": {
          "type": "gauge",
          "description": "Highest number of JVM threads",
          "group": "jvm",
          "default": true
        },
        "node.stats.jvm.jvm.uptime_in_millis": {
          "type": "gauge",
          "description": "Uptime length of JVM",
          "group": "jvm",
          "default": false
        },
        "node.stats.os.os.cgroup.cpu.cfs_period_micros": {
          "type": "gauge",
          "description": "",
          "group": "os",
          "default": false
        },
        "node.stats.os.os.cgroup.cpu.cfs_quota_micros": {
          "type": "gauge",
          "description": "",
          "group": "os",
          "default": false
        },
        "node.stats.os.os.cgroup.cpu.stat.number_of_elapsed_periods": {
          "type": "cumulative",
          "description": "",
          "group": "os",
          "default": false
        },
        "node.stats.os.os.cgroup.cpu.stat.number_of_times_throttled": {
          "type": "cumulative",
          "description": "",
          "group": "os",
          "default": false
        },
        "node.stats.os.os.cgroup.cpu.stat.time_throttled_nanos": {
          "type": "cumulative",
          "description": "",
          "group": "os",
          "default": false
        },
        "node.stats.os.os.cgroup.cpuacct.usage_nanos": {
          "type": "gauge",
          "description": "",
          "group": "os",
          "default": false
        },
        "node.stats.pipelines.events.duration_in_millis": {
          "type": "cumulative",
          "description": "Duration of events in pipelines",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.events.filtered": {
          "type": "cumulative",
          "description": "Number of filtered events in pipelines",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.events.in": {
          "type": "cumulative",
          "description": "Number of received events in pipelines",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.events.out": {
          "type": "cumulative",
          "description": "Number of events sent out from pipelines",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.events.queue_push_duration_in_millis": {
          "type": "cumulative",
          "description": "Duration that events waited in queue before being processed in pipelines",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.plugins.codecs.decode.duration_in_millis": {
          "type": "cumulative",
          "description": "Duration of decode events in codec plugins",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.plugins.codecs.decode.out": {
          "type": "cumulative",
          "description": "Number of decode events sent out from codecs",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.plugins.codecs.decode.writes_in": {
          "type": "cumulative",
          "description": "Number of received decode events in codecs",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.plugins.codecs.encode.duration_in_millis": {
          "type": "cumulative",
          "description": "Duration of encode events in codec plugins",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.plugins.codecs.encode.writes_in": {
          "type": "cumulative",
          "description": "Number of received encode events in codecs",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.plugins.filters.events.duration_in_millis": {
          "type": "cumulative",
          "description": "Duration of events in filter plugins",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.plugins.filters.events.in": {
          "type": "cumulative",
          "description": "Number of received events in filters",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.plugins.filters.events.out": {
          "type": "cumulative",
          "description": "Number of events sent out from filters",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.plugins.inputs.events.out": {
          "type": "cumulative",
          "description": "Number of events sent out from inputs",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.plugins.inputs.events.queue_push_duration_in_millis": {
          "type": "cumulative",
          "description": "Duration that events waited in queue before being processed in inputs",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.plugins.outputs.events.duration_in_millis": {
          "type": "cumulative",
          "description": "Duration of events in output plugins",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.plugins.outputs.events.in": {
          "type": "cumulative",
          "description": "Number of received events in output plugins",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.plugins.outputs.events.out": {
          "type": "cumulative",
          "description": "Number of events sent out from output plugins",
          "group": "pipeline",
          "default": true
        },
        "node.stats.pipelines.queue.events_count": {
          "type": "gauge",
          "description": "Number of events waiting in queue",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.queue.max_queue_size_in_bytes": {
          "type": "gauge",
          "description": "Max queue size in pipelines",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.queue.queue_size_in_bytes": {
          "type": "gauge",
          "description": "Queue size in pipelines",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.reloads.failures": {
          "type": "cumulative",
          "description": "Number of failed reloads",
          "group": "pipeline",
          "default": false
        },
        "node.stats.pipelines.reloads.successes": {
          "type": "cumulative",
          "description": "Number of successful reloads",
          "group": "pipeline",
          "default": false
        },
        "node.stats.process.process.cpu.load_average.15m": {
          "type": "gauge",
          "description": "CPU Load average in 15 minutes",
          "group": "process",
          "default": false
        },
        "node.stats.process.process.cpu.load_average.1m": {
          "type": "gauge",
          "description": "CPU Load average in 1 minute",
          "group": "process",
          "default": false
        },
        "node.stats.process.process.cpu.load_average.5m": {
          "type": "gauge",
          "description": "CPU Load average in 5 minutes",
          "group": "process",
          "default": false
        },
        "node.stats.process.process.cpu.percent": {
          "type": "gauge",
          "description": "CPU usage in percent",
          "group": "process",
          "default": true
        },
        "node.stats.process.process.cpu.total_in_millis": {
          "type": "cumulative",
          "description": "Total CPU time (in milliseconds) used by the process on which the process is running",
          "group": "process",
          "default": false
        },
        "node.stats.process.process.max_file_descriptors": {
          "type": "gauge",
          "description": "Number of opened file descriptors associated with the current process",
          "group": "process",
          "default": false
        },
        "node.stats.process.process.mem.total_virtual_in_bytes": {
          "type": "gauge",
          "description": "Size of the virtual memory of this process",
          "group": "process",
          "default": false
        },
        "node.stats.process.process.open_file_descriptors": {
          "type": "gauge",
          "description": "Number of currently open file descriptors",
          "group": "process",
          "default": false
        },
        "node.stats.process.process.peak_open_file_descriptors": {
          "type": "gauge",
          "description": "Peak number of currently open file descriptors",
          "group": "process",
          "default": false
        },
        "node.stats.reloads.reloads.failures": {
          "type": "cumulative",
          "description": "Number of failed reloads",
          "group": "reloads",
          "default": false
        },
        "node.stats.reloads.reloads.successes": {
          "type": "cumulative",
          "description": "Number of successful reloads",
          "group": "reloads",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/logstash/logstash",
        "fields": [
          {
            "yamlName": "host",
            "doc": "The hostname of Logstash monitoring API",
            "default": "127.0.0.1",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "The port number of Logstash monitoring API",
            "default": 9600,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the host using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timeoutSeconds",
            "doc": "The maximum amount of time to wait for API requests",
            "default": 5,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "logstash-tcp",
      "sendAll": false,
      "dimensions": null,
      "doc": "Fetches events from the [logstash tcp output\nplugin](https://www.elastic.co/guide/en/logstash/current/plugins-outputs-tcp.html)\noperating in either `server` or `client` mode and converts them to SignalFx\ndatapoints.  It is meant to be used in conjunction with the Logstash\n[Metrics filter\nplugin](https://www.elastic.co/guide/en/logstash/current/plugins-filters-metrics.html)\nthat turns events into metrics.\n\nYou can only use auto-discovery when this monitor is in `client` mode.\n\n### Example Logstash Config\n\nThis is a somewhat contrived example that shows the use of both `timer` and\n`meter` metrics from the Logstash Metrics filter plugin:\n\n```\ninput {\n  file {\n    path =\u003e \"/var/log/auth.log\"\n    start_position =\u003e \"beginning\"\n    tags =\u003e [\"auth_log\"]\n  }\n\n  # A contrived file that contains timing messages\n  file {\n    path =\u003e \"/var/log/durations.log\"\n    tags =\u003e [\"duration_log\"]\n    start_position =\u003e \"beginning\"\n  }\n}\n\nfilter {\n  if \"duration_log\" in [tags] {\n    dissect {\n      mapping =\u003e {\n        \"message\" =\u003e \"Processing took %{duration} seconds\"\n      }\n      convert_datatype =\u003e {\n        \"duration\" =\u003e \"float\"\n      }\n    }\n    if \"_dissectfailure\" not in [tags] { # Filter out bad events\n      metrics {\n        timer =\u003e { \"process_time\" =\u003e \"%{duration}\" }\n        flush_interval =\u003e 10\n        # This makes the timing stats pertain to only the previous 5 minutes\n        # instead of since Logstash last started.\n        clear_interval =\u003e 300\n        add_field =\u003e {\"type\" =\u003e \"processing\"}\n        add_tag =\u003e \"metric\"\n      }\n    }\n  }\n  # Count the number of logins via SSH from /var/log/auth.log\n  if \"auth_log\" in [tags] and [message] =~ /sshd.*session opened/ {\n    metrics {\n      # This determines how often metric events will be sent to the agent, and\n      # thus how often datapoints will be emitted.\n      flush_interval =\u003e 10\n      # The name of the meter will be used to construct the name of the metric\n      # in SignalFx.  For this example, a datapoint called `logins.count` would\n      # be generated.\n      meter =\u003e \"logins\"\n      add_tag =\u003e \"metric\"\n    }\n  }\n}\n\noutput {\n  # This can be helpful to debug\n  stdout { codec =\u003e rubydebug }\n\n  if \"metric\" in [tags] {\n    tcp {\n      port =\u003e 8900\n      # The agent will connect to Logstash\n      mode =\u003e \"server\"\n      # Needs to be '0.0.0.0' if running in a container.\n      host =\u003e \"127.0.0.1\"\n    }\n  }\n}\n```\nOnce Logstash is configured with the above configuration. The logstash-tcp monitor\nwill collect `logins.count` and `process_time.\u003ctimer_field\u003e`. See config options\nfor default values.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/logstash/tcp",
        "fields": [
          {
            "yamlName": "host",
            "doc": "If `mode: server`, the local IP address to listen on.  If `mode: client`, the Logstash host/ip to connect to.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "If `mode: server`, the local port to listen on.  If `mode: client`, the port of the Logstash TCP output plugin.  If port is `0`, a random listening port is assigned by the kernel.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "mode",
            "doc": "Whether to act as a `server` or `client`.  The corresponding setting in the Logtash `tcp` output plugin should be set to the opposite of this.",
            "default": "client",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "desiredTimerFields",
            "doc": "",
            "default": [
              "mean",
              "max",
              "p99",
              "count"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "reconnectDelay",
            "doc": "How long to wait before reconnecting if the TCP connection cannot be made or after it gets broken.",
            "default": "5s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "debugEvents",
            "doc": "If true, events received from Logstash will be dumped to the agent's stdout in deserialized form",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "memory",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports memory and memory utilization metrics.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: memory\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "memory.available",
            "memory.buffered",
            "memory.cached",
            "memory.free",
            "memory.slab_recl",
            "memory.slab_unrecl",
            "memory.used",
            "memory.utilization"
          ]
        }
      },
      "metrics": {
        "memory.available": {
          "type": "gauge",
          "description": "(Windows Only) Bytes of memory available for use.",
          "group": null,
          "default": false
        },
        "memory.buffered": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory used for buffering I/O.",
          "group": null,
          "default": true
        },
        "memory.cached": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory used for disk caching.",
          "group": null,
          "default": true
        },
        "memory.free": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory available for use.",
          "group": null,
          "default": true
        },
        "memory.slab_recl": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory, used for SLAB-allocation of kernel objects, that can be reclaimed.",
          "group": null,
          "default": true
        },
        "memory.slab_unrecl": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory, used for SLAB-allocation of kernel objects, that can't be reclaimed.",
          "group": null,
          "default": true
        },
        "memory.used": {
          "type": "gauge",
          "description": "Bytes of memory in use by the system.",
          "group": null,
          "default": true
        },
        "memory.utilization": {
          "type": "gauge",
          "description": "Percent of memory in use on this host. This metric reports with plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/memory",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "net-io",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports I/O metrics about network interfaces.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: net-io\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "if_errors.rx",
            "if_errors.tx",
            "if_octets.rx",
            "if_octets.tx",
            "if_packets.rx",
            "if_packets.tx",
            "network.total"
          ]
        }
      },
      "metrics": {
        "if_errors.rx": {
          "type": "cumulative",
          "description": "Count of receive errors on the interface",
          "group": null,
          "default": true
        },
        "if_errors.tx": {
          "type": "cumulative",
          "description": "Count of transmit errors on the interface",
          "group": null,
          "default": true
        },
        "if_octets.rx": {
          "type": "cumulative",
          "description": "Count of bytes (octets) received on the interface",
          "group": null,
          "default": true
        },
        "if_octets.tx": {
          "type": "cumulative",
          "description": "Count of bytes (octets) transmitted by the interface",
          "group": null,
          "default": true
        },
        "if_packets.rx": {
          "type": "cumulative",
          "description": "Count of packets received on the interface",
          "group": null,
          "default": false
        },
        "if_packets.tx": {
          "type": "cumulative",
          "description": "Count of packets transmitted by the interface",
          "group": null,
          "default": false
        },
        "network.total": {
          "type": "cumulative",
          "description": "Total amount of inbound and outbound network traffic on this host, in bytes.  This metric reports with plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/netio",
        "fields": [
          {
            "yamlName": "interfaces",
            "doc": "The network interfaces to send metrics about. This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters).",
            "default": [
              "*",
              "!/^lo\\d*$/",
              "!/^docker.*/",
              "!/^t(un|ap)\\d*$/",
              "!/^veth.*$/",
              "!/^Loopback*/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "openshift-cluster",
      "sendAll": false,
      "dimensions": {
        "kubernetes_name": {
          "description": "The name of the resource that the metric describes"
        },
        "kubernetes_namespace": {
          "description": "The namespace of the resource that the metric describes"
        },
        "kubernetes_node": {
          "description": "The name of the node, as defined by the `name` field of the node resource."
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that the metric describes"
        },
        "machine_id": {
          "description": "The machine ID from /etc/machine-id.  This should be unique across all nodes in your cluster, but some cluster deployment tools don't guarantee this.  This will not be sent if the `useNodeName` config option is set to true."
        },
        "metric_source": {
          "description": "This is always set to `openshift`"
        },
        "quota_name": {
          "description": "The name of the k8s ResourceQuota object that the quota is part of"
        },
        "resource": {
          "description": "The k8s resource that the quota applies to"
        }
      },
      "doc": "This monitor is for use with an OpenShift cluster. It includes all metrics\nfrom the [kubernetes-cluster](kubernetes-cluster.md) monitor with additional\nOpenShift-specific metrics. You only need to use one monitor or the other.\n\nCollects cluster-level metrics from the Kubernetes API server.  It uses the\n_watch_ functionality of the K8s API to listen for updates about the cluster\nand maintains a cache of metrics that get sent on a regular interval.\n\nSince the agent is generally running in multiple places in a K8s cluster and\nsince it is generally more convenient to share the same configuration across\nall agent instances, this monitor by default makes use of a leader election\nprocess to ensure that it is the only agent sending metrics in a cluster.\nAll of the agents running in the same namespace that have this monitor\nconfigured will decide amongst themselves which should send metrics for this\nmonitor, and the rest will stand by ready to activate if the leader agent\ndies.  You can override leader election by setting the config option\n`alwaysClusterReporter` to true, which will make the monitor always report\nmetrics.\n\nThis monitor is similar to\n[kube-state-metrics](https://github.com/kubernetes/kube-state-metrics), and\nsends many of the same metrics, but in a way that is less verbose and better\nfitted for the SignalFx backend.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "kubernetes.container_cpu_limit",
            "kubernetes.container_cpu_request",
            "kubernetes.container_ephemeral_storage_limit",
            "kubernetes.container_ephemeral_storage_request",
            "kubernetes.container_memory_limit",
            "kubernetes.container_memory_request",
            "kubernetes.container_ready",
            "kubernetes.container_restart_count",
            "kubernetes.cronjob.active",
            "kubernetes.daemon_set.current_scheduled",
            "kubernetes.daemon_set.desired_scheduled",
            "kubernetes.daemon_set.misscheduled",
            "kubernetes.daemon_set.ready",
            "kubernetes.deployment.available",
            "kubernetes.deployment.desired",
            "kubernetes.job.active",
            "kubernetes.job.completions",
            "kubernetes.job.failed",
            "kubernetes.job.parallelism",
            "kubernetes.job.succeeded",
            "kubernetes.namespace_phase",
            "kubernetes.node_ready",
            "kubernetes.pod_phase",
            "kubernetes.replica_set.available",
            "kubernetes.replica_set.desired",
            "kubernetes.replication_controller.available",
            "kubernetes.replication_controller.desired",
            "kubernetes.resource_quota_hard",
            "kubernetes.resource_quota_used",
            "kubernetes.stateful_set.current",
            "kubernetes.stateful_set.desired",
            "kubernetes.stateful_set.ready",
            "kubernetes.stateful_set.updated",
            "openshift.appliedclusterquota.cpu.hard",
            "openshift.appliedclusterquota.cpu.used",
            "openshift.appliedclusterquota.memory.hard",
            "openshift.appliedclusterquota.memory.used",
            "openshift.appliedclusterquota.persistentvolumeclaims.hard",
            "openshift.appliedclusterquota.persistentvolumeclaims.used",
            "openshift.appliedclusterquota.pods.hard",
            "openshift.appliedclusterquota.pods.used",
            "openshift.appliedclusterquota.services.hard",
            "openshift.appliedclusterquota.services.loadbalancers.hard",
            "openshift.appliedclusterquota.services.loadbalancers.used",
            "openshift.appliedclusterquota.services.nodeports.hard",
            "openshift.appliedclusterquota.services.nodeports.used",
            "openshift.appliedclusterquota.services.used",
            "openshift.clusterquota.cpu.hard",
            "openshift.clusterquota.cpu.used",
            "openshift.clusterquota.memory.hard",
            "openshift.clusterquota.memory.used",
            "openshift.clusterquota.persistentvolumeclaims.hard",
            "openshift.clusterquota.persistentvolumeclaims.used",
            "openshift.clusterquota.pods.hard",
            "openshift.clusterquota.pods.used",
            "openshift.clusterquota.services.hard",
            "openshift.clusterquota.services.loadbalancers.hard",
            "openshift.clusterquota.services.loadbalancers.used",
            "openshift.clusterquota.services.nodeports.hard",
            "openshift.clusterquota.services.nodeports.used",
            "openshift.clusterquota.services.used"
          ]
        },
        "hpa": {
          "description": "",
          "metrics": [
            "kubernetes.hpa.spec.max_replicas",
            "kubernetes.hpa.spec.min_replicas",
            "kubernetes.hpa.status.condition.able_to_scale",
            "kubernetes.hpa.status.condition.scaling_active",
            "kubernetes.hpa.status.condition.scaling_limited",
            "kubernetes.hpa.status.current_replicas",
            "kubernetes.hpa.status.desired_replicas"
          ]
        }
      },
      "metrics": {
        "kubernetes.container_cpu_limit": {
          "type": "gauge",
          "description": "Maximum CPU limit set for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available.",
          "group": null,
          "default": false
        },
        "kubernetes.container_cpu_request": {
          "type": "gauge",
          "description": "CPU requested for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available.",
          "group": null,
          "default": false
        },
        "kubernetes.container_ephemeral_storage_limit": {
          "type": "gauge",
          "description": "Maximum ephemeral storage set for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available. See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#local-ephemeral-storage for details.",
          "group": null,
          "default": false
        },
        "kubernetes.container_ephemeral_storage_request": {
          "type": "gauge",
          "description": "Ephemeral storage requested for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available. See https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#local-ephemeral-storage for details",
          "group": null,
          "default": false
        },
        "kubernetes.container_memory_limit": {
          "type": "gauge",
          "description": "Maximum memory limit set for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available.",
          "group": null,
          "default": false
        },
        "kubernetes.container_memory_request": {
          "type": "gauge",
          "description": "Memory requested for the container. This value is derived from https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcerequirements-v1-core which comes from the pod spec and is reported only if a non null value is available.",
          "group": null,
          "default": false
        },
        "kubernetes.container_ready": {
          "type": "gauge",
          "description": "Whether a container has passed its readiness probe (0 for no, 1 for yes)",
          "group": null,
          "default": true
        },
        "kubernetes.container_restart_count": {
          "type": "gauge",
          "description": "How many times the container has restarted in the recent past.  This value is pulled directly from [the K8s API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#containerstatus-v1-core) and the value can go indefinitely high and be reset to 0 at any time depending on how your [kubelet is configured to prune dead containers](https://kubernetes.io/docs/concepts/cluster-administration/kubelet-garbage-collection/). It is best to not depend too much on the exact value but rather look at it as either `== 0`, in which case you can conclude there were no restarts in the recent past, or `\u003e 0`, in which case you can conclude there were restarts in the recent past, and not try and analyze the value beyond that.",
          "group": null,
          "default": true
        },
        "kubernetes.cronjob.active": {
          "type": "gauge",
          "description": "The number of actively running jobs for a cronjob.",
          "group": null,
          "default": false
        },
        "kubernetes.daemon_set.current_scheduled": {
          "type": "gauge",
          "description": "The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod",
          "group": null,
          "default": true
        },
        "kubernetes.daemon_set.desired_scheduled": {
          "type": "gauge",
          "description": "The total number of nodes that should be running the daemon pod (including nodes currently running the daemon pod)",
          "group": null,
          "default": true
        },
        "kubernetes.daemon_set.misscheduled": {
          "type": "gauge",
          "description": "The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod",
          "group": null,
          "default": true
        },
        "kubernetes.daemon_set.ready": {
          "type": "gauge",
          "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready",
          "group": null,
          "default": true
        },
        "kubernetes.deployment.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.",
          "group": null,
          "default": true
        },
        "kubernetes.deployment.desired": {
          "type": "gauge",
          "description": "Number of desired pods in this deployment",
          "group": null,
          "default": true
        },
        "kubernetes.hpa.spec.max_replicas": {
          "type": "gauge",
          "description": "The upper limit for the number of replicas to which the autoscaler can scale up. It cannot be less that minReplicas.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.spec.min_replicas": {
          "type": "gauge",
          "description": "The lower limit for the number of replicas to which the autoscaler can scale down. It defaults to 1 pod.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.condition.able_to_scale": {
          "type": "gauge",
          "description": "A status value that indicates the autoscaler status in reference to the AbleToScale condition. A value of 1 means that the autoscaler is in the AbleToScale condition, a 0 value means that it is not, and -1 means that the status of the AbleToScale condition is unknown. AbleToScale indicates a lack of transient issues which prevent scaling from occurring, such as being in a backoff window, or being unable to access/update the target scale.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.condition.scaling_active": {
          "type": "gauge",
          "description": "A status value that indicates the autoscaler status in reference to the ScalingActive condition. A value of 1 means that the autoscaler is in the ScalingActive condition, a 0 value means that it is not, and -1 means that the status of the ScalingActive condition is unknown. ScalingActive indicates that the HPA controller is able to scale if necessary.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.condition.scaling_limited": {
          "type": "gauge",
          "description": "A status value that indicates the autoscaler status in reference to the ScalingLimited condition. A value of 1 means that the autoscaler is in the ScalingLimited condition, a 0 value means that it is not, and -1 means that the status of the ScalingLimited condition is unknown. ScalingLimited indicates that the calculated scale based on metrics would be above or below the range for the HPA, and has thus been capped.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.current_replicas": {
          "type": "gauge",
          "description": "The current number of pod replicas managed by this autoscaler.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.hpa.status.desired_replicas": {
          "type": "gauge",
          "description": "The desired number of pod replicas managed by this autoscaler.",
          "group": "hpa",
          "default": false
        },
        "kubernetes.job.active": {
          "type": "gauge",
          "description": "The number of actively running pods for a job.",
          "group": null,
          "default": false
        },
        "kubernetes.job.completions": {
          "type": "gauge",
          "description": "The desired number of successfully finished pods the job should be run with.",
          "group": null,
          "default": false
        },
        "kubernetes.job.failed": {
          "type": "counter",
          "description": "The number of pods which reased phase Failed for a job.",
          "group": null,
          "default": false
        },
        "kubernetes.job.parallelism": {
          "type": "gauge",
          "description": "The max desired number of pods the job should run at any given time.",
          "group": null,
          "default": false
        },
        "kubernetes.job.succeeded": {
          "type": "counter",
          "description": "The number of pods which reached phase Succeeded for a job.",
          "group": null,
          "default": false
        },
        "kubernetes.namespace_phase": {
          "type": "gauge",
          "description": "The current phase of namespaces (`1` for _active_ and `0` for _terminating_)",
          "group": null,
          "default": true
        },
        "kubernetes.node_ready": {
          "type": "gauge",
          "description": "Whether this node is ready (1), not ready (0) or in an unknown state (-1)",
          "group": null,
          "default": true
        },
        "kubernetes.pod_phase": {
          "type": "gauge",
          "description": "Current phase of the pod (1 - Pending, 2 - Running, 3 - Succeeded, 4 - Failed, 5 - Unknown)",
          "group": null,
          "default": true
        },
        "kubernetes.replica_set.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replica set",
          "group": null,
          "default": true
        },
        "kubernetes.replica_set.desired": {
          "type": "gauge",
          "description": "Number of desired pods in this replica set",
          "group": null,
          "default": true
        },
        "kubernetes.replication_controller.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replication controller.",
          "group": null,
          "default": true
        },
        "kubernetes.replication_controller.desired": {
          "type": "gauge",
          "description": "Number of desired pods (the `spec.replicas` field)",
          "group": null,
          "default": true
        },
        "kubernetes.resource_quota_hard": {
          "type": "gauge",
          "description": "The upper limit for a particular resource in a specific namespace.  Will only be sent if a quota is specified. CPU requests/limits will be sent as millicores.",
          "group": null,
          "default": true
        },
        "kubernetes.resource_quota_used": {
          "type": "gauge",
          "description": "The usage for a particular resource in a specific namespace.  Will only be sent if a quota is specified. CPU requests/limits will be sent as millicores.",
          "group": null,
          "default": true
        },
        "kubernetes.stateful_set.current": {
          "type": "gauge",
          "description": "The number of pods created by the StatefulSet controller from the\nStatefulSet version indicated by `current_revision` property on the\n`kubernetes_uid` dimension for this StatefulSet.\n",
          "group": null,
          "default": false
        },
        "kubernetes.stateful_set.desired": {
          "type": "gauge",
          "description": "Number of desired pods in the stateful set (the `spec.replicas` field)",
          "group": null,
          "default": false
        },
        "kubernetes.stateful_set.ready": {
          "type": "gauge",
          "description": "Number of pods created by the stateful set that have the `Ready` condition",
          "group": null,
          "default": false
        },
        "kubernetes.stateful_set.updated": {
          "type": "gauge",
          "description": "The number of pods created by the StatefulSet controller from the\nStatefulSet version indicated by the `update_revision` property on the\n`kubernetes_uid` dimension for this StatefulSet.\n",
          "group": null,
          "default": false
        },
        "openshift.appliedclusterquota.cpu.hard": {
          "type": "gauge",
          "description": "Hard limit for number of cpu by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.cpu.used": {
          "type": "gauge",
          "description": "Consumed number of cpu by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.memory.hard": {
          "type": "gauge",
          "description": "Hard limit for amount of memory by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.memory.used": {
          "type": "gauge",
          "description": "Consumed amount of memory by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.persistentvolumeclaims.hard": {
          "type": "gauge",
          "description": "Hard limit for number of persistentvolumeclaims by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.persistentvolumeclaims.used": {
          "type": "gauge",
          "description": "Consumed number of persistentvolumeclaims by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.pods.hard": {
          "type": "gauge",
          "description": "Hard limit for number of pods by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.pods.used": {
          "type": "gauge",
          "description": "Consumed number of pods by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.services.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.services.loadbalancers.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services.loadbalancers by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.services.loadbalancers.used": {
          "type": "gauge",
          "description": "Consumed number of services.loadbalancers by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.services.nodeports.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services.nodeports by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.services.nodeports.used": {
          "type": "gauge",
          "description": "Consumed number of services.nodeports by namespace",
          "group": null,
          "default": true
        },
        "openshift.appliedclusterquota.services.used": {
          "type": "gauge",
          "description": "Consumed number of services by namespace",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.cpu.hard": {
          "type": "gauge",
          "description": "Hard limit for number of cpu across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.cpu.used": {
          "type": "gauge",
          "description": "Consumed number of cpu across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.memory.hard": {
          "type": "gauge",
          "description": "Hard limit for amount of memory across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.memory.used": {
          "type": "gauge",
          "description": "Consumed amount of memory across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.persistentvolumeclaims.hard": {
          "type": "gauge",
          "description": "Hard limit for number of persistentvolumeclaims across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.persistentvolumeclaims.used": {
          "type": "gauge",
          "description": "Consumed number of persistentvolumeclaims across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.pods.hard": {
          "type": "gauge",
          "description": "Hard limit for number of pods across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.pods.used": {
          "type": "gauge",
          "description": "Consumed number of pods across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.services.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.services.loadbalancers.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services.loadbalancers across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.services.loadbalancers.used": {
          "type": "gauge",
          "description": "Consumed number of services.loadbalancers across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.services.nodeports.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services.nodeports across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.services.nodeports.used": {
          "type": "gauge",
          "description": "Consumed number of services.nodeports across all namespaces",
          "group": null,
          "default": true
        },
        "openshift.clusterquota.services.used": {
          "type": "gauge",
          "description": "Consumed number of services across all namespaces",
          "group": null,
          "default": true
        }
      },
      "properties": {
        "\u003cnode label\u003e": {
          "dimension": "machine_id/kubernetes_node",
          "description": "All non-blank labels on a given node will be synced as properties to the `machine_id` or `kubernetes_node` dimension value for that node.  Which dimension gets the properties is determined by the `useNodeName` config option.  Any blank values will be synced as tags on that same dimension."
        },
        "\u003cpod label\u003e": {
          "dimension": "kubernetes_pod_uid",
          "description": "Any labels with non-blank values on the pod will be synced as properties to the `kubernetes_pod_uid` dimension. Any blank labels will be synced as tags on that same dimension."
        },
        "container_status": {
          "dimension": "container_id",
          "description": "Status of the container such as `running`, `waiting` or `terminated` are synced to the `container_id` dimension."
        },
        "container_status_reason": {
          "dimension": "container_id",
          "description": "Reason why a container is in a particular state. This property is synced to `container_id` only if the value of `cotnainer_status` is either `waiting` or `terminated`."
        },
        "cronjob_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the cron job was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "daemonset_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the daemon set was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "deployment_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the deployment was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "job_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the job was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "pod_creation_timestamp": {
          "dimension": "kubernetes_pod_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the pod was created and is in UTC. This property is synced onto `kubernetes_pod_uid`."
        },
        "replicaset_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the replica set was created and is in UTC. This property is synced onto `kubernetes_uid`."
        },
        "statefulset_creation_timestamp": {
          "dimension": "kubernetes_uid",
          "description": "Timestamp (in RFC3339 format) representing the server time when the stateful set was created and is in UTC. This property is synced onto `kubernetes_uid`."
        }
      },
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the K8s monitor",
        "package": "pkg/monitors/kubernetes/cluster",
        "fields": [
          {
            "yamlName": "alwaysClusterReporter",
            "doc": "If `true`, leader election is skipped and metrics are always reported.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "namespace",
            "doc": "If specified, only resources within the given namespace will be monitored.  If omitted (blank) all supported resources across all namespaces will be monitored.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useNodeName",
            "doc": "If set to true, the Kubernetes node name will be used as the dimension to which to sync properties about each respective node.  This is necessary if your cluster's machines do not have unique machine-id values, as can happen when machine images are improperly cloned.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "kubernetesAPI",
            "doc": "Config for the K8s API client",
            "default": "",
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains options relevant to connecting to the K8s API",
              "package": "pkg/core/common/kubernetes",
              "fields": [
                {
                  "yamlName": "authType",
                  "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                  "default": "serviceAccount",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "nodeConditionTypesToReport",
            "doc": "A list of node status condition types to report as metrics.  The metrics will be reported as datapoints of the form `kubernetes.node_\u003ctype_snake_cased\u003e` with a value of `0` corresponding to \"False\", `1` to \"True\", and `-1` to \"Unknown\".",
            "default": [
              "Ready"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "postgresql",
      "sendAll": false,
      "dimensions": {
        "database": {
          "description": "The name of the database within a PostgreSQL server to which the metric pertains."
        },
        "index": {
          "description": "For index metrics, the name of the index"
        },
        "schemaname": {
          "description": "The name of the schema within which the object being monitored resides (e.g. `public`)."
        },
        "table": {
          "description": "The name of the table to which the metric pertains."
        },
        "tablespace": {
          "description": "For table metrics, the tablespace in which the table belongs, if not null."
        },
        "type": {
          "description": "Whether the object (table, index, function, etc.) belongs to the `system` or `user`."
        },
        "user": {
          "description": "For query metrics, the user name of the user that executed the queries."
        }
      },
      "doc": "This monitor pulls metrics from all PostgreSQL databases from a specific\nPostgres server instance.  It pulls basic information that is applicable\nto any database.  It gathers these metrics via SQL queries.\n\n\u003c!--- OVERVIEW ---\u003e\n## Metrics about Queries\n\nIn order to get metrics about query execution time, you must enable the\n`pg_stat_statements` extension.  This extension must be specified in the\n`shared_preload_libraries` config option in the main PostgreSQL\nconfiguration at server start up.  Then the extension must be enabled for\neach database by running `CREATE EXTENSION IF NOT EXISTS\npg_stat_statements;` on each database.\n\nNote that in order to get consistent and accurate query execution time\nmetrics, you must set the [pg_stat_statements.max config\noption](https://www.postgresql.org/docs/9.3/pgstatstatements.html#AEN160631)\nto larger than the number of distinct queries on the server.\n\nHere is a [sample configuration of Postgres to enable statement tracking](https://www.postgresql.org/docs/9.3/pgstatstatements.html#AEN160631).\n\nTested with PostgreSQL `9.2+`.\n\nIf you want to collect additional metrics about PostgreSQL, use the [sql monitor](./sql.md).\n\n\u003c!--- SETUP ---\u003e\n## Example Configuration\n\nThis example uses the [Vault remote config\nsource](https://github.com/signalfx/signalfx-agent/blob/master/docs/remote-config.md#nested-values-vault-only)\nto connect to PostgreSQL using the `params` map that allows you to pull\nout the username and password individually from Vault and interpolate\nthem into the `connectionString` config option.\n\n```yaml\nmonitors:\n - type: postgresql\n   connectionString: 'sslmode=disable user={{.username}} password={{.password}}'\n   params: \u0026psqlParams\n     username: {\"#from\": \"vault:secret/my-database[username]\"}\n     password: {\"#from\": \"vault:secret/my-database[password]\"}\n   discoveryRule: 'container_image =~ \"postgres\" \u0026\u0026 port == 5432'\n\n # This monitor will monitor additional queries from PostgreSQL using the\n # provided SQL queries.\n - type: sql\n   dbDriver: postgres\n   connectionString: 'sslmode=disable user={{.username}} password={{.password}}'\n   # This is a YAML reference to avoid duplicating the above config.\n   params: *psqlParams\n   queries:\n     - query: 'SELECT COUNT(*) as count, country, status FROM customers GROUP BY country, status;'\n       metrics:\n         - metricName: \"customers\"\n           valueColumn: \"count\"\n           dimensionColumns: [\"country\", \"status\"]\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "postgres_block_hit_ratio",
            "postgres_database_size",
            "postgres_deadlocks",
            "postgres_index_scans",
            "postgres_live_rows",
            "postgres_query_count",
            "postgres_query_time",
            "postgres_rows_deleted",
            "postgres_rows_inserted",
            "postgres_rows_updated",
            "postgres_sequential_scans",
            "postgres_sessions",
            "postgres_table_size"
          ]
        },
        "queries": {
          "description": "",
          "metrics": [
            "postgres_queries_average_time",
            "postgres_queries_calls",
            "postgres_queries_total_time"
          ]
        }
      },
      "metrics": {
        "postgres_block_hit_ratio": {
          "type": "gauge",
          "description": "The proportion (between 0 and 1, inclusive) of block reads that used the cache and did not have to go to the disk.  Is sent for `table`, `index`, and the `database` as a whole.",
          "group": null,
          "default": true
        },
        "postgres_database_size": {
          "type": "gauge",
          "description": "Size in bytes of the database on disk",
          "group": null,
          "default": true
        },
        "postgres_deadlocks": {
          "type": "cumulative",
          "description": "Total number of deadlocks detected by the system",
          "group": null,
          "default": true
        },
        "postgres_index_scans": {
          "type": "cumulative",
          "description": "Total number of index scans on the `table`.",
          "group": null,
          "default": true
        },
        "postgres_live_rows": {
          "type": "gauge",
          "description": "Number of rows live (not deleted) in the `table`.",
          "group": null,
          "default": true
        },
        "postgres_queries_average_time": {
          "type": "cumulative",
          "description": "Top N queries based on the average execution time broken down by `database`",
          "group": "queries",
          "default": false
        },
        "postgres_queries_calls": {
          "type": "cumulative",
          "description": "Top N most frequently executed queries broken down by `database`",
          "group": "queries",
          "default": false
        },
        "postgres_queries_total_time": {
          "type": "cumulative",
          "description": "Top N queries based on the total execution time broken down by `database`",
          "group": "queries",
          "default": false
        },
        "postgres_query_count": {
          "type": "cumulative",
          "description": "Total number of queries executed on the `database`, broken down by `user`.  Note that the accuracy of this metric depends on the PostgreSQL [pg_stat_statements.max config option](https://www.postgresql.org/docs/9.3/pgstatstatements.html#AEN160631) being large enough to hold all queries.\n",
          "group": null,
          "default": true
        },
        "postgres_query_time": {
          "type": "cumulative",
          "description": "Total time taken to execute queries on the `database`, broken down by `user`.",
          "group": null,
          "default": true
        },
        "postgres_rows_deleted": {
          "type": "cumulative",
          "description": "Number of rows deleted from the `table`.",
          "group": null,
          "default": true
        },
        "postgres_rows_inserted": {
          "type": "cumulative",
          "description": "Number of rows inserted into the `table`.",
          "group": null,
          "default": true
        },
        "postgres_rows_updated": {
          "type": "cumulative",
          "description": "Number of rows updated in the `table`.",
          "group": null,
          "default": true
        },
        "postgres_sequential_scans": {
          "type": "cumulative",
          "description": "Total number of sequential scans on the `table`.",
          "group": null,
          "default": true
        },
        "postgres_sessions": {
          "type": "gauge",
          "description": "Number of sessions currently on the server instance.  The `state` dimension will specify which which type of session (see `state` row of [pg_stat_activity](https://www.postgresql.org/docs/9.2/monitoring-stats.html#PG-STAT-ACTIVITY-VIEW)).\n",
          "group": null,
          "default": true
        },
        "postgres_table_size": {
          "type": "gauge",
          "description": "The size in bytes of the `table` on disk.",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the postgresql monitor",
        "package": "pkg/monitors/postgresql",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "masterDBName",
            "doc": "The \"master\" database to which the agent first connects to query the list of databases available in the server.  This database should be accessible to the user specified with `connectionString` and `params` below, and that user should have permission to query `pg_database`.  If you want to filter which databases are monitored, use the `databases` option below.",
            "default": "postgres",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "connectionString",
            "doc": "See https://godoc.org/github.com/lib/pq#hdr-Connection_String_Parameters.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "params",
            "doc": "Parameters to the connection string that can be templated into the connection string with the syntax `{{.key}}`.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "databases",
            "doc": "List of databases to send database-specific metrics about.  If omitted, metrics about all databases will be sent.  This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters).",
            "default": [
              "*"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "databasePollIntervalSeconds",
            "doc": "How frequently to poll for new/deleted databases in the DB server. Defaults to the same as `intervalSeconds` if not set.",
            "default": 0,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "topQueryLimit",
            "doc": "The number of top queries to consider when publishing query-related metrics",
            "default": 10,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "processlist",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports the currently running processes for a host, analogous\nto how the `top` or `ps` command on Unix/Linux systems works.  The output\nformat is a special base64-encoded event that gets processed by our backend\nand displayed under the Infrastructure view for a specific host.\nHistorical process information is not retained on the backend, only the\nmost recent version.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/processlist",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "prometheus-exporter",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reads metrics from a [Prometheus\nexporter](https://prometheus.io/docs/instrumenting/exporters/) endpoint.\n\nAll metric types are supported.  See\nhttps://prometheus.io/docs/concepts/metric_types/ for a description of the\nPrometheus metric types.  The conversion happens as follows:\n\n - Gauges are converted directly to SignalFx gauges\n - Counters are converted directly to SignalFx cumulative counters\n - Untyped metrics are converted directly to SignalFx gauges\n - Summary metrics are converted to three distinct metrics, where\n   `\u003cbasename\u003e` is the root name of the metric:\n   - The total count gets converted to a cumulative counter called `\u003cbasename\u003e_count`\n   - The total sum gets converted to a cumulative counter called `\u003cbasename\u003e`\n   - Each quantile value is converted to a gauge called\n     `\u003cbasename\u003e_quantile` and will include a dimension called `quantile` that\n     specifies the quantile.\n - Histogram metrics are converted to three distinct metrics, where\n   `\u003cbasename\u003e` is the root name of the metric:\n   - The total count gets converted to a cumulative counter called `\u003cbasename\u003e_count`\n   - The total sum gets converted to a cumulative counter called `\u003cbasename\u003e`\n   - Each histogram bucket is converted to a cumulative counter called\n     `\u003cbasename\u003e_bucket` and will include a dimension called `upper_bound` that\n     specifies the maximum value in that bucket.  This metric specifies the\n     number of events with a value that is less than or equal to the upper\n     bound.\n\nAll Prometheus labels will be converted directly to SignalFx dimensions.\n\nThis supports service discovery so you can set a discovery rule such as:\n\n`port \u003e= 9100 \u0026\u0026 port \u003c= 9500 \u0026\u0026 containerImage =~ \"exporter\"`\n\nassuming you are running exporters in container images that have the word\n\"exporter\" in them and fall within the standard exporter port range.  In\nK8s, you could also try matching on the container port name as defined in\nthe pod spec, which is the `name` variable in discovery rules for the\n`k8s-api` observer.\n\nFiltering can be very useful here since exporters tend to be fairly verbose.\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: prometheus-exporter\n   discoveryRule: port \u003e= 9100 \u0026\u0026 port \u003c= 9500 \u0026\u0026 container_image =~ \"exporter\"\n   extraDimensions:\n     metric_source: prometheus\n```\n\n## Authentication\nFor basic HTTP authentication use the `username` and `password` options.\n\nOn Kubernetes if the monitored service requires authentication use the `useServiceAccount`\noption to use the service account of the agent when connecting. Make sure that the\nSignalFx Agent service account has sufficient permissions for the monitored service.\n\n## Troubleshooting\n* Log contains the error `net/http: HTTP/1.x transport connection broken: malformed HTTP response`\n\n    **Solution**: enable HTTPS with `useHTTPS`.\n\n* Log contains the error `forbidden: User \\\"system:anonymous\\\" cannot get path \\\"/metrics\\\"`\n\n    **Solution**: enable `useServiceAccount` and make sure the service account SignalFx agent\n    is running with has the necessary permissions.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/prometheusexporter",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/go",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus Go\ncollector](https://godoc.org/github.com/prometheus/client_golang/prometheus#NewGoCollector)\nand [Prometheus process\ncollector](https://godoc.org/github.com/prometheus/client_golang/prometheus#NewProcessCollector)\nmetrics from a Prometheus exporter and sends them to SignalFx.  It is a\nwrapper around the [prometheus-exporter](./prometheus-exporter.md) monitor\nthat provides a restricted but expandable set of metrics.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "go_gc_duration_seconds",
            "go_gc_duration_seconds_bucket",
            "go_gc_duration_seconds_count",
            "go_goroutines",
            "go_info",
            "go_memstats_alloc_bytes",
            "go_memstats_alloc_bytes_total",
            "go_memstats_buck_hash_sys_bytes",
            "go_memstats_frees_total",
            "go_memstats_gc_cpu_fraction",
            "go_memstats_gc_sys_bytes",
            "go_memstats_heap_alloc_bytes",
            "go_memstats_heap_idle_bytes",
            "go_memstats_heap_inuse_bytes",
            "go_memstats_heap_objects",
            "go_memstats_heap_released_bytes",
            "go_memstats_heap_sys_bytes",
            "go_memstats_last_gc_time_seconds",
            "go_memstats_lookups_total",
            "go_memstats_mallocs_total",
            "go_memstats_mcache_inuse_bytes",
            "go_memstats_mcache_sys_bytes",
            "go_memstats_mspan_inuse_bytes",
            "go_memstats_mspan_sys_bytes",
            "go_memstats_next_gc_bytes",
            "go_memstats_other_sys_bytes",
            "go_memstats_stack_inuse_bytes",
            "go_memstats_stack_sys_bytes",
            "go_memstats_sys_bytes",
            "go_threads",
            "process_cpu_seconds_total",
            "process_max_fds",
            "process_open_fds",
            "process_resident_memory_bytes",
            "process_start_time_seconds",
            "process_virtual_memory_bytes",
            "process_virtual_memory_max_bytes"
          ]
        }
      },
      "metrics": {
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations",
          "group": null,
          "default": false
        },
        "go_goroutines": {
          "type": "gauge",
          "description": "Number of goroutines that currently exist",
          "group": null,
          "default": false
        },
        "go_info": {
          "type": "gauge",
          "description": "Information about the Go environment",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated and still in use",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed",
          "group": null,
          "default": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table",
          "group": null,
          "default": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees",
          "group": null,
          "default": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started",
          "group": null,
          "default": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata",
          "group": null,
          "default": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use",
          "group": null,
          "default": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used",
          "group": null,
          "default": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use",
          "group": null,
          "default": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects",
          "group": null,
          "default": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS",
          "group": null,
          "default": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system",
          "group": null,
          "default": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Number of seconds since 1970 of last garbage collection",
          "group": null,
          "default": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups",
          "group": null,
          "default": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system",
          "group": null,
          "default": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place",
          "group": null,
          "default": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations",
          "group": null,
          "default": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator",
          "group": null,
          "default": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator",
          "group": null,
          "default": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system",
          "group": null,
          "default": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created",
          "group": null,
          "default": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent in seconds",
          "group": null,
          "default": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors",
          "group": null,
          "default": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors",
          "group": null,
          "default": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes",
          "group": null,
          "default": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds",
          "group": null,
          "default": true
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes",
          "group": null,
          "default": false
        },
        "process_virtual_memory_max_bytes": {
          "type": "gauge",
          "description": "Maximum amount of virtual memory available in bytes",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/prometheus/go",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/nginx-vts",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus Nginx VTS\nexporter](https://github.com/hnlq715/nginx-vts-exporter) metrics from a\nPrometheus exporter and sends them to SignalFx.  It is a wrapper around the\n[prometheus-exporter](./prometheus-exporter.md) monitor that provides a\nrestricted but expandable set of metrics.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "nginx_vts_info",
            "nginx_vts_main_connections",
            "nginx_vts_main_shm_usage_bytes",
            "nginx_vts_server_bytes_total",
            "nginx_vts_server_cache_total",
            "nginx_vts_server_request_duration_seconds",
            "nginx_vts_server_request_seconds",
            "nginx_vts_server_request_seconds_total",
            "nginx_vts_server_requests_total",
            "nginx_vts_start_time_seconds",
            "nginx_vts_upstream_bytes_total",
            "nginx_vts_upstream_request_duration_seconds",
            "nginx_vts_upstream_request_seconds",
            "nginx_vts_upstream_request_seconds_total",
            "nginx_vts_upstream_requests_total",
            "nginx_vts_upstream_response_duration_seconds",
            "nginx_vts_upstream_response_seconds",
            "nginx_vts_upstream_response_seconds_total"
          ]
        }
      },
      "metrics": {
        "nginx_vts_info": {
          "type": "gauge",
          "description": "Nginx info",
          "group": null,
          "default": false
        },
        "nginx_vts_main_connections": {
          "type": "gauge",
          "description": "connections",
          "group": null,
          "default": true
        },
        "nginx_vts_main_shm_usage_bytes": {
          "type": "gauge",
          "description": "Shared memory [ngx_http_vhost_traffic_status] info",
          "group": null,
          "default": false
        },
        "nginx_vts_server_bytes_total": {
          "type": "cumulative",
          "description": "The request/response bytes",
          "group": null,
          "default": false
        },
        "nginx_vts_server_cache_total": {
          "type": "cumulative",
          "description": "The requests cache counter",
          "group": null,
          "default": false
        },
        "nginx_vts_server_request_duration_seconds": {
          "type": "cumulative",
          "description": "The histogram of request processing time",
          "group": null,
          "default": false
        },
        "nginx_vts_server_request_seconds": {
          "type": "gauge",
          "description": "The average of request processing times in seconds",
          "group": null,
          "default": true
        },
        "nginx_vts_server_request_seconds_total": {
          "type": "cumulative",
          "description": "The request processing time in seconds",
          "group": null,
          "default": false
        },
        "nginx_vts_server_requests_total": {
          "type": "cumulative",
          "description": "The requests counter",
          "group": null,
          "default": true
        },
        "nginx_vts_start_time_seconds": {
          "type": "gauge",
          "description": "Nginx start time",
          "group": null,
          "default": false
        },
        "nginx_vts_upstream_bytes_total": {
          "type": "cumulative",
          "description": "The request/response bytes",
          "group": null,
          "default": false
        },
        "nginx_vts_upstream_request_duration_seconds": {
          "type": "cumulative",
          "description": "The histogram of request processing time including upstream",
          "group": null,
          "default": false
        },
        "nginx_vts_upstream_request_seconds": {
          "type": "gauge",
          "description": "The average of request processing times including upstream in seconds",
          "group": null,
          "default": true
        },
        "nginx_vts_upstream_request_seconds_total": {
          "type": "cumulative",
          "description": "The request Processing time including upstream in seconds",
          "group": null,
          "default": false
        },
        "nginx_vts_upstream_requests_total": {
          "type": "cumulative",
          "description": "The upstream requests counter",
          "group": null,
          "default": false
        },
        "nginx_vts_upstream_response_duration_seconds": {
          "type": "cumulative",
          "description": "The histogram of only upstream response processing time",
          "group": null,
          "default": false
        },
        "nginx_vts_upstream_response_seconds": {
          "type": "gauge",
          "description": "The average of only upstream response processing times in seconds",
          "group": null,
          "default": false
        },
        "nginx_vts_upstream_response_seconds_total": {
          "type": "cumulative",
          "description": "The only upstream response processing time in seconds",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/prometheus/nginxvts",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/node",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus Node\nExporter](https://github.com/prometheus/node_exporter) metrics and sends\nthem to SignalFx.  It is a wrapper around the\n[prometheus-exporter](./prometheus-exporter.md) monitor that provides a\nrestricted but expandable set of metrics.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "node_arp_entries",
            "node_boot_time_seconds",
            "node_context_switches_total",
            "node_cpu_guest_seconds_total",
            "node_cpu_seconds_total",
            "node_disk_io_now",
            "node_disk_io_time_seconds_total",
            "node_disk_io_time_weighted_seconds_total",
            "node_disk_read_bytes_total",
            "node_disk_read_time_seconds_total",
            "node_disk_reads_completed_total",
            "node_disk_reads_merged_total",
            "node_disk_write_time_seconds_total",
            "node_disk_writes_completed_total",
            "node_disk_writes_merged_total",
            "node_disk_written_bytes_total",
            "node_entropy_available_bits",
            "node_exporter_build_info",
            "node_filefd_allocated",
            "node_filefd_maximum",
            "node_filesystem_avail_bytes",
            "node_filesystem_device_error",
            "node_filesystem_files",
            "node_filesystem_files_free",
            "node_filesystem_free_bytes",
            "node_filesystem_readonly",
            "node_filesystem_size_bytes",
            "node_forks_total",
            "node_intr_total",
            "node_ipvs_connections_total",
            "node_ipvs_incoming_bytes_total",
            "node_ipvs_incoming_packets_total",
            "node_ipvs_outgoing_bytes_total",
            "node_ipvs_outgoing_packets_total",
            "node_load1",
            "node_load15",
            "node_load5",
            "node_memory_Active_anon_bytes",
            "node_memory_Active_bytes",
            "node_memory_Active_file_bytes",
            "node_memory_AnonHugePages_bytes",
            "node_memory_AnonPages_bytes",
            "node_memory_Bounce_bytes",
            "node_memory_Buffers_bytes",
            "node_memory_Cached_bytes",
            "node_memory_CommitLimit_bytes",
            "node_memory_Committed_AS_bytes",
            "node_memory_DirectMap1G_bytes",
            "node_memory_DirectMap2M_bytes",
            "node_memory_DirectMap4k_bytes",
            "node_memory_Dirty_bytes",
            "node_memory_HugePages_Free",
            "node_memory_HugePages_Rsvd",
            "node_memory_HugePages_Surp",
            "node_memory_HugePages_Total",
            "node_memory_Hugepagesize_bytes",
            "node_memory_Inactive_anon_bytes",
            "node_memory_Inactive_bytes",
            "node_memory_Inactive_file_bytes",
            "node_memory_KernelStack_bytes",
            "node_memory_Mapped_bytes",
            "node_memory_MemAvailable_bytes",
            "node_memory_MemFree_bytes",
            "node_memory_MemTotal_bytes",
            "node_memory_Mlocked_bytes",
            "node_memory_NFS_Unstable_bytes",
            "node_memory_PageTables_bytes",
            "node_memory_SReclaimable_bytes",
            "node_memory_SUnreclaim_bytes",
            "node_memory_ShmemHugePages_bytes",
            "node_memory_ShmemPmdMapped_bytes",
            "node_memory_Shmem_bytes",
            "node_memory_Slab_bytes",
            "node_memory_SwapCached_bytes",
            "node_memory_SwapFree_bytes",
            "node_memory_SwapTotal_bytes",
            "node_memory_Unevictable_bytes",
            "node_memory_VmallocChunk_bytes",
            "node_memory_VmallocTotal_bytes",
            "node_memory_VmallocUsed_bytes",
            "node_memory_WritebackTmp_bytes",
            "node_memory_Writeback_bytes",
            "node_netstat_Icmp6_InErrors",
            "node_netstat_Icmp6_InMsgs",
            "node_netstat_Icmp6_OutMsgs",
            "node_netstat_Icmp_InErrors",
            "node_netstat_Icmp_InMsgs",
            "node_netstat_Icmp_OutMsgs",
            "node_netstat_Ip6_InOctets",
            "node_netstat_Ip6_OutOctets",
            "node_netstat_IpExt_InOctets",
            "node_netstat_IpExt_OutOctets",
            "node_netstat_Ip_Forwarding",
            "node_netstat_TcpExt_ListenDrops",
            "node_netstat_TcpExt_ListenOverflows",
            "node_netstat_TcpExt_SyncookiesFailed",
            "node_netstat_TcpExt_SyncookiesRecv",
            "node_netstat_TcpExt_SyncookiesSent",
            "node_netstat_Tcp_ActiveOpens",
            "node_netstat_Tcp_CurrEstab",
            "node_netstat_Tcp_InErrs",
            "node_netstat_Tcp_PassiveOpens",
            "node_netstat_Tcp_RetransSegs",
            "node_netstat_Udp6_InDatagrams",
            "node_netstat_Udp6_InErrors",
            "node_netstat_Udp6_NoPorts",
            "node_netstat_Udp6_OutDatagrams",
            "node_netstat_UdpLite6_InErrors",
            "node_netstat_UdpLite_InErrors",
            "node_netstat_Udp_InDatagrams",
            "node_netstat_Udp_InErrors",
            "node_netstat_Udp_NoPorts",
            "node_netstat_Udp_OutDatagrams",
            "node_network_receive_bytes_total",
            "node_network_receive_compressed_total",
            "node_network_receive_drop_total",
            "node_network_receive_errs_total",
            "node_network_receive_fifo_total",
            "node_network_receive_frame_total",
            "node_network_receive_multicast_total",
            "node_network_receive_packets_total",
            "node_network_transmit_bytes_total",
            "node_network_transmit_carrier_total",
            "node_network_transmit_colls_total",
            "node_network_transmit_compressed_total",
            "node_network_transmit_drop_total",
            "node_network_transmit_errs_total",
            "node_network_transmit_fifo_total",
            "node_network_transmit_packets_total",
            "node_nf_conntrack_entries",
            "node_nf_conntrack_entries_limit",
            "node_procs_blocked",
            "node_procs_running",
            "node_scrape_collector_duration_seconds",
            "node_scrape_collector_success",
            "node_sockstat_FRAG_inuse",
            "node_sockstat_FRAG_memory",
            "node_sockstat_RAW_inuse",
            "node_sockstat_TCP_alloc",
            "node_sockstat_TCP_inuse",
            "node_sockstat_TCP_mem",
            "node_sockstat_TCP_mem_bytes",
            "node_sockstat_TCP_orphan",
            "node_sockstat_TCP_tw",
            "node_sockstat_UDPLITE_inuse",
            "node_sockstat_UDP_inuse",
            "node_sockstat_UDP_mem",
            "node_sockstat_UDP_mem_bytes",
            "node_sockstat_sockets_used",
            "node_textfile_scrape_error",
            "node_time_seconds",
            "node_uname_info",
            "node_vmstat_pgfault",
            "node_vmstat_pgmajfault",
            "node_vmstat_pgpgin",
            "node_vmstat_pgpgout",
            "node_vmstat_pswpin",
            "node_vmstat_pswpout"
          ]
        }
      },
      "metrics": {
        "node_arp_entries": {
          "type": "gauge",
          "description": "ARP entries by device",
          "group": null,
          "default": false
        },
        "node_boot_time_seconds": {
          "type": "gauge",
          "description": "Node boot time, in unixtime",
          "group": null,
          "default": false
        },
        "node_context_switches_total": {
          "type": "cumulative",
          "description": "Total number of context switches",
          "group": null,
          "default": false
        },
        "node_cpu_guest_seconds_total": {
          "type": "cumulative",
          "description": "Seconds the cpus spent in guests (VMs) for each mode",
          "group": null,
          "default": false
        },
        "node_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Seconds the cpus spent in each mode",
          "group": null,
          "default": false
        },
        "node_disk_io_now": {
          "type": "gauge",
          "description": "The number of I/Os currently in progress",
          "group": null,
          "default": false
        },
        "node_disk_io_time_seconds_total": {
          "type": "cumulative",
          "description": "Total seconds spent doing I/Os",
          "group": null,
          "default": false
        },
        "node_disk_io_time_weighted_seconds_total": {
          "type": "cumulative",
          "description": "The weighted number of seconds spent doing I/Os. See https://www.kernel.org/doc/Documentation/iostats.txt",
          "group": null,
          "default": false
        },
        "node_disk_read_bytes_total": {
          "type": "cumulative",
          "description": "The total number of bytes read successfully",
          "group": null,
          "default": false
        },
        "node_disk_read_time_seconds_total": {
          "type": "cumulative",
          "description": "The total number of milliseconds spent by all reads",
          "group": null,
          "default": false
        },
        "node_disk_reads_completed_total": {
          "type": "cumulative",
          "description": "The total number of reads completed successfully",
          "group": null,
          "default": false
        },
        "node_disk_reads_merged_total": {
          "type": "cumulative",
          "description": "The total number of reads merged. See https://www.kernel.org/doc/Documentation/iostats.txt",
          "group": null,
          "default": false
        },
        "node_disk_write_time_seconds_total": {
          "type": "cumulative",
          "description": "This is the total number of seconds spent by all writes",
          "group": null,
          "default": false
        },
        "node_disk_writes_completed_total": {
          "type": "cumulative",
          "description": "The total number of writes completed successfully",
          "group": null,
          "default": false
        },
        "node_disk_writes_merged_total": {
          "type": "cumulative",
          "description": "The number of writes merged. See https://www.kernel.org/doc/Documentation/iostats.txt",
          "group": null,
          "default": false
        },
        "node_disk_written_bytes_total": {
          "type": "cumulative",
          "description": "The total number of bytes written successfully",
          "group": null,
          "default": false
        },
        "node_entropy_available_bits": {
          "type": "gauge",
          "description": "Bits of available entropy",
          "group": null,
          "default": false
        },
        "node_exporter_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by version, revision, branch, and goversion from which node_exporter was built",
          "group": null,
          "default": false
        },
        "node_filefd_allocated": {
          "type": "gauge",
          "description": "File descriptor statistics: allocated",
          "group": null,
          "default": false
        },
        "node_filefd_maximum": {
          "type": "gauge",
          "description": "File descriptor statistics: maximum",
          "group": null,
          "default": false
        },
        "node_filesystem_avail_bytes": {
          "type": "gauge",
          "description": "Filesystem space available to non-root users in bytes",
          "group": null,
          "default": false
        },
        "node_filesystem_device_error": {
          "type": "gauge",
          "description": "Whether an error occurred while getting statistics for the given device",
          "group": null,
          "default": false
        },
        "node_filesystem_files": {
          "type": "gauge",
          "description": "Filesystem total file nodes",
          "group": null,
          "default": false
        },
        "node_filesystem_files_free": {
          "type": "gauge",
          "description": "Filesystem total free file nodes",
          "group": null,
          "default": false
        },
        "node_filesystem_free_bytes": {
          "type": "gauge",
          "description": "Filesystem free space in bytes",
          "group": null,
          "default": false
        },
        "node_filesystem_readonly": {
          "type": "gauge",
          "description": "Filesystem read-only status",
          "group": null,
          "default": false
        },
        "node_filesystem_size_bytes": {
          "type": "gauge",
          "description": "Filesystem size in bytes",
          "group": null,
          "default": false
        },
        "node_forks_total": {
          "type": "cumulative",
          "description": "Total number of forks",
          "group": null,
          "default": false
        },
        "node_intr_total": {
          "type": "cumulative",
          "description": "Total number of interrupts serviced",
          "group": null,
          "default": false
        },
        "node_ipvs_connections_total": {
          "type": "cumulative",
          "description": "The total number of connections made",
          "group": null,
          "default": false
        },
        "node_ipvs_incoming_bytes_total": {
          "type": "cumulative",
          "description": "The total amount of incoming data",
          "group": null,
          "default": false
        },
        "node_ipvs_incoming_packets_total": {
          "type": "cumulative",
          "description": "The total number of incoming packets",
          "group": null,
          "default": false
        },
        "node_ipvs_outgoing_bytes_total": {
          "type": "cumulative",
          "description": "The total amount of outgoing data",
          "group": null,
          "default": false
        },
        "node_ipvs_outgoing_packets_total": {
          "type": "cumulative",
          "description": "The total number of outgoing packets",
          "group": null,
          "default": false
        },
        "node_load1": {
          "type": "gauge",
          "description": "1m load average",
          "group": null,
          "default": false
        },
        "node_load15": {
          "type": "gauge",
          "description": "15m load average",
          "group": null,
          "default": false
        },
        "node_load5": {
          "type": "gauge",
          "description": "5m load average",
          "group": null,
          "default": false
        },
        "node_memory_Active_anon_bytes": {
          "type": "gauge",
          "description": "Memory information field Active_anon_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Active_bytes": {
          "type": "gauge",
          "description": "Memory information field Active_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Active_file_bytes": {
          "type": "gauge",
          "description": "Memory information field Active_file_bytes",
          "group": null,
          "default": false
        },
        "node_memory_AnonHugePages_bytes": {
          "type": "gauge",
          "description": "Memory information field AnonHugePages_bytes",
          "group": null,
          "default": false
        },
        "node_memory_AnonPages_bytes": {
          "type": "gauge",
          "description": "Memory information field AnonPages_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Bounce_bytes": {
          "type": "gauge",
          "description": "Memory information field Bounce_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Buffers_bytes": {
          "type": "gauge",
          "description": "Memory information field Buffers_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Cached_bytes": {
          "type": "gauge",
          "description": "Memory information field Cached_bytes",
          "group": null,
          "default": false
        },
        "node_memory_CommitLimit_bytes": {
          "type": "gauge",
          "description": "Memory information field CommitLimit_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Committed_AS_bytes": {
          "type": "gauge",
          "description": "Memory information field Committed_AS_bytes",
          "group": null,
          "default": false
        },
        "node_memory_DirectMap1G_bytes": {
          "type": "gauge",
          "description": "Memory information field DirectMap1G_bytes",
          "group": null,
          "default": false
        },
        "node_memory_DirectMap2M_bytes": {
          "type": "gauge",
          "description": "Memory information field DirectMap2M_bytes",
          "group": null,
          "default": false
        },
        "node_memory_DirectMap4k_bytes": {
          "type": "gauge",
          "description": "Memory information field DirectMap4k_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Dirty_bytes": {
          "type": "gauge",
          "description": "Memory information field Dirty_bytes",
          "group": null,
          "default": false
        },
        "node_memory_HugePages_Free": {
          "type": "gauge",
          "description": "Memory information field HugePages_Free",
          "group": null,
          "default": false
        },
        "node_memory_HugePages_Rsvd": {
          "type": "gauge",
          "description": "Memory information field HugePages_Rsvd",
          "group": null,
          "default": false
        },
        "node_memory_HugePages_Surp": {
          "type": "gauge",
          "description": "Memory information field HugePages_Surp",
          "group": null,
          "default": false
        },
        "node_memory_HugePages_Total": {
          "type": "gauge",
          "description": "Memory information field HugePages_Total",
          "group": null,
          "default": false
        },
        "node_memory_Hugepagesize_bytes": {
          "type": "gauge",
          "description": "Memory information field Hugepagesize_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Inactive_anon_bytes": {
          "type": "gauge",
          "description": "Memory information field Inactive_anon_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Inactive_bytes": {
          "type": "gauge",
          "description": "Memory information field Inactive_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Inactive_file_bytes": {
          "type": "gauge",
          "description": "Memory information field Inactive_file_bytes",
          "group": null,
          "default": false
        },
        "node_memory_KernelStack_bytes": {
          "type": "gauge",
          "description": "Memory information field KernelStack_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Mapped_bytes": {
          "type": "gauge",
          "description": "Memory information field Mapped_bytes",
          "group": null,
          "default": false
        },
        "node_memory_MemAvailable_bytes": {
          "type": "gauge",
          "description": "Memory information field MemAvailable_bytes",
          "group": null,
          "default": false
        },
        "node_memory_MemFree_bytes": {
          "type": "gauge",
          "description": "Memory information field MemFree_bytes",
          "group": null,
          "default": false
        },
        "node_memory_MemTotal_bytes": {
          "type": "gauge",
          "description": "Memory information field MemTotal_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Mlocked_bytes": {
          "type": "gauge",
          "description": "Memory information field Mlocked_bytes",
          "group": null,
          "default": false
        },
        "node_memory_NFS_Unstable_bytes": {
          "type": "gauge",
          "description": "Memory information field NFS_Unstable_bytes",
          "group": null,
          "default": false
        },
        "node_memory_PageTables_bytes": {
          "type": "gauge",
          "description": "Memory information field PageTables_bytes",
          "group": null,
          "default": false
        },
        "node_memory_SReclaimable_bytes": {
          "type": "gauge",
          "description": "Memory information field SReclaimable_bytes",
          "group": null,
          "default": false
        },
        "node_memory_SUnreclaim_bytes": {
          "type": "gauge",
          "description": "Memory information field SUnreclaim_bytes",
          "group": null,
          "default": false
        },
        "node_memory_ShmemHugePages_bytes": {
          "type": "gauge",
          "description": "Memory information field ShmemHugePages_bytes",
          "group": null,
          "default": false
        },
        "node_memory_ShmemPmdMapped_bytes": {
          "type": "gauge",
          "description": "Memory information field ShmemPmdMapped_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Shmem_bytes": {
          "type": "gauge",
          "description": "Memory information field Shmem_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Slab_bytes": {
          "type": "gauge",
          "description": "Memory information field Slab_bytes",
          "group": null,
          "default": false
        },
        "node_memory_SwapCached_bytes": {
          "type": "gauge",
          "description": "Memory information field SwapCached_bytes",
          "group": null,
          "default": false
        },
        "node_memory_SwapFree_bytes": {
          "type": "gauge",
          "description": "Memory information field SwapFree_bytes",
          "group": null,
          "default": false
        },
        "node_memory_SwapTotal_bytes": {
          "type": "gauge",
          "description": "Memory information field SwapTotal_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Unevictable_bytes": {
          "type": "gauge",
          "description": "Memory information field Unevictable_bytes",
          "group": null,
          "default": false
        },
        "node_memory_VmallocChunk_bytes": {
          "type": "gauge",
          "description": "Memory information field VmallocChunk_bytes",
          "group": null,
          "default": false
        },
        "node_memory_VmallocTotal_bytes": {
          "type": "gauge",
          "description": "Memory information field VmallocTotal_bytes",
          "group": null,
          "default": false
        },
        "node_memory_VmallocUsed_bytes": {
          "type": "gauge",
          "description": "Memory information field VmallocUsed_bytes",
          "group": null,
          "default": false
        },
        "node_memory_WritebackTmp_bytes": {
          "type": "gauge",
          "description": "Memory information field WritebackTmp_bytes",
          "group": null,
          "default": false
        },
        "node_memory_Writeback_bytes": {
          "type": "gauge",
          "description": "Memory information field Writeback_bytes",
          "group": null,
          "default": false
        },
        "node_netstat_Icmp6_InErrors": {
          "type": "gauge",
          "description": "Statistic Icmp6InErrors",
          "group": null,
          "default": false
        },
        "node_netstat_Icmp6_InMsgs": {
          "type": "gauge",
          "description": "Statistic Icmp6InMsgs",
          "group": null,
          "default": false
        },
        "node_netstat_Icmp6_OutMsgs": {
          "type": "gauge",
          "description": "Statistic Icmp6OutMsgs",
          "group": null,
          "default": false
        },
        "node_netstat_Icmp_InErrors": {
          "type": "gauge",
          "description": "Statistic IcmpInErrors",
          "group": null,
          "default": false
        },
        "node_netstat_Icmp_InMsgs": {
          "type": "gauge",
          "description": "Statistic IcmpInMsgs",
          "group": null,
          "default": false
        },
        "node_netstat_Icmp_OutMsgs": {
          "type": "gauge",
          "description": "Statistic IcmpOutMsgs",
          "group": null,
          "default": false
        },
        "node_netstat_Ip6_InOctets": {
          "type": "gauge",
          "description": "Statistic Ip6InOctets",
          "group": null,
          "default": false
        },
        "node_netstat_Ip6_OutOctets": {
          "type": "gauge",
          "description": "Statistic Ip6OutOctets",
          "group": null,
          "default": false
        },
        "node_netstat_IpExt_InOctets": {
          "type": "gauge",
          "description": "Statistic IpExtInOctets",
          "group": null,
          "default": false
        },
        "node_netstat_IpExt_OutOctets": {
          "type": "gauge",
          "description": "Statistic IpExtOutOctets",
          "group": null,
          "default": false
        },
        "node_netstat_Ip_Forwarding": {
          "type": "gauge",
          "description": "Statistic IpForwarding",
          "group": null,
          "default": false
        },
        "node_netstat_TcpExt_ListenDrops": {
          "type": "gauge",
          "description": "Statistic TcpExtListenDrops",
          "group": null,
          "default": false
        },
        "node_netstat_TcpExt_ListenOverflows": {
          "type": "gauge",
          "description": "Statistic TcpExtListenOverflows",
          "group": null,
          "default": false
        },
        "node_netstat_TcpExt_SyncookiesFailed": {
          "type": "gauge",
          "description": "Statistic TcpExtSyncookiesFailed",
          "group": null,
          "default": false
        },
        "node_netstat_TcpExt_SyncookiesRecv": {
          "type": "gauge",
          "description": "Statistic TcpExtSyncookiesRecv",
          "group": null,
          "default": false
        },
        "node_netstat_TcpExt_SyncookiesSent": {
          "type": "gauge",
          "description": "Statistic TcpExtSyncookiesSent",
          "group": null,
          "default": false
        },
        "node_netstat_Tcp_ActiveOpens": {
          "type": "gauge",
          "description": "Statistic TcpActiveOpens",
          "group": null,
          "default": false
        },
        "node_netstat_Tcp_CurrEstab": {
          "type": "gauge",
          "description": "Statistic TcpCurrEstab",
          "group": null,
          "default": false
        },
        "node_netstat_Tcp_InErrs": {
          "type": "gauge",
          "description": "Statistic TcpInErrs",
          "group": null,
          "default": false
        },
        "node_netstat_Tcp_PassiveOpens": {
          "type": "gauge",
          "description": "Statistic TcpPassiveOpens",
          "group": null,
          "default": false
        },
        "node_netstat_Tcp_RetransSegs": {
          "type": "gauge",
          "description": "Statistic TcpRetransSegs",
          "group": null,
          "default": false
        },
        "node_netstat_Udp6_InDatagrams": {
          "type": "gauge",
          "description": "Statistic Udp6InDatagrams",
          "group": null,
          "default": false
        },
        "node_netstat_Udp6_InErrors": {
          "type": "gauge",
          "description": "Statistic Udp6InErrors",
          "group": null,
          "default": false
        },
        "node_netstat_Udp6_NoPorts": {
          "type": "gauge",
          "description": "Statistic Udp6NoPorts",
          "group": null,
          "default": false
        },
        "node_netstat_Udp6_OutDatagrams": {
          "type": "gauge",
          "description": "Statistic Udp6OutDatagrams",
          "group": null,
          "default": false
        },
        "node_netstat_UdpLite6_InErrors": {
          "type": "gauge",
          "description": "Statistic UdpLite6InErrors",
          "group": null,
          "default": false
        },
        "node_netstat_UdpLite_InErrors": {
          "type": "gauge",
          "description": "Statistic UdpLiteInErrors",
          "group": null,
          "default": false
        },
        "node_netstat_Udp_InDatagrams": {
          "type": "gauge",
          "description": "Statistic UdpInDatagrams",
          "group": null,
          "default": false
        },
        "node_netstat_Udp_InErrors": {
          "type": "gauge",
          "description": "Statistic UdpInErrors",
          "group": null,
          "default": false
        },
        "node_netstat_Udp_NoPorts": {
          "type": "gauge",
          "description": "Statistic UdpNoPorts",
          "group": null,
          "default": false
        },
        "node_netstat_Udp_OutDatagrams": {
          "type": "gauge",
          "description": "Statistic UdpOutDatagrams",
          "group": null,
          "default": false
        },
        "node_network_receive_bytes_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_bytes",
          "group": null,
          "default": false
        },
        "node_network_receive_compressed_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_compressed",
          "group": null,
          "default": false
        },
        "node_network_receive_drop_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_drop",
          "group": null,
          "default": false
        },
        "node_network_receive_errs_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_errs",
          "group": null,
          "default": false
        },
        "node_network_receive_fifo_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_fifo",
          "group": null,
          "default": false
        },
        "node_network_receive_frame_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_frame",
          "group": null,
          "default": false
        },
        "node_network_receive_multicast_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_multicast",
          "group": null,
          "default": false
        },
        "node_network_receive_packets_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_packets",
          "group": null,
          "default": false
        },
        "node_network_transmit_bytes_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_bytes",
          "group": null,
          "default": false
        },
        "node_network_transmit_carrier_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_carrier",
          "group": null,
          "default": false
        },
        "node_network_transmit_colls_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_colls",
          "group": null,
          "default": false
        },
        "node_network_transmit_compressed_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_compressed",
          "group": null,
          "default": false
        },
        "node_network_transmit_drop_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_drop",
          "group": null,
          "default": false
        },
        "node_network_transmit_errs_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_errs",
          "group": null,
          "default": false
        },
        "node_network_transmit_fifo_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_fifo",
          "group": null,
          "default": false
        },
        "node_network_transmit_packets_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_packets",
          "group": null,
          "default": false
        },
        "node_nf_conntrack_entries": {
          "type": "gauge",
          "description": "Number of currently allocated flow entries for connection tracking",
          "group": null,
          "default": false
        },
        "node_nf_conntrack_entries_limit": {
          "type": "gauge",
          "description": "Maximum size of connection tracking table",
          "group": null,
          "default": false
        },
        "node_procs_blocked": {
          "type": "gauge",
          "description": "Number of processes blocked waiting for I/O to complete",
          "group": null,
          "default": false
        },
        "node_procs_running": {
          "type": "gauge",
          "description": "Number of processes in runnable state",
          "group": null,
          "default": false
        },
        "node_scrape_collector_duration_seconds": {
          "type": "gauge",
          "description": "Duration of a collector scrape",
          "group": null,
          "default": false
        },
        "node_scrape_collector_success": {
          "type": "gauge",
          "description": "Whether a collector succeeded",
          "group": null,
          "default": false
        },
        "node_sockstat_FRAG_inuse": {
          "type": "gauge",
          "description": "Number of FRAG sockets in state inuse",
          "group": null,
          "default": false
        },
        "node_sockstat_FRAG_memory": {
          "type": "gauge",
          "description": "Number of FRAG sockets in state memory",
          "group": null,
          "default": false
        },
        "node_sockstat_RAW_inuse": {
          "type": "gauge",
          "description": "Number of RAW sockets in state inuse",
          "group": null,
          "default": false
        },
        "node_sockstat_TCP_alloc": {
          "type": "gauge",
          "description": "Number of TCP sockets in state alloc",
          "group": null,
          "default": false
        },
        "node_sockstat_TCP_inuse": {
          "type": "gauge",
          "description": "Number of TCP sockets in state inuse",
          "group": null,
          "default": false
        },
        "node_sockstat_TCP_mem": {
          "type": "gauge",
          "description": "Number of TCP sockets in state mem",
          "group": null,
          "default": false
        },
        "node_sockstat_TCP_mem_bytes": {
          "type": "gauge",
          "description": "Number of TCP sockets in state mem_bytes",
          "group": null,
          "default": false
        },
        "node_sockstat_TCP_orphan": {
          "type": "gauge",
          "description": "Number of TCP sockets in state orphan",
          "group": null,
          "default": false
        },
        "node_sockstat_TCP_tw": {
          "type": "gauge",
          "description": "Number of TCP sockets in state tw",
          "group": null,
          "default": false
        },
        "node_sockstat_UDPLITE_inuse": {
          "type": "gauge",
          "description": "Number of UDPLITE sockets in state inuse",
          "group": null,
          "default": false
        },
        "node_sockstat_UDP_inuse": {
          "type": "gauge",
          "description": "Number of UDP sockets in state inuse",
          "group": null,
          "default": false
        },
        "node_sockstat_UDP_mem": {
          "type": "gauge",
          "description": "Number of UDP sockets in state mem",
          "group": null,
          "default": false
        },
        "node_sockstat_UDP_mem_bytes": {
          "type": "gauge",
          "description": "Number of UDP sockets in state mem_bytes",
          "group": null,
          "default": false
        },
        "node_sockstat_sockets_used": {
          "type": "gauge",
          "description": "Number of sockets sockets in state used",
          "group": null,
          "default": false
        },
        "node_textfile_scrape_error": {
          "type": "gauge",
          "description": "1 if there was an error opening or reading a file, 0 otherwise",
          "group": null,
          "default": false
        },
        "node_time_seconds": {
          "type": "gauge",
          "description": "System time in seconds since epoch (1970)",
          "group": null,
          "default": false
        },
        "node_uname_info": {
          "type": "gauge",
          "description": "Labeled system information as provided by the uname system call",
          "group": null,
          "default": false
        },
        "node_vmstat_pgfault": {
          "type": "gauge",
          "description": "/proc/vmstat information field pgfault",
          "group": null,
          "default": false
        },
        "node_vmstat_pgmajfault": {
          "type": "gauge",
          "description": "/proc/vmstat information field pgmajfault",
          "group": null,
          "default": false
        },
        "node_vmstat_pgpgin": {
          "type": "gauge",
          "description": "/proc/vmstat information field pgpgin",
          "group": null,
          "default": false
        },
        "node_vmstat_pgpgout": {
          "type": "gauge",
          "description": "/proc/vmstat information field pgpgout",
          "group": null,
          "default": false
        },
        "node_vmstat_pswpin": {
          "type": "gauge",
          "description": "/proc/vmstat information field pswpin",
          "group": null,
          "default": false
        },
        "node_vmstat_pswpout": {
          "type": "gauge",
          "description": "/proc/vmstat information field pswpout",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/prometheus/node",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/postgres",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus PostgreSQL Server\nExporter](https://github.com/wrouesnel/postgres_exporter) metrics and sends\nthem to SignalFx.  It is a wrapper around the\n[prometheus-exporter](./prometheus-exporter.md) monitor that provides a\nrestricted but expandable set of metrics.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "pg_exporter_last_scrape_duration_seconds",
            "pg_exporter_last_scrape_error",
            "pg_exporter_scrapes_total",
            "pg_exporter_user_queries_load_error",
            "pg_locks_count",
            "pg_postmaster_start_time_seconds",
            "pg_replication_is_replica",
            "pg_replication_lag",
            "pg_settings_allow_system_table_mods",
            "pg_settings_archive_timeout_seconds",
            "pg_settings_array_nulls",
            "pg_settings_authentication_timeout_seconds",
            "pg_settings_autovacuum",
            "pg_settings_autovacuum_analyze_scale_factor",
            "pg_settings_autovacuum_analyze_threshold",
            "pg_settings_autovacuum_freeze_max_age",
            "pg_settings_autovacuum_max_workers",
            "pg_settings_autovacuum_multixact_freeze_max_age",
            "pg_settings_autovacuum_naptime_seconds",
            "pg_settings_autovacuum_vacuum_cost_delay_seconds",
            "pg_settings_autovacuum_vacuum_cost_limit",
            "pg_settings_autovacuum_vacuum_scale_factor",
            "pg_settings_autovacuum_vacuum_threshold",
            "pg_settings_autovacuum_work_mem_bytes",
            "pg_settings_backend_flush_after_bytes",
            "pg_settings_bgwriter_delay_seconds",
            "pg_settings_bgwriter_flush_after_bytes",
            "pg_settings_bgwriter_lru_maxpages",
            "pg_settings_bgwriter_lru_multiplier",
            "pg_settings_block_size",
            "pg_settings_bonjour",
            "pg_settings_check_function_bodies",
            "pg_settings_checkpoint_completion_target",
            "pg_settings_checkpoint_flush_after_bytes",
            "pg_settings_checkpoint_timeout_seconds",
            "pg_settings_checkpoint_warning_seconds",
            "pg_settings_commit_delay",
            "pg_settings_commit_siblings",
            "pg_settings_cpu_index_tuple_cost",
            "pg_settings_cpu_operator_cost",
            "pg_settings_cpu_tuple_cost",
            "pg_settings_cursor_tuple_fraction",
            "pg_settings_data_checksums",
            "pg_settings_db_user_namespace",
            "pg_settings_deadlock_timeout_seconds",
            "pg_settings_debug_assertions",
            "pg_settings_debug_pretty_print",
            "pg_settings_debug_print_parse",
            "pg_settings_debug_print_plan",
            "pg_settings_debug_print_rewritten",
            "pg_settings_default_statistics_target",
            "pg_settings_default_transaction_deferrable",
            "pg_settings_default_transaction_read_only",
            "pg_settings_default_with_oids",
            "pg_settings_effective_cache_size_bytes",
            "pg_settings_effective_io_concurrency",
            "pg_settings_enable_bitmapscan",
            "pg_settings_enable_hashagg",
            "pg_settings_enable_hashjoin",
            "pg_settings_enable_indexonlyscan",
            "pg_settings_enable_indexscan",
            "pg_settings_enable_material",
            "pg_settings_enable_mergejoin",
            "pg_settings_enable_nestloop",
            "pg_settings_enable_seqscan",
            "pg_settings_enable_sort",
            "pg_settings_enable_tidscan",
            "pg_settings_escape_string_warning",
            "pg_settings_exit_on_error",
            "pg_settings_extra_float_digits",
            "pg_settings_from_collapse_limit",
            "pg_settings_fsync",
            "pg_settings_full_page_writes",
            "pg_settings_geqo",
            "pg_settings_geqo_effort",
            "pg_settings_geqo_generations",
            "pg_settings_geqo_pool_size",
            "pg_settings_geqo_seed",
            "pg_settings_geqo_selection_bias",
            "pg_settings_geqo_threshold",
            "pg_settings_gin_fuzzy_search_limit",
            "pg_settings_gin_pending_list_limit_bytes",
            "pg_settings_hot_standby",
            "pg_settings_hot_standby_feedback",
            "pg_settings_idle_in_transaction_session_timeout_seconds",
            "pg_settings_ignore_checksum_failure",
            "pg_settings_ignore_system_indexes",
            "pg_settings_integer_datetimes",
            "pg_settings_join_collapse_limit",
            "pg_settings_krb_caseins_users",
            "pg_settings_lo_compat_privileges",
            "pg_settings_lock_timeout_seconds",
            "pg_settings_log_autovacuum_min_duration_seconds",
            "pg_settings_log_checkpoints",
            "pg_settings_log_connections",
            "pg_settings_log_disconnections",
            "pg_settings_log_duration",
            "pg_settings_log_executor_stats",
            "pg_settings_log_file_mode",
            "pg_settings_log_hostname",
            "pg_settings_log_lock_waits",
            "pg_settings_log_min_duration_statement_seconds",
            "pg_settings_log_parser_stats",
            "pg_settings_log_planner_stats",
            "pg_settings_log_replication_commands",
            "pg_settings_log_rotation_age_seconds",
            "pg_settings_log_rotation_size_bytes",
            "pg_settings_log_statement_stats",
            "pg_settings_log_temp_files_bytes",
            "pg_settings_log_truncate_on_rotation",
            "pg_settings_logging_collector",
            "pg_settings_maintenance_work_mem_bytes",
            "pg_settings_max_connections",
            "pg_settings_max_files_per_process",
            "pg_settings_max_function_args",
            "pg_settings_max_identifier_length",
            "pg_settings_max_index_keys",
            "pg_settings_max_locks_per_transaction",
            "pg_settings_max_parallel_workers_per_gather",
            "pg_settings_max_pred_locks_per_transaction",
            "pg_settings_max_prepared_transactions",
            "pg_settings_max_replication_slots",
            "pg_settings_max_stack_depth_bytes",
            "pg_settings_max_standby_archive_delay_seconds",
            "pg_settings_max_standby_streaming_delay_seconds",
            "pg_settings_max_wal_senders",
            "pg_settings_max_wal_size_bytes",
            "pg_settings_max_worker_processes",
            "pg_settings_min_parallel_relation_size_bytes",
            "pg_settings_min_wal_size_bytes",
            "pg_settings_old_snapshot_threshold_seconds",
            "pg_settings_operator_precedence_warning",
            "pg_settings_parallel_setup_cost",
            "pg_settings_parallel_tuple_cost",
            "pg_settings_password_encryption",
            "pg_settings_port",
            "pg_settings_post_auth_delay_seconds",
            "pg_settings_pre_auth_delay_seconds",
            "pg_settings_quote_all_identifiers",
            "pg_settings_random_page_cost",
            "pg_settings_replacement_sort_tuples",
            "pg_settings_restart_after_crash",
            "pg_settings_row_security",
            "pg_settings_segment_size_bytes",
            "pg_settings_seq_page_cost",
            "pg_settings_server_version_num",
            "pg_settings_shared_buffers_bytes",
            "pg_settings_sql_inheritance",
            "pg_settings_ssl",
            "pg_settings_ssl_prefer_server_ciphers",
            "pg_settings_standard_conforming_strings",
            "pg_settings_statement_timeout_seconds",
            "pg_settings_superuser_reserved_connections",
            "pg_settings_synchronize_seqscans",
            "pg_settings_syslog_sequence_numbers",
            "pg_settings_syslog_split_messages",
            "pg_settings_tcp_keepalives_count",
            "pg_settings_tcp_keepalives_idle_seconds",
            "pg_settings_tcp_keepalives_interval_seconds",
            "pg_settings_temp_buffers_bytes",
            "pg_settings_temp_file_limit_bytes",
            "pg_settings_trace_notify",
            "pg_settings_trace_sort",
            "pg_settings_track_activities",
            "pg_settings_track_activity_query_size",
            "pg_settings_track_commit_timestamp",
            "pg_settings_track_counts",
            "pg_settings_track_io_timing",
            "pg_settings_transaction_deferrable",
            "pg_settings_transaction_read_only",
            "pg_settings_transform_null_equals",
            "pg_settings_unix_socket_permissions",
            "pg_settings_update_process_title",
            "pg_settings_vacuum_cost_delay_seconds",
            "pg_settings_vacuum_cost_limit",
            "pg_settings_vacuum_cost_page_dirty",
            "pg_settings_vacuum_cost_page_hit",
            "pg_settings_vacuum_cost_page_miss",
            "pg_settings_vacuum_defer_cleanup_age",
            "pg_settings_vacuum_freeze_min_age",
            "pg_settings_vacuum_freeze_table_age",
            "pg_settings_vacuum_multixact_freeze_min_age",
            "pg_settings_vacuum_multixact_freeze_table_age",
            "pg_settings_wal_block_size",
            "pg_settings_wal_buffers_bytes",
            "pg_settings_wal_compression",
            "pg_settings_wal_keep_segments",
            "pg_settings_wal_log_hints",
            "pg_settings_wal_receiver_status_interval_seconds",
            "pg_settings_wal_receiver_timeout_seconds",
            "pg_settings_wal_retrieve_retry_interval_seconds",
            "pg_settings_wal_segment_size_bytes",
            "pg_settings_wal_sender_timeout_seconds",
            "pg_settings_wal_writer_delay_seconds",
            "pg_settings_wal_writer_flush_after_bytes",
            "pg_settings_work_mem_bytes",
            "pg_settings_zero_damaged_pages",
            "pg_slow_queries",
            "pg_stat_activity_count",
            "pg_stat_activity_max_tx_duration",
            "pg_stat_bgwriter_buffers_alloc",
            "pg_stat_bgwriter_buffers_backend",
            "pg_stat_bgwriter_buffers_backend_fsync",
            "pg_stat_bgwriter_buffers_checkpoint",
            "pg_stat_bgwriter_buffers_clean",
            "pg_stat_bgwriter_checkpoint_sync_time",
            "pg_stat_bgwriter_checkpoint_write_time",
            "pg_stat_bgwriter_checkpoints_req",
            "pg_stat_bgwriter_checkpoints_timed",
            "pg_stat_bgwriter_maxwritten_clean",
            "pg_stat_bgwriter_stats_reset",
            "pg_stat_database_blk_read_time",
            "pg_stat_database_blk_write_time",
            "pg_stat_database_blks_hit",
            "pg_stat_database_blks_read",
            "pg_stat_database_conflicts",
            "pg_stat_database_conflicts_confl_bufferpin",
            "pg_stat_database_conflicts_confl_deadlock",
            "pg_stat_database_conflicts_confl_lock",
            "pg_stat_database_conflicts_confl_snapshot",
            "pg_stat_database_conflicts_confl_tablespace",
            "pg_stat_database_deadlocks",
            "pg_stat_database_numbackends",
            "pg_stat_database_stats_reset",
            "pg_stat_database_temp_bytes",
            "pg_stat_database_temp_files",
            "pg_stat_database_tup_deleted",
            "pg_stat_database_tup_fetched",
            "pg_stat_database_tup_inserted",
            "pg_stat_database_tup_returned",
            "pg_stat_database_tup_updated",
            "pg_stat_database_xact_commit",
            "pg_stat_database_xact_rollback",
            "pg_static",
            "pg_stuck_idle_in_transaction_queries",
            "pg_total_relation_size_bytes",
            "pg_up",
            "pg_vacuum_age_in_seconds",
            "pg_vacuum_analyze_age_in_seconds",
            "pg_vacuum_analyze_queries",
            "pg_vacuum_queries"
          ]
        }
      },
      "metrics": {
        "pg_exporter_last_scrape_duration_seconds": {
          "type": "gauge",
          "description": "Duration of the last scrape of metrics from PostgresSQL.",
          "group": null,
          "default": false
        },
        "pg_exporter_last_scrape_error": {
          "type": "gauge",
          "description": "Whether the last scrape of metrics from PostgreSQL resulted in an error (1 for error, 0 for success).",
          "group": null,
          "default": false
        },
        "pg_exporter_scrapes_total": {
          "type": "cumulative",
          "description": "Total number of times PostgresSQL was scraped for metrics.",
          "group": null,
          "default": false
        },
        "pg_exporter_user_queries_load_error": {
          "type": "gauge",
          "description": "Whether the user queries file was loaded and parsed successfully (1 for error, 0 for success).",
          "group": null,
          "default": false
        },
        "pg_locks_count": {
          "type": "gauge",
          "description": "Number of locks",
          "group": null,
          "default": false
        },
        "pg_postmaster_start_time_seconds": {
          "type": "gauge",
          "description": "Time at which postmaster started",
          "group": null,
          "default": false
        },
        "pg_replication_is_replica": {
          "type": "gauge",
          "description": "Indicates if this host is a slave",
          "group": null,
          "default": false
        },
        "pg_replication_lag": {
          "type": "gauge",
          "description": "Replication lag behind master in seconds",
          "group": null,
          "default": false
        },
        "pg_settings_allow_system_table_mods": {
          "type": "gauge",
          "description": "Allows modifications of the structure of system tables.",
          "group": null,
          "default": false
        },
        "pg_settings_archive_timeout_seconds": {
          "type": "gauge",
          "description": "Forces a switch to the next xlog file if a new file has not been started within N seconds. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_array_nulls": {
          "type": "gauge",
          "description": "Enable input of NULL elements in arrays.",
          "group": null,
          "default": false
        },
        "pg_settings_authentication_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum allowed time to complete client authentication. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum": {
          "type": "gauge",
          "description": "Starts the autovacuum subprocess.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_analyze_scale_factor": {
          "type": "gauge",
          "description": "Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_analyze_threshold": {
          "type": "gauge",
          "description": "Minimum number of tuple inserts, updates, or deletes prior to analyze.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_freeze_max_age": {
          "type": "gauge",
          "description": "Age at which to autovacuum a table to prevent transaction ID wraparound.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_max_workers": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously running autovacuum worker processes.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_multixact_freeze_max_age": {
          "type": "gauge",
          "description": "Multixact age at which to autovacuum a table to prevent multixact wraparound.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_naptime_seconds": {
          "type": "gauge",
          "description": "Time to sleep between autovacuum runs. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_vacuum_cost_delay_seconds": {
          "type": "gauge",
          "description": "Vacuum cost delay in milliseconds, for autovacuum. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_vacuum_cost_limit": {
          "type": "gauge",
          "description": "Vacuum cost amount available before napping, for autovacuum.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_vacuum_scale_factor": {
          "type": "gauge",
          "description": "Number of tuple updates or deletes prior to vacuum as a fraction of reltuples.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_vacuum_threshold": {
          "type": "gauge",
          "description": "Minimum number of tuple updates or deletes prior to vacuum.",
          "group": null,
          "default": false
        },
        "pg_settings_autovacuum_work_mem_bytes": {
          "type": "gauge",
          "description": "Sets the maximum memory to be used by each autovacuum worker process. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_backend_flush_after_bytes": {
          "type": "gauge",
          "description": "Number of pages after which previously performed writes are flushed to disk. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_bgwriter_delay_seconds": {
          "type": "gauge",
          "description": "Background writer sleep time between rounds. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_bgwriter_flush_after_bytes": {
          "type": "gauge",
          "description": "Number of pages after which previously performed writes are flushed to disk. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_bgwriter_lru_maxpages": {
          "type": "gauge",
          "description": "Background writer maximum number of LRU pages to flush per round.",
          "group": null,
          "default": false
        },
        "pg_settings_bgwriter_lru_multiplier": {
          "type": "gauge",
          "description": "Multiple of the average buffer usage to free per round.",
          "group": null,
          "default": false
        },
        "pg_settings_block_size": {
          "type": "gauge",
          "description": "Shows the size of a disk block.",
          "group": null,
          "default": false
        },
        "pg_settings_bonjour": {
          "type": "gauge",
          "description": "Enables advertising the server via Bonjour.",
          "group": null,
          "default": false
        },
        "pg_settings_check_function_bodies": {
          "type": "gauge",
          "description": "Check function bodies during CREATE FUNCTION.",
          "group": null,
          "default": false
        },
        "pg_settings_checkpoint_completion_target": {
          "type": "gauge",
          "description": "Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval.",
          "group": null,
          "default": false
        },
        "pg_settings_checkpoint_flush_after_bytes": {
          "type": "gauge",
          "description": "Number of pages after which previously performed writes are flushed to disk. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_checkpoint_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum time between automatic WAL checkpoints. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_checkpoint_warning_seconds": {
          "type": "gauge",
          "description": "Enables warnings if checkpoint segments are filled more frequently than this. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_commit_delay": {
          "type": "gauge",
          "description": "Sets the delay in microseconds between transaction commit and flushing WAL to disk.",
          "group": null,
          "default": false
        },
        "pg_settings_commit_siblings": {
          "type": "gauge",
          "description": "Sets the minimum concurrent open transactions before performing commit_delay.",
          "group": null,
          "default": false
        },
        "pg_settings_cpu_index_tuple_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of processing each index entry during an index scan.",
          "group": null,
          "default": false
        },
        "pg_settings_cpu_operator_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of processing each operator or function call.",
          "group": null,
          "default": false
        },
        "pg_settings_cpu_tuple_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of processing each tuple (row).",
          "group": null,
          "default": false
        },
        "pg_settings_cursor_tuple_fraction": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the fraction of a cursor's rows that will be retrieved.",
          "group": null,
          "default": false
        },
        "pg_settings_data_checksums": {
          "type": "gauge",
          "description": "Shows whether data checksums are turned on for this cluster.",
          "group": null,
          "default": false
        },
        "pg_settings_db_user_namespace": {
          "type": "gauge",
          "description": "Enables per-database user names.",
          "group": null,
          "default": false
        },
        "pg_settings_deadlock_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the time to wait on a lock before checking for deadlock. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_debug_assertions": {
          "type": "gauge",
          "description": "Shows whether the running server has assertion checks enabled.",
          "group": null,
          "default": false
        },
        "pg_settings_debug_pretty_print": {
          "type": "gauge",
          "description": "Indents parse and plan tree displays.",
          "group": null,
          "default": false
        },
        "pg_settings_debug_print_parse": {
          "type": "gauge",
          "description": "Logs each query's parse tree.",
          "group": null,
          "default": false
        },
        "pg_settings_debug_print_plan": {
          "type": "gauge",
          "description": "Logs each query's execution plan.",
          "group": null,
          "default": false
        },
        "pg_settings_debug_print_rewritten": {
          "type": "gauge",
          "description": "Logs each query's rewritten parse tree.",
          "group": null,
          "default": false
        },
        "pg_settings_default_statistics_target": {
          "type": "gauge",
          "description": "Sets the default statistics target.",
          "group": null,
          "default": false
        },
        "pg_settings_default_transaction_deferrable": {
          "type": "gauge",
          "description": "Sets the default deferrable status of new transactions.",
          "group": null,
          "default": false
        },
        "pg_settings_default_transaction_read_only": {
          "type": "gauge",
          "description": "Sets the default read-only status of new transactions.",
          "group": null,
          "default": false
        },
        "pg_settings_default_with_oids": {
          "type": "gauge",
          "description": "Create new tables with OIDs by default.",
          "group": null,
          "default": false
        },
        "pg_settings_effective_cache_size_bytes": {
          "type": "gauge",
          "description": "Sets the planner's assumption about the size of the data cache. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_effective_io_concurrency": {
          "type": "gauge",
          "description": "Number of simultaneous requests that can be handled efficiently by the disk subsystem.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_bitmapscan": {
          "type": "gauge",
          "description": "Enables the planner's use of bitmap-scan plans.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_hashagg": {
          "type": "gauge",
          "description": "Enables the planner's use of hashed aggregation plans.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_hashjoin": {
          "type": "gauge",
          "description": "Enables the planner's use of hash join plans.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_indexonlyscan": {
          "type": "gauge",
          "description": "Enables the planner's use of index-only-scan plans.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_indexscan": {
          "type": "gauge",
          "description": "Enables the planner's use of index-scan plans.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_material": {
          "type": "gauge",
          "description": "Enables the planner's use of materialization.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_mergejoin": {
          "type": "gauge",
          "description": "Enables the planner's use of merge join plans.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_nestloop": {
          "type": "gauge",
          "description": "Enables the planner's use of nested-loop join plans.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_seqscan": {
          "type": "gauge",
          "description": "Enables the planner's use of sequential-scan plans.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_sort": {
          "type": "gauge",
          "description": "Enables the planner's use of explicit sort steps.",
          "group": null,
          "default": false
        },
        "pg_settings_enable_tidscan": {
          "type": "gauge",
          "description": "Enables the planner's use of TID scan plans.",
          "group": null,
          "default": false
        },
        "pg_settings_escape_string_warning": {
          "type": "gauge",
          "description": "Warn about backslash escapes in ordinary string literals.",
          "group": null,
          "default": false
        },
        "pg_settings_exit_on_error": {
          "type": "gauge",
          "description": "Terminate session on any error.",
          "group": null,
          "default": false
        },
        "pg_settings_extra_float_digits": {
          "type": "gauge",
          "description": "Sets the number of digits displayed for floating-point values.",
          "group": null,
          "default": false
        },
        "pg_settings_from_collapse_limit": {
          "type": "gauge",
          "description": "Sets the FROM-list size beyond which subqueries are not collapsed.",
          "group": null,
          "default": false
        },
        "pg_settings_fsync": {
          "type": "gauge",
          "description": "Forces synchronization of updates to disk.",
          "group": null,
          "default": false
        },
        "pg_settings_full_page_writes": {
          "type": "gauge",
          "description": "Writes full pages to WAL when first modified after a checkpoint.",
          "group": null,
          "default": false
        },
        "pg_settings_geqo": {
          "type": "gauge",
          "description": "Enables genetic query optimization.",
          "group": null,
          "default": false
        },
        "pg_settings_geqo_effort": {
          "type": "gauge",
          "description": "GEQO: effort is used to set the default for other GEQO parameters.",
          "group": null,
          "default": false
        },
        "pg_settings_geqo_generations": {
          "type": "gauge",
          "description": "GEQO: number of iterations of the algorithm.",
          "group": null,
          "default": false
        },
        "pg_settings_geqo_pool_size": {
          "type": "gauge",
          "description": "GEQO: number of individuals in the population.",
          "group": null,
          "default": false
        },
        "pg_settings_geqo_seed": {
          "type": "gauge",
          "description": "GEQO: seed for random path selection.",
          "group": null,
          "default": false
        },
        "pg_settings_geqo_selection_bias": {
          "type": "gauge",
          "description": "GEQO: selective pressure within the population.",
          "group": null,
          "default": false
        },
        "pg_settings_geqo_threshold": {
          "type": "gauge",
          "description": "Sets the threshold of FROM items beyond which GEQO is used.",
          "group": null,
          "default": false
        },
        "pg_settings_gin_fuzzy_search_limit": {
          "type": "gauge",
          "description": "Sets the maximum allowed result for exact search by GIN.",
          "group": null,
          "default": false
        },
        "pg_settings_gin_pending_list_limit_bytes": {
          "type": "gauge",
          "description": "Sets the maximum size of the pending list for GIN index. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_hot_standby": {
          "type": "gauge",
          "description": "Allows connections and queries during recovery.",
          "group": null,
          "default": false
        },
        "pg_settings_hot_standby_feedback": {
          "type": "gauge",
          "description": "Allows feedback from a hot standby to the primary that will avoid query conflicts.",
          "group": null,
          "default": false
        },
        "pg_settings_idle_in_transaction_session_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum allowed duration of any idling transaction. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_ignore_checksum_failure": {
          "type": "gauge",
          "description": "Continues processing after a checksum failure.",
          "group": null,
          "default": false
        },
        "pg_settings_ignore_system_indexes": {
          "type": "gauge",
          "description": "Disables reading from system indexes.",
          "group": null,
          "default": false
        },
        "pg_settings_integer_datetimes": {
          "type": "gauge",
          "description": "Datetimes are integer based.",
          "group": null,
          "default": false
        },
        "pg_settings_join_collapse_limit": {
          "type": "gauge",
          "description": "Sets the FROM-list size beyond which JOIN constructs are not flattened.",
          "group": null,
          "default": false
        },
        "pg_settings_krb_caseins_users": {
          "type": "gauge",
          "description": "Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive.",
          "group": null,
          "default": false
        },
        "pg_settings_lo_compat_privileges": {
          "type": "gauge",
          "description": "Enables backward compatibility mode for privilege checks on large objects.",
          "group": null,
          "default": false
        },
        "pg_settings_lock_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum allowed duration of any wait for a lock. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_log_autovacuum_min_duration_seconds": {
          "type": "gauge",
          "description": "Sets the minimum execution time above which autovacuum actions will be logged. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_log_checkpoints": {
          "type": "gauge",
          "description": "Logs each checkpoint.",
          "group": null,
          "default": false
        },
        "pg_settings_log_connections": {
          "type": "gauge",
          "description": "Logs each successful connection.",
          "group": null,
          "default": false
        },
        "pg_settings_log_disconnections": {
          "type": "gauge",
          "description": "Logs end of a session, including duration.",
          "group": null,
          "default": false
        },
        "pg_settings_log_duration": {
          "type": "gauge",
          "description": "Logs the duration of each completed SQL statement.",
          "group": null,
          "default": false
        },
        "pg_settings_log_executor_stats": {
          "type": "gauge",
          "description": "Writes executor performance statistics to the server log.",
          "group": null,
          "default": false
        },
        "pg_settings_log_file_mode": {
          "type": "gauge",
          "description": "Sets the file permissions for log files.",
          "group": null,
          "default": false
        },
        "pg_settings_log_hostname": {
          "type": "gauge",
          "description": "Logs the host name in the connection logs.",
          "group": null,
          "default": false
        },
        "pg_settings_log_lock_waits": {
          "type": "gauge",
          "description": "Logs long lock waits.",
          "group": null,
          "default": false
        },
        "pg_settings_log_min_duration_statement_seconds": {
          "type": "gauge",
          "description": "Sets the minimum execution time above which statements will be logged. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_log_parser_stats": {
          "type": "gauge",
          "description": "Writes parser performance statistics to the server log.",
          "group": null,
          "default": false
        },
        "pg_settings_log_planner_stats": {
          "type": "gauge",
          "description": "Writes planner performance statistics to the server log.",
          "group": null,
          "default": false
        },
        "pg_settings_log_replication_commands": {
          "type": "gauge",
          "description": "Logs each replication command.",
          "group": null,
          "default": false
        },
        "pg_settings_log_rotation_age_seconds": {
          "type": "gauge",
          "description": "Automatic log file rotation will occur after N minutes. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_log_rotation_size_bytes": {
          "type": "gauge",
          "description": "Automatic log file rotation will occur after N kilobytes. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_log_statement_stats": {
          "type": "gauge",
          "description": "Writes cumulative performance statistics to the server log.",
          "group": null,
          "default": false
        },
        "pg_settings_log_temp_files_bytes": {
          "type": "gauge",
          "description": "Log the use of temporary files larger than this number of kilobytes. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_log_truncate_on_rotation": {
          "type": "gauge",
          "description": "Truncate existing log files of same name during log rotation.",
          "group": null,
          "default": false
        },
        "pg_settings_logging_collector": {
          "type": "gauge",
          "description": "Start a subprocess to capture stderr output and/or csvlogs into log files.",
          "group": null,
          "default": false
        },
        "pg_settings_maintenance_work_mem_bytes": {
          "type": "gauge",
          "description": "Sets the maximum memory to be used for maintenance operations. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_max_connections": {
          "type": "gauge",
          "description": "Sets the maximum number of concurrent connections.",
          "group": null,
          "default": false
        },
        "pg_settings_max_files_per_process": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously open files for each server process.",
          "group": null,
          "default": false
        },
        "pg_settings_max_function_args": {
          "type": "gauge",
          "description": "Shows the maximum number of function arguments.",
          "group": null,
          "default": false
        },
        "pg_settings_max_identifier_length": {
          "type": "gauge",
          "description": "Shows the maximum identifier length.",
          "group": null,
          "default": false
        },
        "pg_settings_max_index_keys": {
          "type": "gauge",
          "description": "Shows the maximum number of index keys.",
          "group": null,
          "default": false
        },
        "pg_settings_max_locks_per_transaction": {
          "type": "gauge",
          "description": "Sets the maximum number of locks per transaction.",
          "group": null,
          "default": false
        },
        "pg_settings_max_parallel_workers_per_gather": {
          "type": "gauge",
          "description": "Sets the maximum number of parallel processes per executor node.",
          "group": null,
          "default": false
        },
        "pg_settings_max_pred_locks_per_transaction": {
          "type": "gauge",
          "description": "Sets the maximum number of predicate locks per transaction.",
          "group": null,
          "default": false
        },
        "pg_settings_max_prepared_transactions": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously prepared transactions.",
          "group": null,
          "default": false
        },
        "pg_settings_max_replication_slots": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously defined replication slots.",
          "group": null,
          "default": false
        },
        "pg_settings_max_stack_depth_bytes": {
          "type": "gauge",
          "description": "Sets the maximum stack depth, in kilobytes. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_max_standby_archive_delay_seconds": {
          "type": "gauge",
          "description": "Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_max_standby_streaming_delay_seconds": {
          "type": "gauge",
          "description": "Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_max_wal_senders": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously running WAL sender processes.",
          "group": null,
          "default": false
        },
        "pg_settings_max_wal_size_bytes": {
          "type": "gauge",
          "description": "Sets the WAL size that triggers a checkpoint. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_max_worker_processes": {
          "type": "gauge",
          "description": "Maximum number of concurrent worker processes.",
          "group": null,
          "default": false
        },
        "pg_settings_min_parallel_relation_size_bytes": {
          "type": "gauge",
          "description": "Sets the minimum size of relations to be considered for parallel scan. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_min_wal_size_bytes": {
          "type": "gauge",
          "description": "Sets the minimum size to shrink the WAL to. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_old_snapshot_threshold_seconds": {
          "type": "gauge",
          "description": "Time before a snapshot is too old to read pages changed after the snapshot was taken. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_operator_precedence_warning": {
          "type": "gauge",
          "description": "Emit a warning for constructs that changed meaning since PostgreSQL 9.4.",
          "group": null,
          "default": false
        },
        "pg_settings_parallel_setup_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of starting up worker processes for parallel query.",
          "group": null,
          "default": false
        },
        "pg_settings_parallel_tuple_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of passing each tuple (row) from worker to master backend.",
          "group": null,
          "default": false
        },
        "pg_settings_password_encryption": {
          "type": "gauge",
          "description": "Encrypt passwords.",
          "group": null,
          "default": false
        },
        "pg_settings_port": {
          "type": "gauge",
          "description": "Sets the TCP port the server listens on.",
          "group": null,
          "default": false
        },
        "pg_settings_post_auth_delay_seconds": {
          "type": "gauge",
          "description": "Waits N seconds on connection startup after authentication. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_pre_auth_delay_seconds": {
          "type": "gauge",
          "description": "Waits N seconds on connection startup before authentication. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_quote_all_identifiers": {
          "type": "gauge",
          "description": "When generating SQL fragments, quote all identifiers.",
          "group": null,
          "default": false
        },
        "pg_settings_random_page_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of a nonsequentially fetched disk page.",
          "group": null,
          "default": false
        },
        "pg_settings_replacement_sort_tuples": {
          "type": "gauge",
          "description": "Sets the maximum number of tuples to be sorted using replacement selection.",
          "group": null,
          "default": false
        },
        "pg_settings_restart_after_crash": {
          "type": "gauge",
          "description": "Reinitialize server after backend crash.",
          "group": null,
          "default": false
        },
        "pg_settings_row_security": {
          "type": "gauge",
          "description": "Enable row security.",
          "group": null,
          "default": false
        },
        "pg_settings_segment_size_bytes": {
          "type": "gauge",
          "description": "Shows the number of pages per disk file. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_seq_page_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of a sequentially fetched disk page.",
          "group": null,
          "default": false
        },
        "pg_settings_server_version_num": {
          "type": "gauge",
          "description": "Shows the server version as an integer.",
          "group": null,
          "default": false
        },
        "pg_settings_shared_buffers_bytes": {
          "type": "gauge",
          "description": "Sets the number of shared memory buffers used by the server. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_sql_inheritance": {
          "type": "gauge",
          "description": "Causes subtables to be included by default in various commands.",
          "group": null,
          "default": false
        },
        "pg_settings_ssl": {
          "type": "gauge",
          "description": "Enables SSL connections.",
          "group": null,
          "default": false
        },
        "pg_settings_ssl_prefer_server_ciphers": {
          "type": "gauge",
          "description": "Give priority to server ciphersuite order.",
          "group": null,
          "default": false
        },
        "pg_settings_standard_conforming_strings": {
          "type": "gauge",
          "description": "Causes '...' strings to treat backslashes literally.",
          "group": null,
          "default": false
        },
        "pg_settings_statement_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum allowed duration of any statement. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_superuser_reserved_connections": {
          "type": "gauge",
          "description": "Sets the number of connection slots reserved for superusers.",
          "group": null,
          "default": false
        },
        "pg_settings_synchronize_seqscans": {
          "type": "gauge",
          "description": "Enable synchronized sequential scans.",
          "group": null,
          "default": false
        },
        "pg_settings_syslog_sequence_numbers": {
          "type": "gauge",
          "description": "Add sequence number to syslog messages to avoid duplicate suppression.",
          "group": null,
          "default": false
        },
        "pg_settings_syslog_split_messages": {
          "type": "gauge",
          "description": "Split messages sent to syslog by lines and to fit into 1024 bytes.",
          "group": null,
          "default": false
        },
        "pg_settings_tcp_keepalives_count": {
          "type": "gauge",
          "description": "Maximum number of TCP keepalive retransmits.",
          "group": null,
          "default": false
        },
        "pg_settings_tcp_keepalives_idle_seconds": {
          "type": "gauge",
          "description": "Time between issuing TCP keepalives. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_tcp_keepalives_interval_seconds": {
          "type": "gauge",
          "description": "Time between TCP keepalive retransmits. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_temp_buffers_bytes": {
          "type": "gauge",
          "description": "Sets the maximum number of temporary buffers used by each session. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_temp_file_limit_bytes": {
          "type": "gauge",
          "description": "Limits the total size of all temporary files used by each process. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_trace_notify": {
          "type": "gauge",
          "description": "Generates debugging output for LISTEN and NOTIFY.",
          "group": null,
          "default": false
        },
        "pg_settings_trace_sort": {
          "type": "gauge",
          "description": "Emit information about resource usage in sorting.",
          "group": null,
          "default": false
        },
        "pg_settings_track_activities": {
          "type": "gauge",
          "description": "Collects information about executing commands.",
          "group": null,
          "default": false
        },
        "pg_settings_track_activity_query_size": {
          "type": "gauge",
          "description": "Sets the size reserved for pg_stat_activity.query, in bytes.",
          "group": null,
          "default": false
        },
        "pg_settings_track_commit_timestamp": {
          "type": "gauge",
          "description": "Collects transaction commit time.",
          "group": null,
          "default": false
        },
        "pg_settings_track_counts": {
          "type": "gauge",
          "description": "Collects statistics on database activity.",
          "group": null,
          "default": false
        },
        "pg_settings_track_io_timing": {
          "type": "gauge",
          "description": "Collects timing statistics for database I/O activity.",
          "group": null,
          "default": false
        },
        "pg_settings_transaction_deferrable": {
          "type": "gauge",
          "description": "Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures.",
          "group": null,
          "default": false
        },
        "pg_settings_transaction_read_only": {
          "type": "gauge",
          "description": "Sets the current transaction's read-only status.",
          "group": null,
          "default": false
        },
        "pg_settings_transform_null_equals": {
          "type": "gauge",
          "description": "Treats \"expr=NULL\" as \"expr IS NULL\".",
          "group": null,
          "default": false
        },
        "pg_settings_unix_socket_permissions": {
          "type": "gauge",
          "description": "Sets the access permissions of the Unix-domain socket.",
          "group": null,
          "default": false
        },
        "pg_settings_update_process_title": {
          "type": "gauge",
          "description": "Updates the process title to show the active SQL command.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_cost_delay_seconds": {
          "type": "gauge",
          "description": "Vacuum cost delay in milliseconds. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_cost_limit": {
          "type": "gauge",
          "description": "Vacuum cost amount available before napping.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_cost_page_dirty": {
          "type": "gauge",
          "description": "Vacuum cost for a page dirtied by vacuum.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_cost_page_hit": {
          "type": "gauge",
          "description": "Vacuum cost for a page found in the buffer cache.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_cost_page_miss": {
          "type": "gauge",
          "description": "Vacuum cost for a page not found in the buffer cache.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_defer_cleanup_age": {
          "type": "gauge",
          "description": "Number of transactions by which VACUUM and HOT cleanup should be deferred, if any.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_freeze_min_age": {
          "type": "gauge",
          "description": "Minimum age at which VACUUM should freeze a table row.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_freeze_table_age": {
          "type": "gauge",
          "description": "Age at which VACUUM should scan whole table to freeze tuples.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_multixact_freeze_min_age": {
          "type": "gauge",
          "description": "Minimum age at which VACUUM should freeze a MultiXactId in a table row.",
          "group": null,
          "default": false
        },
        "pg_settings_vacuum_multixact_freeze_table_age": {
          "type": "gauge",
          "description": "Multixact age at which VACUUM should scan whole table to freeze tuples.",
          "group": null,
          "default": false
        },
        "pg_settings_wal_block_size": {
          "type": "gauge",
          "description": "Shows the block size in the write ahead log.",
          "group": null,
          "default": false
        },
        "pg_settings_wal_buffers_bytes": {
          "type": "gauge",
          "description": "Sets the number of disk-page buffers in shared memory for WAL. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_wal_compression": {
          "type": "gauge",
          "description": "Compresses full-page writes written in WAL file.",
          "group": null,
          "default": false
        },
        "pg_settings_wal_keep_segments": {
          "type": "gauge",
          "description": "Sets the number of WAL files held for standby servers.",
          "group": null,
          "default": false
        },
        "pg_settings_wal_log_hints": {
          "type": "gauge",
          "description": "Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modifications.",
          "group": null,
          "default": false
        },
        "pg_settings_wal_receiver_status_interval_seconds": {
          "type": "gauge",
          "description": "Sets the maximum interval between WAL receiver status reports to the primary. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_wal_receiver_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum wait time to receive data from the primary. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_wal_retrieve_retry_interval_seconds": {
          "type": "gauge",
          "description": "Sets the time to wait before retrying to retrieve WAL after a failed attempt. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_wal_segment_size_bytes": {
          "type": "gauge",
          "description": "Shows the number of pages per write ahead log segment. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_wal_sender_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum time to wait for WAL replication. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_wal_writer_delay_seconds": {
          "type": "gauge",
          "description": "Time between WAL flushes performed in the WAL writer. [Units converted to seconds.]",
          "group": null,
          "default": false
        },
        "pg_settings_wal_writer_flush_after_bytes": {
          "type": "gauge",
          "description": "Amount of WAL written out by WAL writer that triggers a flush. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_work_mem_bytes": {
          "type": "gauge",
          "description": "Sets the maximum memory to be used for query workspaces. [Units converted to bytes.]",
          "group": null,
          "default": false
        },
        "pg_settings_zero_damaged_pages": {
          "type": "gauge",
          "description": "Continues processing past damaged page headers.",
          "group": null,
          "default": false
        },
        "pg_slow_queries": {
          "type": "gauge",
          "description": "Current number of slow queries",
          "group": null,
          "default": false
        },
        "pg_stat_activity_count": {
          "type": "gauge",
          "description": "Number of connections in this state",
          "group": null,
          "default": true
        },
        "pg_stat_activity_max_tx_duration": {
          "type": "gauge",
          "description": "Max duration in seconds any active transaction has been running",
          "group": null,
          "default": true
        },
        "pg_stat_bgwriter_buffers_alloc": {
          "type": "cumulative",
          "description": "Number of buffers allocated",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_buffers_backend": {
          "type": "cumulative",
          "description": "Number of buffers written directly by a backend",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_buffers_backend_fsync": {
          "type": "cumulative",
          "description": "Number of times a backend had to execute its own fsync call (normally the background writer handles those even when the backend does its own write)",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_buffers_checkpoint": {
          "type": "cumulative",
          "description": "Number of buffers written during checkpoints",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_buffers_clean": {
          "type": "cumulative",
          "description": "Number of buffers written by the background writer",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_checkpoint_sync_time": {
          "type": "cumulative",
          "description": "Total amount of time that has been spent in the portion of checkpoint processing where files are synchronized to disk, in milliseconds",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_checkpoint_write_time": {
          "type": "cumulative",
          "description": "Total amount of time that has been spent in the portion of checkpoint processing where files are written to disk, in milliseconds",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_checkpoints_req": {
          "type": "cumulative",
          "description": "Number of requested checkpoints that have been performed",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_checkpoints_timed": {
          "type": "cumulative",
          "description": "Number of scheduled checkpoints that have been performed",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_maxwritten_clean": {
          "type": "cumulative",
          "description": "Number of times the background writer stopped a cleaning scan because it had written too many buffers",
          "group": null,
          "default": false
        },
        "pg_stat_bgwriter_stats_reset": {
          "type": "cumulative",
          "description": "Time at which these statistics were last reset",
          "group": null,
          "default": false
        },
        "pg_stat_database_blk_read_time": {
          "type": "cumulative",
          "description": "Time spent reading data file blocks by backends in this database, in milliseconds",
          "group": null,
          "default": true
        },
        "pg_stat_database_blk_write_time": {
          "type": "cumulative",
          "description": "Time spent writing data file blocks by backends in this database, in milliseconds",
          "group": null,
          "default": true
        },
        "pg_stat_database_blks_hit": {
          "type": "cumulative",
          "description": "Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)",
          "group": null,
          "default": true
        },
        "pg_stat_database_blks_read": {
          "type": "cumulative",
          "description": "Number of disk blocks read in this database",
          "group": null,
          "default": true
        },
        "pg_stat_database_conflicts": {
          "type": "cumulative",
          "description": "Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see pg_stat_database_conflicts for details.)",
          "group": null,
          "default": false
        },
        "pg_stat_database_conflicts_confl_bufferpin": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to pinned buffers",
          "group": null,
          "default": true
        },
        "pg_stat_database_conflicts_confl_deadlock": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to deadlocks",
          "group": null,
          "default": true
        },
        "pg_stat_database_conflicts_confl_lock": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to lock timeouts",
          "group": null,
          "default": true
        },
        "pg_stat_database_conflicts_confl_snapshot": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to old snapshots",
          "group": null,
          "default": true
        },
        "pg_stat_database_conflicts_confl_tablespace": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to dropped tablespaces",
          "group": null,
          "default": true
        },
        "pg_stat_database_deadlocks": {
          "type": "cumulative",
          "description": "Number of deadlocks detected in this database",
          "group": null,
          "default": false
        },
        "pg_stat_database_numbackends": {
          "type": "gauge",
          "description": "Number of backends currently connected to this database. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.",
          "group": null,
          "default": true
        },
        "pg_stat_database_stats_reset": {
          "type": "cumulative",
          "description": "Time at which these statistics were last reset",
          "group": null,
          "default": false
        },
        "pg_stat_database_temp_bytes": {
          "type": "cumulative",
          "description": "Total amount of data written to temporary files by queries in this database. All temporary files are counted, regardless of why the temporary file was created, and regardless of the log_temp_files setting.",
          "group": null,
          "default": true
        },
        "pg_stat_database_temp_files": {
          "type": "cumulative",
          "description": "Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (e.g., sorting or hashing), and regardless of the log_temp_files setting.",
          "group": null,
          "default": true
        },
        "pg_stat_database_tup_deleted": {
          "type": "cumulative",
          "description": "Number of rows deleted by queries in this database",
          "group": null,
          "default": true
        },
        "pg_stat_database_tup_fetched": {
          "type": "cumulative",
          "description": "Number of rows fetched by queries in this database",
          "group": null,
          "default": true
        },
        "pg_stat_database_tup_inserted": {
          "type": "cumulative",
          "description": "Number of rows inserted by queries in this database",
          "group": null,
          "default": true
        },
        "pg_stat_database_tup_returned": {
          "type": "cumulative",
          "description": "Number of rows returned by queries in this database",
          "group": null,
          "default": true
        },
        "pg_stat_database_tup_updated": {
          "type": "cumulative",
          "description": "Number of rows updated by queries in this database",
          "group": null,
          "default": true
        },
        "pg_stat_database_xact_commit": {
          "type": "cumulative",
          "description": "Number of transactions in this database that have been committed",
          "group": null,
          "default": true
        },
        "pg_stat_database_xact_rollback": {
          "type": "cumulative",
          "description": "Number of transactions in this database that have been rolled back",
          "group": null,
          "default": true
        },
        "pg_static": {
          "type": "gauge",
          "description": "Version string as reported by postgres",
          "group": null,
          "default": false
        },
        "pg_stuck_idle_in_transaction_queries": {
          "type": "gauge",
          "description": "Current number of queries that are stuck being idle in transactions",
          "group": null,
          "default": false
        },
        "pg_total_relation_size_bytes": {
          "type": "gauge",
          "description": "Total disk space usage for the specified table and associated indexes",
          "group": null,
          "default": true
        },
        "pg_up": {
          "type": "gauge",
          "description": "Whether the last scrape of metrics from PostgreSQL was able to connect to the server (1 for yes, 0 for no).",
          "group": null,
          "default": false
        },
        "pg_vacuum_age_in_seconds": {
          "type": "gauge",
          "description": "The current maximum VACUUM query age in seconds",
          "group": null,
          "default": false
        },
        "pg_vacuum_analyze_age_in_seconds": {
          "type": "gauge",
          "description": "The current maximum VACUUM ANALYZE query age in seconds",
          "group": null,
          "default": false
        },
        "pg_vacuum_analyze_queries": {
          "type": "gauge",
          "description": "The current number of VACUUM ANALYZE queries",
          "group": null,
          "default": false
        },
        "pg_vacuum_queries": {
          "type": "gauge",
          "description": "The current number of VACUUM queries",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/prometheus/postgres",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/prometheus",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus server's own internal\ncollector](https://prometheus.io/docs/prometheus/latest/getting_started/#configuring-prometheus-to-monitor-itself)\nmetrics from a Prometheus exporter and sends them to SignalFx.  It is a\nwrapper around the [prometheus-exporter](./prometheus-exporter.md) monitor\nthat provides a restricted but expandable set of metrics.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "net_conntrack_dialer_conn_attempted_total",
            "net_conntrack_dialer_conn_closed_total",
            "net_conntrack_dialer_conn_established_total",
            "net_conntrack_dialer_conn_failed_total",
            "net_conntrack_listener_conn_accepted_total",
            "net_conntrack_listener_conn_closed_total",
            "prometheus_api_remote_read_queries",
            "prometheus_build_info",
            "prometheus_config_last_reload_success_timestamp_seconds",
            "prometheus_config_last_reload_successful",
            "prometheus_engine_queries",
            "prometheus_engine_queries_concurrent_max",
            "prometheus_engine_query_duration_seconds",
            "prometheus_engine_query_duration_seconds_count",
            "prometheus_http_request_duration_seconds",
            "prometheus_http_request_duration_seconds_bucket",
            "prometheus_http_request_duration_seconds_count",
            "prometheus_http_response_size_bytes",
            "prometheus_http_response_size_bytes_bucket",
            "prometheus_http_response_size_bytes_count",
            "prometheus_notifications_alertmanagers_discovered",
            "prometheus_notifications_dropped_total",
            "prometheus_notifications_queue_capacity",
            "prometheus_notifications_queue_length",
            "prometheus_rule_evaluation_duration_seconds",
            "prometheus_rule_evaluation_duration_seconds_count",
            "prometheus_rule_evaluation_failures_total",
            "prometheus_rule_group_duration_seconds",
            "prometheus_rule_group_duration_seconds_count",
            "prometheus_rule_group_interval_seconds",
            "prometheus_rule_group_iterations_missed_total",
            "prometheus_rule_group_iterations_total",
            "prometheus_rule_group_last_duration_seconds",
            "prometheus_sd_azure_refresh_duration_seconds",
            "prometheus_sd_azure_refresh_duration_seconds_count",
            "prometheus_sd_azure_refresh_failures_total",
            "prometheus_sd_configs_failed_total",
            "prometheus_sd_consul_rpc_duration_seconds",
            "prometheus_sd_consul_rpc_duration_seconds_count",
            "prometheus_sd_consul_rpc_failures_total",
            "prometheus_sd_discovered_targets",
            "prometheus_sd_dns_lookup_failures_total",
            "prometheus_sd_dns_lookups_total",
            "prometheus_sd_ec2_refresh_duration_seconds",
            "prometheus_sd_ec2_refresh_duration_seconds_count",
            "prometheus_sd_ec2_refresh_failures_total",
            "prometheus_sd_file_read_errors_total",
            "prometheus_sd_file_scan_duration_seconds",
            "prometheus_sd_file_scan_duration_seconds_count",
            "prometheus_sd_gce_refresh_duration",
            "prometheus_sd_gce_refresh_duration_count",
            "prometheus_sd_gce_refresh_failures_total",
            "prometheus_sd_kubernetes_cache_last_resource_version",
            "prometheus_sd_kubernetes_cache_list_duration_seconds",
            "prometheus_sd_kubernetes_cache_list_duration_seconds_count",
            "prometheus_sd_kubernetes_cache_list_items",
            "prometheus_sd_kubernetes_cache_list_items_count",
            "prometheus_sd_kubernetes_cache_list_total",
            "prometheus_sd_kubernetes_cache_short_watches_total",
            "prometheus_sd_kubernetes_cache_watch_duration_seconds",
            "prometheus_sd_kubernetes_cache_watch_duration_seconds_count",
            "prometheus_sd_kubernetes_cache_watch_events",
            "prometheus_sd_kubernetes_cache_watch_events_count",
            "prometheus_sd_kubernetes_cache_watches_total",
            "prometheus_sd_kubernetes_events_total",
            "prometheus_sd_marathon_refresh_duration_seconds",
            "prometheus_sd_marathon_refresh_duration_seconds_count",
            "prometheus_sd_marathon_refresh_failures_total",
            "prometheus_sd_openstack_refresh_duration_seconds",
            "prometheus_sd_openstack_refresh_duration_seconds_count",
            "prometheus_sd_openstack_refresh_failures_total",
            "prometheus_sd_received_updates_total",
            "prometheus_sd_triton_refresh_duration_seconds",
            "prometheus_sd_triton_refresh_duration_seconds_count",
            "prometheus_sd_triton_refresh_failures_total",
            "prometheus_sd_updates_delayed_total",
            "prometheus_sd_updates_total",
            "prometheus_target_interval_length_seconds",
            "prometheus_target_interval_length_seconds_count",
            "prometheus_target_scrape_pool_sync_total",
            "prometheus_target_scrapes_exceeded_sample_limit_total",
            "prometheus_target_scrapes_sample_duplicate_timestamp_total",
            "prometheus_target_scrapes_sample_out_of_bounds_total",
            "prometheus_target_scrapes_sample_out_of_order_total",
            "prometheus_target_sync_length_seconds",
            "prometheus_target_sync_length_seconds_count",
            "prometheus_treecache_watcher_goroutines",
            "prometheus_treecache_zookeeper_failures_total",
            "prometheus_tsdb_blocks_loaded",
            "prometheus_tsdb_checkpoint_creations_failed_total",
            "prometheus_tsdb_checkpoint_creations_total",
            "prometheus_tsdb_checkpoint_deletions_failed_total",
            "prometheus_tsdb_checkpoint_deletions_total",
            "prometheus_tsdb_compaction_chunk_range_seconds",
            "prometheus_tsdb_compaction_chunk_range_seconds_bucket",
            "prometheus_tsdb_compaction_chunk_range_seconds_count",
            "prometheus_tsdb_compaction_chunk_samples",
            "prometheus_tsdb_compaction_chunk_samples_bucket",
            "prometheus_tsdb_compaction_chunk_samples_count",
            "prometheus_tsdb_compaction_chunk_size_bytes",
            "prometheus_tsdb_compaction_chunk_size_bytes_bucket",
            "prometheus_tsdb_compaction_chunk_size_bytes_count",
            "prometheus_tsdb_compaction_duration_seconds",
            "prometheus_tsdb_compaction_duration_seconds_bucket",
            "prometheus_tsdb_compaction_duration_seconds_count",
            "prometheus_tsdb_compactions_failed_total",
            "prometheus_tsdb_compactions_total",
            "prometheus_tsdb_compactions_triggered_total",
            "prometheus_tsdb_head_active_appenders",
            "prometheus_tsdb_head_chunks",
            "prometheus_tsdb_head_chunks_created_total",
            "prometheus_tsdb_head_chunks_removed_total",
            "prometheus_tsdb_head_gc_duration_seconds",
            "prometheus_tsdb_head_gc_duration_seconds_count",
            "prometheus_tsdb_head_max_time",
            "prometheus_tsdb_head_min_time",
            "prometheus_tsdb_head_samples_appended_total",
            "prometheus_tsdb_head_series",
            "prometheus_tsdb_head_series_created_total",
            "prometheus_tsdb_head_series_not_found_total",
            "prometheus_tsdb_head_series_removed_total",
            "prometheus_tsdb_head_truncations_failed_total",
            "prometheus_tsdb_head_truncations_total",
            "prometheus_tsdb_lowest_timestamp",
            "prometheus_tsdb_reloads_failures_total",
            "prometheus_tsdb_reloads_total",
            "prometheus_tsdb_retention_cutoffs_failures_total",
            "prometheus_tsdb_retention_cutoffs_total",
            "prometheus_tsdb_symbol_table_size_bytes",
            "prometheus_tsdb_tombstone_cleanup_seconds",
            "prometheus_tsdb_tombstone_cleanup_seconds_bucket",
            "prometheus_tsdb_tombstone_cleanup_seconds_count",
            "prometheus_tsdb_wal_completed_pages_total",
            "prometheus_tsdb_wal_fsync_duration_seconds",
            "prometheus_tsdb_wal_fsync_duration_seconds_count",
            "prometheus_tsdb_wal_page_flushes_total",
            "prometheus_tsdb_wal_truncate_duration_seconds",
            "prometheus_tsdb_wal_truncate_duration_seconds_count",
            "prometheus_tsdb_wal_truncations_failed_total",
            "prometheus_tsdb_wal_truncations_total",
            "promhttp_metric_handler_requests_in_flight",
            "promhttp_metric_handler_requests_total"
          ]
        }
      },
      "metrics": {
        "net_conntrack_dialer_conn_attempted_total": {
          "type": "cumulative",
          "description": "Total number of connections attempted by the given dialer a given name",
          "group": null,
          "default": false
        },
        "net_conntrack_dialer_conn_closed_total": {
          "type": "cumulative",
          "description": "Total number of connections closed which originated from the dialer of a given name",
          "group": null,
          "default": false
        },
        "net_conntrack_dialer_conn_established_total": {
          "type": "cumulative",
          "description": "Total number of connections successfully established by the given dialer a given name",
          "group": null,
          "default": false
        },
        "net_conntrack_dialer_conn_failed_total": {
          "type": "cumulative",
          "description": "Total number of connections failed to dial by the dialer a given name",
          "group": null,
          "default": false
        },
        "net_conntrack_listener_conn_accepted_total": {
          "type": "cumulative",
          "description": "Total number of connections opened to the listener of a given name",
          "group": null,
          "default": false
        },
        "net_conntrack_listener_conn_closed_total": {
          "type": "cumulative",
          "description": "Total number of connections closed that were made to the listener of a given name",
          "group": null,
          "default": false
        },
        "prometheus_api_remote_read_queries": {
          "type": "gauge",
          "description": "The current number of remote read queries being executed or waiting",
          "group": null,
          "default": false
        },
        "prometheus_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by version, revision, branch, and goversion from which prometheus was built",
          "group": null,
          "default": false
        },
        "prometheus_config_last_reload_success_timestamp_seconds": {
          "type": "gauge",
          "description": "Timestamp of the last successful configuration reload",
          "group": null,
          "default": false
        },
        "prometheus_config_last_reload_successful": {
          "type": "gauge",
          "description": "Whether the last configuration reload attempt was successful",
          "group": null,
          "default": false
        },
        "prometheus_engine_queries": {
          "type": "gauge",
          "description": "The current number of queries being executed or waiting",
          "group": null,
          "default": false
        },
        "prometheus_engine_queries_concurrent_max": {
          "type": "gauge",
          "description": "The max number of concurrent queries",
          "group": null,
          "default": false
        },
        "prometheus_engine_query_duration_seconds": {
          "type": "cumulative",
          "description": "Query timings",
          "group": null,
          "default": false
        },
        "prometheus_engine_query_duration_seconds_count": {
          "type": "cumulative",
          "description": "Query timings (count)",
          "group": null,
          "default": false
        },
        "prometheus_http_request_duration_seconds": {
          "type": "cumulative",
          "description": "Histogram of latencies for HTTP requests",
          "group": null,
          "default": false
        },
        "prometheus_http_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Histogram of latencies for HTTP requests in the respective bucket",
          "group": null,
          "default": false
        },
        "prometheus_http_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Histogram of latencies for HTTP requests (count)",
          "group": null,
          "default": false
        },
        "prometheus_http_response_size_bytes": {
          "type": "cumulative",
          "description": "Histogram of response size for HTTP requests",
          "group": null,
          "default": false
        },
        "prometheus_http_response_size_bytes_bucket": {
          "type": "cumulative",
          "description": "Histogram of response size for HTTP requests in the respective bucket",
          "group": null,
          "default": false
        },
        "prometheus_http_response_size_bytes_count": {
          "type": "cumulative",
          "description": "Histogram of response size for HTTP requests",
          "group": null,
          "default": false
        },
        "prometheus_notifications_alertmanagers_discovered": {
          "type": "gauge",
          "description": "The number of alertmanagers discovered and active",
          "group": null,
          "default": false
        },
        "prometheus_notifications_dropped_total": {
          "type": "cumulative",
          "description": "Total number of alerts dropped due to errors when sending to Alertmanager",
          "group": null,
          "default": false
        },
        "prometheus_notifications_queue_capacity": {
          "type": "gauge",
          "description": "The capacity of the alert notifications queue",
          "group": null,
          "default": false
        },
        "prometheus_notifications_queue_length": {
          "type": "gauge",
          "description": "The number of alert notifications in the queue",
          "group": null,
          "default": false
        },
        "prometheus_rule_evaluation_duration_seconds": {
          "type": "cumulative",
          "description": "The duration for a rule to execute",
          "group": null,
          "default": false
        },
        "prometheus_rule_evaluation_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration for a rule to execute (count)",
          "group": null,
          "default": false
        },
        "prometheus_rule_evaluation_failures_total": {
          "type": "cumulative",
          "description": "The total number of rule evaluation failures",
          "group": null,
          "default": false
        },
        "prometheus_rule_group_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of rule group evaluations",
          "group": null,
          "default": false
        },
        "prometheus_rule_group_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of rule group evaluations (count)",
          "group": null,
          "default": false
        },
        "prometheus_rule_group_interval_seconds": {
          "type": "gauge",
          "description": "The interval of a rule group",
          "group": null,
          "default": false
        },
        "prometheus_rule_group_iterations_missed_total": {
          "type": "cumulative",
          "description": "The total number of rule group evaluations missed due to slow rule group evaluation",
          "group": null,
          "default": false
        },
        "prometheus_rule_group_iterations_total": {
          "type": "cumulative",
          "description": "The total number of scheduled rule group evaluations, whether executed or missed",
          "group": null,
          "default": false
        },
        "prometheus_rule_group_last_duration_seconds": {
          "type": "gauge",
          "description": "The duration of the last rule group evaluation",
          "group": null,
          "default": false
        },
        "prometheus_sd_azure_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a Azure-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_azure_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a Azure-SD refresh in seconds (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_azure_refresh_failures_total": {
          "type": "cumulative",
          "description": "Number of Azure-SD refresh failures",
          "group": null,
          "default": false
        },
        "prometheus_sd_configs_failed_total": {
          "type": "cumulative",
          "description": "Total number of service discovery configurations that failed to load",
          "group": null,
          "default": false
        },
        "prometheus_sd_consul_rpc_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a Consul RPC call in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_consul_rpc_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a Consul RPC call in seconds (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_consul_rpc_failures_total": {
          "type": "cumulative",
          "description": "The number of Consul RPC call failures",
          "group": null,
          "default": false
        },
        "prometheus_sd_discovered_targets": {
          "type": "gauge",
          "description": "Current number of discovered targets",
          "group": null,
          "default": false
        },
        "prometheus_sd_dns_lookup_failures_total": {
          "type": "cumulative",
          "description": "The number of DNS-SD lookup failures",
          "group": null,
          "default": false
        },
        "prometheus_sd_dns_lookups_total": {
          "type": "cumulative",
          "description": "The number of DNS-SD lookups",
          "group": null,
          "default": false
        },
        "prometheus_sd_ec2_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a EC2-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_ec2_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a EC2-SD refresh in seconds (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_ec2_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of EC2-SD scrape failures",
          "group": null,
          "default": false
        },
        "prometheus_sd_file_read_errors_total": {
          "type": "cumulative",
          "description": "The number of File-SD read errors",
          "group": null,
          "default": false
        },
        "prometheus_sd_file_scan_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of the File-SD scan in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_file_scan_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of the File-SD scan in seconds (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_gce_refresh_duration": {
          "type": "cumulative",
          "description": "The duration of a GCE-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_gce_refresh_duration_count": {
          "type": "cumulative",
          "description": "The duration of a GCE-SD refresh in seconds (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_gce_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of GCE-SD refresh failures",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_last_resource_version": {
          "type": "gauge",
          "description": "Last resource version from the Kubernetes API",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_list_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of a Kubernetes API call in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_list_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of a Kubernetes API call in seconds (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_list_items": {
          "type": "cumulative",
          "description": "Count of items in a list from the Kubernetes API",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_list_items_count": {
          "type": "cumulative",
          "description": "Count of items in a list from the Kubernetes API (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_list_total": {
          "type": "cumulative",
          "description": "Total number of list operations",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_short_watches_total": {
          "type": "cumulative",
          "description": "Total number of short watch operations",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_watch_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of watches on the Kubernetes API",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_watch_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of watches on the Kubernetes API (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_watch_events": {
          "type": "cumulative",
          "description": "Number of items in watches on the Kubernetes API",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_watch_events_count": {
          "type": "cumulative",
          "description": "Number of items in watches on the Kubernetes API (count)",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_cache_watches_total": {
          "type": "cumulative",
          "description": "Total number of watch operations",
          "group": null,
          "default": false
        },
        "prometheus_sd_kubernetes_events_total": {
          "type": "cumulative",
          "description": "The number of Kubernetes events handled",
          "group": null,
          "default": false
        },
        "prometheus_sd_marathon_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a Marathon-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_marathon_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a Marathon-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_marathon_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of Marathon-SD refresh failures",
          "group": null,
          "default": false
        },
        "prometheus_sd_openstack_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of an OpenStack-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_openstack_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of an OpenStack-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_openstack_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of OpenStack-SD scrape failures",
          "group": null,
          "default": false
        },
        "prometheus_sd_received_updates_total": {
          "type": "cumulative",
          "description": "Total number of update events received from the SD providers",
          "group": null,
          "default": false
        },
        "prometheus_sd_triton_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a Triton-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_triton_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a Triton-SD refresh in seconds",
          "group": null,
          "default": false
        },
        "prometheus_sd_triton_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of Triton-SD scrape failures",
          "group": null,
          "default": false
        },
        "prometheus_sd_updates_delayed_total": {
          "type": "cumulative",
          "description": "Total number of update events that couldn't be sent immediately",
          "group": null,
          "default": false
        },
        "prometheus_sd_updates_total": {
          "type": "cumulative",
          "description": "Total number of update events sent to the SD consumers",
          "group": null,
          "default": false
        },
        "prometheus_target_interval_length_seconds": {
          "type": "cumulative",
          "description": "Actual intervals between scrapes",
          "group": null,
          "default": false
        },
        "prometheus_target_interval_length_seconds_count": {
          "type": "cumulative",
          "description": "Actual intervals between scrapes",
          "group": null,
          "default": false
        },
        "prometheus_target_scrape_pool_sync_total": {
          "type": "cumulative",
          "description": "Total number of syncs that were executed on a scrape pool",
          "group": null,
          "default": false
        },
        "prometheus_target_scrapes_exceeded_sample_limit_total": {
          "type": "cumulative",
          "description": "Total number of scrapes that hit the sample limit and were rejected",
          "group": null,
          "default": false
        },
        "prometheus_target_scrapes_sample_duplicate_timestamp_total": {
          "type": "cumulative",
          "description": "Total number of samples rejected due to duplicate timestamps but different values",
          "group": null,
          "default": false
        },
        "prometheus_target_scrapes_sample_out_of_bounds_total": {
          "type": "cumulative",
          "description": "Total number of samples rejected due to timestamp falling outside of the time bounds",
          "group": null,
          "default": false
        },
        "prometheus_target_scrapes_sample_out_of_order_total": {
          "type": "cumulative",
          "description": "Total number of samples rejected due to not being out of the expected order",
          "group": null,
          "default": false
        },
        "prometheus_target_sync_length_seconds": {
          "type": "cumulative",
          "description": "Actual interval to sync the scrape pool",
          "group": null,
          "default": false
        },
        "prometheus_target_sync_length_seconds_count": {
          "type": "cumulative",
          "description": "Actual interval to sync the scrape pool",
          "group": null,
          "default": false
        },
        "prometheus_treecache_watcher_goroutines": {
          "type": "gauge",
          "description": "The current number of watcher goroutines",
          "group": null,
          "default": false
        },
        "prometheus_treecache_zookeeper_failures_total": {
          "type": "cumulative",
          "description": "The total number of ZooKeeper failures",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_blocks_loaded": {
          "type": "gauge",
          "description": "Number of currently loaded data blocks",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_checkpoint_creations_failed_total": {
          "type": "cumulative",
          "description": "Total number of checkpoint creations that failed",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_checkpoint_creations_total": {
          "type": "cumulative",
          "description": "Total number of checkpoint creations attempted",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_checkpoint_deletions_failed_total": {
          "type": "cumulative",
          "description": "Total number of checkpoint deletions that failed",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_checkpoint_deletions_total": {
          "type": "cumulative",
          "description": "Total number of checkpoint deletions attempted",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_range_seconds": {
          "type": "cumulative",
          "description": "Final time range of chunks on their first compaction",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_range_seconds_bucket": {
          "type": "cumulative",
          "description": "Final time range of chunks on their first compaction in the respective bucket",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_range_seconds_count": {
          "type": "cumulative",
          "description": "Final time range of chunks on their first compaction (count)",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_samples": {
          "type": "cumulative",
          "description": "Final number of samples on their first compaction",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_samples_bucket": {
          "type": "cumulative",
          "description": "Final number of samples on their first compaction in the respective bucket",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_samples_count": {
          "type": "cumulative",
          "description": "Final number of samples on their first compaction (count)",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_size_bytes": {
          "type": "cumulative",
          "description": "Final size of chunks on their first compaction",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_size_bytes_bucket": {
          "type": "cumulative",
          "description": "Final size of chunks on their first compaction in the respective bucket",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_chunk_size_bytes_count": {
          "type": "cumulative",
          "description": "Final size of chunks on their first compaction",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of compaction runs",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Duration of compaction runs in the respective bucket",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compaction_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of compaction runs (count)",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compactions_failed_total": {
          "type": "cumulative",
          "description": "Total number of compactions that failed for the partition",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compactions_total": {
          "type": "cumulative",
          "description": "Total number of compactions that were executed for the partition",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_compactions_triggered_total": {
          "type": "cumulative",
          "description": "Total number of triggered compactions for the partition",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_active_appenders": {
          "type": "gauge",
          "description": "Number of currently active appender transactions",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_chunks": {
          "type": "gauge",
          "description": "Total number of chunks in the head block",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_chunks_created_total": {
          "type": "cumulative",
          "description": "Total number of chunks created in the head",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_chunks_removed_total": {
          "type": "cumulative",
          "description": "Total number of chunks removed in the head",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_gc_duration_seconds": {
          "type": "cumulative",
          "description": "Runtime of garbage collection in the head block",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "Runtime of garbage collection in the head block (count)",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_max_time": {
          "type": "gauge",
          "description": "Maximum timestamp of the head block",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_min_time": {
          "type": "gauge",
          "description": "Minimum time bound of the head block",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_samples_appended_total": {
          "type": "cumulative",
          "description": "Total number of appended samples",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_series": {
          "type": "gauge",
          "description": "Total number of series in the head block",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_series_created_total": {
          "type": "cumulative",
          "description": "Total number of series created in the head",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_series_not_found_total": {
          "type": "cumulative",
          "description": "Total number of requests for series that were not found",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_series_removed_total": {
          "type": "cumulative",
          "description": "Total number of series removed in the head",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_truncations_failed_total": {
          "type": "cumulative",
          "description": "Total number of head truncations that failed",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_head_truncations_total": {
          "type": "cumulative",
          "description": "Total number of head truncations attempted",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_lowest_timestamp": {
          "type": "gauge",
          "description": "Lowest timestamp value stored in the database",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_reloads_failures_total": {
          "type": "cumulative",
          "description": "Number of times the database failed to reload block data from disk",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_reloads_total": {
          "type": "cumulative",
          "description": "Number of times the database reloaded block data from disk",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_retention_cutoffs_failures_total": {
          "type": "cumulative",
          "description": "Number of times the database failed to cut off block data from disk",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_retention_cutoffs_total": {
          "type": "cumulative",
          "description": "Number of times the database cut off block data from disk",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_symbol_table_size_bytes": {
          "type": "gauge",
          "description": "Size of symbol table on disk (in bytes)",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_tombstone_cleanup_seconds": {
          "type": "cumulative",
          "description": "The time taken to recompact blocks to remove tombstones",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_tombstone_cleanup_seconds_bucket": {
          "type": "cumulative",
          "description": "The time taken to recompact blocks to remove tombstones in the respective bucket",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_tombstone_cleanup_seconds_count": {
          "type": "cumulative",
          "description": "The time taken to recompact blocks to remove tombstones (count)",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_wal_completed_pages_total": {
          "type": "cumulative",
          "description": "Total number of completed pages",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_wal_fsync_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of WAL fsync",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_wal_fsync_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of WAL fsync (count)",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_wal_page_flushes_total": {
          "type": "cumulative",
          "description": "Total number of page flushes",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_wal_truncate_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of WAL truncation",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_wal_truncate_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of WAL truncation (count)",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_wal_truncations_failed_total": {
          "type": "cumulative",
          "description": "Total number of WAL truncations that failed",
          "group": null,
          "default": false
        },
        "prometheus_tsdb_wal_truncations_total": {
          "type": "cumulative",
          "description": "Total number of WAL truncations attempted",
          "group": null,
          "default": false
        },
        "promhttp_metric_handler_requests_in_flight": {
          "type": "gauge",
          "description": "Current number of scrapes being served",
          "group": null,
          "default": false
        },
        "promhttp_metric_handler_requests_total": {
          "type": "cumulative",
          "description": "Total number of scrapes by HTTP status code",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/prometheus/prometheus",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/redis",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus Redis\nExporter](https://github.com/oliver006/redis_exporter) metrics and sends\nthem to SignalFx.  It is a wrapper around the\n[prometheus-exporter](./prometheus-exporter.md) monitor that provides a\nrestricted but expandable set of metrics.\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "redis_aof_current_rewrite_duration_sec",
            "redis_aof_enabled",
            "redis_aof_last_rewrite_duration_sec",
            "redis_aof_rewrite_in_progress",
            "redis_aof_rewrite_scheduled",
            "redis_blocked_clients",
            "redis_client_biggest_input_buf",
            "redis_client_longest_output_list",
            "redis_cluster_enabled",
            "redis_command_call_duration_seconds_count",
            "redis_command_call_duration_seconds_sum",
            "redis_commands_processed_total",
            "redis_config_maxclients",
            "redis_config_maxmemory",
            "redis_connected_clients",
            "redis_connected_slaves",
            "redis_connections_received_total",
            "redis_db_avg_ttl_seconds",
            "redis_db_keys",
            "redis_db_keys_expiring",
            "redis_evicted_keys_total",
            "redis_expired_keys_total",
            "redis_exporter_build_info",
            "redis_exporter_last_scrape_duration_seconds",
            "redis_exporter_last_scrape_error",
            "redis_exporter_scrapes_total",
            "redis_instance_info",
            "redis_instantaneous_input_kbps",
            "redis_instantaneous_ops_per_sec",
            "redis_instantaneous_output_kbps",
            "redis_keyspace_hits_total",
            "redis_keyspace_misses_total",
            "redis_latest_fork_usec",
            "redis_loading_dump_file",
            "redis_master_repl_offset",
            "redis_memory_fragmentation_ratio",
            "redis_memory_max_bytes",
            "redis_memory_used_bytes",
            "redis_memory_used_lua_bytes",
            "redis_memory_used_peak_bytes",
            "redis_memory_used_rss_bytes",
            "redis_net_input_bytes_total",
            "redis_net_output_bytes_total",
            "redis_process_id",
            "redis_pubsub_channels",
            "redis_pubsub_patterns",
            "redis_rdb_changes_since_last_save",
            "redis_rdb_current_bgsave_duration_sec",
            "redis_rdb_last_bgsave_duration_sec",
            "redis_rejected_connections_total",
            "redis_replication_backlog_bytes",
            "redis_slowlog_length",
            "redis_start_time_seconds",
            "redis_up",
            "redis_uptime_in_seconds",
            "redis_used_cpu_sys",
            "redis_used_cpu_sys_children",
            "redis_used_cpu_user",
            "redis_used_cpu_user_children"
          ]
        }
      },
      "metrics": {
        "redis_aof_current_rewrite_duration_sec": {
          "type": "gauge",
          "description": "aof_current_rewrite_duration_sec metric",
          "group": null,
          "default": false
        },
        "redis_aof_enabled": {
          "type": "gauge",
          "description": "aof_enabled metric",
          "group": null,
          "default": false
        },
        "redis_aof_last_rewrite_duration_sec": {
          "type": "gauge",
          "description": "aof_last_rewrite_duration_sec metric",
          "group": null,
          "default": false
        },
        "redis_aof_rewrite_in_progress": {
          "type": "gauge",
          "description": "aof_rewrite_in_progress metric",
          "group": null,
          "default": false
        },
        "redis_aof_rewrite_scheduled": {
          "type": "gauge",
          "description": "aof_rewrite_scheduled metric",
          "group": null,
          "default": false
        },
        "redis_blocked_clients": {
          "type": "gauge",
          "description": "blocked_clients metric",
          "group": null,
          "default": false
        },
        "redis_client_biggest_input_buf": {
          "type": "gauge",
          "description": "client_biggest_input_buf metric",
          "group": null,
          "default": false
        },
        "redis_client_longest_output_list": {
          "type": "gauge",
          "description": "client_longest_output_list metric",
          "group": null,
          "default": false
        },
        "redis_cluster_enabled": {
          "type": "gauge",
          "description": "cluster_enabled metric",
          "group": null,
          "default": false
        },
        "redis_command_call_duration_seconds_count": {
          "type": "gauge",
          "description": "command_call_duration_seconds_count metric",
          "group": null,
          "default": false
        },
        "redis_command_call_duration_seconds_sum": {
          "type": "gauge",
          "description": "Total amount of time in seconds spent per command",
          "group": null,
          "default": false
        },
        "redis_commands_processed_total": {
          "type": "gauge",
          "description": "commands_processed_total metric",
          "group": null,
          "default": false
        },
        "redis_config_maxclients": {
          "type": "gauge",
          "description": "config_maxclients metric",
          "group": null,
          "default": false
        },
        "redis_config_maxmemory": {
          "type": "gauge",
          "description": "config_maxmemory metric",
          "group": null,
          "default": false
        },
        "redis_connected_clients": {
          "type": "gauge",
          "description": "connected_clients metric",
          "group": null,
          "default": false
        },
        "redis_connected_slaves": {
          "type": "gauge",
          "description": "connected_slaves metric",
          "group": null,
          "default": false
        },
        "redis_connections_received_total": {
          "type": "gauge",
          "description": "connections_received_total metric",
          "group": null,
          "default": false
        },
        "redis_db_avg_ttl_seconds": {
          "type": "gauge",
          "description": "Avg TTL in seconds",
          "group": null,
          "default": false
        },
        "redis_db_keys": {
          "type": "gauge",
          "description": "Total number of keys by DB",
          "group": null,
          "default": false
        },
        "redis_db_keys_expiring": {
          "type": "gauge",
          "description": "Total number of expiring keys by DB",
          "group": null,
          "default": false
        },
        "redis_evicted_keys_total": {
          "type": "gauge",
          "description": "evicted_keys_total metric",
          "group": null,
          "default": false
        },
        "redis_expired_keys_total": {
          "type": "gauge",
          "description": "expired_keys_total metric",
          "group": null,
          "default": false
        },
        "redis_exporter_build_info": {
          "type": "gauge",
          "description": "redis exporter build_info",
          "group": null,
          "default": false
        },
        "redis_exporter_last_scrape_duration_seconds": {
          "type": "gauge",
          "description": "The last scrape duration",
          "group": null,
          "default": false
        },
        "redis_exporter_last_scrape_error": {
          "type": "gauge",
          "description": "The last scrape error status",
          "group": null,
          "default": false
        },
        "redis_exporter_scrapes_total": {
          "type": "gauge",
          "description": "Current total redis scrapes",
          "group": null,
          "default": false
        },
        "redis_instance_info": {
          "type": "gauge",
          "description": "Information about the Redis instance",
          "group": null,
          "default": false
        },
        "redis_instantaneous_input_kbps": {
          "type": "gauge",
          "description": "instantaneous_input_kbps metric",
          "group": null,
          "default": false
        },
        "redis_instantaneous_ops_per_sec": {
          "type": "gauge",
          "description": "instantaneous_ops_per_sec metric",
          "group": null,
          "default": false
        },
        "redis_instantaneous_output_kbps": {
          "type": "gauge",
          "description": "instantaneous_output_kbps metric",
          "group": null,
          "default": false
        },
        "redis_keyspace_hits_total": {
          "type": "gauge",
          "description": "keyspace_hits_total metric",
          "group": null,
          "default": false
        },
        "redis_keyspace_misses_total": {
          "type": "gauge",
          "description": "keyspace_misses_total metric",
          "group": null,
          "default": false
        },
        "redis_latest_fork_usec": {
          "type": "gauge",
          "description": "latest_fork_usec metric",
          "group": null,
          "default": false
        },
        "redis_loading_dump_file": {
          "type": "gauge",
          "description": "loading_dump_file metric",
          "group": null,
          "default": false
        },
        "redis_master_repl_offset": {
          "type": "gauge",
          "description": "master_repl_offset metric",
          "group": null,
          "default": false
        },
        "redis_memory_fragmentation_ratio": {
          "type": "gauge",
          "description": "memory_fragmentation_ratio metric",
          "group": null,
          "default": false
        },
        "redis_memory_max_bytes": {
          "type": "gauge",
          "description": "memory_max_bytes metric",
          "group": null,
          "default": false
        },
        "redis_memory_used_bytes": {
          "type": "gauge",
          "description": "memory_used_bytes metric",
          "group": null,
          "default": false
        },
        "redis_memory_used_lua_bytes": {
          "type": "gauge",
          "description": "memory_used_lua_bytes metric",
          "group": null,
          "default": false
        },
        "redis_memory_used_peak_bytes": {
          "type": "gauge",
          "description": "memory_used_peak_bytes metric",
          "group": null,
          "default": false
        },
        "redis_memory_used_rss_bytes": {
          "type": "gauge",
          "description": "memory_used_rss_bytes metric",
          "group": null,
          "default": false
        },
        "redis_net_input_bytes_total": {
          "type": "gauge",
          "description": "net_input_bytes_total metric",
          "group": null,
          "default": false
        },
        "redis_net_output_bytes_total": {
          "type": "gauge",
          "description": "net_output_bytes_total metric",
          "group": null,
          "default": false
        },
        "redis_process_id": {
          "type": "gauge",
          "description": "process_id metric",
          "group": null,
          "default": false
        },
        "redis_pubsub_channels": {
          "type": "gauge",
          "description": "pubsub_channels metric",
          "group": null,
          "default": false
        },
        "redis_pubsub_patterns": {
          "type": "gauge",
          "description": "pubsub_patterns metric",
          "group": null,
          "default": false
        },
        "redis_rdb_changes_since_last_save": {
          "type": "gauge",
          "description": "rdb_changes_since_last_save metric",
          "group": null,
          "default": false
        },
        "redis_rdb_current_bgsave_duration_sec": {
          "type": "gauge",
          "description": "rdb_current_bgsave_duration_sec metric",
          "group": null,
          "default": false
        },
        "redis_rdb_last_bgsave_duration_sec": {
          "type": "gauge",
          "description": "rdb_last_bgsave_duration_sec metric",
          "group": null,
          "default": false
        },
        "redis_rejected_connections_total": {
          "type": "gauge",
          "description": "rejected_connections_total metric",
          "group": null,
          "default": false
        },
        "redis_replication_backlog_bytes": {
          "type": "gauge",
          "description": "replication_backlog_bytes metric",
          "group": null,
          "default": false
        },
        "redis_slowlog_length": {
          "type": "gauge",
          "description": "Total slowlog",
          "group": null,
          "default": false
        },
        "redis_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the Redis instance since unix epoch in seconds",
          "group": null,
          "default": false
        },
        "redis_up": {
          "type": "gauge",
          "description": "up metric",
          "group": null,
          "default": false
        },
        "redis_uptime_in_seconds": {
          "type": "gauge",
          "description": "uptime_in_seconds metric",
          "group": null,
          "default": false
        },
        "redis_used_cpu_sys": {
          "type": "gauge",
          "description": "used_cpu_sys metric",
          "group": null,
          "default": false
        },
        "redis_used_cpu_sys_children": {
          "type": "gauge",
          "description": "used_cpu_sys_children metric",
          "group": null,
          "default": false
        },
        "redis_used_cpu_user": {
          "type": "gauge",
          "description": "used_cpu_user metric",
          "group": null,
          "default": false
        },
        "redis_used_cpu_user_children": {
          "type": "gauge",
          "description": "used_cpu_user_children metric",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/prometheus/redis",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "python-monitor",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor allows you to generate metrics from a Python script.\n\nYour Python code should be Python 2.7+ *AND* 3.0+ compatible.  The Python\nruntime bundled with the agent is currently version 2.7 but this could be\nupgraded at anytime to Python 3.  If you want to use Python 3 at this time,\nyou can specify a custom Python binary with the `pythonBinary` config\noption.\n\n## Module Loading\nThe full file path to the Python script that you want to run should be\nspecified in the `scriptFilePath` config option.  This file will be loaded in\nPython by adding the directory containing the file to the front of the Python\npath (`sys.path`) and then dynamically importing the file as a module.  For\na hypothetical script at `/opt/scripts/mymonitor.py`, this is roughly\nequivalent to the following Python code:\n\n```\nimport sys\nsys.path.insert(0, \"/opt/scripts\")\n\nimport mymodule\n```\n\nThere are two ways you can implement a monitor in Python, a simple way or a\ncomplex, but more powerful way.  \n\n## Simple monitor \nThe simple way is to write a script that has a `run` function in it.  This\nfunction should accept two parameters: `config` and `output`.  The `run`\nfunction will be called on a regular interval, specified by the common\n`intervalSeconds` config option on the monitor config.\n\nHere is [an example of a simple monitor](https://github.com/signalfx/signalfx-agent/tree/master/python/sample/monitor_simple.py).\n\n## Complex monitor\n\nIf you need more power and flexibility in defining your monitor, you can\nuse the complex monitor format.  With this, you define a class called\n`Monitor` in a Python module. Here is [a documented example of a complex\nmonitor](https://github.com/signalfx/signalfx-agent/tree/master/python/sample/monitor_complex.py).\n\n## Auto-discovery\n\nThis monitor works with auto-discovery just like other monitors.  If you\nset a `discoveryRule` on the monitor config, a new instance of the monitor\nwill be created for each matching endpoint and the `host` and `port` config\nfields will be populated with the appropriate values and passed to the\nPython script in the `config` dictionary.\n\n## Example Config\n\nThis shows loading a Python module from the agent repo using a single custom config value (`myconfig`):\n\n```yaml\nmonitors:\n - type: python-monitor\n   # pythonBinary: /usr/bin/python\n   scriptFilePath: /usr/src/signalfx-agent/python/sample/monitor_complex.py\n   myconfig: [1,2,3]\n```\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config specifies configurations that are specific to the individual python based monitor",
        "package": "pkg/monitors/subproc/signalfx/python",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host will be filled in by auto-discovery if this monitor has a discovery rule.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port will be filled in by auto-discovery if this monitor has a discovery rule.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "scriptFilePath",
            "doc": "Path to the Python script that implements the monitoring logic.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pythonBinary",
            "doc": "By default, the agent will use its bundled Python runtime (version 2.7). If you wish to use a Python runtime that already exists on the system, specify the full path to the `python` binary here, e.g. `/usr/bin/python3`.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pythonPath",
            "doc": "The PYTHONPATH that will be used when importing the script specified at `scriptFilePath`.  The directory of `scriptFilePath` will always be included in the path.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "signalfx-forwarder",
      "sendAll": false,
      "dimensions": null,
      "doc": "Runs an HTTP server that listens for SignalFx datapoints and trace spans\nand forwards them to SignalFx (or the configured ingest host in the\n`writer` section of the agent config).  This supports the latest formats\nfor datapoints (v2) and spans (v1) that our ingest server supports and at\nthe same path (`/v2/datapoint`, `/v1/trace`).  By default, the server listens on\nlocalhost port 9080 but can be configured to anything.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/forwarder",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host:port on which to listen for datapoints.  The listening server accepts datapoints on the same HTTP path that ingest/gateway accepts them (e.g. `/v2/datapoint`, `/v1/trace`).  Requests to other paths will return 404s.",
            "default": "127.0.0.1:9080",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serverTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "5s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "sendInternalMetrics",
            "doc": "Whether to emit internal metrics about the HTTP listener",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "sql",
      "sendAll": true,
      "dimensions": null,
      "doc": "Run arbitrary SQL queries against a relational database and use the results to generate dataponts.\n\nFor example, if you had a database table `customers` that looked like:\n\n| id | name       | country | status   |\n|----|------------|---------|----------|\n| 1  | Bill       | USA     | active   |\n| 2  | Mary       | USA     | inactive |\n| 3  | Joe        | USA     | active   |\n| 4  | Elizabeth  | Germany | active   |\n\nYou could use the following monitor config to generate metrics about active users and customer counts by country:\n\n```yaml\nmonitors:\n  - type: sql\n    host: localhost\n    port: 5432\n    dbDriver: postgres\n    params:\n      user: admin\n      password: s3cr3t\n    # The `host` and `port` values from above (or provided through auto-discovery) should be interpolated\n    # to the connection string as appropriate for your database driver.\n    # Also, the values from the `params` config option above can be\n    # interpolated.\n    connectionString: 'host={{.host}} port={{.port}} dbname=main user={{.user}} password={{.password}} sslmode=disabled'\n    queries:\n      - query: 'SELECT COUNT(*) as count, country, status FROM customers GROUP BY country, status;'\n        metrics:\n          - metricName: \"customers\"\n            valueColumn: \"count\"\n            dimensionColumns: [\"country\", \"status\"]\n```\n\nThis would generate a series of timeseries, all with the metric name\n`customers` that includes a `county` and `status` dimension.  The value\nis the number of customers that belong to that combination of `country`\nand `status`.  You could also specify multiple `metrics` items to\ngenerate more than one metric from a single query.\n\n## Supported Drivers\n\nThe `dbDriver` config option must specify the database driver to use.\nThese are equivalent to the name of the Golang SQL driver used in the\nagent.  The `connectionString` option will be formatted according to the\ndriver that is going to receive it.  Here is a list of the drivers we\ncurrently support and documentation on the connection string:\n\n  - `postgres`: https://godoc.org/github.com/lib/pq#hdr-Connection_String_Parameters\n  - `mysql`: https://github.com/go-sql-driver/mysql#dsn-data-source-name\n  - `mssql`: https://github.com/denisenkom/go-mssqldb#connection-parameters-and-dsn\n\n## Parameterized Connection String\n\nThe `connectionString` config option acts as a template with a context\nconsisting of the variables: `host`, `port`, and all the values from\nthe `params` config option map.  You interpolate variables into it\nwith the Go template syntax `{{.varname}}` (see example config\nabove).\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/sql",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "params",
            "doc": "Parameters to the connectionString that can be templated into that option using Go template syntax (e.g. `{{.key}}`).",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "dbDriver",
            "doc": "The database driver to use, valid values are `postgres` and `mysql`.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "connectionString",
            "doc": "A URL or simple option string used to connect to the database. If using PostgreSQL, [see the list of connection string params](https://godoc.org/github.com/lib/pq#hdr-Connection_String_Parameters).",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "queries",
            "doc": "A list of queries to make against the database that are used to generate datapoints.",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Query",
              "doc": "Query is used to configure a query statement and the resulting datapoints",
              "package": "pkg/monitors/sql",
              "fields": [
                {
                  "yamlName": "query",
                  "doc": "A SQL query text that selects one or more rows from a database",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "params",
                  "doc": "Optional parameters that will replace placeholders in the query string.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "interface"
                },
                {
                  "yamlName": "metrics",
                  "doc": "Metrics that should be generated from the query.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "Metric",
                    "doc": "Metric describes how to derive a metric from the individual rows of a query result.",
                    "package": "pkg/monitors/sql",
                    "fields": [
                      {
                        "yamlName": "metricName",
                        "doc": "The name of the metric as it will appear in SignalFx.",
                        "default": null,
                        "required": true,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "valueColumn",
                        "doc": "The column name that holds the datapoint value",
                        "default": null,
                        "required": true,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "dimensionColumns",
                        "doc": "The names of the columns that should make up the dimensions of the datapoint.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "isCumulative",
                        "doc": "Whether the value is a cumulative counters (true) or gauge (false).  If you set this to the wrong value and send in your first datapoint for the metric name with the wrong type, you will have to manually change the type in SignalFx, as it is set in the system based on the first type seen.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "dimensionPropertyColumns",
                        "doc": "The mapping between dimensions and the columns to be used to attach respective properties",
                        "default": null,
                        "required": false,
                        "type": "map",
                        "elementKind": "slice"
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "yamlName": "logQueries",
            "doc": "If true, query results will be logged at the info level.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "statsd",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor will receive and aggergate Statsd metrics and convert them to\ndatapoints.  It listens on a configured address and port in order to\nreceive the statsd metrics.  Note that this monitor does not support statsd\nextensions such as tags.\n\nThe monitor supports the `Counter`, `Timer`, `Gauge` and `Set` types which\nare dispatched as the SignalFx types `counter`, `gauge`, `gauge` and\n`gauge` respectively.\n\n**Note that datapoints will get a `host` dimension of the current host that\nthe agent is running on, not the host from which the statsd metric was sent.\nFor this reason, it is recommended to send statsd metrics to a local agent\ninstance. If you don't want the `host` dimension, you can set\n`disableHostDimensions: true` on the monitor configuration**\n\n\u003c!--- SETUP ---\u003e\n#### Verifying installation\n\nYou can send StatsD metrics locally with `netcat` as follows, then verify\nin SignalFx that the metric arrived (assuming the default config).\n\n```\n$ echo \"statsd.test:1|g\" | nc -w 1 -u 127.0.0.1 8125\n```\n\n\u003c!--- SETUP ---\u003e\n#### Adding dimensions to StatsD metrics\n\nThe StatsD monitor can parse keywords from a statsd metric name by a set of\nconverters that was configured by user.\n\n```\nconverters:\n  - pattern: \"cluster.cds_{traffic}_{mesh}_{service}-vn_{}.{action}\"\n    ...\n```\n\nThis converter will parse `traffic`, `mesh`, `service` and `action` as dimensions\nfrom a metric name `cluster.cds_egress_ecommerce-demo-mesh_gateway-vn_tcp_8080.update_success`.\nIf a section has only a pair of brackets without a name, it will not capture a dimension.\n\nWhen multiple converters were provided, a metric will be converted by the first converter with a\nmatching pattern to the metric name.\n\n\u003c!--- SETUP ---\u003e\n#### Formatting metric name\n\nYou can customize a metric name by providing a format string within the converter configuration.\n\n```\nconverters:\n  - pattern: \"cluster.cds_{traffic}_{mesh}_{service}-vn_{}.{action}\"\n    metricName: \"{traffic}.{action}\"\n```\n\nThe metrics which match to the given pattern will be reported to SignalFx as `{traffic}.{action}`.\nFor instance, metric `cluster.cds_egress_ecommerce-demo-mesh_gateway-vn_tcp_8080.update_success`\nwill be reported as `egress.update_success`.\n\n`metricName` is required for a converter configuration. A converter will be\ndisabled if `metricName` is not provided.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/statsd",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host/address on which to bind the UDP listener that accepts statsd datagrams",
            "default": "localhost",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "listenPort",
            "doc": "The port on which to listen for statsd messages (**default:** `8125`)",
            "default": null,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "metricPrefix",
            "doc": "A prefix in metric names that needs to be removed before metric name conversion",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "converters",
            "doc": "A list converters to convert StatsD metric names into SignalFx metric names and dimensions",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "ConverterInput",
              "doc": "ConverterInput is to receive configs to setup metric converters",
              "package": "pkg/monitors/statsd",
              "fields": [
                {
                  "yamlName": "pattern",
                  "doc": "A pattern to match against StatsD metric names",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "metricName",
                  "doc": "A format to compose a metric name to report to SignalFx",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/logparser",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor is based on the Telegraf logparser plugin.\nThe monitor tails log files. More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/logparser).\nAll metrics emitted from this monitor will have the `plugin` dimension set to `telegraf-logparser`\n\nSample YAML configuration:\n\n```yaml\n - type: telegraf/logparser\n   files:\n    - '$file'\n   watchMethod: poll       # specify the file watch method (\"inotify\" or \"poll\")\n   fromBeginning: true     # specify to read from the beginning\n   measurementName: test-measurement # the metric name prefix\n   patterns:\n    - \"%{COMMON_LOG_FORMAT}\" # specifies the apache common log format\n   timezone: UTC\n```\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/telegraf/monitors/telegraflogparser",
        "fields": [
          {
            "yamlName": "files",
            "doc": "Paths to files to be tailed",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "watchMethod",
            "doc": "Method for watching changes to files (\"ionotify\" or \"poll\")",
            "default": "poll",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "fromBeginning",
            "doc": "Whether to start tailing from the beginning of the file",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "measurementName",
            "doc": "Name of the measurement",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "patterns",
            "doc": "A list of patterns to match.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "namedPatterns",
            "doc": "A list of named grok patterns to match.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "customPatterns",
            "doc": "Custom grok patterns. (`grok` only)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customPatternFiles",
            "doc": "List of paths to custom grok pattern files.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "timezone",
            "doc": "Specifies the timezone.  The default is UTC time.  Other options are `Local` for the local time on the machine, `UTC`, and `Canada/Eastern` (unix style timezones).",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/procstat",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reports metrics about processes.\nThis monitor is based on the Telegraf procstat plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/procstat).\n\nPlease note that the Smart Agent only supports the `native` pid finder and the options\n`cgroup` and `systemd unit` are not supported at this time.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\nSample Yaml Configuration\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: telegraf/procstat\n   exe: \"signalfx-agent*\"\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "procstat.cpu_time",
            "procstat.cpu_usage",
            "procstat.involuntary_context_switches",
            "procstat.memory_data",
            "procstat.memory_locked",
            "procstat.memory_rss",
            "procstat.memory_stack",
            "procstat.memory_swap",
            "procstat.memory_vms",
            "procstat.nice_priority",
            "procstat.num_fds",
            "procstat.num_threads",
            "procstat.read_bytes",
            "procstat.read_count",
            "procstat.realtime_priority",
            "procstat.rlimit_cpu_time_hard",
            "procstat.rlimit_cpu_time_soft",
            "procstat.rlimit_file_locks_hard",
            "procstat.rlimit_file_locks_soft",
            "procstat.rlimit_memory_data_hard",
            "procstat.rlimit_memory_data_soft",
            "procstat.rlimit_memory_locked_hard",
            "procstat.rlimit_memory_locked_soft",
            "procstat.rlimit_memory_rss_hard",
            "procstat.rlimit_memory_rss_soft",
            "procstat.rlimit_memory_stack_hard",
            "procstat.rlimit_memory_stack_soft",
            "procstat.rlimit_memory_vms_hard",
            "procstat.rlimit_memory_vms_soft",
            "procstat.rlimit_nice_priority_hard",
            "procstat.rlimit_nice_priority_soft",
            "procstat.rlimit_num_fds_hard",
            "procstat.rlimit_num_fds_soft",
            "procstat.rlimit_realtime_priority_hard",
            "procstat.rlimit_realtime_priority_soft",
            "procstat.rlimit_signals_pending_hard",
            "procstat.rlimit_signals_pending_soft",
            "procstat.signals_pending",
            "procstat.write_bytes",
            "procstat.write_count",
            "procstat_lookup.pid_count"
          ]
        }
      },
      "metrics": {
        "procstat.cpu_time": {
          "type": "gauge",
          "description": "Amount of cpu time consumed by the process.",
          "group": null,
          "default": false
        },
        "procstat.cpu_usage": {
          "type": "gauge",
          "description": "CPU used by the process.",
          "group": null,
          "default": false
        },
        "procstat.involuntary_context_switches": {
          "type": "gauge",
          "description": "Number of involuntary context switches.",
          "group": null,
          "default": false
        },
        "procstat.memory_data": {
          "type": "gauge",
          "description": "VMData memory used by the process.",
          "group": null,
          "default": false
        },
        "procstat.memory_locked": {
          "type": "gauge",
          "description": "VMLocked memory used by the process.",
          "group": null,
          "default": false
        },
        "procstat.memory_rss": {
          "type": "gauge",
          "description": "VMRSS memory used by the process.",
          "group": null,
          "default": false
        },
        "procstat.memory_stack": {
          "type": "gauge",
          "description": "VMStack memory used by the process.",
          "group": null,
          "default": false
        },
        "procstat.memory_swap": {
          "type": "gauge",
          "description": "VMSwap memory used by the process.",
          "group": null,
          "default": false
        },
        "procstat.memory_vms": {
          "type": "gauge",
          "description": "VMS memory used by the process.",
          "group": null,
          "default": false
        },
        "procstat.nice_priority": {
          "type": "gauge",
          "description": "Nice priority number of the process.",
          "group": null,
          "default": false
        },
        "procstat.num_fds": {
          "type": "gauge",
          "description": "Number of file descriptors.  This may require the agent to be running as root.",
          "group": null,
          "default": false
        },
        "procstat.num_threads": {
          "type": "gauge",
          "description": "Number of threads used by the process.",
          "group": null,
          "default": false
        },
        "procstat.read_bytes": {
          "type": "gauge",
          "description": "Number of bytes read by the process.  This may require the agent to be running as root.",
          "group": null,
          "default": false
        },
        "procstat.read_count": {
          "type": "gauge",
          "description": "Number of read operations by the process.  This may require the agent to be running as root.",
          "group": null,
          "default": false
        },
        "procstat.realtime_priority": {
          "type": "gauge",
          "description": "Real time priority of the process.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_cpu_time_hard": {
          "type": "gauge",
          "description": "The hard cpu rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_cpu_time_soft": {
          "type": "gauge",
          "description": "The soft cpu rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_file_locks_hard": {
          "type": "gauge",
          "description": "The hard file lock rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_file_locks_soft": {
          "type": "gauge",
          "description": "The soft file lock rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_data_hard": {
          "type": "gauge",
          "description": "The hard data memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_data_soft": {
          "type": "gauge",
          "description": "The soft data memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_locked_hard": {
          "type": "gauge",
          "description": "The hard locked memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_locked_soft": {
          "type": "gauge",
          "description": "The soft locked memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_rss_hard": {
          "type": "gauge",
          "description": "The hard rss memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_rss_soft": {
          "type": "gauge",
          "description": "The soft rss memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_stack_hard": {
          "type": "gauge",
          "description": "The hard stack memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_stack_soft": {
          "type": "gauge",
          "description": "The soft stack memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_vms_hard": {
          "type": "gauge",
          "description": "The hard vms memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_memory_vms_soft": {
          "type": "gauge",
          "description": "The soft vms memory rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_nice_priority_hard": {
          "type": "gauge",
          "description": "The hard nice priority rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_nice_priority_soft": {
          "type": "gauge",
          "description": "The soft nice priority rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_num_fds_hard": {
          "type": "gauge",
          "description": "The hard file descriptor rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_num_fds_soft": {
          "type": "gauge",
          "description": "The soft file descriptor rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_realtime_priority_hard": {
          "type": "gauge",
          "description": "The hard realtime priority rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_realtime_priority_soft": {
          "type": "gauge",
          "description": "The soft realtime priority rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_signals_pending_hard": {
          "type": "gauge",
          "description": "The hard pending signal rlimit.",
          "group": null,
          "default": false
        },
        "procstat.rlimit_signals_pending_soft": {
          "type": "gauge",
          "description": "The soft pendidng signal rlimit.",
          "group": null,
          "default": false
        },
        "procstat.signals_pending": {
          "type": "gauge",
          "description": "The number of signals pending.",
          "group": null,
          "default": false
        },
        "procstat.write_bytes": {
          "type": "gauge",
          "description": "Number of bytes written by the process.  This may require the agent to be running as root.",
          "group": null,
          "default": false
        },
        "procstat.write_count": {
          "type": "gauge",
          "description": "Number of write operations by the process.  This may require the agent to be running as root.",
          "group": null,
          "default": false
        },
        "procstat_lookup.pid_count": {
          "type": "gauge",
          "description": "The number of pids. This metric emits with the plugin dimension set to \"procstat_lookup\".",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/telegraf/monitors/procstat",
        "fields": [
          {
            "yamlName": "exe",
            "doc": "The name of an executable to monitor.  (ie: `exe: \"signalfx-agent*\"`)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pattern",
            "doc": "Pattern to match against.  On Windows the pattern should be in the form of a WMI query. (ie: `pattern: \"%signalfx-agent%\"`)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "user",
            "doc": "Username to match against",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pidFile",
            "doc": "Path to Pid file to monitor.  (ie: `pidFile: \"/var/run/signalfx-agent.pid\"`)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "processName",
            "doc": "Used to override the process name dimension",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "prefix",
            "doc": "Prefix to be added to each dimension",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pidTag",
            "doc": "Whether to add PID as a dimension instead of part of the metric name",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "cGroup",
            "doc": "The name of the cgroup to monitor.  This cgroup name will be appended to the configured `sysPath`.  See the agent config schema for more information about the `sysPath` agent configuration.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "WinService",
            "doc": "The name of a windows service to report procstat information on.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/snmp",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reports metrics from snmp agents.\nThis monitor is based on the Telegraf SNMP plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/snmp).\n\n**NOTE:** This snmp monitor does not currently support MIB look ups because of a dependency on `net-snmp`\nand specifically the commands `snmptranslate` and `snmptable`.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/snmp\n   agents:\n     - \"127.0.0.1:161\"\n   version: 2\n   community: \"public\"\n   fields:\n     - name: \"uptime\"\n       oid: \".1.3.6.1.2.1.1.3.0\"\n```\n\nUsing a discovery rule to discover and configure for a specific snmp agent\n```yaml\nmonitors:\n - type: telegraf/snmp\n   discoveryRule: container_name =~ \"snmp\" \u0026\u0026 port == 161\n   version: 2\n   community: \"public\"\n   fields:\n     - name: \"uptime\"\n       oid: \".1.3.6.1.2.1.1.3.0\"\n```\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/telegraf/monitors/telegrafsnmp",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host and port will be concatenated and appended to the list of SNMP agents to connect to.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port and Host will be concatenated and appended to the list of SNMP agents to connect to.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "agents",
            "doc": "SNMP agent address and ports to query for information.  An example address is `0.0.0.0:5555` If an address is supplied with out a port, the default port `161` will be used.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "retries",
            "doc": "The number of times to retry.",
            "default": 0,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "community",
            "doc": "The SNMP community to use.",
            "default": "public",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "maxRepetitions",
            "doc": "Maximum number of iterations for reqpeating variables",
            "default": 50,
            "required": false,
            "type": "uint8",
            "elementKind": ""
          },
          {
            "yamlName": "contextName",
            "doc": "SNMP v3 context name to use with requests",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "secLevel",
            "doc": "Security level to use for SNMP v3 messages: `noAuthNoPriv` `authNoPriv`, `authPriv`.",
            "default": "noAuthNoPriv",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "secName",
            "doc": "Name to used to authenticate with SNMP v3 requests.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "authProtocol",
            "doc": "Protocol to used to authenticate SNMP v3 requests: `\"MD5\"`, `\"SHA\"`, and `\"\"` (default).",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "authPassword",
            "doc": "Password used to authenticate SNMP v3 requests.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "privProtocol",
            "doc": "Protocol used for encrypted SNMP v3 messages: `DES`, `AES`, `\"\"` (default).",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "privPassword",
            "doc": "Password used to encrypt SNMP v3 messages.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "engineID",
            "doc": "The SNMP v3 engine ID.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "engineBoots",
            "doc": "The SNMP v3 engine boots.",
            "default": 0,
            "required": false,
            "type": "uint32",
            "elementKind": ""
          },
          {
            "yamlName": "engineTime",
            "doc": "The SNMP v3 engine time.",
            "default": 0,
            "required": false,
            "type": "uint32",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "The top-level measurement name",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "fields",
            "doc": "The top-level SNMP fields",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Field",
              "doc": "Field represents an SNMP field",
              "package": "pkg/monitors/telegraf/monitors/telegrafsnmp",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "Name of the field.  The OID will be used if no value is supplied.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "oid",
                  "doc": "The OID to fetch.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "oidIndexSuffix",
                  "doc": "The sub-identifier to strip off when matching indexes to other fields.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "oidIndexLength",
                  "doc": "The index length after the table OID.  The index will be truncated after this length in order to remove length index suffixes or non-fixed values.",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "isTag",
                  "doc": "Whether to output the field as a tag.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "conversion",
                  "doc": "Controls the type conversion applied to the value: `\"float(X)\"`, `\"float\"`, `\"int\"`, `\"hwaddr\"`, `\"ipaddr\"` or `\"\"` (default).",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "tables",
            "doc": "SNMP Tables",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Table",
              "doc": "Table represents an SNMP table",
              "package": "pkg/monitors/telegraf/monitors/telegrafsnmp",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "Metric name.  If not supplied the OID will be used.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "inheritTags",
                  "doc": "Top level tags to inherit.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "indexAsTag",
                  "doc": "Add a tag for the table index for each row.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "field",
                  "doc": "Specifies the ags and values to look up.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "Field",
                    "doc": "Field represents an SNMP field",
                    "package": "pkg/monitors/telegraf/monitors/telegrafsnmp",
                    "fields": [
                      {
                        "yamlName": "name",
                        "doc": "Name of the field.  The OID will be used if no value is supplied.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "oid",
                        "doc": "The OID to fetch.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "oidIndexSuffix",
                        "doc": "The sub-identifier to strip off when matching indexes to other fields.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "oidIndexLength",
                        "doc": "The index length after the table OID.  The index will be truncated after this length in order to remove length index suffixes or non-fixed values.",
                        "default": 0,
                        "required": false,
                        "type": "int",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "isTag",
                        "doc": "Whether to output the field as a tag.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "conversion",
                        "doc": "Controls the type conversion applied to the value: `\"float(X)\"`, `\"float\"`, `\"int\"`, `\"hwaddr\"`, `\"ipaddr\"` or `\"\"` (default).",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "oid",
                  "doc": "The OID to fetch.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/sqlserver",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports metrics about Microsoft SQL servers.\nThis monitor is based on the telegraf sqlserver plugin.  More information about the telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/sqlserver).\n\nYou will need to create a login on the SQL server for the monitor to use.  You can create this login by\nexecuting the following commands in an a SQL client while logged in as an administrator.\n\n```\nUSE master;\nGO\nCREATE LOGIN [signalfxagent] WITH PASSWORD = N'\u003cYOUR PASSWORD HERE\u003e';\nGO\nGRANT VIEW SERVER STATE TO [signalfxagent];\nGO\nGRANT VIEW ANY DEFINITION TO [signalfxagent];\nGO\n```\n\nTroubleshooting:\n\nOn some Windows based SQL server distributions TCP/IP has been disabled by default.  This behavior\nhas been observed on Azure SQL server instances.  You may need to explicitly turn on TCP/IP for the\nSQL server if you see error messages simillar to the following.\n\n```\nCannot read handshake packet: read tcp: wsarecv: An existing connection was forcibly closed by the remote host.\n```\n\n1. Verify agent configurations are correct.\n2. Ensure TCP/IP is enabled for the SQL server by going to `Start` -\u003e `Administrative Tools` -\u003e `Computer Management`\n3. In the `Computer Management` side bar, drill down to `Services and Applications` -\u003e `SQL Server Configuration Manager` -\u003e `SQL Server Network Configuration`\n4. Select `Protocols for \u003cYOUR SQL SERVER NAME\u003e`.\n5. In the protocol list to the right, right-click on the `TCP/IP` protocol and `enable` it.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/sqlserver\n   host: hostname\n   port: 1433\n   userID: sa\n   password: P@ssw0rd!\n   appName: signalfxagent\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "sqlserver_database_io.read_bytes",
            "sqlserver_database_io.read_latency_ms",
            "sqlserver_database_io.reads",
            "sqlserver_database_io.write_bytes",
            "sqlserver_database_io.write_latency_ms",
            "sqlserver_database_io.writes",
            "sqlserver_memory_clerks.size_kb.bound_trees",
            "sqlserver_memory_clerks.size_kb.buffer_pool",
            "sqlserver_memory_clerks.size_kb.connection_pool",
            "sqlserver_memory_clerks.size_kb.general",
            "sqlserver_memory_clerks.size_kb.in-memory_oltp",
            "sqlserver_memory_clerks.size_kb.log_pool",
            "sqlserver_memory_clerks.size_kb.memoryclerk_sqltrace",
            "sqlserver_memory_clerks.size_kb.schema_manager_user_store",
            "sqlserver_memory_clerks.size_kb.sos_node",
            "sqlserver_memory_clerks.size_kb.sql_optimizer",
            "sqlserver_memory_clerks.size_kb.sql_plans",
            "sqlserver_memory_clerks.size_kb.sql_reservations",
            "sqlserver_memory_clerks.size_kb.sql_storage_engine",
            "sqlserver_memory_clerks.size_kb.system_rowset_store",
            "sqlserver_performance.active_memory_grant_amount_kb",
            "sqlserver_performance.active_temp_tables",
            "sqlserver_performance.background_writer_pages_sec",
            "sqlserver_performance.backup_restore_throughput_sec",
            "sqlserver_performance.batch_requests_sec",
            "sqlserver_performance.blocked_tasks",
            "sqlserver_performance.buffer_cache_hit_ratio",
            "sqlserver_performance.bytes_received_from_replica_sec",
            "sqlserver_performance.bytes_sent_to_replica_sec",
            "sqlserver_performance.bytes_sent_to_transport_sec",
            "sqlserver_performance.checkpoint_pages_sec",
            "sqlserver_performance.cpu_limit_violation_count",
            "sqlserver_performance.cpu_usage_pct",
            "sqlserver_performance.cpu_usage_time",
            "sqlserver_performance.data_file_size_kb",
            "sqlserver_performance.disk_read_bytes_sec",
            "sqlserver_performance.disk_read_io_sec",
            "sqlserver_performance.disk_read_io_throttled_sec",
            "sqlserver_performance.disk_write_bytes_sec",
            "sqlserver_performance.disk_write_io_sec",
            "sqlserver_performance.disk_write_io_throttled_sec",
            "sqlserver_performance.errors_sec",
            "sqlserver_performance.flow_control_sec",
            "sqlserver_performance.flow_control_time_ms_sec",
            "sqlserver_performance.forwarded_records_sec",
            "sqlserver_performance.free_list_stalls_sec",
            "sqlserver_performance.free_space_in_tempdb_kb",
            "sqlserver_performance.full_scans_sec",
            "sqlserver_performance.index_searches_sec",
            "sqlserver_performance.latch_waits_sec",
            "sqlserver_performance.lazy_writes_sec",
            "sqlserver_performance.lock_timeouts_sec",
            "sqlserver_performance.lock_wait_count",
            "sqlserver_performance.lock_wait_time",
            "sqlserver_performance.lock_waits_sec",
            "sqlserver_performance.log_apply_pending_queue",
            "sqlserver_performance.log_apply_ready_queue",
            "sqlserver_performance.log_bytes_flushed_sec",
            "sqlserver_performance.log_bytes_received_sec",
            "sqlserver_performance.log_file_size_kb",
            "sqlserver_performance.log_file_used_size_kb",
            "sqlserver_performance.log_flush_wait_time",
            "sqlserver_performance.log_flushes_sec",
            "sqlserver_performance.log_send_queue",
            "sqlserver_performance.logins_sec",
            "sqlserver_performance.logouts_sec",
            "sqlserver_performance.memory_broker_clerk_size",
            "sqlserver_performance.memory_grants_outstanding",
            "sqlserver_performance.memory_grants_pending",
            "sqlserver_performance.number_of_deadlocks_sec",
            "sqlserver_performance.page_life_expectancy",
            "sqlserver_performance.page_lookups_sec",
            "sqlserver_performance.page_reads_sec",
            "sqlserver_performance.page_splits_sec",
            "sqlserver_performance.page_writes_sec",
            "sqlserver_performance.pct_log_used",
            "sqlserver_performance.processes_blocked",
            "sqlserver_performance.query",
            "sqlserver_performance.queued_request_count",
            "sqlserver_performance.queued_requests",
            "sqlserver_performance.readahead_pages_sec",
            "sqlserver_performance.receives_from_replica_sec",
            "sqlserver_performance.recovery_queue",
            "sqlserver_performance.redone_bytes_sec",
            "sqlserver_performance.reduced_memory_grant_count",
            "sqlserver_performance.request_count",
            "sqlserver_performance.requests_completed_sec",
            "sqlserver_performance.resent_messages_sec",
            "sqlserver_performance.sends_to_replica_sec",
            "sqlserver_performance.sends_to_transport_sec",
            "sqlserver_performance.sql_compilations_sec",
            "sqlserver_performance.sql_re-compilations_sec",
            "sqlserver_performance.target_server_memory_kb",
            "sqlserver_performance.temp_tables_creation_rate",
            "sqlserver_performance.temp_tables_for_destruction",
            "sqlserver_performance.total_server_memory_kb",
            "sqlserver_performance.transaction_delay",
            "sqlserver_performance.transactions_sec",
            "sqlserver_performance.used_memory_kb",
            "sqlserver_performance.user_connections",
            "sqlserver_performance.version_store_size_kb",
            "sqlserver_performance.write_transactions_sec",
            "sqlserver_performance.xtp_memory_used_kb",
            "sqlserver_server_properties.available_storage_mb",
            "sqlserver_server_properties.cpu_count",
            "sqlserver_server_properties.db_offline",
            "sqlserver_server_properties.db_online",
            "sqlserver_server_properties.db_recovering",
            "sqlserver_server_properties.db_recoverypending",
            "sqlserver_server_properties.db_restoring",
            "sqlserver_server_properties.db_suspect",
            "sqlserver_server_properties.engine_edition",
            "sqlserver_server_properties.server_memory",
            "sqlserver_server_properties.total_storage_mb",
            "sqlserver_server_properties.uptime",
            "sqlserver_waitstats.max_wait_time_ms",
            "sqlserver_waitstats.resource_wait_ms",
            "sqlserver_waitstats.signal_wait_time_ms",
            "sqlserver_waitstats.wait_time_ms",
            "sqlserver_waitstats.waiting_tasks_count"
          ]
        }
      },
      "metrics": {
        "sqlserver_database_io.read_bytes": {
          "type": "gauge",
          "description": "Bytes read by the database.",
          "group": null,
          "default": true
        },
        "sqlserver_database_io.read_latency_ms": {
          "type": "gauge",
          "description": "Latency in milliseconds reading from the database.",
          "group": null,
          "default": true
        },
        "sqlserver_database_io.reads": {
          "type": "gauge",
          "description": "Number of reads from the database.",
          "group": null,
          "default": true
        },
        "sqlserver_database_io.write_bytes": {
          "type": "gauge",
          "description": "Bytes written to the database.",
          "group": null,
          "default": true
        },
        "sqlserver_database_io.write_latency_ms": {
          "type": "gauge",
          "description": "Latency in milliseconds writing to the database.",
          "group": null,
          "default": true
        },
        "sqlserver_database_io.writes": {
          "type": "gauge",
          "description": "Number of writes to the database.",
          "group": null,
          "default": true
        },
        "sqlserver_memory_clerks.size_kb.bound_trees": {
          "type": "gauge",
          "description": "Size in KB of bound trees memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.buffer_pool": {
          "type": "gauge",
          "description": "Size in KB of buffer pool memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.connection_pool": {
          "type": "gauge",
          "description": "Size in KB of connection pool memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.general": {
          "type": "gauge",
          "description": "Size in KB of general memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.in-memory_oltp": {
          "type": "gauge",
          "description": "Size in KB of in in-memoory oltp memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.log_pool": {
          "type": "gauge",
          "description": "Size in KB of log pool memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.memoryclerk_sqltrace": {
          "type": "gauge",
          "description": "Size in KB of sql trace memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.schema_manager_user_store": {
          "type": "gauge",
          "description": "Size in KB of user store schema manager memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.sos_node": {
          "type": "gauge",
          "description": "Size in KB of sos node memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.sql_optimizer": {
          "type": "gauge",
          "description": "Size in KB of SQL optimizer memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.sql_plans": {
          "type": "gauge",
          "description": "Size in KB of sql plans memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.sql_reservations": {
          "type": "gauge",
          "description": "Size in KB of sql reservations memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.sql_storage_engine": {
          "type": "gauge",
          "description": "Size in KB of sql storage engine memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_memory_clerks.size_kb.system_rowset_store": {
          "type": "gauge",
          "description": "Size in KB of system rowset store memory clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.active_memory_grant_amount_kb": {
          "type": "gauge",
          "description": "Amount of active memory in KB granted.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.active_temp_tables": {
          "type": "gauge",
          "description": "Number of active temporary tables.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.background_writer_pages_sec": {
          "type": "gauge",
          "description": "Rate per second of pages written in the background.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.backup_restore_throughput_sec": {
          "type": "gauge",
          "description": "Rate per second of backup/restore throughput.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.batch_requests_sec": {
          "type": "gauge",
          "description": "Rate per second of batch requests.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.blocked_tasks": {
          "type": "gauge",
          "description": "Number of blocked tasks.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.buffer_cache_hit_ratio": {
          "type": "gauge",
          "description": "Buffer cache hit ration.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.bytes_received_from_replica_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes received from replicas.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.bytes_sent_to_replica_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes sent to replicas.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.bytes_sent_to_transport_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes sent to transports.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.checkpoint_pages_sec": {
          "type": "gauge",
          "description": "Rate per second of checkpoint pages.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.cpu_limit_violation_count": {
          "type": "gauge",
          "description": "Number of cpu limit violations.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.cpu_usage_pct": {
          "type": "gauge",
          "description": "CPU usage percentage.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.cpu_usage_time": {
          "type": "gauge",
          "description": "CPU usage time.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.data_file_size_kb": {
          "type": "gauge",
          "description": "Size in KB of data files.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.disk_read_bytes_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes from disk.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.disk_read_io_sec": {
          "type": "gauge",
          "description": "Rate per second of read operations from disk.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.disk_read_io_throttled_sec": {
          "type": "gauge",
          "description": "Rate per second of throttled read operations.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.disk_write_bytes_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes written to disk.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.disk_write_io_sec": {
          "type": "gauge",
          "description": "Rate per second of write operations to disk.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.disk_write_io_throttled_sec": {
          "type": "gauge",
          "description": "Rate per second of write operations throttled.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.errors_sec": {
          "type": "gauge",
          "description": "Rate of errors per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.flow_control_sec": {
          "type": "gauge",
          "description": "Rate per second of flow control.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.flow_control_time_ms_sec": {
          "type": "gauge",
          "description": "Rate per second of ms of flow control time.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.forwarded_records_sec": {
          "type": "gauge",
          "description": "Rate per second of record forwarding.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.free_list_stalls_sec": {
          "type": "gauge",
          "description": "Rate per second of stalled free list.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.free_space_in_tempdb_kb": {
          "type": "gauge",
          "description": "Free space in KB of tempdb.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.full_scans_sec": {
          "type": "gauge",
          "description": "Rate per second of full scans.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.index_searches_sec": {
          "type": "gauge",
          "description": "Rate per second of index searches.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.latch_waits_sec": {
          "type": "gauge",
          "description": "Rate per second of latch waits.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.lazy_writes_sec": {
          "type": "gauge",
          "description": "Rate per second of lazy writes.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.lock_timeouts_sec": {
          "type": "gauge",
          "description": "Rate per second of lock timeouts.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.lock_wait_count": {
          "type": "gauge",
          "description": "Number of lock waits.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.lock_wait_time": {
          "type": "gauge",
          "description": "Lock wait time.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.lock_waits_sec": {
          "type": "gauge",
          "description": "Rate per second of lock waits.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_apply_pending_queue": {
          "type": "gauge",
          "description": "Size of the log apply pending queue.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_apply_ready_queue": {
          "type": "gauge",
          "description": "Size of log apply ready queue.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_bytes_flushed_sec": {
          "type": "gauge",
          "description": "Rate per second of log bytes flushed.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_bytes_received_sec": {
          "type": "gauge",
          "description": "Rate per second of log bytes received.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_file_size_kb": {
          "type": "gauge",
          "description": "Size in KB of log file.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_file_used_size_kb": {
          "type": "gauge",
          "description": "Size in KB of log file used.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_flush_wait_time": {
          "type": "gauge",
          "description": "Time spent flushing the log.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_flushes_sec": {
          "type": "gauge",
          "description": "Rate per second of log flushes.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.log_send_queue": {
          "type": "gauge",
          "description": "Size of the log send queue.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.logins_sec": {
          "type": "gauge",
          "description": "Rate of logins per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.logouts_sec": {
          "type": "gauge",
          "description": "Rate of logouts per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.memory_broker_clerk_size": {
          "type": "gauge",
          "description": "Size of memory broker clerk.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.memory_grants_outstanding": {
          "type": "gauge",
          "description": "Number of outstanding memory grants.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.memory_grants_pending": {
          "type": "gauge",
          "description": "Number of pending memory grants.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.number_of_deadlocks_sec": {
          "type": "gauge",
          "description": "Rate of deadlocks per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.page_life_expectancy": {
          "type": "gauge",
          "description": "Page life expectancy.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.page_lookups_sec": {
          "type": "gauge",
          "description": "Rate of page look ups per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.page_reads_sec": {
          "type": "gauge",
          "description": "Rate of page reads per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.page_splits_sec": {
          "type": "gauge",
          "description": "Rate of page splits per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.page_writes_sec": {
          "type": "gauge",
          "description": "Rate of page writes per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.pct_log_used": {
          "type": "gauge",
          "description": "Percentage of log used.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.processes_blocked": {
          "type": "gauge",
          "description": "Number of blocked processes.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.query": {
          "type": "gauge",
          "description": "[User settable](https://docs.microsoft.com/en-us/sql/relational-databases/performance-monitor/sql-server-user-settable-object?view=sql-server-2017) performance counters\n",
          "group": null,
          "default": false
        },
        "sqlserver_performance.queued_request_count": {
          "type": "gauge",
          "description": "Number of queued requests.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.queued_requests": {
          "type": "gauge",
          "description": "Average number of queued requests.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.readahead_pages_sec": {
          "type": "gauge",
          "description": "Rate per second of read ahead pages.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.receives_from_replica_sec": {
          "type": "gauge",
          "description": "Rate receives from replicas per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.recovery_queue": {
          "type": "gauge",
          "description": "Size of recovery queue.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.redone_bytes_sec": {
          "type": "gauge",
          "description": "Rate of redone bytes per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.reduced_memory_grant_count": {
          "type": "gauge",
          "description": "Number of reduced memory grants.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.request_count": {
          "type": "gauge",
          "description": "Number of requests.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.requests_completed_sec": {
          "type": "gauge",
          "description": "Rate of completed requests per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.resent_messages_sec": {
          "type": "gauge",
          "description": "Rate of resent messages per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.sends_to_replica_sec": {
          "type": "gauge",
          "description": "Rate of sends to replicas per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.sends_to_transport_sec": {
          "type": "gauge",
          "description": "Rate of sends to transports per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.sql_compilations_sec": {
          "type": "gauge",
          "description": "Rate of sql compilations per second.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.sql_re-compilations_sec": {
          "type": "gauge",
          "description": "Rate of sql recompilations per sec.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.target_server_memory_kb": {
          "type": "gauge",
          "description": "Size of target server memory in KB.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.temp_tables_creation_rate": {
          "type": "gauge",
          "description": "Rate of temporary table creations.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.temp_tables_for_destruction": {
          "type": "gauge",
          "description": "Number of temporary tables marked for destruction.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.total_server_memory_kb": {
          "type": "gauge",
          "description": "Total server memory in KB.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.transaction_delay": {
          "type": "gauge",
          "description": "Number of delayed transactions.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.transactions_sec": {
          "type": "gauge",
          "description": "Rate of transactions per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.used_memory_kb": {
          "type": "gauge",
          "description": "Used memory in KB.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.user_connections": {
          "type": "gauge",
          "description": "Number of user connections.",
          "group": null,
          "default": true
        },
        "sqlserver_performance.version_store_size_kb": {
          "type": "gauge",
          "description": "Size of the version store in KB.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.write_transactions_sec": {
          "type": "gauge",
          "description": "Rate of write transactions per second.",
          "group": null,
          "default": false
        },
        "sqlserver_performance.xtp_memory_used_kb": {
          "type": "gauge",
          "description": "Size of xtp memory used in KB.",
          "group": null,
          "default": false
        },
        "sqlserver_server_properties.available_storage_mb": {
          "type": "gauge",
          "description": "Available storage in MB.",
          "group": null,
          "default": false
        },
        "sqlserver_server_properties.cpu_count": {
          "type": "gauge",
          "description": "Number of cpus.",
          "group": null,
          "default": false
        },
        "sqlserver_server_properties.db_offline": {
          "type": "gauge",
          "description": "Number of offline databases.",
          "group": null,
          "default": true
        },
        "sqlserver_server_properties.db_online": {
          "type": "gauge",
          "description": "Number of online databases.",
          "group": null,
          "default": true
        },
        "sqlserver_server_properties.db_recovering": {
          "type": "gauge",
          "description": "Number of databases recovering.",
          "group": null,
          "default": true
        },
        "sqlserver_server_properties.db_recoverypending": {
          "type": "gauge",
          "description": "Number of databases pending recovery.",
          "group": null,
          "default": true
        },
        "sqlserver_server_properties.db_restoring": {
          "type": "gauge",
          "description": "Number of databases restoring.",
          "group": null,
          "default": true
        },
        "sqlserver_server_properties.db_suspect": {
          "type": "gauge",
          "description": "Number of suspect databases.",
          "group": null,
          "default": true
        },
        "sqlserver_server_properties.engine_edition": {
          "type": "gauge",
          "description": "Sql server engine edition version.",
          "group": null,
          "default": false
        },
        "sqlserver_server_properties.server_memory": {
          "type": "gauge",
          "description": "Amount of memory on the sql server.",
          "group": null,
          "default": false
        },
        "sqlserver_server_properties.total_storage_mb": {
          "type": "gauge",
          "description": "Amount of storage in MB of the sql server.",
          "group": null,
          "default": false
        },
        "sqlserver_server_properties.uptime": {
          "type": "gauge",
          "description": "Uptime of the sql server.",
          "group": null,
          "default": false
        },
        "sqlserver_waitstats.max_wait_time_ms": {
          "type": "gauge",
          "description": "Maximum time in millisecond spent waiting.",
          "group": null,
          "default": false
        },
        "sqlserver_waitstats.resource_wait_ms": {
          "type": "gauge",
          "description": "Time in milliseconds spent waiting on a resource.",
          "group": null,
          "default": false
        },
        "sqlserver_waitstats.signal_wait_time_ms": {
          "type": "gauge",
          "description": "Time in milliseconds waiting on a signal.",
          "group": null,
          "default": false
        },
        "sqlserver_waitstats.wait_time_ms": {
          "type": "gauge",
          "description": "Time in milliseconds waiting.",
          "group": null,
          "default": false
        },
        "sqlserver_waitstats.waiting_tasks_count": {
          "type": "gauge",
          "description": "Time in milliseconds",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/telegraf/monitors/mssqlserver",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "userID",
            "doc": "UserID used to access the SQL Server instance.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password used to access the SQL Server instance.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "appName",
            "doc": "The app name used by the monitor when connecting to the SQLServer.",
            "default": "signalfxagent",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "queryVersion",
            "doc": "The version of queries to use when accessing the cluster. Please refer to the telegraf documentation for more information.",
            "default": 2,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "azureDB",
            "doc": "Whether the database is an azure database or not.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "excludedQueries",
            "doc": "Queries to exclude possible values are `PerformanceCounters`, `WaitStatsCategorized`, `DatabaseIO`, `DatabaseProperties`, `CPUHistory`, `DatabaseSize`, `DatabaseStats`, `MemoryClerk` `VolumeSpace`, and `PerformanceMetrics`.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "log",
            "doc": "Log level to use when accessing the database",
            "default": 1,
            "required": false,
            "type": "uint",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/statsd",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor acts as a Telegraf StatsD listener for receiving telegrafstatsd metrics.\nThis monitor is based on the Telegraf Statsd input plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/statsd).\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/statsd\n   protocol: udp\n   serviceAddress: \":8125\"\n   parseDataDogTags: true\n```\n\n```yaml\nmonitors:\n - type: telegraf/statsd\n   protocol: udp\n   serviceAddress: \"127.0.0.1:0\"\n   parseDataDogTags: true\n   metricSeparator: '.'\n```\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/telegraf/monitors/telegrafstatsd",
        "fields": [
          {
            "yamlName": "protocol",
            "doc": "Protocol to use with the listener: `tcp`, `udp4`, `udp6`, or `udp`.",
            "default": "udp",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceAddress",
            "doc": "The address and port to serve from",
            "default": ":8125",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "maxTCPConnections",
            "doc": "Maximum number of tcp connections allowed.",
            "default": 250,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "TCPKeepAlive",
            "doc": "Indicates whether to keep the tcp connection alive.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteGauges",
            "doc": "Whether to clear the gauge cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteCounters",
            "doc": "Whether to clear the counter cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteSets",
            "doc": "Whether to clear the sets cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteTimings",
            "doc": "Whether to clear the timings cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "percentiles",
            "doc": "The percentiles that are collected for timing and histogram stats.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "int"
          },
          {
            "yamlName": "allowedPendingMessages",
            "doc": "Number of messages allowed to queue up between each collection interval. Packets will be dropped until the next collection interval if this buffer fills up.",
            "default": 10000,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "percentileLimit",
            "doc": "The maximum number of histogram values to track each measurement when calculating percentiles. Increasing the limit will increase memory consumption but will also improve accuracy.",
            "default": 1000,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "metricSeparator",
            "doc": "The separator used to separate parts of a metric name",
            "default": "_",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "templates",
            "doc": "Templates that transform telegrafstatsd metrics into influx tags and measurements. Please refer to the Telegraf (documentation)[https://github.com/influxdata/telegraf/tree/master/plugins/inputs/statsd#statsd-bucket---influxdb-line-protocol-templates] for more information on templates.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "parseDataDogTags",
            "doc": "Indicates whether to parse dogstatsd tags",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/tail",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor is based on the Telegraf tail plugin.  The monitor tails files and\nnamed pipes.  The Telegraf parser configured with this monitor extracts metrics in different\n[formats](https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md)\nfrom the tailed output. More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/tail).\nAll metrics emitted from this monitor will have the `plugin` dimension set to `telegraf-tail`\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/tail\n   files:\n    - '/logs/**.log'       # find all .log files in /logs\n    - '/logs/*/*.log'      # find all .log files who are contained in a directory under /logs/\n    - '/var/log/agent.log' # tail the specified log file\n   watchMethod: inotify    # specify the file watch method (\"ionotify\" or \"poll\")\n```\n\nSample YAML configuration that specifies a parser:\n\n```yaml\nmonitors:\n - type: telegraf/tail\n   files:\n    - '/logs/**.log'       # find all .log files in /logs\n    - '/logs/*/*.log'      # find all .log files who are contained in a directory under /logs/\n    - '/var/log/agent.log' # tail the specified log file\n   watchMethod: inotify    # specify the file watch method (\"inotify\" or \"poll\")\n   telegrafParser:         # specify a parser\n     dataFormat: \"influx\"  # set the parser's dataFormat\n```\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/telegraf/monitors/tail",
        "fields": [
          {
            "yamlName": "files",
            "doc": "Paths to files to be tailed",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "watchMethod",
            "doc": "Method for watching changes to files (\"ionotify\" or \"poll\")",
            "default": "poll",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pipe",
            "doc": "Indicates if the file is a named pipe",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "fromBeginning",
            "doc": "Whether to start tailing from the beginning of the file",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "telegrafParser",
            "doc": "telegrafParser is a nested object that defines configurations for a Telegraf parser. Please refer to the Telegraf documentation for more information on Telegraf parsers.",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "Config",
              "doc": "Config implements Telegraf parsers.Config, but with SignalFx Smart Agent struct tags and a methods for returning a Telegraf parsers.Config struct and a Telegraf parsers.Parser. Please refer to Telegraf's documentation for more information about the different parsers and their specific configurations",
              "package": "pkg/monitors/telegraf/common/parser",
              "fields": [
                {
                  "yamlName": "dataFormat",
                  "doc": "dataFormat specifies a data format to parse: `json`, `value`, `influx`, `graphite`, `value`, `nagios`, `collectd`, `dropwizard`, `wavefront`, `grok`, `csv`, or `logfmt`.",
                  "default": "influx",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "defaultTags",
                  "doc": "defaultTags are tags that will be added to all metrics. (`json`, `value`, `graphite`, `collectd`, `dropwizard`, `wavefront`, `grok`, `csv` and `logfmt` only)",
                  "default": null,
                  "required": false,
                  "type": "map",
                  "elementKind": "string"
                },
                {
                  "yamlName": "metricName",
                  "doc": "metricName applies to (`json` and `value`). This will be the name of the measurement.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dataType",
                  "doc": "dataType specifies the value type to parse the value to: `integer`, `float`, `long`, `string`, or `boolean`. (`value` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONTagKeys",
                  "doc": "A list of tag names to fetch from JSON data. (`json` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "JSONStringFields",
                  "doc": "A list of fields in JSON to extract and use as string fields. (json only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "JSONNameKey",
                  "doc": "A path used to extract the metric name in JSON data.  (`json` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONQuery",
                  "doc": "A gjson path for json parser. (`json` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONTimeKey",
                  "doc": "The name of the timestamp key. (`json` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONTimeFormat",
                  "doc": "Specifies the timestamp format. (`json` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "separator",
                  "doc": "Separator for Graphite data. (`graphite` only).",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "templates",
                  "doc": "A list of templates for Graphite data. (`graphite` only).",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "collectdAuthFile",
                  "doc": "The path to the collectd authentication file (`collectd` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "collectdSecurityLevel",
                  "doc": "Specifies the security level: `none` (default), `sign`, or `encrypt`. (`collectd only`)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "collectdTypesDB",
                  "doc": "A list of paths to collectd TypesDB files. (`collectd` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "collectdSplit",
                  "doc": "Indicates whether to separate or join multivalue metrics. (`collectd` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardMetricRegistryPath",
                  "doc": "An optional gjson path used to locate a metric registry inside of JSON data. The default behavior is to consider the entire JSON document. (`dropwizard` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardTimePath",
                  "doc": "An optional gjson path used to identify the drop wizard metric timestamp. (`dropwizard` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardTimeFormat",
                  "doc": "The format used for parsing the drop wizard metric timestamp. The default format is time.RFC3339. (`dropwizard` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardTagsPath",
                  "doc": "An optional gjson path used to locate drop wizard tags. (`dropwizard` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardTagPathsMap",
                  "doc": "A map of gjson tag names and gjson paths used to extract tag values from the JSON document. This is only used if `dropwizardTagsPath` is not specified. (`dropwizard` only)",
                  "default": null,
                  "required": false,
                  "type": "map",
                  "elementKind": "string"
                },
                {
                  "yamlName": "grokPatterns",
                  "doc": "A list of patterns to match. (`grok` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "grokNamedPatterns",
                  "doc": "A list of named grok patterns to match.  (`grok` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "grokCustomPatterns",
                  "doc": "Custom grok patterns. (`grok` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "grokCustomPatternFiles",
                  "doc": "List of paths to custom grok pattern files. (`grok` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "grokTimezone",
                  "doc": "Specifies the timezone.  The default is UTC time.  Other options are `Local` for the local time on the machine, `UTC`, and `Canada/Eastern` (unix style timezones).  (`grok` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVDelimiter",
                  "doc": "The delimiter used between fields in the csv. (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVComment",
                  "doc": "The character used to mark rows as comments. (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVTrimSpace",
                  "doc": "Indicates whether to trim leading white from fields. (`csv` only)",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVColumnNames",
                  "doc": "List of custom column names.  All columns must have names.  Unnamed columns are ignored. This configuration must be set when `CSVHeaderRowCount` is 0. (`csv` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "CSVColumnTypes",
                  "doc": "List of types to assign to columns.  Acceptable values are `int`, `float`, `bool`, or `string` (`csv` only).",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "CSVTagColumns",
                  "doc": "List of columns that should be added as tags.  Unspecified columns will be added as fields. (`csv` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "CSVMeasurementColumn",
                  "doc": "The name of the column to extract the metric name from (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVTimestampColumn",
                  "doc": "The name of the column to extract the metric timestamp from. `CSVTimestampFormat` must be set when using this option.  (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVTimestampFormat",
                  "doc": "The format to use for extracting timestamps. (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVHeaderRowCount",
                  "doc": "The number of rows that are headers.  By default no rows are treated as headers.  (`csv` only)",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVSkipRows",
                  "doc": "The number of rows to ignore before looking for headers. (`csv` only)",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVSkipColumns",
                  "doc": "The number of columns to ignore before parsing data on a given row. (`csv` only)",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/win_perf_counters",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reads Windows performance\ncounters\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/win_perf_counters\n   printValid: true\n   objects:\n    - objectName: \"Processor\"\n      instances:\n       - \"*\"\n      counters:\n       - \"% Idle Time\"\n       - \"% Interrupt Time\"\n       - \"% Privileged Time\"\n       - \"% User Time\"\n       - \"% Processor Time\"\n      includeTotal: true\n      measurement: \"win_cpu\"\n```\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/telegraf/monitors/winperfcounters",
        "fields": [
          {
            "yamlName": "objects",
            "doc": "",
            "default": "",
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "PerfCounterObj",
              "doc": "PerfCounterObj represents a windows performance counter object to monitor",
              "package": "pkg/monitors/telegraf/monitors/winperfcounters",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "The name of a windows performance counter object",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "counters",
                  "doc": "The name of the counters to collect from the performance counter object",
                  "default": "",
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "instances",
                  "doc": "The windows performance counter instances to fetch for the performance counter object",
                  "default": "",
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "measurement",
                  "doc": "The name of the telegraf measurement that will be used as a metric name",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "warnOnMissing",
                  "doc": "Log a warning if the perf counter object is missing",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "failOnMissing",
                  "doc": "Panic if the performance counter object is missing (this will stop the agent)",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "includeTotal",
                  "doc": "Include the total instance when collecting performance counter metrics",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "counterRefreshInterval",
            "doc": "The frequency that counter paths should be expanded and how often to refresh counters from configuration. This is expressed as a duration.",
            "default": "5s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "useWildCardExpansion",
            "doc": "If `true`, instance indexes will be included in instance names, and wildcards will be expanded and localized (if applicable).  If `false`, non partial wildcards will be expanded and instance names will not include instance indexes.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "Print out the configurations that match available performance counters",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "pcrMetricNames",
            "doc": "If `true`, metric names will be emitted in the format emitted by the SignalFx PerfCounterReporter",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/win_services",
      "sendAll": true,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics about Windows services.\nThis monitor is based on the Telegraf win_services plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/win_services).\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/win_services  # monitor all services\n```\n\n```yaml\nmonitors:\n - type: telegraf/win_services\n   serviceNames:\n     - exampleService1  # only monitor exampleService1\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "win_services.startup_mode",
            "win_services.state"
          ]
        }
      },
      "metrics": {
        "win_services.startup_mode": {
          "type": "gauge",
          "description": "The configured start up mode of the window windows service.  Possible values are: `0` (Boot Start), `1` (System Start), `2` (Auto Start), `3` (Demand Start), `4` (disabled).",
          "group": null,
          "default": false
        },
        "win_services.state": {
          "type": "gauge",
          "description": "The state of the windows service.  Possible values are: `1` (Stopped), `2` (Start Pending), `3` (Stop Pending), `4` (Running), `5` (Continue Pending), `6` (Pause Pending), and `7` (Paused).",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/telegraf/monitors/winservices",
        "fields": [
          {
            "yamlName": "serviceNames",
            "doc": "Names of services to monitor.  All services will be monitored if none are specified.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "trace-forwarder",
      "sendAll": false,
      "dimensions": null,
      "doc": "Runs an HTTP server that listens for trace spans\nand forwards them to SignalFx (or the configured ingest host in the `writer`\nsection of the agent config).  This supports the same span formats that our\ningest server supports and at the same path (`/v1/trace`).  By default, the\nserver listens on localhost port 9080 but can be configured to anything.\n",
      "groups": {},
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/traceforwarder",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host:port on which to listen for datapoints.  The listening server accepts datapoints on the same HTTP path that ingest/gateway accepts them (e.g. `/v2/datapoint`, `/v1/trace`).  Requests to other paths will return 404s.",
            "default": "127.0.0.1:9080",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serverTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "5s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "sendInternalMetrics",
            "doc": "Whether to emit internal metrics about the HTTP listener",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "traefik",
      "sendAll": false,
      "dimensions": null,
      "doc": "Traefik is an open-source HTTP reverse proxy and load balancer. Traefik exports Prometheus metrics that can be\nscraped by the SignalFx Smart Agent. These metrics can be categorized into Traefik-related, entrypoint-related and\nbackend-related metrics. The Traefik-related metrics are prefixed by `go_` and `process_`. The entrypoint-related\nmetrics are prefixed by `traefik_entrypoint_` and the backend-related metrics prefixed by `traefik_backend_`.\n\nThe Traefik-related metrics are for monitoring Traefik itself. For instance, the `go_memstats_sys_bytes` metric can\nbe used to plot Traefik memory usage. The entrypoint-related and backend-related metrics are the number and duration\nof requests measured at entrypoints and backends. These metrics are used to compute measurements such as the average\nrequest duration.\n\n## Requirements and Dependencies\n\n| Software          | Version        |\n|-------------------|----------------|\n| signalfx-agent    |     4.7.0+     |\n\n## Traefik Configuration\n\nEdit the Traefik configuration file, typically `traefik.toml`, to enable Traefik to expose prometheus metrics at an\nendpoint. The endpoint is on path `/metrics` by default. When running the Traefik binary, the configuration file is\ntypically passed in as a command line argument. For example,\n\n`./traefik -c traefik.toml`\n\nHowever, when running the Traefik Docker image, the configuration file is mounted to volume\n`/etc/traefik/traefik.toml`. For example,\n\n`docker run -d -p 8080:8080 -p 80:80 -v $PWD/traefik.toml:/etc/traefik/traefik.toml`\n\nIf the Traefik configuration file is not available use the sample configuration file\n\u003ca target=\"_blank\" href=\"https://raw.githubusercontent.com/containous/traefik/master/traefik.sample.toml\"\u003ehere\u003c/a\u003e\nto get started.\n\nSee \u003ca target=\"_blank\" href=\"https://docs.traefik.io/\"\u003ehere\u003c/a\u003e for complete Traefik docs.\n\n## Smart Agent Configuration\n\nSignalFx Smart Agent docs can be found \u003ca target=\"_blank\" href=\"https://github.com/signalfx/signalfx-agent\"\u003ehere\u003c/a\u003e.\nChoose deployment specific configuration instruction\n\u003ca target=\"_blank\" href=\"https://github.com/signalfx/signalfx-agent/tree/master/deployments\"\u003ehere\u003c/a\u003e. The\nSignalFx Smart Agent must have network access to Traefik.\n\nBelow is an example configuration that enables the traefik monitor. For the given configuration below, the monitor\nwill scrape Prometheus metrics in the default path `/metrics` on port 8080, add dimension\n`metric_source=traefik` to the metrics and export them to SignalFx.\n\n```\nmonitors:\n- type: traefik\n  discoveryRule: port == 8080\n  extraDimensions:\n    metric_source: traefik\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "go_gc_duration_seconds",
            "go_gc_duration_seconds_count",
            "go_gc_duration_seconds_sum",
            "go_goroutines",
            "go_memstats_alloc_bytes",
            "go_memstats_alloc_bytes_total",
            "go_memstats_buck_hash_sys_bytes",
            "go_memstats_frees_total",
            "go_memstats_gc_cpu_fraction",
            "go_memstats_gc_sys_bytes",
            "go_memstats_heap_alloc_bytes",
            "go_memstats_heap_idle_bytes",
            "go_memstats_heap_inuse_bytes",
            "go_memstats_heap_objects",
            "go_memstats_heap_released_bytes",
            "go_memstats_heap_sys_bytes",
            "go_memstats_last_gc_time_seconds",
            "go_memstats_lookups_total",
            "go_memstats_mallocs_total",
            "go_memstats_mcache_inuse_bytes",
            "go_memstats_mcache_sys_bytes",
            "go_memstats_mspan_inuse_bytes",
            "go_memstats_mspan_sys_bytes",
            "go_memstats_next_gc_bytes",
            "go_memstats_other_sys_bytes",
            "go_memstats_stack_inuse_bytes",
            "go_memstats_stack_sys_bytes",
            "go_memstats_sys_bytes",
            "go_threads",
            "process_cpu_seconds_total",
            "process_max_fds",
            "process_open_fds",
            "process_resident_memory_bytes",
            "process_start_time_seconds",
            "process_virtual_memory_bytes",
            "traefik_backend_open_connections",
            "traefik_backend_request_duration_seconds_bucket",
            "traefik_backend_request_duration_seconds_count",
            "traefik_backend_request_duration_seconds_sum",
            "traefik_backend_requests_total",
            "traefik_backend_server_up",
            "traefik_config_last_reload_failure",
            "traefik_config_last_reload_success",
            "traefik_config_reloads_failure_total",
            "traefik_config_reloads_total",
            "traefik_entrypoint_open_connections",
            "traefik_entrypoint_request_duration_seconds_bucket",
            "traefik_entrypoint_request_duration_seconds_count",
            "traefik_entrypoint_request_duration_seconds_sum",
            "traefik_entrypoint_requests_total"
          ]
        }
      },
      "metrics": {
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations.",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A count of the GC invocation durations.",
          "group": null,
          "default": false
        },
        "go_gc_duration_seconds_sum": {
          "type": "cumulative",
          "description": "The sum of the GC invocation durations, in seconds.",
          "group": null,
          "default": false
        },
        "go_goroutines": {
          "type": "cumulative",
          "description": "Number of goroutines that currently exist.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed.",
          "group": null,
          "default": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table.",
          "group": null,
          "default": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started.",
          "group": null,
          "default": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS.",
          "group": null,
          "default": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Length of time since last garbage collection, in seconds since unix epoch.",
          "group": null,
          "default": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups.",
          "group": null,
          "default": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures.",
          "group": null,
          "default": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system.",
          "group": null,
          "default": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place.",
          "group": null,
          "default": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator.",
          "group": null,
          "default": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system.",
          "group": null,
          "default": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created",
          "group": null,
          "default": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent, in seconds.",
          "group": null,
          "default": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors.",
          "group": null,
          "default": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes.",
          "group": null,
          "default": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds.",
          "group": null,
          "default": true
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes.",
          "group": null,
          "default": false
        },
        "traefik_backend_open_connections": {
          "type": "gauge",
          "description": "How many open connections exist on a backend, partitioned by method and protocol.",
          "group": null,
          "default": true
        },
        "traefik_backend_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The sum of request durations that are within a configured time interval. The request durations are measured at a backend in seconds. This value is partitioned by status code, protocol, and method.",
          "group": null,
          "default": false
        },
        "traefik_backend_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "The number of request durations that were measured on a backend. The values are partitioned by status code, protocol, and method.",
          "group": null,
          "default": false
        },
        "traefik_backend_request_duration_seconds_sum": {
          "type": "cumulative",
          "description": "The sum of the request durations in seconds, measured on a backend, partitioned by status code, protocol, and method.",
          "group": null,
          "default": true
        },
        "traefik_backend_requests_total": {
          "type": "cumulative",
          "description": "How many HTTP requests were processed on a backend, partitioned by status code, protocol, and method.",
          "group": null,
          "default": true
        },
        "traefik_backend_server_up": {
          "type": "gauge",
          "description": "Backend server is up, described by gauge value of 0 (down) or 1 (up).",
          "group": null,
          "default": true
        },
        "traefik_config_last_reload_failure": {
          "type": "gauge",
          "description": "Last config reload failure",
          "group": null,
          "default": false
        },
        "traefik_config_last_reload_success": {
          "type": "gauge",
          "description": "Last config reload success",
          "group": null,
          "default": false
        },
        "traefik_config_reloads_failure_total": {
          "type": "cumulative",
          "description": "Total number of config reloads that failed",
          "group": null,
          "default": false
        },
        "traefik_config_reloads_total": {
          "type": "cumulative",
          "description": "Config reloads",
          "group": null,
          "default": false
        },
        "traefik_entrypoint_open_connections": {
          "type": "gauge",
          "description": "How many open connections exist on an entrypoint, partitioned by method and protocol.",
          "group": null,
          "default": true
        },
        "traefik_entrypoint_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The sum of request durations that are within a configured time interval. The request durations are measured at an entrypoint in seconds. This value is partitioned by status code, protocol, and method.",
          "group": null,
          "default": false
        },
        "traefik_entrypoint_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "The number of request durations that were measured on an entrypoint. The values are partitioned by status code, protocol, and method.",
          "group": null,
          "default": true
        },
        "traefik_entrypoint_request_duration_seconds_sum": {
          "type": "cumulative",
          "description": "The sum of the request durations in seconds measured on an entrypoint, partitioned by status code, protocol, and method.",
          "group": null,
          "default": true
        },
        "traefik_entrypoint_requests_total": {
          "type": "cumulative",
          "description": "How many HTTP requests processed on an entrypoint, partitioned by status code, protocol, and method.",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/traefik",
        "fields": [
          {
            "yamlName": "httpTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "10s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertPath",
            "doc": "Path to the CA cert that has signed the TLS cert, unnecessary if `skipVerify` is set to false.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertPath",
            "doc": "Path to the client TLS cert to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKeyPath",
            "doc": "Path to the client TLS key to use for TLS required connections",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useServiceAccount",
            "doc": "Use pod service account to authenticate.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "vmem",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects information about the virtual memory\nsubsystem of the kernel.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: vmem\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "vmpage.swap.in_per_second",
            "vmpage.swap.out_per_second",
            "vmpage.swap.total.per_second",
            "vmpage_faults.majflt",
            "vmpage_faults.minflt",
            "vmpage_io.memory.in",
            "vmpage_io.memory.out",
            "vmpage_io.swap.in",
            "vmpage_io.swap.out",
            "vmpage_number.free_pages",
            "vmpage_number.mapped",
            "vmpage_number.shmem_pmdmapped"
          ]
        }
      },
      "metrics": {
        "vmpage.swap.in_per_second": {
          "type": "gauge",
          "description": "(Windows Only)",
          "group": null,
          "default": false
        },
        "vmpage.swap.out_per_second": {
          "type": "gauge",
          "description": "(Windows Only)",
          "group": null,
          "default": false
        },
        "vmpage.swap.total.per_second": {
          "type": "gauge",
          "description": "(Windows Only)",
          "group": null,
          "default": false
        },
        "vmpage_faults.majflt": {
          "type": "cumulative",
          "description": "(Linux Only) Number of major page faults on the system",
          "group": null,
          "default": false
        },
        "vmpage_faults.minflt": {
          "type": "cumulative",
          "description": "(Linux Only) Number of minor page faults on the system",
          "group": null,
          "default": false
        },
        "vmpage_io.memory.in": {
          "type": "cumulative",
          "description": "(Linux Only) Page Ins for Memory",
          "group": null,
          "default": false
        },
        "vmpage_io.memory.out": {
          "type": "cumulative",
          "description": "(Linux Only) Page Outs for Memory",
          "group": null,
          "default": false
        },
        "vmpage_io.swap.in": {
          "type": "cumulative",
          "description": "(Linux Only) Page Ins for Swap",
          "group": null,
          "default": true
        },
        "vmpage_io.swap.out": {
          "type": "cumulative",
          "description": "(Linux Only) Page Outs for Swap",
          "group": null,
          "default": true
        },
        "vmpage_number.free_pages": {
          "type": "gauge",
          "description": "(Linux Only) Number of free memory pages",
          "group": null,
          "default": false
        },
        "vmpage_number.mapped": {
          "type": "gauge",
          "description": "(Linux Only) Number of mapped pages",
          "group": null,
          "default": false
        },
        "vmpage_number.shmem_pmdmapped": {
          "type": "gauge",
          "description": "(Linux Only) The amount of shared (shmem/tmpfs) memory backed by huge pages",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/vmem",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) The frequency that wildcards in counter paths should be expanded and how often to refresh counters from configuration. This is expressed as a duration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "vsphere",
      "sendAll": false,
      "dimensions": {
        "cluster": {
          "description": "If the metric's host or virtual machine is attached to a cluster, the name of the cluster."
        },
        "datacenter": {
          "description": "The name of the datacenter to which the metric pertains."
        },
        "esx_ip": {
          "description": "The IP address of the ESX host to which the metric pertains."
        },
        "guest_family": {
          "description": "For virtual machine metrics, the guest operating system family for the virtual machine to which this metric pertains. For example 'linuxGuest'."
        },
        "guest_fullname": {
          "description": "For virtual machine metrics, the full name of the guest operating system for the virtual machine to which the metric pertains. For example 'Windows 2000 Professional'."
        },
        "guest_id": {
          "description": "For virtual machine metrics, the guest identifier of the virtual machine to which the metric pertains."
        },
        "object": {
          "description": "For some metrics, the source of the metric. For example, the identifier of a NIC for a network metric, or the processor number for a CPU metric."
        },
        "object_type": {
          "description": "The type of the resource to which the metric pertains. Values can be 'VirtualMachine' for a VM, or 'HostSystem' for an ESX host."
        },
        "ref_id": {
          "description": "The unique vCenter identifier for the resource to which the metric pertains."
        },
        "vcenter": {
          "description": "The hostname of the vCenter server to which the monitor is connected."
        },
        "vm_ip": {
          "description": "For virtual machine metrics, the IP address of the virtual machine to which this metric pertains."
        },
        "vm_name": {
          "description": "For virtual machine metrics, the name of the virtual machine to which the metric pertains."
        }
      },
      "doc": "A VMware vSphere deployment includes physical hosts, ESXi hypervisors, virtual machines, and vCenter Server.\nThis monitor reports metrics for a vSphere deployment by logging into a vCenter Server and periodically\nretrieving data about the deployment and its real time performance data.\n\nWhen this monitor starts up, it logs into vCenter Server and traverses the inventory, gathering and caching all of\nthe hosts and virtual machines, and their available metrics.\n\nThen it periodically queries the vCenter for the performance data for those metrics. It does so at a rate of\nonce every 20 seconds, the interval at which vCenter makes real-time performance data avaialable.\n\nBecause the 20 second interval for real-time metrics is fixed by vSphere, this monitor runs every 20 seconds,\nregardless of the IntervalSeconds value in the agent config.\n\nIt also refreshes, at a configurable interval, the cache of hosts, virtual machines, and metrics. By default,\nit does this every 60 seconds, but this interval can be changed by updating the configuration field\n`InventoryRefreshInterval`.\n\nCompatibility:\nThis monitor uses VMware's govmomi SDK, which is built for and tested against vCenter 6.0, 6.5 and 6.7.\nIt may work with versions 5.5 and 5.1, but neither are officially supported.\n\nSample YAML configuration:\n```yaml\nmonitors:\n  - type: vsphere\n    host: \"172.16.248.140\"\n    username: \"administrator@vsphere.local\"\n    password: \"S3cr3t\"\n    insecureSkipVerify: true\n```\n",
      "groups": {
        "cpu": {
          "description": "CPU utilization",
          "metrics": [
            "vsphere.cpu_core_utilization_percent",
            "vsphere.cpu_costop_ms",
            "vsphere.cpu_demand_entitlement_ratio_percent",
            "vsphere.cpu_demand_mhz",
            "vsphere.cpu_entitlement_mhz",
            "vsphere.cpu_idle_ms",
            "vsphere.cpu_latency_percent",
            "vsphere.cpu_maxlimited_ms",
            "vsphere.cpu_overlap_ms",
            "vsphere.cpu_readiness_percent",
            "vsphere.cpu_ready_ms",
            "vsphere.cpu_reservedCapacity_mhz",
            "vsphere.cpu_run_ms",
            "vsphere.cpu_swapwait_ms",
            "vsphere.cpu_system_ms",
            "vsphere.cpu_totalCapacity_mhz",
            "vsphere.cpu_usage_percent",
            "vsphere.cpu_usagemhz",
            "vsphere.cpu_used_percent",
            "vsphere.cpu_utilization_percent",
            "vsphere.cpu_wait_ms"
          ]
        },
        "datastore": {
          "description": "I/O operations on datastores",
          "metrics": [
            "vsphere.datastore_datastore_iops",
            "vsphere.datastore_max_total_latency_ms",
            "vsphere.datastore_read_kbs",
            "vsphere.datastore_read_load_metric",
            "vsphere.datastore_size_normalized_datastore_latency_ms",
            "vsphere.datastore_total_read_latency_ms",
            "vsphere.datastore_total_write_latency_ms",
            "vsphere.datastore_vmobserved_latency_ms",
            "vsphere.datastore_write_kbs",
            "vsphere.datastore_write_load_metric"
          ]
        },
        "disk": {
          "description": "I/O performance (such as latency and read- and write-speeds), and utilization",
          "metrics": [
            "vsphere.disk_bus_resets",
            "vsphere.disk_commands",
            "vsphere.disk_commands_aborted",
            "vsphere.disk_commands_averaged",
            "vsphere.disk_device_latency_ms",
            "vsphere.disk_device_read_latency_ms",
            "vsphere.disk_device_write_latency_ms",
            "vsphere.disk_kernel_latency_ms",
            "vsphere.disk_kernel_read_latency_ms",
            "vsphere.disk_kernel_write_latency_ms",
            "vsphere.disk_max_queue_depth",
            "vsphere.disk_max_total_latency_ms",
            "vsphere.disk_number_read",
            "vsphere.disk_number_read_averaged",
            "vsphere.disk_number_write",
            "vsphere.disk_number_write_averaged",
            "vsphere.disk_queue_latency_ms",
            "vsphere.disk_queue_read_latency_ms",
            "vsphere.disk_queue_write_latency_ms",
            "vsphere.disk_read_kbs",
            "vsphere.disk_total_latency_ms",
            "vsphere.disk_total_read_latency_ms",
            "vsphere.disk_total_write_latency_ms",
            "vsphere.disk_usage_kbs",
            "vsphere.disk_write_kbs"
          ]
        },
        "hbr": {
          "description": "Host-based replication",
          "metrics": [
            "vsphere.hbr_net_rx_kbs",
            "vsphere.hbr_net_tx_kbs",
            "vsphere.hbr_num_vms"
          ]
        },
        "mem": {
          "description": "Guest physical memory for VMs and machine memory for hosts",
          "metrics": [
            "vsphere.mem_active_kb",
            "vsphere.mem_activewrite_kb",
            "vsphere.mem_compressed_kb",
            "vsphere.mem_compression_rate_kbs",
            "vsphere.mem_consumed_kb",
            "vsphere.mem_decompression_rate_kbs",
            "vsphere.mem_entitlement_kb",
            "vsphere.mem_granted_kb",
            "vsphere.mem_heap_kb",
            "vsphere.mem_heapfree_kb",
            "vsphere.mem_latency_percent",
            "vsphere.mem_ll_swap_in_kb",
            "vsphere.mem_ll_swap_in_rate_kbs",
            "vsphere.mem_ll_swap_out_kb",
            "vsphere.mem_ll_swap_out_rate_kbs",
            "vsphere.mem_ll_swap_used_kb",
            "vsphere.mem_lowfreethreshold_kb",
            "vsphere.mem_overhead_kb",
            "vsphere.mem_overhead_max_kb",
            "vsphere.mem_overhead_touched_kb",
            "vsphere.mem_reserved_capacity_mb",
            "vsphere.mem_shared_kb",
            "vsphere.mem_sharedcommon_kb",
            "vsphere.mem_state",
            "vsphere.mem_swapin_kb",
            "vsphere.mem_swapin_rate_kbs",
            "vsphere.mem_swapout_kb",
            "vsphere.mem_swapout_rate_kbs",
            "vsphere.mem_swapped_kb",
            "vsphere.mem_swaptarget_kb",
            "vsphere.mem_swapused_kb",
            "vsphere.mem_sys_usage_kb",
            "vsphere.mem_total_capacity_mb",
            "vsphere.mem_unreserved_kb",
            "vsphere.mem_usage_percent",
            "vsphere.mem_vmfs_pbc_cap_miss_ratio_percent",
            "vsphere.mem_vmfs_pbc_overhead_kb",
            "vsphere.mem_vmfs_pbc_size_max_mb",
            "vsphere.mem_vmfs_pbc_size_mb",
            "vsphere.mem_vmfs_pbc_working_set_max_tb",
            "vsphere.mem_vmfs_pbc_working_set_tb",
            "vsphere.mem_vmmemctl_kb",
            "vsphere.mem_vmmemctltarget_kb",
            "vsphere.mem_zero_kb",
            "vsphere.mem_zip_saved_kb",
            "vsphere.mem_zipped_kb"
          ]
        },
        "net": {
          "description": "Physical and virtual NICs and other network devices, such as virtual switches",
          "metrics": [
            "vsphere.net_broadcast_rx",
            "vsphere.net_broadcast_tx",
            "vsphere.net_bytes_rx_kbs",
            "vsphere.net_bytes_tx_kbs",
            "vsphere.net_dropped_rx",
            "vsphere.net_dropped_tx",
            "vsphere.net_errors_rx",
            "vsphere.net_errors_tx",
            "vsphere.net_multicast_rx",
            "vsphere.net_multicast_tx",
            "vsphere.net_packets_rx",
            "vsphere.net_packets_tx",
            "vsphere.net_received_kbs",
            "vsphere.net_transmitted_kbs",
            "vsphere.net_unknown_protos",
            "vsphere.net_usage_kbs"
          ]
        },
        "power": {
          "description": "Power resources",
          "metrics": [
            "vsphere.power_cap_watts",
            "vsphere.power_energy_joules",
            "vsphere.power_watts"
          ]
        },
        "rescpu": {
          "description": "CPU-load-history statistics about resource pools and virtual machines",
          "metrics": [
            "vsphere.rescpu_actav1",
            "vsphere.rescpu_actav15_percent",
            "vsphere.rescpu_actav5_percent",
            "vsphere.rescpu_actpk15_percent",
            "vsphere.rescpu_actpk1_percent",
            "vsphere.rescpu_actpk5_percent",
            "vsphere.rescpu_max_limited15_percent",
            "vsphere.rescpu_max_limited1_percent",
            "vsphere.rescpu_max_limited5_percent",
            "vsphere.rescpu_runav15_percent",
            "vsphere.rescpu_runav1_percent",
            "vsphere.rescpu_runav5_percent",
            "vsphere.rescpu_runpk15_percent",
            "vsphere.rescpu_runpk1_percent",
            "vsphere.rescpu_runpk5_percent",
            "vsphere.rescpu_sample_count",
            "vsphere.rescpu_sample_period_ms"
          ]
        },
        "storage_adapter": {
          "description": "I/O operations on storage adapters",
          "metrics": [
            "vsphere.storage_adapter_commands_averaged",
            "vsphere.storage_adapter_max_total_latency_ms",
            "vsphere.storage_adapter_number_read_averaged",
            "vsphere.storage_adapter_number_write_averaged",
            "vsphere.storage_adapter_read_kbs",
            "vsphere.storage_adapter_total_read_latency_ms",
            "vsphere.storage_adapter_total_write_latency_ms",
            "vsphere.storage_adapter_write_kbs"
          ]
        },
        "storage_path": {
          "description": "I/O operations on a storage path",
          "metrics": [
            "vsphere.storage_path_commands_averaged",
            "vsphere.storage_path_max_total_latency_ms",
            "vsphere.storage_path_number_read_averaged",
            "vsphere.storage_path_number_write_averaged",
            "vsphere.storage_path_read_kbs",
            "vsphere.storage_path_total_read_latency_ms",
            "vsphere.storage_path_total_write_latency_ms",
            "vsphere.storage_path_write_kbs"
          ]
        },
        "sys": {
          "description": "Overall system availability",
          "metrics": [
            "vsphere.sys_heartbeat",
            "vsphere.sys_os_uptime_seconds",
            "vsphere.sys_resource_cpu_act1_percent",
            "vsphere.sys_resource_cpu_act5",
            "vsphere.sys_resource_cpu_alloc_min_mhz",
            "vsphere.sys_resource_cpu_alloc_shares",
            "vsphere.sys_resource_cpu_max_limited1_percent",
            "vsphere.sys_resource_cpu_max_limited5_percent",
            "vsphere.sys_resource_cpu_run1_percent",
            "vsphere.sys_resource_cpu_run5_percent",
            "vsphere.sys_resource_cpu_usage_mhz",
            "vsphere.sys_resource_fd_usage",
            "vsphere.sys_resource_mem_alloc_max_kb",
            "vsphere.sys_resource_mem_alloc_min_kb",
            "vsphere.sys_resource_mem_alloc_shares",
            "vsphere.sys_resource_mem_consumed_kb",
            "vsphere.sys_resource_mem_cow_kb",
            "vsphere.sys_resource_mem_mapped_kb",
            "vsphere.sys_resource_mem_overhead_kb",
            "vsphere.sys_resource_mem_shared_kb",
            "vsphere.sys_resource_mem_swapped_kb",
            "vsphere.sys_resource_mem_touched_kb",
            "vsphere.sys_resource_mem_zero_kb",
            "vsphere.sys_uptime_seconds"
          ]
        },
        "virtual_disk": {
          "description": "I/O operations on virtual disks",
          "metrics": [
            "vsphere.virtual_disk_large_seeks",
            "vsphere.virtual_disk_medium_seeks",
            "vsphere.virtual_disk_number_read_averaged",
            "vsphere.virtual_disk_number_write_averaged",
            "vsphere.virtual_disk_read_iosize",
            "vsphere.virtual_disk_read_kbs",
            "vsphere.virtual_disk_read_latency_us",
            "vsphere.virtual_disk_read_load_metric",
            "vsphere.virtual_disk_read_oio",
            "vsphere.virtual_disk_small_seeks",
            "vsphere.virtual_disk_total_read_latency_ms",
            "vsphere.virtual_disk_total_write_latency_ms",
            "vsphere.virtual_disk_write_iosize",
            "vsphere.virtual_disk_write_kbs",
            "vsphere.virtual_disk_write_latency_us",
            "vsphere.virtual_disk_write_load_metric",
            "vsphere.virtual_disk_write_oio"
          ]
        }
      },
      "metrics": {
        "vsphere.cpu_core_utilization_percent": {
          "type": "gauge",
          "description": "CPU utilization of the corresponding core as a percentage during the interval.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_costop_ms": {
          "type": "counter",
          "description": "Time the virtual machine is ready to run, but is unable to run due to co-scheduling constraints.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_demand_entitlement_ratio_percent": {
          "type": "gauge",
          "description": "CPU resource entitlement to CPU demand ratio.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_demand_mhz": {
          "type": "counter",
          "description": "The amount of CPU resources a virtual machine would use if there were no CPU contention or CPU limit.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_entitlement_mhz": {
          "type": "gauge",
          "description": "CPU resources devoted by the ESXi scheduler.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_idle_ms": {
          "type": "counter",
          "description": "Total time that the CPU spent in an idle state.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_latency_percent": {
          "type": "gauge",
          "description": "Percent of time the virtual machine is unable to run because it is contending for access to the physical CPU(s).",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_maxlimited_ms": {
          "type": "counter",
          "description": "Time the virtual machine is ready to run, but is not running because it has reached its maximum CPU limit setting.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_overlap_ms": {
          "type": "counter",
          "description": "Time the virtual machine was interrupted to perform system services on behalf of itself or other virtual machines.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_readiness_percent": {
          "type": "gauge",
          "description": "Percentage of time that the virtual machine was ready, but could not get scheduled to run on the physical CPU.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_ready_ms": {
          "type": "counter",
          "description": "Time that the virtual machine was ready, but could not get scheduled to run on the physical CPU during last measurement interval. CPU ready time is dependent on the number of virtual machines on the host and their CPU loads.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_reservedCapacity_mhz": {
          "type": "gauge",
          "description": "Total CPU capacity reserved by virtual machines.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_run_ms": {
          "type": "counter",
          "description": "Time the virtual machine is scheduled to run",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_swapwait_ms": {
          "type": "gauge",
          "description": "CPU time spent waiting for swap-in.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_system_ms": {
          "type": "counter",
          "description": "Amount of time spent on system processes on each virtual CPU in the virtual machine.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_totalCapacity_mhz": {
          "type": "gauge",
          "description": "Total CPU capacity reserved by and available for virtual machines",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_usage_percent": {
          "type": "gauge",
          "description": "CPU usage as a percentage during the interval.",
          "group": "cpu",
          "default": true
        },
        "vsphere.cpu_usagemhz": {
          "type": "gauge",
          "description": "CPU usage, as measured in megahertz, during the interval.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_used_percent": {
          "type": "counter",
          "description": "Time accounted to the virtual machine.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_utilization_percent": {
          "type": "gauge",
          "description": "CPU utilization as a percentage during the interval. CPU usage and CPU utilization might be different due to power management technologies or hyper-threading.",
          "group": "cpu",
          "default": false
        },
        "vsphere.cpu_wait_ms": {
          "type": "counter",
          "description": "Total CPU time spent in wait state. The wait total includes time spent the CPU Idle, CPU Swap Wait, and CPU I/O Wait states.",
          "group": "cpu",
          "default": false
        },
        "vsphere.datastore_datastore_iops": {
          "type": "gauge",
          "description": "Average amount of time for an I/O operation to the datastore or LUN across all ESX hosts accessing it.",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_max_total_latency_ms": {
          "type": "gauge",
          "description": "Highest latency value across all datastores used by the host.",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_read_kbs": {
          "type": "gauge",
          "description": "Rate of reading data from the datastore (kilobytes per second)",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_read_load_metric": {
          "type": "gauge",
          "description": "Storage DRS datastore metric for read workload model.",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_size_normalized_datastore_latency_ms": {
          "type": "gauge",
          "description": "Storage I/O Control size-normalized I/O latency.",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_total_read_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time for a read operation from the vsphere datastore. Total latency = kernel latency + device latency.",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_total_write_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time for a write operation to the vsphere datastore. Total latency = kernel latency + device latency.",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_vmobserved_latency_ms": {
          "type": "gauge",
          "description": "The average datastore latency as seen by virtual machines.",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_write_kbs": {
          "type": "gauge",
          "description": "Rate of writing data to the datastore.",
          "group": "datastore",
          "default": false
        },
        "vsphere.datastore_write_load_metric": {
          "type": "gauge",
          "description": "Storage DRS datastore metric for write workload model.",
          "group": "datastore",
          "default": false
        },
        "vsphere.disk_bus_resets": {
          "type": "counter",
          "description": "Number of SCSI-bus reset commands issued during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_commands": {
          "type": "counter",
          "description": "Number of SCSI commands issued during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_commands_aborted": {
          "type": "counter",
          "description": "Number of SCSI commands aborted during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_commands_averaged": {
          "type": "gauge",
          "description": "Average number of SCSI commands issued per second during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_device_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time, in milliseconds, to complete a SCSI command from the physical device.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_device_read_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time, in milliseconds, to read from the physical device.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_device_write_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time, in milliseconds, to write to the physical device.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_kernel_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time, in milliseconds, spent by VMkernel to process each SCSI command.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_kernel_read_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time, in milliseconds, spent by VMkernel to process each SCSI read command.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_kernel_write_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time, in milliseconds, spent by VMkernel to process each SCSI write command.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_max_queue_depth": {
          "type": "gauge",
          "description": "Maximum queue depth.",
          "group": "disk",
          "default": true
        },
        "vsphere.disk_max_total_latency_ms": {
          "type": "gauge",
          "description": "Highest latency value across all disks used by the host.",
          "group": "disk",
          "default": true
        },
        "vsphere.disk_number_read": {
          "type": "counter",
          "description": "Number of disk reads during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_number_read_averaged": {
          "type": "gauge",
          "description": "Average number of read commands issued per second to the datastore during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_number_write": {
          "type": "counter",
          "description": "Number of disk writes during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_number_write_averaged": {
          "type": "gauge",
          "description": "Average number of write commands issued per second to the datastore during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_queue_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time spent in the VMkernel queue, per SCSI command, during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_queue_read_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time spent in the VMkernel queue, per SCSI read command, during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_queue_write_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time spent in the VMkernel queue, per SCSI write command, during the collection interval.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_read_kbs": {
          "type": "gauge",
          "description": "Average number of kilobytes read from the disk each second during the collection interval.",
          "group": "disk",
          "default": true
        },
        "vsphere.disk_total_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time taken during the collection interval to process a SCSI command issued by the guest OS to the virtual machine.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_total_read_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time taken during the collection interval to process a SCSI read command issued from the guest OS to the virtual machine.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_total_write_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time taken during the collection interval to process a SCSI write command issued by the guest OS to the virtual machine.",
          "group": "disk",
          "default": false
        },
        "vsphere.disk_usage_kbs": {
          "type": "gauge",
          "description": "Aggregated disk I/O rate.",
          "group": "disk",
          "default": true
        },
        "vsphere.disk_write_kbs": {
          "type": "gauge",
          "description": "Average number of kilobytes written to disk each second during the collection interval.",
          "group": "disk",
          "default": true
        },
        "vsphere.hbr_net_rx_kbs": {
          "type": "gauge",
          "description": "Kilobytes per second of outgoing host-based replication network traffic (for this virtual machine or host).",
          "group": "hbr",
          "default": false
        },
        "vsphere.hbr_net_tx_kbs": {
          "type": "gauge",
          "description": "Average amount of data transmitted per second.",
          "group": "hbr",
          "default": false
        },
        "vsphere.hbr_num_vms": {
          "type": "gauge",
          "description": "Number of powered-on virtual machines running on this host that currently have host-based replication protection enabled.",
          "group": "hbr",
          "default": false
        },
        "vsphere.mem_active_kb": {
          "type": "gauge",
          "description": "Amount of memory that is actively used, as estimated by VMkernel based on recently touched memory pages.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_activewrite_kb": {
          "type": "gauge",
          "description": "Estimate for the amount of memory actively being written to by the virtual machine.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_compressed_kb": {
          "type": "gauge",
          "description": "Amount of memory reserved by userworlds.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_compression_rate_kbs": {
          "type": "gauge",
          "description": "Rate of memory compression for the virtual machine.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_consumed_kb": {
          "type": "gauge",
          "description": "Amount of host physical memory consumed by a virtual machine, host, or cluster.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_decompression_rate_kbs": {
          "type": "gauge",
          "description": "Rate of memory decompression for the virtual machine.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_entitlement_kb": {
          "type": "gauge",
          "description": "Amount of host physical memory the virtual machine is entitled to, as determined by the ESX scheduler.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_granted_kb": {
          "type": "gauge",
          "description": "Amount of host physical memory or physical memory that is mapped for a virtual machine or a host.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_heap_kb": {
          "type": "gauge",
          "description": "VMkernel virtual address space dedicated to VMkernel main heap and related data.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_heapfree_kb": {
          "type": "gauge",
          "description": "Free address space in the VMkernel main heap.Varies based on number of physical devices and configuration options.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_latency_percent": {
          "type": "gauge",
          "description": "Percentage of time the virtual machine is waiting to access swapped or compressed memory.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_ll_swap_in_kb": {
          "type": "gauge",
          "description": "Amount of memory swapped-in from host cache.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_ll_swap_in_rate_kbs": {
          "type": "gauge",
          "description": "Rate at which memory is being swapped from host cache into active memory.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_ll_swap_out_kb": {
          "type": "gauge",
          "description": "Amount of memory swapped-out to host cache.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_ll_swap_out_rate_kbs": {
          "type": "gauge",
          "description": "Rate at which memory is being swapped from active memory to host cache.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_ll_swap_used_kb": {
          "type": "gauge",
          "description": "Space used for caching swapped pages in the host cache.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_lowfreethreshold_kb": {
          "type": "gauge",
          "description": "Threshold of free host physical memory below which ESX/ESXi will begin reclaiming memory from virtual machines through ballooning and swapping.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_overhead_kb": {
          "type": "gauge",
          "description": "Host physical memory (KB) consumed by the virtualization infrastructure for running the virtual machine.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_overhead_max_kb": {
          "type": "gauge",
          "description": "Host physical memory (KB) reserved for use as the virtualization overhead for the virtual machine.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_overhead_touched_kb": {
          "type": "gauge",
          "description": "Actively touched overhead host physical memory (KB) reserved for use as the virtualization overhead for the virtual machine.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_reserved_capacity_mb": {
          "type": "gauge",
          "description": "Total amount of memory reservation used by powered-on virtual machines and vSphere services on the host.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_shared_kb": {
          "type": "gauge",
          "description": "Amount of guest physical memory that is shared with other virtual machines, relative to a single virtual machine or to all powered-on virtual machines on a host.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_sharedcommon_kb": {
          "type": "gauge",
          "description": "Amount of machine memory that is shared by all powered-on virtual machines and vSphere services on the host.Subtract this metric from the shared metric to gauge how much machine memory is saved due to sharing -- shared - sharedcommon = machine memory (host memory) savings (KB).",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_state": {
          "type": "gauge",
          "description": "One of four threshold levels representing the percentage of free memory on the host. The counter value determines swapping and ballooning behavior for memory reclamation.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_swapin_kb": {
          "type": "gauge",
          "description": "Amount swapped-in to memory from disk.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_swapin_rate_kbs": {
          "type": "gauge",
          "description": "Rate at which memory is swapped from disk into active memory during the interval.",
          "group": "mem",
          "default": true
        },
        "vsphere.mem_swapout_kb": {
          "type": "gauge",
          "description": "Amount of memory swapped-out to disk.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_swapout_rate_kbs": {
          "type": "gauge",
          "description": "Rate at which memory is being swapped from active memory to disk during the current interval.",
          "group": "mem",
          "default": true
        },
        "vsphere.mem_swapped_kb": {
          "type": "gauge",
          "description": "Current amount of guest physical memory swapped out to the virtual machine swap file by the VMkernel.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_swaptarget_kb": {
          "type": "gauge",
          "description": "Target size for the virtual machine swap file.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_swapused_kb": {
          "type": "gauge",
          "description": "Amount of memory that is used by swap.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_sys_usage_kb": {
          "type": "gauge",
          "description": "Amount of host physical memory used by VMkernel for core functionality, such as device drivers and other internal uses.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_total_capacity_mb": {
          "type": "gauge",
          "description": "Total amount of memory reservation used by and available for powered-on virtual machines and vSphere services on the host.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_unreserved_kb": {
          "type": "gauge",
          "description": "Amount of memory that is unreserved.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_usage_percent": {
          "type": "gauge",
          "description": "Percentage of host physical memory that has been consumed.",
          "group": "mem",
          "default": true
        },
        "vsphere.mem_vmfs_pbc_cap_miss_ratio_percent": {
          "type": "gauge",
          "description": "Trailing average of the ratio of capacity misses to compulsory misses for the VMFS PB Cache.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_vmfs_pbc_overhead_kb": {
          "type": "gauge",
          "description": "Amount of VMFS heap used by the VMFS PB Cache.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_vmfs_pbc_size_max_mb": {
          "type": "gauge",
          "description": "Maximum size the VMFS Pointer Block Cache can grow to.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_vmfs_pbc_size_mb": {
          "type": "gauge",
          "description": "Space used for holding VMFS Pointer Blocks in memory.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_vmfs_pbc_working_set_max_tb": {
          "type": "gauge",
          "description": "Maximum amount of file blocks whose addresses are cached in the VMFS PB Cache.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_vmfs_pbc_working_set_tb": {
          "type": "gauge",
          "description": "Amount of file blocks whose addresses are cached in the VMFS PB Cache.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_vmmemctl_kb": {
          "type": "gauge",
          "description": "Amount of memory allocated by the virtual machine memory control driver.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_vmmemctltarget_kb": {
          "type": "gauge",
          "description": "Target value set by VMkernal for the virtual machine's memory balloon size.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_zero_kb": {
          "type": "gauge",
          "description": "Memory that contains 0s only.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_zip_saved_kb": {
          "type": "gauge",
          "description": "Memory (KB) saved due to memory zipping.",
          "group": "mem",
          "default": false
        },
        "vsphere.mem_zipped_kb": {
          "type": "gauge",
          "description": "Memory (KB) zipped.",
          "group": "mem",
          "default": false
        },
        "vsphere.net_broadcast_rx": {
          "type": "counter",
          "description": "Number of broadcast packets received during the sampling interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_broadcast_tx": {
          "type": "counter",
          "description": "Number of broadcast packets transmitted during the sampling interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_bytes_rx_kbs": {
          "type": "gauge",
          "description": "Average amount of data received per second.",
          "group": "net",
          "default": false
        },
        "vsphere.net_bytes_tx_kbs": {
          "type": "gauge",
          "description": "Average amount of data transmitted per second.",
          "group": "net",
          "default": false
        },
        "vsphere.net_dropped_rx": {
          "type": "counter",
          "description": "Number of received packets dropped during the collection interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_dropped_tx": {
          "type": "counter",
          "description": "Number of transmitted packets dropped during the collection interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_errors_rx": {
          "type": "counter",
          "description": "Number of packets with errors received during the sampling interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_errors_tx": {
          "type": "counter",
          "description": "Number of packets with errors transmitted during the sampling interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_multicast_rx": {
          "type": "counter",
          "description": "Number of multicast packets received during the sampling interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_multicast_tx": {
          "type": "counter",
          "description": "Number of multicast packets transmitted during the sampling interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_packets_rx": {
          "type": "counter",
          "description": "Number of packets received during the interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_packets_tx": {
          "type": "counter",
          "description": "Number of packets transmitted during the interval.",
          "group": "net",
          "default": false
        },
        "vsphere.net_received_kbs": {
          "type": "gauge",
          "description": "Average rate at which data was received during the interval.",
          "group": "net",
          "default": true
        },
        "vsphere.net_transmitted_kbs": {
          "type": "gauge",
          "description": "Average rate at which data was transmitted during the interval. This represents the bandwidth of the network.",
          "group": "net",
          "default": true
        },
        "vsphere.net_unknown_protos": {
          "type": "counter",
          "description": "Number of frames with unknown protocol received during the sampling interval",
          "group": "net",
          "default": false
        },
        "vsphere.net_usage_kbs": {
          "type": "gauge",
          "description": "Network utilization (combined transmit- and receive-rates) during the interval.",
          "group": "net",
          "default": true
        },
        "vsphere.power_cap_watts": {
          "type": "gauge",
          "description": "Maximum allowed power usage.",
          "group": "power",
          "default": false
        },
        "vsphere.power_energy_joules": {
          "type": "counter",
          "description": "Total energy used since last stats reset.",
          "group": "power",
          "default": false
        },
        "vsphere.power_watts": {
          "type": "gauge",
          "description": "Current power usage.",
          "group": "power",
          "default": false
        },
        "vsphere.rescpu_actav1": {
          "type": "gauge",
          "description": "CPU active average over 1 minute.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_actav15_percent": {
          "type": "gauge",
          "description": "CPU active average over 15 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_actav5_percent": {
          "type": "gauge",
          "description": "CPU active average over 5 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_actpk15_percent": {
          "type": "gauge",
          "description": "CPU active peak over 15 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_actpk1_percent": {
          "type": "gauge",
          "description": "CPU active peak over 1 minute.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_actpk5_percent": {
          "type": "gauge",
          "description": "CPU active peak over 5 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_max_limited15_percent": {
          "type": "gauge",
          "description": "Amount of CPU resources over the limit that were refused, average over 15 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_max_limited1_percent": {
          "type": "gauge",
          "description": "Amount of CPU resources over the limit that were refused, average over 1 minute.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_max_limited5_percent": {
          "type": "gauge",
          "description": "Amount of CPU resources over the limit that were refused, average over 5 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_runav15_percent": {
          "type": "gauge",
          "description": "CPU running average over 15 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_runav1_percent": {
          "type": "gauge",
          "description": "CPU running average over 1 minute.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_runav5_percent": {
          "type": "gauge",
          "description": "CPU running average over 5 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_runpk15_percent": {
          "type": "gauge",
          "description": "CPU running peak over 15 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_runpk1_percent": {
          "type": "gauge",
          "description": "CPU running peak over 1 minute.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_runpk5_percent": {
          "type": "gauge",
          "description": "CPU running peak over 5 minutes.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_sample_count": {
          "type": "gauge",
          "description": "Group CPU sample count.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.rescpu_sample_period_ms": {
          "type": "gauge",
          "description": "Group CPU sample period.",
          "group": "rescpu",
          "default": false
        },
        "vsphere.storage_adapter_commands_averaged": {
          "type": "gauge",
          "description": "Average number of commands issued per second by the storage adapter during the collection interval.",
          "group": "storage_adapter",
          "default": false
        },
        "vsphere.storage_adapter_max_total_latency_ms": {
          "type": "gauge",
          "description": "Highest latency value across all storage adapters used by the host.",
          "group": "storage_adapter",
          "default": false
        },
        "vsphere.storage_adapter_number_read_averaged": {
          "type": "gauge",
          "description": "Average number of read commands issued per second by the storage adapter during the collection interval.",
          "group": "storage_adapter",
          "default": false
        },
        "vsphere.storage_adapter_number_write_averaged": {
          "type": "gauge",
          "description": "Average number of write commands issued per second by the storage adapter during the collection interval.",
          "group": "storage_adapter",
          "default": false
        },
        "vsphere.storage_adapter_read_kbs": {
          "type": "gauge",
          "description": "Rate of reading data by the storage adapter.",
          "group": "storage_adapter",
          "default": false
        },
        "vsphere.storage_adapter_total_read_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time for a read operation by the storage adapter. Total latency = kernel latency + device latency.",
          "group": "storage_adapter",
          "default": false
        },
        "vsphere.storage_adapter_total_write_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time for a write operation by the storage adapter. Total latency = kernel latency + device latency.",
          "group": "storage_adapter",
          "default": false
        },
        "vsphere.storage_adapter_write_kbs": {
          "type": "gauge",
          "description": "Rate of writing data by the storage adapter.",
          "group": "storage_adapter",
          "default": false
        },
        "vsphere.storage_path_commands_averaged": {
          "type": "gauge",
          "description": "Average number of commands issued per second on the storage path during the collection interval.",
          "group": "storage_path",
          "default": false
        },
        "vsphere.storage_path_max_total_latency_ms": {
          "type": "gauge",
          "description": "Highest latency value across all storage paths used by the host.",
          "group": "storage_path",
          "default": false
        },
        "vsphere.storage_path_number_read_averaged": {
          "type": "gauge",
          "description": "Average number of read commands issued per second on the storage path during the collection interval.",
          "group": "storage_path",
          "default": false
        },
        "vsphere.storage_path_number_write_averaged": {
          "type": "gauge",
          "description": "Average number of write commands issued per second on the storage path during the collection interval.",
          "group": "storage_path",
          "default": false
        },
        "vsphere.storage_path_read_kbs": {
          "type": "gauge",
          "description": "Rate of reading data on the storage path.",
          "group": "storage_path",
          "default": false
        },
        "vsphere.storage_path_total_read_latency_ms": {
          "type": "gauge",
          "description": "The average time a read issued on the storage path takes.",
          "group": "storage_path",
          "default": false
        },
        "vsphere.storage_path_total_write_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time for a write issued on the storage path. Total latency = kernel latency + device latency.",
          "group": "storage_path",
          "default": false
        },
        "vsphere.storage_path_write_kbs": {
          "type": "gauge",
          "description": "Rate of writing data on the storage path.",
          "group": "storage_path",
          "default": false
        },
        "vsphere.sys_heartbeat": {
          "type": "counter",
          "description": "Number of heartbeats issued per virtual machine during the interval.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_os_uptime_seconds": {
          "type": "gauge",
          "description": "Total time elapsed, in seconds, since last operating system boot-up.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_act1_percent": {
          "type": "gauge",
          "description": "CPU active average over 1 minute of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_act5": {
          "type": "gauge",
          "description": "CPU active average over 5 minutes of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_alloc_min_mhz": {
          "type": "gauge",
          "description": "CPU allocation reservation (in MHz) of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_alloc_shares": {
          "type": "gauge",
          "description": "CPU allocation shares of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_max_limited1_percent": {
          "type": "gauge",
          "description": "CPU maximum limited over 1 minute of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_max_limited5_percent": {
          "type": "gauge",
          "description": "CPU maximum limited over 5 minutes of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_run1_percent": {
          "type": "gauge",
          "description": "CPU running average over 1 minute of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_run5_percent": {
          "type": "gauge",
          "description": "CPU running average over 5 minutes of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_cpu_usage_mhz": {
          "type": "gauge",
          "description": "Amount of CPU used by the Service Console and other applications during the interval by the Service Console and other applications.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_fd_usage": {
          "type": "gauge",
          "description": "Number of file descriptors used by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_alloc_max_kb": {
          "type": "gauge",
          "description": "Memory allocation limit (in KB) of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_alloc_min_kb": {
          "type": "gauge",
          "description": "Memory allocation reservation (in KB) of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_alloc_shares": {
          "type": "gauge",
          "description": "Memory allocation shares of the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_consumed_kb": {
          "type": "gauge",
          "description": "Memory consumed by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_cow_kb": {
          "type": "gauge",
          "description": "Memory shared by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_mapped_kb": {
          "type": "gauge",
          "description": "Memory mapped by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_overhead_kb": {
          "type": "gauge",
          "description": "Overhead memory consumed by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_shared_kb": {
          "type": "gauge",
          "description": "Memory saved due to sharing by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_swapped_kb": {
          "type": "gauge",
          "description": "Memory swapped out by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_touched_kb": {
          "type": "gauge",
          "description": "Memory touched by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_resource_mem_zero_kb": {
          "type": "gauge",
          "description": "Zero filled memory used by the system resource group.",
          "group": "sys",
          "default": false
        },
        "vsphere.sys_uptime_seconds": {
          "type": "gauge",
          "description": "Total time elapsed, in seconds, since last system startup.",
          "group": "sys",
          "default": false
        },
        "vsphere.virtual_disk_large_seeks": {
          "type": "gauge",
          "description": "Number of seeks during the interval that were greater than 8192 LBNs apart.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_medium_seeks": {
          "type": "gauge",
          "description": "Number of seeks during the interval that were between 64 and 8192 LBNs apart.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_number_read_averaged": {
          "type": "gauge",
          "description": "Average number of read commands issued per second to the virtual disk during the collection interval.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_number_write_averaged": {
          "type": "gauge",
          "description": "Average number of write commands issued per second to the virtual disk during the collection interval.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_read_iosize": {
          "type": "gauge",
          "description": "Average read request size in bytes.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_read_kbs": {
          "type": "gauge",
          "description": "Rate of reading data from the virtual disk.",
          "group": "virtual_disk",
          "default": true
        },
        "vsphere.virtual_disk_read_latency_us": {
          "type": "gauge",
          "description": "Read latency in microseconds.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_read_load_metric": {
          "type": "gauge",
          "description": "Storage DRS virtual disk metric for the read workload model.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_read_oio": {
          "type": "gauge",
          "description": "Average number of outstanding read requests to the virtual disk during the collection interval.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_small_seeks": {
          "type": "gauge",
          "description": "Number of seeks during the interval that were less than 64 LBNs apart.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_total_read_latency_ms": {
          "type": "gauge",
          "description": "Average amount of time for a read operation from the virtual disk. Total latency = kernel latency + device latency.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_total_write_latency_ms": {
          "type": "gauge",
          "description": "The average time a write to the virtual disk takes.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_write_iosize": {
          "type": "gauge",
          "description": "Average write request size in bytes.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_write_kbs": {
          "type": "gauge",
          "description": "Rate of writing data to the virtual disk.",
          "group": "virtual_disk",
          "default": true
        },
        "vsphere.virtual_disk_write_latency_us": {
          "type": "gauge",
          "description": "Write latency in microseconds.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_write_load_metric": {
          "type": "gauge",
          "description": "Storage DRS virtual disk metric for the write workload model.",
          "group": "virtual_disk",
          "default": false
        },
        "vsphere.virtual_disk_write_oio": {
          "type": "gauge",
          "description": "Average number of outstanding write requests to the virtual disk during the collection interval.",
          "group": "virtual_disk",
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the vSphere monitor",
        "package": "pkg/monitors/vsphere",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "The vSphere username",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "The vSphere password",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "insecureSkipVerify",
            "doc": "Whether we verify the server's certificate chain and host name",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "inventoryRefreshInterval",
            "doc": "How often to reload the inventory and inventory metrics",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "tlsCACertPath",
            "doc": "Path to the ca file",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tlsClientCertificatePath",
            "doc": "Configure client certs. Both tlsClientKeyPath and tlsClientCertificatePath must be present. The files must contain PEM encoded data. Path to the client certificate",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tlsClientKeyPath",
            "doc": "Path to the keyfile",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "windows-iis",
      "sendAll": false,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics for Windows Internet Information Services.\nIt is used to drive the Windows IIS dashboard content.\n\n## Windows Performance Counters\nThe underlying source for these metrics are Windows Performance Counters.\nMost of the performance counters that we query in this monitor are actually Gauges\nthat represent rates per second and percentages.\n\nThis monitor reports the instantaneous values for these Windows Performance Counters.\nThis means that in between a collection interval, spikes could occur on the\nPerformance Counters.  The best way to mitigate this limitation is to increase\nthe reporting interval on this monitor to collect more frequently.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: windows-iis\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "process.handle_count",
            "process.id_process",
            "process.pct_processor_time",
            "process.private_bytes",
            "process.thread_count",
            "process.virtual_bytes",
            "process.working_set",
            "web_service.anonymous_users_sec",
            "web_service.bytes_received_sec",
            "web_service.bytes_sent_sec",
            "web_service.connection_attempts_sec",
            "web_service.current_connections",
            "web_service.files_received_sec",
            "web_service.files_sent_sec",
            "web_service.get_requests_sec",
            "web_service.isapi_extension_requests_sec",
            "web_service.nonanonymous_users_sec",
            "web_service.not_found_errors_sec",
            "web_service.post_requests_sec",
            "web_service.service_uptime",
            "web_service.total_method_requests_sec"
          ]
        }
      },
      "metrics": {
        "process.handle_count": {
          "type": "gauge",
          "description": "The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.",
          "group": null,
          "default": false
        },
        "process.id_process": {
          "type": "gauge",
          "description": "The unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.",
          "group": null,
          "default": false
        },
        "process.pct_processor_time": {
          "type": "gauge",
          "description": "The percentage of elapsed time that all process threads used the processor to execution instructions. Code executed to handle some hardware interrupts and trap conditions are included in this count.",
          "group": null,
          "default": false
        },
        "process.private_bytes": {
          "type": "gauge",
          "description": "The current size, in bytes, of memory that this process has allocated that cannot be shared with other processes.",
          "group": null,
          "default": false
        },
        "process.thread_count": {
          "type": "gauge",
          "description": "The number of threads currently active in this process. Every running process has at least one thread.",
          "group": null,
          "default": false
        },
        "process.virtual_bytes": {
          "type": "gauge",
          "description": "The current size, in bytes, of the virtual address space the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries.",
          "group": null,
          "default": false
        },
        "process.working_set": {
          "type": "gauge",
          "description": "The current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed, they will then be soft-faulted back into the Working Set before leaving main memory.",
          "group": null,
          "default": false
        },
        "web_service.anonymous_users_sec": {
          "type": "gauge",
          "description": "Rate at which users are making anonymous requests to the web service",
          "group": null,
          "default": true
        },
        "web_service.bytes_received_sec": {
          "type": "gauge",
          "description": "Rate that data is received by web service",
          "group": null,
          "default": true
        },
        "web_service.bytes_sent_sec": {
          "type": "gauge",
          "description": "Rate that data is sent by web service",
          "group": null,
          "default": true
        },
        "web_service.connection_attempts_sec": {
          "type": "gauge",
          "description": "Rate that connections to web service are attempted Requests",
          "group": null,
          "default": true
        },
        "web_service.current_connections": {
          "type": "gauge",
          "description": "Number of current connections to the web service",
          "group": null,
          "default": true
        },
        "web_service.files_received_sec": {
          "type": "gauge",
          "description": "Rate at which files are received by web service",
          "group": null,
          "default": true
        },
        "web_service.files_sent_sec": {
          "type": "gauge",
          "description": "Rate at which files are sent by web service",
          "group": null,
          "default": true
        },
        "web_service.get_requests_sec": {
          "type": "gauge",
          "description": "Rate of HTTP GET requests",
          "group": null,
          "default": true
        },
        "web_service.isapi_extension_requests_sec": {
          "type": "gauge",
          "description": "Rate of ISAPI extension request processed simultaneously by the web service",
          "group": null,
          "default": false
        },
        "web_service.nonanonymous_users_sec": {
          "type": "gauge",
          "description": "Rate at which users are making nonanonymous requests to the web service",
          "group": null,
          "default": true
        },
        "web_service.not_found_errors_sec": {
          "type": "gauge",
          "description": "Rate of 'Not Found' Errors",
          "group": null,
          "default": true
        },
        "web_service.post_requests_sec": {
          "type": "gauge",
          "description": "Rate of HTTP POST requests",
          "group": null,
          "default": true
        },
        "web_service.service_uptime": {
          "type": "gauge",
          "description": "Service uptime",
          "group": null,
          "default": false
        },
        "web_service.total_method_requests_sec": {
          "type": "gauge",
          "description": "Rate at which all HTTP requests are received",
          "group": null,
          "default": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/windowsiis",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) Number of seconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "windows-legacy",
      "sendAll": false,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics for Windows system Performance Counters.\nThe metric names are intended to match what was originally reported by\nthe SignalFx [PerfCounterReporter](https://github.com/signalfx/PerfCounterReporter)\nThe metric types are all gauges as originally reported by the PerfCounterReporter.\n\n## Windows Performance Counters\nThe underlying source for these metrics are Windows Performance Counters.\nMost of the performance counters that we query in this monitor are actually\nrates per second and percentages that we report as instantaneous Gauge values\neach collection interval.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: windows-legacy\n```\n",
      "groups": {
        "": {
          "description": "",
          "metrics": [
            "logicaldisk.disk_read_bytes_sec",
            "logicaldisk.disk_reads_sec",
            "logicaldisk.disk_transfers_sec",
            "logicaldisk.disk_write_bytes_sec",
            "logicaldisk.disk_writes_sec",
            "logicaldisk.free_megabytes",
            "logicaldisk.pct_free_space",
            "memory.available_mbytes",
            "memory.pages_input_sec",
            "network_interface.bytes_received_sec",
            "network_interface.bytes_sent_sec",
            "network_interface.bytes_total_sec",
            "network_interface.current_bandwidth",
            "network_interface.packets_outbound_discarded",
            "network_interface.packets_outbound_errors",
            "network_interface.packets_received_discarded",
            "network_interface.packets_received_errors",
            "network_interface.packets_received_sec",
            "network_interface.packets_sent_sec",
            "paging_file.pct_usage",
            "paging_file.pct_usage_peak",
            "physicaldisk.avg_disk_sec_read",
            "physicaldisk.avg_disk_sec_transfer",
            "physicaldisk.avg_disk_sec_write",
            "processor.interrupts_sec",
            "processor.pct_privileged_time",
            "processor.pct_processor_time",
            "processor.pct_user_time",
            "system.context_switches_sec",
            "system.processor_queue_length",
            "system.system_calls_sec"
          ]
        }
      },
      "metrics": {
        "logicaldisk.disk_read_bytes_sec": {
          "type": "gauge",
          "description": "The number of bytes read from disk per second.",
          "group": null,
          "default": false
        },
        "logicaldisk.disk_reads_sec": {
          "type": "gauge",
          "description": "The number of read operations per second.",
          "group": null,
          "default": true
        },
        "logicaldisk.disk_transfers_sec": {
          "type": "gauge",
          "description": "The number of transfers per second.",
          "group": null,
          "default": false
        },
        "logicaldisk.disk_write_bytes_sec": {
          "type": "gauge",
          "description": "The number of bytes written to disk per second.",
          "group": null,
          "default": false
        },
        "logicaldisk.disk_writes_sec": {
          "type": "gauge",
          "description": "The number of write operations per second.",
          "group": null,
          "default": true
        },
        "logicaldisk.free_megabytes": {
          "type": "gauge",
          "description": "The number of available megabytes.",
          "group": null,
          "default": true
        },
        "logicaldisk.pct_free_space": {
          "type": "gauge",
          "description": "The percentage of free disk space available.",
          "group": null,
          "default": true
        },
        "memory.available_mbytes": {
          "type": "gauge",
          "description": "Unused physical memory (not page file).",
          "group": null,
          "default": true
        },
        "memory.pages_input_sec": {
          "type": "gauge",
          "description": "Reads from hard disk per second to resolve hard pages.",
          "group": null,
          "default": true
        },
        "network_interface.bytes_received_sec": {
          "type": "gauge",
          "description": "Bytes Received/sec is the rate at which bytes are received over each network adapter, including framing characters.",
          "group": null,
          "default": true
        },
        "network_interface.bytes_sent_sec": {
          "type": "gauge",
          "description": "Bytes Sent/sec is the rate at which bytes are sent over each network adapter, including framing characters.",
          "group": null,
          "default": true
        },
        "network_interface.bytes_total_sec": {
          "type": "gauge",
          "description": "The number of bytes sent and received over a specific network adapter, including framing characters.",
          "group": null,
          "default": true
        },
        "network_interface.current_bandwidth": {
          "type": "gauge",
          "description": "Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).",
          "group": null,
          "default": false
        },
        "network_interface.packets_outbound_discarded": {
          "type": "gauge",
          "description": "The number of outbound packets discarded",
          "group": null,
          "default": false
        },
        "network_interface.packets_outbound_errors": {
          "type": "gauge",
          "description": "The number of packets sent that encountered an error.",
          "group": null,
          "default": true
        },
        "network_interface.packets_received_discarded": {
          "type": "gauge",
          "description": "The number of received packets discarded.",
          "group": null,
          "default": false
        },
        "network_interface.packets_received_errors": {
          "type": "gauge",
          "description": "The number of packets received that encountered an error.",
          "group": null,
          "default": true
        },
        "network_interface.packets_received_sec": {
          "type": "gauge",
          "description": "Tracking the packets received over time can give you a good indication of the typical use of the system's network.",
          "group": null,
          "default": false
        },
        "network_interface.packets_sent_sec": {
          "type": "gauge",
          "description": "The number of packets sent per second.",
          "group": null,
          "default": false
        },
        "paging_file.pct_usage": {
          "type": "gauge",
          "description": "Amount of Page File in use, which indicates the server is substituting disk space for memory.",
          "group": null,
          "default": true
        },
        "paging_file.pct_usage_peak": {
          "type": "gauge",
          "description": "Highest %Usage metric since the last time the server was restarted.",
          "group": null,
          "default": false
        },
        "physicaldisk.avg_disk_sec_read": {
          "type": "gauge",
          "description": "The average time, in milliseconds, of each read from disk.",
          "group": null,
          "default": false
        },
        "physicaldisk.avg_disk_sec_transfer": {
          "type": "gauge",
          "description": "The average time in milliseconds spent transfering data on disk.",
          "group": null,
          "default": false
        },
        "physicaldisk.avg_disk_sec_write": {
          "type": "gauge",
          "description": "The average time, in milliseconds, of each write to disk.",
          "group": null,
          "default": false
        },
        "processor.interrupts_sec": {
          "type": "gauge",
          "description": "Rate of processor interrupts per second.",
          "group": null,
          "default": false
        },
        "processor.pct_privileged_time": {
          "type": "gauge",
          "description": "Percentage of elapsed time the processor spends on privileged tasks.",
          "group": null,
          "default": false
        },
        "processor.pct_processor_time": {
          "type": "gauge",
          "description": "Percentage of elapsed time the processor spends executing non-idle threads.",
          "group": null,
          "default": true
        },
        "processor.pct_user_time": {
          "type": "gauge",
          "description": "Percentage of elapsed time the processor spends executing user threads.",
          "group": null,
          "default": false
        },
        "system.context_switches_sec": {
          "type": "gauge",
          "description": "Number of execution contexts switched in the last second, where \u003e6000 is poor, \u003c3000 is good, and \u003c1500 is excellent.",
          "group": null,
          "default": false
        },
        "system.processor_queue_length": {
          "type": "gauge",
          "description": "Number of threads waiting for CPU cycles, where \u003c 12 per CPU is good/fair, \u003c 8 is better, \u003c 4 is best",
          "group": null,
          "default": false
        },
        "system.system_calls_sec": {
          "type": "gauge",
          "description": "The number of system calls being serviced by the CPU per second.",
          "group": null,
          "default": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "pkg/monitors/windowslegacy",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) Number of seconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    }
  ],
  "Observers": [
    {
      "name": "Config",
      "doc": " Queries the Docker Engine API for running containers.  If\nyou are using Kubernetes, you should use the [k8s-api\nobserver](./k8s-api.md) instead of this.\n\nRequires Docker API version 1.22+.\n\nNote that you will need permissions to access the Docker engine API.  For a\nDocker domain socket URL, this means that the agent needs to have read\npermissions on the socket.  We don't currently support authentication for\nHTTP URLs.\n\n## Configuration from Labels\nYou can configure monitors by putting special labels on your Docker\ncontainers.  You can either specify all of the configuration in container\nlabels, or you can use the more traditional agent configuration with\ndiscovery rules and specify configuration overrides with labels.\n\nThe config labels are of the form `agent.signalfx.com.config.\u003cport\nnumber\u003e.\u003cconfig_key\u003e: \u003cconfig value\u003e`.  The `\u003cconfig value\u003e` must be a\nstring in a container label, but it will be deserialized as a YAML value to\nthe most appropriate type when consumed by the agent.  For example, if you\nhave a Redis container and want to monitor it at a higher frequency than\nother Redis containers, you could have an agent config that looks like the\nfollowing:\n\n```\nobservers:\n - type: docker\nmonitors:\n - type: collectd/redis\n   discoveryRule: container_image =~ \"redis\" \u0026\u0026 port == 6379\n   auth: mypassword\n   intervalSeconds: 10\n```\n\nAnd then launch the Redis container with the label:\n\n`agent.signalfx.com.config.6379.intervalSeconds`: `1`\n\nThis would cause the config value for `intervalSeconds` to be overwritten to\nthe more frequent 1 second interval.\n\nYou can also specify the monitor configuration entirely with Docker labels\nand completely omit monitor config from the agent config.  With the agent\nconfig:\n\n```\nobservers:\n - type: docker\n```\n\nYou can then launch a Redis container with the following labels:\n\n - `agent.signalfx.com.monitorType.6379`: `collectd/redis`\n - `agent.signalfx.com.config.6379.auth`: `mypassword`\n\nWhich would configure a Redis monitor with the given authentication\nconfiguration.  No Redis configuration is required in the agent config file.\n\nThe distinction is that the `monitorType` label was added to the Docker\ncontainer.  If a `monitorType` label is present, **no discovery rules will\nbe considered for this endpoint**, and thus, no agent configuration can be\nused anyway.\n\n### Multiple Monitors per Port\nIf you want to configure multiple monitors per port, you can specify the\nport name in the form `\u003cport number\u003e-\u003cport name\u003e` instead of just the port\nnumber.  For example, if you had two different Prometheus exporters running\non the same port, but on different paths in a given container, you could\nprovide labels like the following:\n\n```\n - `agent.signalfx.com.monitorType.8080-app`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.monitorType.8080-goruntime`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n```\n\nThe name that is given to the port will populate the `name` field of the\ndiscovered endpoint and can be used in discovery rules as such.  For\nexample, with the following agent config:\n\n```\nobservers:\n - type: docker\nmonitors:\n - type: prometheus-exporter\n   discoveryRule: name == \"app\" \u0026\u0026 port == 8080\n   intervalSeconds: 1\n```\n\nAnd given docker labels as follows (remember that discovery rules are\nirrelevant to endpoints that specify `monitorType` labels):\n\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n\nWould result in the `app` endpoint getting an interval of 1 second and the\n`goruntime` endpoint getting the default interval of the agent.\n",
      "package": "pkg/observers/docker",
      "fields": [
        {
          "yamlName": "dockerURL",
          "doc": "",
          "default": "unix:///var/run/docker.sock",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "labelsToDimensions",
          "doc": "A mapping of container label names to dimension names that will get applied to the metrics of all discovered services. The corresponding label values will become the dimension values for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "useHostnameIfPresent",
          "doc": "If true, the \"Config.Hostname\" field (if present) of the docker container will be used as the discovered host that is used to configure monitors.  If false or if no hostname is configured, the field `NetworkSettings.IPAddress` is used instead.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "useHostBindings",
          "doc": "If true, the observer will configure monitors for matching container endpoints using the host bound ip and port.  This is useful if containers exist that are not accessible to an instance of the agent running outside of the docker network stack.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "ignoreNonHostBindings",
          "doc": "If true, the observer will ignore discovered container endpoints that are not bound to host ports.  This is useful if containers exist that are not accessible to an instance of the agent running outside of the docker network stack.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "observerType": "docker",
      "dimensions": {
        "container_id": {
          "description": "The container id of the container running this endpoint."
        },
        "container_image": {
          "description": "The image name (including tags) of the running container"
        },
        "container_name": {
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        }
      },
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "has_port",
          "type": "string",
          "elementKind": "",
          "description": "Set to `true` if the endpoint has a port assigned to it.  This will be `false` for endpoints that represent a host/container as a whole."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions). For containers managed by Kubernetes, this will be set to the pod's labels, as individual containers do not have labels in Kubernetes proper."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint.  If this is an IPv6 address, it will be surrounded by `[` and `]`."
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint. For example, if using the `k8s-api` observer, `name` will be the port name in the pod spec, if any."
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        },
        {
          "name": "target",
          "type": "string",
          "elementKind": "",
          "description": "The type of the thing that this endpoint directly refers to.  If the endpoint has a host and port associated with it (most common), the value will be `hostport`.  Other possible values are: `pod`, `container`, `host`.  See the docs for the specific observer you are using for more details on what types that observer emits."
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Queries the [ECS Task Metadata Endpoint version 2](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v2.html) for running containers.\n\nThe Smart Agent needs to run in the same task with the containers to be\nmonitored to get access to the data through ECS task metadata endpoint.\n\n## Configuration from Labels\nYou must put at least one special label to identify an exposed port on your Docker\ncontainers in the ECS task definition since ECS metadata does not contain any port\ninformation. You can either specify all of the configuration in container labels,\nor you can use the more traditional agent configuration with discovery rules and\nspecify configuration overrides with labels.\n\nThe config labels are of the form `agent.signalfx.com.config.\u003cport\nnumber\u003e.\u003cconfig_key\u003e: \u003cconfig value\u003e`.  The `\u003cconfig value\u003e` must be a\nstring in a container label, but it will be deserialized as a YAML value to\nthe most appropriate type when consumed by the agent.  For example, if you\nhave a Redis container and want to monitor it at a higher frequency than\nother Redis containers, you could have an agent config that looks like the\nfollowing:\n\n```\nobservers:\n - type: ecs\nmonitors:\n - type: collectd/redis\n   discoveryRule: container_image =~ \"redis\" \u0026\u0026 port == 6379\n   auth: mypassword\n   intervalSeconds: 10\n```\n\nAnd then launch the Redis container with the label:\n\n`agent.signalfx.com.config.6379.intervalSeconds`: `1`\n\nThis would cause the config value for `intervalSeconds` to be overwritten to\nthe more frequent 1 second interval.\n\nYou can also specify the monitor configuration entirely with Docker labels\nand completely omit monitor config from the agent config.  With the agent\nconfig:\n\n```\nobservers:\n - type: ecs\n```\n\nYou can then launch a Redis container with the following labels:\n\n - `agent.signalfx.com.monitorType.6379`: `collectd/redis`\n - `agent.signalfx.com.config.6379.auth`: `mypassword`\n\nWhich would configure a Redis monitor with the given authentication\nconfiguration.  No Redis configuration is required in the agent config file.\n\nThe distinction is that the `monitorType` label was added to the Docker\ncontainer.  If a `monitorType` label is present, **no discovery rules will\nbe considered for this endpoint**, and thus, no agent configuration can be\nused anyway.\n\n### Multiple Monitors per Port\nIf you want to configure multiple monitors per port, you can specify the\nport name in the form `\u003cport number\u003e-\u003cport name\u003e` instead of just the port\nnumber.  For example, if you had two different Prometheus exporters running\non the same port, but on different paths in a given container, you could\nprovide labels like the following:\n\n```\n - `agent.signalfx.com.monitorType.8080-app`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.monitorType.8080-goruntime`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n```\n\nThe name that is given to the port will populate the `name` field of the\ndiscovered endpoint and can be used in discovery rules as such.  For\nexample, with the following agent config:\n\n```\nobservers:\n - type: ecs\nmonitors:\n - type: prometheus-exporter\n   discoveryRule: name == \"app\" \u0026\u0026 port == 8080\n   intervalSeconds: 1\n```\n\nAnd given docker labels as follows (remember that discovery rules are\nirrelevant to endpoints that specify `monitorType` labels):\n\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n\nWould result in the `app` endpoint getting an interval of 1 second and the\n`goruntime` endpoint getting the default interval of the agent.\n",
      "package": "pkg/observers/ecs",
      "fields": [
        {
          "yamlName": "metadataEndpoint",
          "doc": "The URL of the ECS task metadata. Default is http://169.254.170.2/v2/metadata, which is hardcoded by AWS for version 2.",
          "default": "http://169.254.170.2/v2/metadata",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "labelsToDimensions",
          "doc": "A mapping of container label names to dimension names that will get applied to the metrics of all discovered services. The corresponding label values will become the dimension values for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        }
      ],
      "observerType": "ecs",
      "dimensions": {
        "container_id": {
          "description": "The container id of the container running this endpoint."
        },
        "container_image": {
          "description": "The image name (including tags) of the running container"
        },
        "container_name": {
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        }
      },
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "has_port",
          "type": "string",
          "elementKind": "",
          "description": "Set to `true` if the endpoint has a port assigned to it.  This will be `false` for endpoints that represent a host/container as a whole."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions). For containers managed by Kubernetes, this will be set to the pod's labels, as individual containers do not have labels in Kubernetes proper."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint.  If this is an IPv6 address, it will be surrounded by `[` and `]`."
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint. For example, if using the `k8s-api` observer, `name` will be the port name in the pod spec, if any."
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        },
        {
          "name": "target",
          "type": "string",
          "elementKind": "",
          "description": "The type of the thing that this endpoint directly refers to.  If the endpoint has a host and port associated with it (most common), the value will be `hostport`.  Other possible values are: `pod`, `container`, `host`.  See the docs for the specific observer you are using for more details on what types that observer emits."
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Looks at the current host for listening network endpoints.\nIt uses the `/proc` filesystem and requires the `SYS_PTRACE` and\n`DAC_READ_SEARCH` capabilities so that it can determine what processes own\nthe listening sockets.\n\nIt will look for all listening sockets on TCP and UDP over IPv4 and IPv6.\n",
      "package": "pkg/observers/host",
      "fields": [
        {
          "yamlName": "pollIntervalSeconds",
          "doc": "",
          "default": 10,
          "required": false,
          "type": "int",
          "elementKind": ""
        }
      ],
      "observerType": "host",
      "dimensions": {
        "pid": {
          "description": "The PID of the process that owns the listening endpoint"
        }
      },
      "endpointVariables": [
        {
          "name": "command",
          "type": "string",
          "elementKind": "",
          "description": "The full command used to invoke this process, including the executable itself at the beginning."
        },
        {
          "name": "has_port",
          "type": "string",
          "elementKind": "",
          "description": "Set to `true` if the endpoint has a port assigned to it.  This will be `false` for endpoints that represent a host/container as a whole."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "is_ipv6",
          "type": "string",
          "elementKind": "",
          "description": "Will be `true` if the endpoint is IPv6."
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint.  If this is an IPv6 address, it will be surrounded by `[` and `]`."
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint. For example, if using the `k8s-api` observer, `name` will be the port name in the pod spec, if any."
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        },
        {
          "name": "target",
          "type": "string",
          "elementKind": "",
          "description": "The type of the thing that this endpoint directly refers to.  If the endpoint has a host and port associated with it (most common), the value will be `hostport`.  Other possible values are: `pod`, `container`, `host`.  See the docs for the specific observer you are using for more details on what types that observer emits."
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Discovers services running in a Kubernetes cluster by\nquerying the Kubernetes API server.  This observer is designed to only\ndiscover pod endpoints exposed on the same node that the agent is running,\nso that the monitoring of services does not generate cross-node traffic.  To\nknow which node the agent is running on, you should set an environment\nvariable called `MY_NODE_NAME` using the downward API `spec.nodeName` value\nin the pod spec.  Our provided K8s DaemonSet resource does this already and\nprovides an example.\n\nNote that this observer discovers exposed ports on pod containers, not K8s\nEndpoint resources, so don't let the terminology of agent \"endpoints\"\nconfuse you.\n",
      "package": "pkg/observers/kubernetes",
      "fields": [
        {
          "yamlName": "namespace",
          "doc": "If specified, only pods within the given namespace on the same node as the agent will be discovered. If blank, all pods on the same node as the agent will be discovered.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "kubernetesAPI",
          "doc": "Configuration for the K8s API client",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains options relevant to connecting to the K8s API",
            "package": "pkg/core/common/kubernetes",
            "fields": [
              {
                "yamlName": "authType",
                "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                "default": "serviceAccount",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        },
        {
          "yamlName": "additionalPortAnnotations",
          "doc": "A list of annotation names that should be used to infer additional ports to be discovered on a particular pod.  The pod's annotation value should be a port number.  This is useful for annotations like `prometheus.io/port: 9230`.  If you don't already have preexisting annotations like this, we recommend using the [SignalFx-specific annotations](https://docs.signalfx.com/en/latest/kubernetes/k8s-monitors-observers.html#config-via-k8s-annotations).",
          "default": null,
          "required": false,
          "type": "slice",
          "elementKind": "string"
        }
      ],
      "observerType": "k8s-api",
      "dimensions": {
        "container_id": {
          "description": "The container id of the container running this endpoint."
        },
        "container_image": {
          "description": "The image name (including tags) of the running container"
        },
        "container_name": {
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        },
        "container_spec_name": {
          "description": "The short name of the container in the pod spec, **NOT** the running container's name in the Docker engine"
        },
        "kubernetes_namespace": {
          "description": "The namespace that the discovered service endpoint is running in."
        },
        "kubernetes_pod_name": {
          "description": "The name of the running pod that is exposing the discovered endpoint"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that is exposing the discovered endpoint"
        }
      },
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "has_port",
          "type": "string",
          "elementKind": "",
          "description": "Set to `true` if the endpoint has a port assigned to it.  This will be `false` for endpoints that represent a host/container as a whole."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "kubernetes_annotations",
          "type": "string",
          "elementKind": "",
          "description": "The set of annotations on the discovered pod."
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "pod_metadata",
          "type": "string",
          "elementKind": "",
          "description": "The full pod metadata object, as represented by the Go K8s client library (client-go): https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#ObjectMeta."
        },
        {
          "name": "pod_spec",
          "type": "string",
          "elementKind": "",
          "description": "The full pod spec object, as represented by the Go K8s client library (client-go): https://godoc.org/k8s.io/api/core/v1#PodSpec."
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions). For containers managed by Kubernetes, this will be set to the pod's labels, as individual containers do not have labels in Kubernetes proper."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint.  If this is an IPv6 address, it will be surrounded by `[` and `]`."
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint. For example, if using the `k8s-api` observer, `name` will be the port name in the pod spec, if any."
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        },
        {
          "name": "target",
          "type": "string",
          "elementKind": "",
          "description": "The type of the thing that this endpoint directly refers to.  If the endpoint has a host and port associated with it (most common), the value will be `hostport`.  Other possible values are: `pod`, `container`, `host`.  See the docs for the specific observer you are using for more details on what types that observer emits."
        }
      ]
    },
    {
      "name": "Config",
      "doc": " **DEPRECATED** Discovers service endpoints running on\nthe same node as the agent by querying the local kubelet instance.  It is\ngenerally recommended to use the [k8s-api](./k8s-api.md) observer because\nauthentication to the local kubelet can be more difficult to setup, and also\nthe kubelet API is technically not documented for public consumption, so\nthis observer may break more easily in future K8s versions.\n",
      "package": "pkg/observers/kubelet",
      "fields": [
        {
          "yamlName": "pollIntervalSeconds",
          "doc": "How often to poll the Kubelet instance for pod information",
          "default": 10,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "kubeletAPI",
          "doc": "Config for the Kubelet HTTP client",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains config specific to the KubeletAPI",
            "package": "pkg/core/common/kubelet",
            "fields": [
              {
                "yamlName": "url",
                "doc": "URL of the Kubelet instance.  This will default to `http://\u003ccurrent node hostname\u003e:10255` if not provided.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "authType",
                "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                "default": "none",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verification of the Kubelet's TLS cert",
                "default": true,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "logResponses",
                "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "observerType": "k8s-kubelet",
      "dimensions": {
        "container_id": {
          "description": "The container id of the container running this endpoint."
        },
        "container_image": {
          "description": "The image name (including tags) of the running container"
        },
        "container_name": {
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        },
        "container_spec_name": {
          "description": "The short name of the container in the pod spec, **NOT** the running container's name in the Docker engine"
        },
        "kubernetes_namespace": {
          "description": "The namespace that the discovered service endpoint is running in."
        },
        "kubernetes_pod_name": {
          "description": "The name of the running pod that is exposing the discovered endpoint"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that is exposing the discovered endpoint"
        }
      },
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "has_port",
          "type": "string",
          "elementKind": "",
          "description": "Set to `true` if the endpoint has a port assigned to it.  This will be `false` for endpoints that represent a host/container as a whole."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions). For containers managed by Kubernetes, this will be set to the pod's labels, as individual containers do not have labels in Kubernetes proper."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint.  If this is an IPv6 address, it will be surrounded by `[` and `]`."
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint. For example, if using the `k8s-api` observer, `name` will be the port name in the pod spec, if any."
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        },
        {
          "name": "target",
          "type": "string",
          "elementKind": "",
          "description": "The type of the thing that this endpoint directly refers to.  If the endpoint has a host and port associated with it (most common), the value will be `hostport`.  Other possible values are: `pod`, `container`, `host`.  See the docs for the specific observer you are using for more details on what types that observer emits."
        }
      ]
    }
  ],
  "SourceConfig": {
    "name": "SourceConfig",
    "doc": "SourceConfig represents configuration for various config sources that we support.",
    "package": "pkg/core/config/sources",
    "fields": [
      {
        "yamlName": "watch",
        "doc": "Whether to watch config sources for changes.  If this is `true` and any of the config changes (either the main agent.yaml, or remote config values), the agent will dynamically reconfigure itself with minimal disruption.  This is generally better than restarting the agent on config changes since that can result in larger gaps in metric data.  The main disadvantage of watching is slightly greater network and compute resource usage. This option is not itself watched for changes. If you change the value of this option, you must restart the agent.",
        "default": true,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "file",
        "doc": "Configuration for other file sources",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for the file-based config source",
          "package": "pkg/core/config/sources/file",
          "fields": [
            {
              "yamlName": "pollRateSeconds",
              "doc": "How often to poll files (in seconds) to test for changes.  There are so many edge cases that break inotify that it is more robust to simply poll files than rely on that. This option is not subject to watching and changes to it will require an agent restart.",
              "default": 5,
              "required": false,
              "type": "int",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "zookeeper",
        "doc": "Configuration for a Zookeeper remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config is used to configure the Zookeeper client",
          "package": "pkg/core/config/sources/zookeeper",
          "fields": [
            {
              "yamlName": "endpoints",
              "doc": "A list of Zookeeper servers to use for the client",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "timeoutSeconds",
              "doc": "Client timeout",
              "default": 10,
              "required": false,
              "type": "uint",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "etcd2",
        "doc": "Configuration for an Etcd 2 remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for an Etcd2 source",
          "package": "pkg/core/config/sources/etcd2",
          "fields": [
            {
              "yamlName": "endpoints",
              "doc": "A list of Etcd2 servers to use",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "username",
              "doc": "An optional username to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "password",
              "doc": "An optional password to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "consul",
        "doc": "Configuration for a Consul remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for the consul client",
          "package": "pkg/core/config/sources/consul",
          "fields": [
            {
              "yamlName": "endpoint",
              "doc": "A Consul server URL",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "username",
              "doc": "An optional username to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "password",
              "doc": "An optional password to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "token",
              "doc": "An authentication token, if needed",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "datacenter",
              "doc": "The Consul datacenter to use",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "vault",
        "doc": "Configuration for a Hashicorp Vault remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for the vault remote config",
          "package": "pkg/core/config/sources/vault",
          "fields": [
            {
              "yamlName": "vaultAddr",
              "doc": "The Vault Address.  Can also be provided by the standard Vault envvar `VAULT_ADDR`.  This option takes priority over the envvar if provided.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "vaultToken",
              "doc": "The Vault token, can also be provided by it the standard Vault envvar `VAULT_TOKEN`.  This option takes priority over the envvar if provided.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "kvV2PollInterval",
              "doc": "The polling interval for checking KV V2 secrets for a new version.  This can be any string value that can be parsed by https://golang.org/pkg/time/#ParseDuration.",
              "default": "60s",
              "required": false,
              "type": "int64",
              "elementKind": ""
            },
            {
              "yamlName": "authMethod",
              "doc": "The authetication method to use, if any, to obtain the Vault token.  If `vaultToken` is specified above, this option will have no effect. Currently supported values are: `iam`.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "iam",
              "doc": "Further config options for the `iam` auth method.  These options are identical to the [CLI helper tool options](https://github.com/hashicorp/vault/blob/v1.1.0/builtin/credential/aws/cli.go#L148)",
              "default": "",
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "IAMConfig",
                "doc": "IAMConfig is the config for the AWS Auth method in Vault",
                "package": "pkg/core/config/sources/vault/auth",
                "fields": [
                  {
                    "yamlName": "awsAccessKeyId",
                    "doc": "Explicit AWS access key ID",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "awsSecretAccessKey",
                    "doc": "Explicit AWS secret access key",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "awsSecurityToken",
                    "doc": "Explicit AWS security token for temporary credentials",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "headerValue",
                    "doc": "Value for the x-vault-aws-iam-server-id header in requests",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "mount",
                    "doc": "Path where the AWS credential method is mounted. This is usually provided via the -path flag in the \"vault login\" command, but it can be specified here as well. If specified here, it takes precedence over the value for -path. The default value is \"aws\".",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "role",
                    "doc": "Name of the Vault role to request a token against",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "gcp",
              "doc": "Further config options for the `gcp` auth method. These options are identical to the [CLI helper tool options](https://github.com/hashicorp/vault-plugin-auth-gcp/blob/e1f6784b379d277038ca0661606aa8d23791e392/plugin/cli.go#L120). You must provide a valid GCP IAM credential JSON either explicitly via the `credentials` option (not recommended), or through any GCP Application Default Credentials.",
              "default": "",
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "GCPConfig",
                "doc": "GCPConfig is the config for the GCP Auth method in Vault",
                "package": "pkg/core/config/sources/vault/auth",
                "fields": [
                  {
                    "yamlName": "role",
                    "doc": "Required. The name of the role you're requesting a token for.",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "mount",
                    "doc": "This is usually provided via the -path flag in the \"vault login\" command, but it can be specified here as well. If specified here, it takes precedence over the value for -path.  Defaults to `gcp`.",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "credentials",
                    "doc": "Explicitly specified GCP credentials in JSON string format (not recommended)",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "jwt_exp",
                    "doc": "Time until the generated JWT expires in minutes. The given IAM role will have a max_jwt_exp field, the time in minutes that all valid authentication JWTs must expire within (from time of authentication). Defaults to 15 minutes, the default max_jwt_exp for a role. Must be less than an hour.",
                    "default": null,
                    "required": false,
                    "type": "int",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "service_account",
                    "doc": "Service account to generate a JWT for. Defaults to credentials \"client_email\" if \"credentials\" specified and this value is not. The actual credential must have the \"iam.serviceAccounts.signJWT\" permissions on this service account.",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "project",
                    "doc": "Project for the service account who will be authenticating to Vault. Defaults to the credential's \"project_id\" (if credentials are specified).\"",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            }
          ]
        }
      }
    ]
  },
  "TopConfig": {
    "name": "Config",
    "doc": "Config is the top level config struct for configurations that are common to all platoforms",
    "package": "pkg/core/config",
    "fields": [
      {
        "yamlName": "signalFxAccessToken",
        "doc": "The access token for the org that should receive the metrics emitted by the agent.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "ingestUrl",
        "doc": "The URL of SignalFx ingest server.  Should be overridden if using the SignalFx Gateway.  If not set, this will be determined by the `signalFxRealm` option below.  If you want to send trace spans to a different location, set the `traceEndpointUrl` option.  If you want to send events to a different location, set the `eventEndpointUrl` option.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "eventEndpointUrl",
        "doc": "The full URL (including path) to the event ingest server.  If this is not set, all events will be sent to the same place as `ingestUrl` above.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "traceEndpointUrl",
        "doc": "The full URL (including path) to the trace ingest server.  If this is not set, all trace spans will be sent to the same place as `ingestUrl` above.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "apiUrl",
        "doc": "The SignalFx API base URL.  If not set, this will determined by the `signalFxRealm` option below.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "signalFxRealm",
        "doc": "The SignalFx Realm that the organization you want to send to is a part of.  This defaults to the original realm (`us0`) but if you are setting up the agent for the first time, you quite likely need to change this.",
        "default": "us0",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "hostname",
        "doc": "The hostname that will be reported as the `host` dimension. If blank, this will be auto-determined by the agent based on a reverse lookup of the machine's IP address.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "useFullyQualifiedHost",
        "doc": "If true (the default), and the `hostname` option is not set, the hostname will be determined by doing a reverse DNS query on the IP address that is returned by querying for the bare hostname.  This is useful in cases where the hostname reported by the kernel is a short name. (**default**: `true`)",
        "default": null,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "disableHostDimensions",
        "doc": "Our standard agent model is to collect metrics for services running on the same host as the agent.  Therefore, host-specific dimensions (e.g. `host`, `AWSUniqueId`, etc) are automatically added to every datapoint that is emitted from the agent by default.  Set this to true if you are using the agent primarily to monitor things on other hosts.  You can set this option at the monitor level as well.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "intervalSeconds",
        "doc": "How often to send metrics to SignalFx.  Monitors can override this individually.",
        "default": 10,
        "required": false,
        "type": "int",
        "elementKind": ""
      },
      {
        "yamlName": "globalDimensions",
        "doc": "Dimensions (key:value pairs) that will be added to every datapoint emitted by the agent. To specify that all metrics should be high-resolution, add the dimension `sf_hires: 1`",
        "default": "",
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "sendMachineID",
        "doc": "Whether to send the machine-id dimension on all host-specific datapoints generated by the agent.  This dimension is derived from the Linux machine-id value.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "cluster",
        "doc": "The logical environment/cluster that this agent instance is running in. All of the services that this instance monitors should be in the same environment as well. This value, if provided, will be synced as a property onto the `host` dimension, or onto any cloud-provided specific dimensions (`AWSUniqueId`, `gcp_id`, and `azure_resource_id`) when available. Example values: \"prod-usa\", \"dev\"",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "syncClusterOnHostDimension",
        "doc": "If true, force syncing of the `cluster` property on the `host` dimension, even when cloud-specific dimensions are present.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "validateDiscoveryRules",
        "doc": "If true, a warning will be emitted if a discovery rule contains variables that will never possibly match a rule.  If using multiple observers, it is convenient to set this to false to suppress spurious errors.",
        "default": true,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "observers",
        "doc": "A list of observers to use (see observer config)",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "ObserverConfig",
          "doc": "ObserverConfig holds the configuration for an observer",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "type",
              "doc": "The type of the observer",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "monitors",
        "doc": "A list of monitors to use (see monitor config)",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MonitorConfig",
          "doc": "MonitorConfig is used to configure monitor instances.  One instance of MonitorConfig may be used to configure multiple monitor instances.  If a monitor's discovery rule does not match any discovered services, the monitor will not run.",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "type",
              "doc": "The type of the monitor",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "discoveryRule",
              "doc": "The rule used to match up this configuration with a discovered endpoint. If blank, the configuration will be run immediately when the agent is started.  If multiple endpoints match this rule, multiple instances of the monitor type will be created with the same configuration (except different host/port).",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "validateDiscoveryRule",
              "doc": "If true, a warning will be emitted if a discovery rule contains variables that will never possibly match a rule.  If using multiple observers, it is convenient to set this to false to suppress spurious errors.  The top-level setting `validateDiscoveryRules` acts as a default if this isn't set.",
              "default": "false",
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "extraDimensions",
              "doc": "A set of extra dimensions (key:value pairs) to include on datapoints emitted by the monitor(s) created from this configuration. To specify metrics from this monitor should be high-resolution, add the dimension `sf_hires: 1`",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "extraDimensionsFromEndpoint",
              "doc": "A mapping of extra dimension names to a [discovery rule expression](https://docs.signalfx.com/en/latest/integrations/agent/auto-discovery.html) that is used to derive the value of the dimension.  For example, to use a certain container label as a dimension, you could use something like this in your monitor config block: `extraDimensionsFromEndpoint: {env: 'Get(container_labels, \"myapp.com/environment\")'}`",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "configEndpointMappings",
              "doc": "A set of mappings from a configuration option on this monitor to attributes of a discovered endpoint.  The keys are the config option on this monitor and the value can be any valid expression used in discovery rules.",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "intervalSeconds",
              "doc": "The interval (in seconds) at which to emit datapoints from the monitor(s) created by this configuration.  If not set (or set to 0), the global agent intervalSeconds config option will be used instead.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "solo",
              "doc": "If one or more configurations have this set to true, only those configurations will be considered. This setting can be useful for testing.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "metricsToExclude",
              "doc": "DEPRECATED in favor of the `datapointsToExclude` option.  That option handles negation of filter items differently.",
              "default": "",
              "required": false,
              "type": "slice",
              "elementKind": "struct",
              "elementStruct": {
                "name": "MetricFilter",
                "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
                "package": "pkg/core/config",
                "fields": [
                  {
                    "yamlName": "dimensions",
                    "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
                    "default": "",
                    "required": false,
                    "type": "map",
                    "elementKind": "interface"
                  },
                  {
                    "yamlName": "metricNames",
                    "doc": "A list of metric names to match against",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "metricName",
                    "doc": "A single metric name to match against",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "monitorType",
                    "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "negated",
                    "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
                    "default": false,
                    "required": false,
                    "type": "bool",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "datapointsToExclude",
              "doc": "A list of datapoint filters.  These filters allow you to comprehensively define which datapoints to exclude by metric name or dimension set, as well as the ability to define overrides to re-include metrics excluded by previous patterns within the same filter item.  See [monitor filtering](./filtering.md#additional-monitor-level-filtering) for examples and more information.",
              "default": "",
              "required": false,
              "type": "slice",
              "elementKind": "struct",
              "elementStruct": {
                "name": "MetricFilter",
                "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
                "package": "pkg/core/config",
                "fields": [
                  {
                    "yamlName": "dimensions",
                    "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
                    "default": "",
                    "required": false,
                    "type": "map",
                    "elementKind": "interface"
                  },
                  {
                    "yamlName": "metricNames",
                    "doc": "A list of metric names to match against",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "metricName",
                    "doc": "A single metric name to match against",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "monitorType",
                    "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "negated",
                    "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
                    "default": false,
                    "required": false,
                    "type": "bool",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "disableHostDimensions",
              "doc": "Some monitors pull metrics from services not running on the same host and should not get the host-specific dimensions set on them (e.g. `host`, `AWSUniqueId`, etc).  Setting this to `true` causes those dimensions to be omitted.  You can disable this globally with the `disableHostDimensions` option on the top level of the config.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "disableEndpointDimensions",
              "doc": "This can be set to true if you don't want to include the dimensions that are specific to the endpoint that was discovered by an observer.  This is useful when you have an endpoint whose identity is not particularly important since it acts largely as a proxy or adapter for other metrics.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "dimensionTransformations",
              "doc": "A map from dimension names emitted by the monitor to the desired dimension name that will be emitted in the datapoint that goes to SignalFx.  This can be useful if you have custom metrics from your applications and want to make the dimensions from a monitor match those. Also can be useful when scraping free-form metrics, say with the `prometheus-exporter` monitor.  Right now, only static key/value transformations are supported.  Note that filtering by dimensions will be done on the *original* dimension name and not the new name. Note that it is possible to remove unwanted dimensions via this configuration, by making the desired dimension name an empty string.",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "extraMetrics",
              "doc": "Extra metrics to enable besides the default included ones.  This is an [overridable filter](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filtering).",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "extraGroups",
              "doc": "Extra metric groups to enable in addition to the metrics that are emitted by default.  A metric group is simply a collection of metrics, and they are defined in each monitor's documentation.",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            }
          ]
        }
      },
      {
        "yamlName": "writer",
        "doc": "Configuration of the datapoint/event writer",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "WriterConfig",
          "doc": "WriterConfig holds configuration for the datapoint writer.",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "datapointMaxBatchSize",
              "doc": "The maximum number of datapoints to include in a batch before sending the batch to the ingest server.  Smaller batch sizes than this will be sent if datapoints originate in smaller chunks.",
              "default": 1000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "maxDatapointsBuffered",
              "doc": "The maximum number of datapoints that are allowed to be buffered in the agent (i.e. received from a monitor but have not yet received confirmation of successful receipt by the target ingest/gateway server downstream).  Any datapoints that come in beyond this number will overwrite existing datapoints if they have not been sent yet, starting with the oldest.",
              "default": 25000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "traceSpanMaxBatchSize",
              "doc": "The analogue of `datapointMaxBatchSize` for trace spans.",
              "default": 1000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "traceExportFormat",
              "doc": "Format to export traces in. Choices are \"zipkin\" and \"sapm\"",
              "default": "zipkin",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "datapointMaxRequests",
              "doc": "Deprecated: use `maxRequests` instead.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "maxRequests",
              "doc": "The maximum number of concurrent requests to make to a single ingest server with datapoints/events/trace spans.  This number multiplied by `datapointMaxBatchSize` is more or less the maximum number of datapoints that can be \"in-flight\" at any given time.  Same thing for the `traceSpanMaxBatchSize` option and trace spans.",
              "default": 10,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "eventSendIntervalSeconds",
              "doc": "The agent does not send events immediately upon a monitor generating them, but buffers them and sends them in batches.  The lower this number, the less delay for events to appear in SignalFx.",
              "default": 1,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesMaxRequests",
              "doc": "The analogue of `maxRequests` for dimension property requests.",
              "default": 20,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesMaxBuffered",
              "doc": "How many dimension property updates to hold pending being sent before dropping subsequent property updates.  Property updates will be resent eventually and they are slow to change so dropping them (esp on agent start up) usually isn't a big deal.",
              "default": 10000,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesSendDelaySeconds",
              "doc": "How long to wait for property updates to be sent once they are generated.  Any duplicate updates to the same dimension within this time frame will result in the latest property set being sent.  This helps prevent spurious updates that get immediately overwritten by very flappy property generation.",
              "default": 30,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesHistorySize",
              "doc": "Properties that are synced to SignalFx are cached to prevent duplicate requests from being sent, causing unnecessary load on our backend.",
              "default": 10000,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "logDatapoints",
              "doc": "If the log level is set to `debug` and this is true, all datapoints generated by the agent will be logged.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logEvents",
              "doc": "The analogue of `logDatapoints` for events.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logTraceSpans",
              "doc": "The analogue of `logDatapoints` for trace spans.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logDimensionUpdates",
              "doc": "If `true`, dimension updates will be logged at the INFO level.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logDroppedDatapoints",
              "doc": "If true, and the log level is `debug`, filtered out datapoints will be logged.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "sendTraceHostCorrelationMetrics",
              "doc": "Whether to send host correlation metrics to correlation traced services with the underlying host",
              "default": true,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "staleServiceTimeout",
              "doc": "How long to wait after a trace span's service name is last seen to continue sending the correlation datapoints for that service.  This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration.  This option is irrelvant if `sendTraceHostCorrelationMetrics` is false.",
              "default": "5m",
              "required": false,
              "type": "int64",
              "elementKind": ""
            },
            {
              "yamlName": "traceHostCorrelationMetricsInterval",
              "doc": "How frequently to send host correlation metrics that are generated from the service name seen in trace spans sent through or by the agent.  This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration.  This option is irrelvant if `sendTraceHostCorrelationMetrics` is false.",
              "default": "1m",
              "required": false,
              "type": "int64",
              "elementKind": ""
            },
            {
              "yamlName": "maxTraceSpansInFlight",
              "doc": "How many trace spans are allowed to be in the process of sending.  While this number is exceeded, the oldest spans will be discarded to accommodate new spans generated to avoid memory exhaustion.  If you see log messages about \"Aborting pending trace requests...\" or \"Dropping new trace spans...\" it means that the downstream target for traces is not able to accept them fast enough. Usually if the downstream is offline you will get connection refused errors and most likely spans will not build up in the agent (there is no retry mechanism). In the case of slow downstreams, you might be able to increase `maxRequests` to increase the concurrent stream of spans downstream (if the target can make efficient use of additional connections) or, less likely, increase `traceSpanMaxBatchSize` if your batches are maxing out (turn on debug logging to see the batch sizes being sent) and being split up too much. If neither of those options helps, your downstream is likely too slow to handle the volume of trace spans and should be upgraded to more powerful hardware/networking.",
              "default": 100000,
              "required": false,
              "type": "uint",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "logging",
        "doc": "Log configuration",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "LogConfig",
          "doc": "LogConfig contains configuration related to logging",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "level",
              "doc": "Valid levels include `debug`, `info`, `warn`, `error`.  Note that `debug` logging may leak sensitive configuration (e.g. passwords) to the agent output.",
              "default": "info",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "format",
              "doc": "The log output format to use.  Valid values are: `text`, `json`.",
              "default": "text",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "collectd",
        "doc": "Configuration of the managed collectd subprocess",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "CollectdConfig",
          "doc": "CollectdConfig high-level configurations",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "disableCollectd",
              "doc": "If you won't be using any collectd monitors, this can be set to true to prevent collectd from pre-initializing",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "timeout",
              "doc": "How many read intervals before abandoning a metric. Doesn't affect much in normal usage. See [Timeout](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#timeout_iterations).",
              "default": 40,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "readThreads",
              "doc": "Number of threads dedicated to executing read callbacks. See [ReadThreads](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#readthreads_num)",
              "default": 5,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeThreads",
              "doc": "Number of threads dedicated to writing value lists to write callbacks. This should be much less than readThreads because writing is batched in the write_http plugin that writes back to the agent. See [WriteThreads](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writethreads_num).",
              "default": 2,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeQueueLimitHigh",
              "doc": "The maximum numbers of values in the queue to be written back to the agent from collectd.  Since the values are written to a local socket that the agent exposes, there should be almost no queuing and the default should be more than sufficient. See [WriteQueueLimitHigh](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writequeuelimithigh_highnum)",
              "default": 500000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeQueueLimitLow",
              "doc": "The lowest number of values in the collectd queue before which metrics begin being randomly dropped.  See [WriteQueueLimitLow](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writequeuelimitlow_lownum)",
              "default": 400000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "logLevel",
              "doc": "Collectd's log level -- info, notice, warning, or err",
              "default": "notice",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "intervalSeconds",
              "doc": "A default read interval for collectd plugins.  If zero or undefined, will default to the global agent interval.  Some collectd python monitors do not support overridding the interval at the monitor level, but this setting will apply to them.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeServerIPAddr",
              "doc": "The local IP address of the server that the agent exposes to which collectd will send metrics.  This defaults to an arbitrary address in the localhost subnet, but can be overridden if needed.",
              "default": "127.9.8.7",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "writeServerPort",
              "doc": "The port of the agent's collectd metric sink server.  If set to zero (the default) it will allow the OS to assign it a free port.",
              "default": 0,
              "required": false,
              "type": "uint16",
              "elementKind": ""
            },
            {
              "yamlName": "configDir",
              "doc": "This is where the agent will write the collectd config files that it manages.  If you have secrets in those files, consider setting this to a path on a tmpfs mount.  The files in this directory should be considered transient -- there is no value in editing them by hand.  If you want to add your own collectd config, see the collectd/custom monitor.",
              "default": "/var/run/signalfx-agent/collectd",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "enableBuiltInFiltering",
        "doc": "If true, the agent will filter out [custom metrics](https://docs.signalfx.com/en/latest/admin-guide/usage.html#about-custom-bundled-and-high-resolution-metrics) without having to rely on the `whitelist.json` filter that was previously configured under `metricsToExclude`.  Whether a metric is custom or not is documented in each monitor's documentation.  If `true`, every monitor's default configuration (i.e. the minimum amount of configuration to make it work) will only send non-custom metrics.  In order to send out custom metrics from a monitor, certain config flags on the monitor must be set _or_ you can specify the metric in the `extraMetrics` config option on each monitor if you know the specific metric name.  You would not have to modify the whitelist via `metricsToInclude` as before.  If you set this option to `true`, the `whitelist.json` entry under `metricToExclude` should be removed, if it is present -- otherwise custom metrics won't be emitted.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "metricsToInclude",
        "doc": "A list of metric filters that will whitelist/include metrics.  These filters take priority over the filters specified in `metricsToExclude`.",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "interface"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "metricsToExclude",
        "doc": "A list of metric filters",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "interface"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "propertiesToExclude",
        "doc": "A list of properties filters",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "PropertyFilterConfig",
          "doc": "PropertyFilterConfig describes a set of subtractive filters applied to properties used to create a PropertyFilter",
          "package": "pkg/core/config",
          "fields": [
            {
              "yamlName": "propertyName",
              "doc": "A single property name to match",
              "default": "*",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "propertyValue",
              "doc": "A property value to match",
              "default": "*",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "dimensionName",
              "doc": "A dimension name to match",
              "default": "*",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "dimensionValue",
              "doc": "A dimension value to match",
              "default": "*",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "internalStatusHost",
        "doc": "The host on which the internal status server will listen.  The internal status HTTP server serves internal metrics and diagnostic information about the agent and can be scraped by the `internal-metrics` monitor. Can be set to `0.0.0.0` if you want to monitor the agent from another host.  If you set this to blank/null, the internal status server will not be started.  See `internalStatusPort`.",
        "default": "localhost",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "internalStatusPort",
        "doc": "The port on which the internal status server will listen.  See `internalStatusHost`.",
        "default": 8095,
        "required": false,
        "type": "uint16",
        "elementKind": ""
      },
      {
        "yamlName": "profiling",
        "doc": "Enables Go pprof endpoint on port 6060 that serves profiling data for development",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "profilingHost",
        "doc": "The host/ip address for the pprof profile server to listen on. `profiling` must be enabled for this to have any effect.",
        "default": "127.0.0.1",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "profilingPort",
        "doc": "The port for the pprof profile server to listen on. `profiling` must be enabled for this to have any effect.",
        "default": 6060,
        "required": false,
        "type": "int",
        "elementKind": ""
      },
      {
        "yamlName": "bundleDir",
        "doc": "Path to the directory holding the agent dependencies.  This will normally be derived automatically. Overrides the envvar SIGNALFX_BUNDLE_DIR if set.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "scratch",
        "doc": "This exists purely to give the user a place to put common yaml values to reference in other parts of the config file.",
        "default": null,
        "required": false,
        "type": "interface",
        "elementKind": ""
      },
      {
        "yamlName": "configSources",
        "doc": "Configuration of remote config stores",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "SourceConfig",
          "doc": "SourceConfig represents configuration for various config sources that we support.",
          "package": "pkg/core/config/sources",
          "fields": [
            {
              "yamlName": "watch",
              "doc": "Whether to watch config sources for changes.  If this is `true` and any of the config changes (either the main agent.yaml, or remote config values), the agent will dynamically reconfigure itself with minimal disruption.  This is generally better than restarting the agent on config changes since that can result in larger gaps in metric data.  The main disadvantage of watching is slightly greater network and compute resource usage. This option is not itself watched for changes. If you change the value of this option, you must restart the agent.",
              "default": true,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "file",
              "doc": "Configuration for other file sources",
              "default": "",
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for the file-based config source",
                "package": "pkg/core/config/sources/file",
                "fields": [
                  {
                    "yamlName": "pollRateSeconds",
                    "doc": "How often to poll files (in seconds) to test for changes.  There are so many edge cases that break inotify that it is more robust to simply poll files than rely on that. This option is not subject to watching and changes to it will require an agent restart.",
                    "default": 5,
                    "required": false,
                    "type": "int",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "zookeeper",
              "doc": "Configuration for a Zookeeper remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config is used to configure the Zookeeper client",
                "package": "pkg/core/config/sources/zookeeper",
                "fields": [
                  {
                    "yamlName": "endpoints",
                    "doc": "A list of Zookeeper servers to use for the client",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "timeoutSeconds",
                    "doc": "Client timeout",
                    "default": 10,
                    "required": false,
                    "type": "uint",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "etcd2",
              "doc": "Configuration for an Etcd 2 remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for an Etcd2 source",
                "package": "pkg/core/config/sources/etcd2",
                "fields": [
                  {
                    "yamlName": "endpoints",
                    "doc": "A list of Etcd2 servers to use",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "username",
                    "doc": "An optional username to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "password",
                    "doc": "An optional password to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "consul",
              "doc": "Configuration for a Consul remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for the consul client",
                "package": "pkg/core/config/sources/consul",
                "fields": [
                  {
                    "yamlName": "endpoint",
                    "doc": "A Consul server URL",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "username",
                    "doc": "An optional username to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "password",
                    "doc": "An optional password to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "token",
                    "doc": "An authentication token, if needed",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "datacenter",
                    "doc": "The Consul datacenter to use",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "vault",
              "doc": "Configuration for a Hashicorp Vault remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for the vault remote config",
                "package": "pkg/core/config/sources/vault",
                "fields": [
                  {
                    "yamlName": "vaultAddr",
                    "doc": "The Vault Address.  Can also be provided by the standard Vault envvar `VAULT_ADDR`.  This option takes priority over the envvar if provided.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "vaultToken",
                    "doc": "The Vault token, can also be provided by it the standard Vault envvar `VAULT_TOKEN`.  This option takes priority over the envvar if provided.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "kvV2PollInterval",
                    "doc": "The polling interval for checking KV V2 secrets for a new version.  This can be any string value that can be parsed by https://golang.org/pkg/time/#ParseDuration.",
                    "default": "60s",
                    "required": false,
                    "type": "int64",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "authMethod",
                    "doc": "The authetication method to use, if any, to obtain the Vault token.  If `vaultToken` is specified above, this option will have no effect. Currently supported values are: `iam`.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "iam",
                    "doc": "Further config options for the `iam` auth method.  These options are identical to the [CLI helper tool options](https://github.com/hashicorp/vault/blob/v1.1.0/builtin/credential/aws/cli.go#L148)",
                    "default": "",
                    "required": false,
                    "type": "struct",
                    "elementKind": "",
                    "elementStruct": {
                      "name": "IAMConfig",
                      "doc": "IAMConfig is the config for the AWS Auth method in Vault",
                      "package": "pkg/core/config/sources/vault/auth",
                      "fields": [
                        {
                          "yamlName": "awsAccessKeyId",
                          "doc": "Explicit AWS access key ID",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "awsSecretAccessKey",
                          "doc": "Explicit AWS secret access key",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "awsSecurityToken",
                          "doc": "Explicit AWS security token for temporary credentials",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "headerValue",
                          "doc": "Value for the x-vault-aws-iam-server-id header in requests",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "mount",
                          "doc": "Path where the AWS credential method is mounted. This is usually provided via the -path flag in the \"vault login\" command, but it can be specified here as well. If specified here, it takes precedence over the value for -path. The default value is \"aws\".",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "role",
                          "doc": "Name of the Vault role to request a token against",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        }
                      ]
                    }
                  },
                  {
                    "yamlName": "gcp",
                    "doc": "Further config options for the `gcp` auth method. These options are identical to the [CLI helper tool options](https://github.com/hashicorp/vault-plugin-auth-gcp/blob/e1f6784b379d277038ca0661606aa8d23791e392/plugin/cli.go#L120). You must provide a valid GCP IAM credential JSON either explicitly via the `credentials` option (not recommended), or through any GCP Application Default Credentials.",
                    "default": "",
                    "required": false,
                    "type": "struct",
                    "elementKind": "",
                    "elementStruct": {
                      "name": "GCPConfig",
                      "doc": "GCPConfig is the config for the GCP Auth method in Vault",
                      "package": "pkg/core/config/sources/vault/auth",
                      "fields": [
                        {
                          "yamlName": "role",
                          "doc": "Required. The name of the role you're requesting a token for.",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "mount",
                          "doc": "This is usually provided via the -path flag in the \"vault login\" command, but it can be specified here as well. If specified here, it takes precedence over the value for -path.  Defaults to `gcp`.",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "credentials",
                          "doc": "Explicitly specified GCP credentials in JSON string format (not recommended)",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "jwt_exp",
                          "doc": "Time until the generated JWT expires in minutes. The given IAM role will have a max_jwt_exp field, the time in minutes that all valid authentication JWTs must expire within (from time of authentication). Defaults to 15 minutes, the default max_jwt_exp for a role. Must be less than an hour.",
                          "default": null,
                          "required": false,
                          "type": "int",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "service_account",
                          "doc": "Service account to generate a JWT for. Defaults to credentials \"client_email\" if \"credentials\" specified and this value is not. The actual credential must have the \"iam.serviceAccounts.signJWT\" permissions on this service account.",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "project",
                          "doc": "Project for the service account who will be authenticating to Vault. Defaults to the credential's \"project_id\" (if credentials are specified).\"",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        }
                      ]
                    }
                  }
                ]
              }
            }
          ]
        }
      },
      {
        "yamlName": "procPath",
        "doc": "Path to the host's `/proc` filesystem. This is useful for containerized environments.",
        "default": "/proc",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "etcPath",
        "doc": "Path to the host's `/etc` directory. This is useful for containerized environments.",
        "default": "/etc",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "varPath",
        "doc": "Path to the host's `/var` directory. This is useful for containerized environments.",
        "default": "/var",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "runPath",
        "doc": "Path to the host's `/run` directory. This is useful for containerized environments.",
        "default": "/run",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "sysPath",
        "doc": "Path to the host's `/sys` directory. This is useful for containerized environments.",
        "default": "/sys",
        "required": false,
        "type": "string",
        "elementKind": ""
      }
    ]
  }
}
