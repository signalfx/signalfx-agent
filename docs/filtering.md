# Filtering

You may wish to filter out certain datapoints or properties at a 
high level to prevent them from ever leaving the agent. 
Filtering can be useful to reduce clutter in charts without having to 
resort to filtering in the UI.  If possible, it is preferable to prevent
the datapoints and properties you want to omit from being generated by
a monitor in the first place, as this will reduce CPU and
memory usage of the agent, but sometimes this is impractical.

## Datapoint Filtering

Filters can be specified with the `metricsToExclude` config of the agent
config.  This parameter should be a list of filters that specify the metric
name and/or dimensions to match on.

Metric names and dimension values can be either globbed (i.e. where `*` is a
wildcard for zero or more characters, and `?` is a wildcard for a single
character) or specified as a Go-compatible regular expression (the value must
be surrounded by `/` to be considered a regex).

You can limit the scope of a filter to a specific monitor type with the
`monitorType` option in the filter item.  This value matches the monitor type
used in the monitor config.  This is very useful when trying to filter on a
heavily overloaded dimension, such as the `plugin_instance` dimension that most
collectd-based monitors emit.

Sometimes it is easier to whitelist the metrics you want to allow through.
You can do this by setting the `negated` option to `true` on a filter item.
This makes all metric name and dimension matching negated so that only
datapoints with that name or dimension are allowed through.  You would also
use this option to specify custom metrics that you want to send to SignalFx.
The `monitorType`option is never negated, and always serves to scope a filter 
item to the specified monitor type, if given.

Examples:

```yaml
  # If a metric matches any one of these filters it will be excluded.
  metricsToExclude:
    # Excludes all metrics that start with 'container_spec_memory_'
    - metricName: container_spec_memory_*

    # Excludes multiple metric names in a single filter
    - metricNames:
      - container_start_time_seconds
      - container_tasks_state

    # Excludes networking metrics about flannel interfaces that match the
    # pattern (e.g. 'flannel.1', 'flannel.2', etc.)
    - metricName: pod_network_*
      dimensions:
        interface: /flannel\.\d/

    # This is a metric from collectd.  All instances of it will be suppressed.
    - metricName: vmpage_io.swap.in

    # This filter will only match against datapoints from the collectd/df
    # monitor
    - dimensions:
        plugin_instance: dm-*
      monitorType: collectd/df

    # This only allows cpu and memory metrics from the docker monitor to come
    # through.  Note that the monitorType is never negated, and metrics from
    # other monitors will not be excluded since this filter is scoped to a
    # single monitor.
    - metricNames:
      - cpu*
      - memory*
      monitorType: collectd/docker
      negated: true

    # This indicates that you want to monitor the custom metrics
    # gauge.cluster.status and gauge.thread_pool.active for the
    # elasticsearch monitor.
    - metricNames:
      - gauge.cluster.status
      - gauge.thread_pool.active
      monitorType: collectd/elasticsearch
      negated: true

```

## Property Filtering
Property filtering behaves very similar to datapoint filtering.
Filters can be specified with the `propertiesToExclude` config of the agent
config. This parameter should be a list of filters that specify which
properties to exclude by defining any or all of the following: `dimensionName`,
`dimensionValue`, `propertyName`, `propertyValues`. Each filter from the list
will be applied to all properties the agent emits, so be careful when scoping.

Properties and dimensions (both names and values) can be either
globbed (i.e. where `*` is a wildcard for zero or more characters, and `?` is
a wildcard for a single character) or specified as a Go-compatible regular
expression (the value must be surrounded by `/` to be considered a regex).

Sometimes it is easier to whitelist the properties you want to allow through,
and not allow any others.
You can do this by prefixing any config value with `!`, which will negate the
matching value. This can be applied to any of the config options.
See examples below.


Examples:
```yaml
  # If a property matches any one of these filters it will be excluded
  propertiesToExclude:
    # Exclude 'pod-template-hash' from syncing to any dimension
    - propertyName: pod-template-hash

    # Do not sync any properties to 'kubernetes_pod_uid'
    - dimensionName: kubernetes_pod_uid
    
    # Exclude 'pod-template-hash'  from syncing on dimension 'kubernetes_pod_uid'
    - propertyName: pod-template-hash
      dimensionName: kubernetes_pod_uid

    # Exclude all properties except 'pod-template-hash' on 'kubernetes_pod_uid'
    -  propertyName: "!pod-template-hash"
       dimensionName: kubernetes_pod_uid

    # Do not sync any property beginning with 'load_balancer' to 'kubernetes_pod_uid'
    - propertyName: "load_balancer*"
      dimensionName: kubernetes_pod_uid

    # Do not sync any property name 'pod-template-hash' beginning with value '123'
    # on a dimension name `kubernetes_pod_uid` with a dimension value starting
    # with 'abc'
    - propertyName: pod-template-hash
      propertyValue: "123*"
      dimensionName: kubernetes_pod_uid
      dimensionValue: "abc*"
```
