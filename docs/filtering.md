# Filtering

You may wish to filter out certain datapoints or properties at a
high level to prevent them from ever leaving the agent.
Filtering can be useful to reduce clutter in charts without having to
resort to filtering in the UI.  If possible, it is preferable to prevent
the datapoints and properties you want to omit from being generated by
a monitor in the first place, as this will reduce CPU and
memory usage of the agent, but sometimes this is impractical.

## Datapoint Filtering

Filters can be specified with the `metricsToExclude` config of the agent
config.  This parameter should be a list of filters that specify the metric
name and/or dimensions to match on.

Metric names and dimension values can be either globbed (i.e. where `*` is a
wildcard for zero or more characters, and `?` is a wildcard for a single
character) or specified as a Go-compatible regular expression (the value must
be surrounded by `/` to be considered a regex).

You can limit the scope of a filter to a specific monitor type with the
`monitorType` option in the filter item.  This value matches the monitor type
used in the monitor config.  This is very useful when trying to filter on a
heavily overloaded dimension, such as the `plugin_instance` dimension that most
collectd-based monitors emit.

Sometimes it is easier to whitelist the metrics you want to allow through.
You can do this by setting the `negated` option to `true` on a filter item.
This makes all metric name and dimension matching negated so that only
datapoints with that name or dimension are allowed through.  You would also
use this option to specify custom metrics that you want to send to SignalFx.
The `monitorType` option is never negated, and always serves to scope a filter
item to the specified monitor type, if given. In the case where multiple filters
overlap, they will be combined by the agent. If metrics are matched by two filters
which have opposite negation, the agent will favor exclusion.

Examples:

```yaml
  # If a metric matches any one of these filters it will be excluded.
  metricsToExclude:
    # Excludes all metrics that start with 'container_spec_memory_'
    - metricName: container_spec_memory_*

    # Excludes multiple metric names in a single filter
    - metricNames:
      - container_start_time_seconds
      - container_tasks_state

    # Excludes networking metrics about flannel interfaces that match the
    # pattern (e.g. 'flannel.1', 'flannel.2', etc.)
    - metricName: pod_network_*
      dimensions:
        interface: /flannel\.\d/

    # This is a metric from collectd.  All instances of it will be suppressed.
    - metricName: vmpage_io.swap.in

    # This filter will only match against datapoints from the collectd/df
    # monitor
    - dimensions:
        plugin_instance: dm-*
      monitorType: collectd/df

    # This only allows cpu and memory metrics from the docker monitor to come
    # through.  Note that the monitorType is never negated, and metrics from
    # other monitors will not be excluded since this filter is scoped to a
    # single monitor.
    - metricNames:
      - cpu*
      - memory*
      monitorType: collectd/docker
      negated: true

    # This indicates that you want to monitor the custom metrics
    # gauge.cluster.status and gauge.thread_pool.active for the
    # elasticsearch monitor.
    - metricNames:
      - gauge.cluster.status
      - gauge.thread_pool.active
      monitorType: collectd/elasticsearch
      negated: true

    # This will be automatically merged with the above filter to produce one
    # whitelist filter on three metric names for elasticsearch
    - metricNames:
      - gauge.thread_pool.inactive
      monitorType: collectd/elasticsearch
      negated: true

    # This will override the above filter, exclusion is always favored
    - metricNames:
      - gauge.thread_pool.inactive
      monitorType: collectd/elasticsearch
```

### Inclusion filtering
Sometimes it is necessary to specify metrics that you want to include even when
they would be otherwise excluded by filters in `metricsToExclude`.  Therefore,
there is the `metricsToInclude` option that should be a list of the same type
of metric filters used in `metricsToExclude`.

The main difference between a filter in `metricsToExclude` that has `negated:
true` and a filter in `metricsToInclude` is that the filter in
`metricsToExclude` will actually exclude metrics that don't match the filter,
whereas the filter in `metricsToInclude` will never exclude anything, but only
override the exclusion in `metricsToExclude`.

For example:

```yaml
  metricsToExclude:
   - metricNames:
     - request_size
     - response_size
  metricsToInclude:
   # This allows through datapoints with the name `request_size` that have the
   # specified dimension but still excludes other datapoints without those
   # dimensions.  All `response_size` metrics are still excluded.
   - metricName: request_size
     dimensions:
       app: bigapp
```

This can be useful for overridding the built-in whitelist for metrics.


## Property Filtering
Property filtering behaves very similar to datapoint filtering.
Filters can be specified with the `propertiesToExclude` config of the agent
config. This parameter should be a list of filters that specify which
properties to exclude by defining any or all of the following: `dimensionName`,
`dimensionValue`, `propertyName`, `propertyValues`. Each filter from the list
will be applied to all properties the agent emits, so be careful when scoping.

Properties and dimensions (both names and values) can be either
globbed (i.e. where `*` is a wildcard for zero or more characters, and `?` is
a wildcard for a single character) or specified as a Go-compatible regular
expression (the value must be surrounded by `/` to be considered a regex).

Sometimes it is easier to whitelist the properties you want to allow through,
and not allow any others.
You can do this by prefixing any config value with `!`, which will negate the
matching value. This can be applied to any of the config options.
See examples below.


Examples:
```yaml
  # If a property matches any one of these filters it will be excluded
  propertiesToExclude:
    # Exclude 'pod-template-hash' from syncing to any dimension
    - propertyName: pod-template-hash

    # Do not sync any properties to 'kubernetes_pod_uid'
    - dimensionName: kubernetes_pod_uid

    # Exclude 'pod-template-hash'  from syncing on dimension 'kubernetes_pod_uid'
    - propertyName: pod-template-hash
      dimensionName: kubernetes_pod_uid

    # Exclude all properties except 'pod-template-hash' on 'kubernetes_pod_uid'
    -  propertyName: "!pod-template-hash"
       dimensionName: kubernetes_pod_uid

    # Do not sync any property beginning with 'load_balancer' to 'kubernetes_pod_uid'
    - propertyName: "load_balancer*"
      dimensionName: kubernetes_pod_uid

    # Do not sync any property name 'pod-template-hash' beginning with value '123'
    # on a dimension name `kubernetes_pod_uid` with a dimension value starting
    # with 'abc'
    - propertyName: pod-template-hash
      propertyValue: "123*"
      dimensionName: kubernetes_pod_uid
      dimensionValue: "abc*"
```

## Generic Filters

Some config options for monitors and observers support comprehensive filtering that
accepts a list of strings that define the filter.  These config options support
string literals, globbed values, and regular expressions.  Filter items can be prefixed
by `!` to exclude the given values (which can then also be literal values,
globbed values, or regular expressions).

Regular expressions are processed by the [Golang regexp package](https://golang.org/pkg/regexp/syntax/),
so the syntax can be anything supported by that.

Globs can be anything with `*` (zero or more characters) or `?` (zero or one character).

Examples:

```yaml
 # Would allow the values "a" and "b" and nothing else
 filter:
  - a
  - b

 # Would allow all values except for "a"
 filter:
  - "*"
  - "!a"

 # Would allow all values matching the pattern disk_* except for "disk_tmp"
 filter:
  - "/disk_.*/"
  - "!disk_tmp"

```
