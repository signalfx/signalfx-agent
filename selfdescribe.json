{
  "GenericMonitorConfig": {
    "name": "MonitorConfig",
    "doc": "MonitorConfig is used to configure monitor instances.  One instance of MonitorConfig may be used to configure multiple monitor instances.  If a monitor's discovery rule does not match any discovered services, the monitor will not run.",
    "package": "internal/core/config",
    "fields": [
      {
        "yamlName": "type",
        "doc": "The type of the monitor",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "discoveryRule",
        "doc": "The rule used to match up this configuration with a discovered endpoint. If blank, the configuration will be run immediately when the agent is started.  If multiple endpoints match this rule, multiple instances of the monitor type will be created with the same configuration (except different host/port).",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "validateDiscoveryRule",
        "doc": "If true, a warning will be emitted if a discovery rule contains variables that will never possibly match a rule.  If using multiple observers, it is convenient to set this to false to suppress spurious errors.  The top-level setting `validateDiscoveryRules` acts as a default if this isn't set.",
        "default": "false",
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "extraDimensions",
        "doc": "A set of extra dimensions (key:value pairs) to include on datapoints emitted by the monitor(s) created from this configuration. To specify metrics from this monitor should be high-resolution, add the dimension `sf_hires: 1`",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "extraDimensionsFromEndpoint",
        "doc": "A mapping of extra dimension names to a [discovery rule expression](https://docs.signalfx.com/en/latest/integrations/agent/auto-discovery.html) that is used to derive the value of the dimension.  For example, to use a certain container label as a dimension, you could use something like this in your monitor config block: `extraDimensionsFromEndpoint: {env: 'Get(container_labels, \"myapp.com/environment\")'}`",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "configEndpointMappings",
        "doc": "A set of mappings from a configuration option on this monitor to attributes of a discovered endpoint.  The keys are the config option on this monitor and the value can be any valid expression used in discovery rules.",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "intervalSeconds",
        "doc": "The interval (in seconds) at which to emit datapoints from the monitor(s) created by this configuration.  If not set (or set to 0), the global agent intervalSeconds config option will be used instead.",
        "default": 0,
        "required": false,
        "type": "int",
        "elementKind": ""
      },
      {
        "yamlName": "solo",
        "doc": "If one or more configurations have this set to true, only those configurations will be considered. This setting can be useful for testing.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "metricsToExclude",
        "doc": "DEPRECATED in favor of the `datapointsToExclude` option.  That option handles negation of filter items differently.",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "interface"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "datapointsToExclude",
        "doc": "A list of datapoint filters.  These filters allow you to comprehensively define which datapoints to exclude by metric name or dimension set, as well as the ability to define overrides to re-include metrics excluded by previous patterns within the same filter item.  See [monitor filtering](https://github.com/signalfx/signalfx-agent/tree/master/docs/filtering.md#monitor-level-filtering) for examples and more information.",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "interface"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "disableHostDimensions",
        "doc": "Some monitors pull metrics from services not running on the same host and should not get the host-specific dimensions set on them (e.g. `host`, `AWSUniqueId`, etc).  Setting this to `true` causes those dimensions to be omitted.  You can disable this globally with the `disableHostDimensions` option on the top level of the config.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "disableEndpointDimensions",
        "doc": "This can be set to true if you don't want to include the dimensions that are specific to the endpoint that was discovered by an observer.  This is useful when you have an endpoint whose identity is not particularly important since it acts largely as a proxy or adapter for other metrics.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "dimensionTransformations",
        "doc": "A map from dimension names emitted by the monitor to the desired dimension name that will be emitted in the datapoint that goes to SignalFx.  This can be useful if you have custom metrics from your applications and want to make the dimensions from a monitor match those. Also can be useful when scraping free-form metrics, say with the `prometheus-exporter` monitor.  Right now, only static key/value transformations are supported.  Note that filtering by dimensions will be done on the *original* dimension name and not the new name.",
        "default": null,
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "extraMetrics",
        "doc": "Extra metrics to enable besides the default included ones.",
        "default": null,
        "required": false,
        "type": "slice",
        "elementKind": "string"
      },
      {
        "yamlName": "extraGroups",
        "doc": "Extra metric groups to enable besides the metrics that are included by default.",
        "default": null,
        "required": false,
        "type": "slice",
        "elementKind": "string"
      }
    ]
  },
  "GenericObserverConfig": {
    "name": "ObserverConfig",
    "doc": "ObserverConfig holds the configuration for an observer",
    "package": "internal/core/config",
    "fields": [
      {
        "yamlName": "type",
        "doc": "The type of the observer",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      }
    ]
  },
  "Monitors": [
    {
      "monitorType": "appmesh",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor starts a StatsD monitor to listen to StatsD metrics emitted\nby AWS AppMesh Envoy Proxy.\n\nTo report AppMesh Envoy metrics, you need to enable Envoy StatsD sink on AppMesh\nand deploy the agent as a sidecar in the services that need to be monitored.\n\n\nSample Envoy StatsD configuration:\n\n```yaml\nstats_sinks:\n -\n  name: \"envoy.statsd\"\n  config:\n   address:\n    socket_address:\n     address: \"127.0.0.1\"\n     port_value: 8125\n     protocol: \"UDP\"\n   prefix: statsd.appmesh\n```\nPlease remember to provide the prefix to the agent monitor configuration.\n\nSee [Envoy API reference](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/stats.proto#envoy-api-msg-config-metrics-v2-statsdsink) for more info\n\nSample SignalFx SmartAgent configuration:\n\n```yaml\nmonitors:\n - type: appmesh\n   listenAddress: 0.0.0.0\n   listenPort: 8125\n   metricPrefix: statsd.appmesh\n```\n",
      "groups": null,
      "metrics": {
        "circuit_breakers.\u003cpriority\u003e.cx_open": {
          "type": "gauge",
          "description": "Whether the connection circuit breaker is closed (0) or open (1)",
          "group": null,
          "included": false
        },
        "circuit_breakers.\u003cpriority\u003e.cx_pool_open": {
          "type": "gauge",
          "description": "Whether the connection pool circuit breaker is closed (0) or open (1)",
          "group": null,
          "included": false
        },
        "circuit_breakers.\u003cpriority\u003e.remaining_cx": {
          "type": "gauge",
          "description": "Number of remaining connections until the circuit breaker opens",
          "group": null,
          "included": false
        },
        "circuit_breakers.\u003cpriority\u003e.remaining_pending": {
          "type": "gauge",
          "description": "Number of remaining pending requests until the circuit breaker opens",
          "group": null,
          "included": false
        },
        "circuit_breakers.\u003cpriority\u003e.remaining_retries": {
          "type": "gauge",
          "description": "Number of remaining retries until the circuit breaker opens",
          "group": null,
          "included": false
        },
        "circuit_breakers.\u003cpriority\u003e.remaining_rq": {
          "type": "gauge",
          "description": "Number of remaining requests until the circuit breaker opens",
          "group": null,
          "included": false
        },
        "circuit_breakers.\u003cpriority\u003e.rq_open": {
          "type": "gauge",
          "description": "Whether the requests circuit breaker is closed (0) or open (1)",
          "group": null,
          "included": false
        },
        "circuit_breakers.\u003cpriority\u003e.rq_pending_open": {
          "type": "gauge",
          "description": "Whether the pending requests circuit breaker is closed (0) or open (1)",
          "group": null,
          "included": false
        },
        "circuit_breakers.\u003cpriority\u003e.rq_retry_open": {
          "type": "gauge",
          "description": "Whether the retry circuit breaker is closed (0) or open (1)",
          "group": null,
          "included": false
        },
        "external.upstream_rq_\u003c_\u003e": {
          "type": "cumulative",
          "description": "External origin specific HTTP response codes",
          "group": null,
          "included": false
        },
        "external.upstream_rq_\u003c_xx\u003e": {
          "type": "cumulative",
          "description": "External origin aggregate HTTP response codes",
          "group": null,
          "included": false
        },
        "external.upstream_rq_completed": {
          "type": "cumulative",
          "description": "Total external origin requests completed",
          "group": null,
          "included": false
        },
        "external.upstream_rq_time": {
          "type": "gauge",
          "description": "External origin request time milliseconds",
          "group": null,
          "included": false
        },
        "internal.upstream_rq_\u003c_\u003e": {
          "type": "cumulative",
          "description": "Internal origin specific HTTP response codes",
          "group": null,
          "included": false
        },
        "internal.upstream_rq_\u003c_xx\u003e": {
          "type": "cumulative",
          "description": "Internal origin aggregate HTTP response codes",
          "group": null,
          "included": false
        },
        "internal.upstream_rq_completed": {
          "type": "cumulative",
          "description": "Total internal origin requests completed",
          "group": null,
          "included": false
        },
        "internal.upstream_rq_time": {
          "type": "gauge",
          "description": "Internal origin request time milliseconds",
          "group": null,
          "included": false
        },
        "membership_change": {
          "type": "cumulative",
          "description": "Total cluster membership changes",
          "group": null,
          "included": false
        },
        "membership_degraded": {
          "type": "gauge",
          "description": "Current cluster degraded total",
          "group": null,
          "included": false
        },
        "membership_healthy": {
          "type": "gauge",
          "description": "Current cluster healthy total (inclusive of both health checking and outlier detection)",
          "group": null,
          "included": true
        },
        "membership_total": {
          "type": "gauge",
          "description": "Current cluster membership total",
          "group": null,
          "included": true
        },
        "upstream_cx_active": {
          "type": "gauge",
          "description": "Total active connections",
          "group": null,
          "included": false
        },
        "upstream_cx_close_notify": {
          "type": "cumulative",
          "description": "Total connections closed via HTTP/1.1 connection close header or HTTP/2 GOAWAY",
          "group": null,
          "included": false
        },
        "upstream_cx_connect_attempts_exceeded": {
          "type": "cumulative",
          "description": "Total consecutive connection failures exceeding configured connection attempts",
          "group": null,
          "included": false
        },
        "upstream_cx_connect_fail": {
          "type": "cumulative",
          "description": "Total connection failures",
          "group": null,
          "included": false
        },
        "upstream_cx_connect_ms": {
          "type": "gauge",
          "description": "Connection establishment milliseconds",
          "group": null,
          "included": false
        },
        "upstream_cx_connect_timeout": {
          "type": "cumulative",
          "description": "Total connection connect timeouts",
          "group": null,
          "included": false
        },
        "upstream_cx_destroy": {
          "type": "cumulative",
          "description": "Total destroyed connections",
          "group": null,
          "included": false
        },
        "upstream_cx_destroy_local": {
          "type": "cumulative",
          "description": "Total connections destroyed locally",
          "group": null,
          "included": false
        },
        "upstream_cx_destroy_local_with_active_rq": {
          "type": "cumulative",
          "description": "Total connections destroyed locally with 1+ active request",
          "group": null,
          "included": false
        },
        "upstream_cx_destroy_remote": {
          "type": "cumulative",
          "description": "Total connections destroyed remotely",
          "group": null,
          "included": false
        },
        "upstream_cx_destroy_remote_with_active_rq": {
          "type": "cumulative",
          "description": "Total connections destroyed remotely with 1+ active request",
          "group": null,
          "included": false
        },
        "upstream_cx_destroy_with_active_rq": {
          "type": "cumulative",
          "description": "Total connections destroyed with 1+ active request",
          "group": null,
          "included": false
        },
        "upstream_cx_http1_total": {
          "type": "cumulative",
          "description": "Total HTTP/1.1 connections",
          "group": null,
          "included": false
        },
        "upstream_cx_http2_total": {
          "type": "cumulative",
          "description": "Total HTTP/2 connections",
          "group": null,
          "included": false
        },
        "upstream_cx_idle_timeout": {
          "type": "cumulative",
          "description": "Total connection idle timeouts",
          "group": null,
          "included": false
        },
        "upstream_cx_length_ms": {
          "type": "gauge",
          "description": "Connection length milliseconds",
          "group": null,
          "included": false
        },
        "upstream_cx_max_requests": {
          "type": "cumulative",
          "description": "Total connections closed due to maximum requests",
          "group": null,
          "included": false
        },
        "upstream_cx_none_healthy": {
          "type": "cumulative",
          "description": "Total times connection not established due to no healthy hosts",
          "group": null,
          "included": false
        },
        "upstream_cx_overflow": {
          "type": "cumulative",
          "description": "Total times that the cluster’s connection circuit breaker overflowed",
          "group": null,
          "included": false
        },
        "upstream_cx_pool_overflow": {
          "type": "cumulative",
          "description": "Total times that the cluster’s connection pool circuit breaker overflowed",
          "group": null,
          "included": false
        },
        "upstream_cx_protocol_error": {
          "type": "cumulative",
          "description": "Total connection protocol errors",
          "group": null,
          "included": false
        },
        "upstream_cx_rx_bytes_buffered": {
          "type": "gauge",
          "description": "Received connection bytes currently buffered",
          "group": null,
          "included": false
        },
        "upstream_cx_rx_bytes_total": {
          "type": "cumulative",
          "description": "Total received connection bytes",
          "group": null,
          "included": true
        },
        "upstream_cx_total": {
          "type": "cumulative",
          "description": "Total connections",
          "group": null,
          "included": false
        },
        "upstream_cx_tx_bytes_buffered": {
          "type": "gauge",
          "description": "Send connection bytes currently buffered",
          "group": null,
          "included": false
        },
        "upstream_cx_tx_bytes_total": {
          "type": "cumulative",
          "description": "Total sent connection bytes",
          "group": null,
          "included": false
        },
        "upstream_rq_\u003c_\u003e": {
          "type": "cumulative",
          "description": "Specific HTTP response codes (e.g., 201, 302, etc.)",
          "group": null,
          "included": true
        },
        "upstream_rq_\u003c_xx\u003e": {
          "type": "cumulative",
          "description": "Aggregate HTTP response codes (e.g., 2xx, 3xx, etc.)",
          "group": null,
          "included": true
        },
        "upstream_rq_active": {
          "type": "gauge",
          "description": "Total active requests",
          "group": null,
          "included": false
        },
        "upstream_rq_cancelled": {
          "type": "cumulative",
          "description": "Total requests cancelled before obtaining a connection pool connection",
          "group": null,
          "included": false
        },
        "upstream_rq_completed": {
          "type": "cumulative",
          "description": "Total upstream requests completed",
          "group": null,
          "included": true
        },
        "upstream_rq_maintenance_mode": {
          "type": "cumulative",
          "description": "Total requests that resulted in an immediate 503 due to maintenance mode",
          "group": null,
          "included": false
        },
        "upstream_rq_pending_active": {
          "type": "gauge",
          "description": "Total active requests pending a connection pool connection",
          "group": null,
          "included": false
        },
        "upstream_rq_pending_failure_eject": {
          "type": "cumulative",
          "description": "Total requests that were failed due to a connection pool connection failure",
          "group": null,
          "included": false
        },
        "upstream_rq_pending_overflow": {
          "type": "cumulative",
          "description": "Total requests that overflowed connection pool circuit breaking and were failed",
          "group": null,
          "included": false
        },
        "upstream_rq_pending_total": {
          "type": "cumulative",
          "description": "Total requests pending a connection pool connection",
          "group": null,
          "included": false
        },
        "upstream_rq_per_try_timeout": {
          "type": "cumulative",
          "description": "Total requests that hit the per try timeout",
          "group": null,
          "included": false
        },
        "upstream_rq_retry": {
          "type": "cumulative",
          "description": "Total request retries",
          "group": null,
          "included": true
        },
        "upstream_rq_retry_overflow": {
          "type": "cumulative",
          "description": "Total requests not retried due to circuit breaking",
          "group": null,
          "included": false
        },
        "upstream_rq_retry_success": {
          "type": "cumulative",
          "description": "Total request retry successes",
          "group": null,
          "included": true
        },
        "upstream_rq_rx_reset": {
          "type": "cumulative",
          "description": "Total requests that were reset remotely",
          "group": null,
          "included": false
        },
        "upstream_rq_time": {
          "type": "gauge",
          "description": "Request time milliseconds",
          "group": null,
          "included": true
        },
        "upstream_rq_timeout": {
          "type": "cumulative",
          "description": "Total requests that timed out waiting for a response",
          "group": null,
          "included": false
        },
        "upstream_rq_total": {
          "type": "cumulative",
          "description": "Total requests",
          "group": null,
          "included": false
        },
        "upstream_rq_tx_reset": {
          "type": "cumulative",
          "description": "Total requests that were reset locally",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/appmesh",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host/address on which to bind the UDP listener that accepts statsd datagrams",
            "default": "localhost",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "listenPort",
            "doc": "The port on which to listen for statsd messages (**default:** `8125`)",
            "default": null,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "metricPrefix",
            "doc": "A prefix in metric names that needs to be removed before metric name conversion",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "aspdotnet",
      "sendAll": true,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics about requests, errors, sessions,\nworker processes for ASP.NET applications.\n\n## Windows Performance Counters\nThe underlying source for these metrics are Windows Performance Counters.\nMost of the performance counters that we query in this monitor are actually Gauges\nthat represent rates per second and percentages.\n\nThis monitor reports the instantaneous values for these Windows Performance Counters.\nThis means that in between a collection interval, spikes could occur on the\nPerformance Counters.  The best way to mitigate this limitation is to increase\nthe reporting interval on this monitor to collect more frequently.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: aspdotnet\n```\n",
      "groups": null,
      "metrics": {
        "asp_net.application_restarts": {
          "type": "gauge",
          "description": "Count of ASP.NET application restarts.",
          "group": null,
          "included": false
        },
        "asp_net.applications_running": {
          "type": "gauge",
          "description": "Number of running ASP.NET applications.",
          "group": null,
          "included": false
        },
        "asp_net.requests_current": {
          "type": "gauge",
          "description": "Current number of ASP.NET requests.",
          "group": null,
          "included": false
        },
        "asp_net.requests_queue": {
          "type": "gauge",
          "description": "Number of queued ASP.NET requests.",
          "group": null,
          "included": false
        },
        "asp_net.requests_rejected": {
          "type": "gauge",
          "description": "Count of rejected ASP.NET requests.",
          "group": null,
          "included": false
        },
        "asp_net.worker_process_restarts": {
          "type": "gauge",
          "description": "Count of ASP.NET worker process restarts.",
          "group": null,
          "included": false
        },
        "asp_net.worker_processes_running": {
          "type": "gauge",
          "description": "Number of running ASP.NET worker processes.",
          "group": null,
          "included": false
        },
        "asp_net_applications.errors_during_execution": {
          "type": "gauge",
          "description": "Count of errors encountered by ASP.NET application durring execution.",
          "group": null,
          "included": false
        },
        "asp_net_applications.errors_total_sec": {
          "type": "gauge",
          "description": "Error rate per second for the given ASP.NET application.",
          "group": null,
          "included": false
        },
        "asp_net_applications.errors_unhandled_during_execution_sec": {
          "type": "gauge",
          "description": "Unhandled error rate per second countered while an ASP.NET application is running.",
          "group": null,
          "included": false
        },
        "asp_net_applications.pipeline_instance_count": {
          "type": "gauge",
          "description": "Number of instances in the ASP.NET application pipeline.",
          "group": null,
          "included": false
        },
        "asp_net_applications.requests_failed": {
          "type": "gauge",
          "description": "Count of failed requests in the ASP.NET application",
          "group": null,
          "included": false
        },
        "asp_net_applications.requests_sec": {
          "type": "gauge",
          "description": "Rate of requests in the ASP.NET application per second.",
          "group": null,
          "included": false
        },
        "asp_net_applications.session_sql_server_connections_total": {
          "type": "gauge",
          "description": "Number of connections to microsoft sql server by an ASP.NET application.",
          "group": null,
          "included": false
        },
        "asp_net_applications.sessions_active": {
          "type": "gauge",
          "description": "Number of active sessions in the ASP.NET application.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/aspdotnet",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) Number of seconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This is used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "cadvisor",
      "sendAll": false,
      "dimensions": {
        "container_id": {
          "description": "The ID of the running container"
        },
        "container_image": {
          "description": "The container image name"
        },
        "container_name": {
          "description": "The container's name as it appears in the pod spec, the same as container_spec_name but retained for backwards compatibility."
        },
        "container_spec_name": {
          "description": "The container's name as it appears in the pod spec"
        },
        "kubernetes_namespace": {
          "description": "The K8s namespace the container is part of"
        },
        "kubernetes_pod_name": {
          "description": "The pod instance under which this container runs"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod instance under which this container runs"
        }
      },
      "doc": "This monitor pulls metrics directly from cadvisor, which\nconventionally runs on port 4194, but can be configured to anything.  If you\nare running on Kubernetes, consider the [kubelet-stats](./kubelet-stats.md)\nmonitor because many K8s nodes do not expose cAdvisor on a network port,\neven though they are running it within Kubelet.\n\nIf you are running containers with Docker, there is a fair amount of\nduplication with the `collectd/docker` monitor in terms of the metrics sent\n(under distinct metric names) so you may want to consider not enabling the\nDocker monitor in a K8s environment, or else use filtering to whitelist only\ncertain metrics.  Note that this will cause the built-in Docker dashboards\nto be blank, but container metrics will be available on the Kubernetes\ndashboards instead.\n",
      "groups": null,
      "metrics": {
        "container_cpu_cfs_periods": {
          "type": "cumulative",
          "description": "Total number of elapsed CFS enforcement intervals",
          "group": null,
          "included": false
        },
        "container_cpu_cfs_throttled_periods": {
          "type": "cumulative",
          "description": "Total number of times tasks in the cgroup have been throttled",
          "group": null,
          "included": false
        },
        "container_cpu_cfs_throttled_time": {
          "type": "cumulative",
          "description": "Total time duration, in nanoseconds, for which tasks in the cgroup have been throttled",
          "group": null,
          "included": false
        },
        "container_cpu_percent": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization as a percentage of the total host CPU available.  This metric is equivalent to `container_cpu_utilization` / \u003c# of CPUs/cores on host\u003e.",
          "group": null,
          "included": false
        },
        "container_cpu_system_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative system cpu time consumed in nanoseconds",
          "group": null,
          "included": false
        },
        "container_cpu_usage_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative cpu time consumed per cpu in nanoseconds",
          "group": null,
          "included": false
        },
        "container_cpu_user_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative user cpu time consumed in nanoseconds",
          "group": null,
          "included": false
        },
        "container_cpu_utilization": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization in percentages.  This is equivalent to \"centicores\", or hundreths of CPU cores consumed.  This metric is **NOT** normalized by the total # of cores on the system.",
          "group": null,
          "included": true
        },
        "container_cpu_utilization_per_core": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization in percentages per core",
          "group": null,
          "included": false
        },
        "container_fs_io_current": {
          "type": "gauge",
          "description": "Number of I/Os currently in progress",
          "group": null,
          "included": false
        },
        "container_fs_io_time_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent doing I/Os",
          "group": null,
          "included": false
        },
        "container_fs_io_time_weighted_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative weighted I/O time in seconds",
          "group": null,
          "included": false
        },
        "container_fs_limit_bytes": {
          "type": "gauge",
          "description": "Number of bytes that the container may occupy on this filesystem",
          "group": null,
          "included": false
        },
        "container_fs_read_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent reading",
          "group": null,
          "included": false
        },
        "container_fs_reads_merged_total": {
          "type": "cumulative",
          "description": "Cumulative count of reads merged",
          "group": null,
          "included": false
        },
        "container_fs_reads_total": {
          "type": "cumulative",
          "description": "Cumulative count of reads completed",
          "group": null,
          "included": false
        },
        "container_fs_sector_reads_total": {
          "type": "cumulative",
          "description": "Cumulative count of sector reads completed",
          "group": null,
          "included": false
        },
        "container_fs_sector_writes_total": {
          "type": "cumulative",
          "description": "Cumulative count of sector writes completed",
          "group": null,
          "included": false
        },
        "container_fs_usage_bytes": {
          "type": "gauge",
          "description": "Number of bytes that are consumed by the container on this filesystem",
          "group": null,
          "included": false
        },
        "container_fs_write_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent writing",
          "group": null,
          "included": false
        },
        "container_fs_writes_merged_total": {
          "type": "cumulative",
          "description": "Cumulative count of writes merged",
          "group": null,
          "included": false
        },
        "container_fs_writes_total": {
          "type": "cumulative",
          "description": "Cumulative count of writes completed",
          "group": null,
          "included": false
        },
        "container_last_seen": {
          "type": "gauge",
          "description": "Last time a container was seen by the exporter",
          "group": null,
          "included": false
        },
        "container_memory_failcnt": {
          "type": "cumulative",
          "description": "Number of memory usage hits limits",
          "group": null,
          "included": false
        },
        "container_memory_failures_total": {
          "type": "cumulative",
          "description": "Cumulative count of memory allocation failures",
          "group": null,
          "included": true
        },
        "container_memory_usage_bytes": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": null,
          "included": true
        },
        "container_memory_working_set_bytes": {
          "type": "gauge",
          "description": "Current working set in bytes",
          "group": null,
          "included": false
        },
        "container_spec_cpu_period": {
          "type": "gauge",
          "description": "The number of microseconds that the [CFS scheduler](https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) uses as a window when limiting container processes",
          "group": null,
          "included": true
        },
        "container_spec_cpu_quota": {
          "type": "gauge",
          "description": "In CPU quota for the CFS process scheduler. In K8s this is equal to the containers's CPU limit as a fraction of 1 core and multiplied by the `container_spec_cpu_period`.  So if the CPU limit is `500m` (500 millicores) for a container and the `container_spec_cpu_period` is set to 100,000, this value will be 50,000.",
          "group": null,
          "included": true
        },
        "container_spec_cpu_shares": {
          "type": "gauge",
          "description": "CPU share of the container",
          "group": null,
          "included": false
        },
        "container_spec_memory_limit_bytes": {
          "type": "gauge",
          "description": "Memory limit for the container.",
          "group": null,
          "included": true
        },
        "container_spec_memory_swap_limit_bytes": {
          "type": "gauge",
          "description": "Memory swap limit for the container.",
          "group": null,
          "included": false
        },
        "container_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the container since unix epoch in seconds.",
          "group": null,
          "included": false
        },
        "container_tasks_state": {
          "type": "gauge",
          "description": "Number of tasks in given state",
          "group": null,
          "included": false
        },
        "machine_cpu_cores": {
          "type": "gauge",
          "description": "Number of CPU cores on the node.",
          "group": null,
          "included": true
        },
        "machine_cpu_frequency_khz": {
          "type": "gauge",
          "description": "Node's CPU frequency.",
          "group": null,
          "included": false
        },
        "machine_memory_bytes": {
          "type": "gauge",
          "description": "Amount of memory installed on the node.",
          "group": null,
          "included": true
        },
        "pod_network_receive_bytes_total": {
          "type": "cumulative",
          "description": "Cumulative count of bytes received",
          "group": null,
          "included": true
        },
        "pod_network_receive_errors_total": {
          "type": "cumulative",
          "description": "Cumulative count of errors encountered while receiving",
          "group": null,
          "included": true
        },
        "pod_network_receive_packets_dropped_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets dropped while receiving",
          "group": null,
          "included": false
        },
        "pod_network_receive_packets_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets received",
          "group": null,
          "included": false
        },
        "pod_network_transmit_bytes_total": {
          "type": "cumulative",
          "description": "Cumulative count of bytes transmitted",
          "group": null,
          "included": true
        },
        "pod_network_transmit_errors_total": {
          "type": "cumulative",
          "description": "Cumulative count of errors encountered while transmitting",
          "group": null,
          "included": true
        },
        "pod_network_transmit_packets_dropped_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets dropped while transmitting",
          "group": null,
          "included": false
        },
        "pod_network_transmit_packets_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets transmitted",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "CHTTPConfig",
        "doc": "CHTTPConfig is the monitor-specific config for cAdvisor",
        "package": "internal/monitors/cadvisor",
        "fields": [
          {
            "yamlName": "cadvisorURL",
            "doc": "Where to find cAdvisor",
            "default": "http://localhost:4194",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/activemq",
      "sendAll": false,
      "dimensions": null,
      "doc": "SignalFx's integration with ActiveMQ wraps the [Collectd GenericJMX\nmonitor](https://docs.signalfx.com/en/latest/integrations/agent/monitors/collectd-genericjmx.html)\nto monitor ActiveMQ.\n\nUse this monitor to gather the following types of information from ActiveMQ:\n\n* Broker (Totals per broker)\n* Queue (Queue status)\n* Topic (Topic status)\n\nFor more information on the built-in content available for this\nintegration, see [the integration docs](https://docs.signalfx.com/en/latest/integrations/integrations-reference/integrations.activemq.html).\n\nTo monitor the age of messages inside ActiveMQ queues, see [ActiveMQ\nmessage age listener](https://github.com/signalfx/integrations/tree/master/amq-message-age).\n\n## Example config\n\n```yaml\nmonitors:\n - type: collectd/activemq\n   host: localhost\n   # This is the remote JMX port for ActiveMQ\n   port: 1099\n```\n",
      "groups": null,
      "metrics": {
        "counter.amq.TotalConnectionsCount": {
          "type": "counter",
          "description": "Total connections count per broker",
          "group": null,
          "included": true
        },
        "gauge.amq.TotalConsumerCount": {
          "type": "gauge",
          "description": "Total number of consumers subscribed to destinations on the broker",
          "group": null,
          "included": true
        },
        "gauge.amq.TotalDequeueCount": {
          "type": "gauge",
          "description": "Total number of messages that have been acknowledged from the broker.",
          "group": null,
          "included": false
        },
        "gauge.amq.TotalEnqueueCount": {
          "type": "gauge",
          "description": "Total number of messages that have been sent to the broker.",
          "group": null,
          "included": true
        },
        "gauge.amq.TotalMessageCount": {
          "type": "gauge",
          "description": "Total number of unacknowledged messages on the broker",
          "group": null,
          "included": true
        },
        "gauge.amq.TotalProducerCount": {
          "type": "gauge",
          "description": "Total number of message producers active on destinations on the broker",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.AverageBlockedTime": {
          "type": "gauge",
          "description": "Average time (ms) that messages have spent blocked by Flow Control.",
          "group": null,
          "included": false
        },
        "gauge.amq.queue.AverageEnqueueTime": {
          "type": "gauge",
          "description": "Average time (ms) that messages have been held at this destination",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.AverageMessageSize": {
          "type": "gauge",
          "description": "Average size of messages in this queue, in bytes.",
          "group": null,
          "included": false
        },
        "gauge.amq.queue.BlockedSends": {
          "type": "gauge",
          "description": "Number of messages blocked by Flow Control.",
          "group": null,
          "included": false
        },
        "gauge.amq.queue.ConsumerCount": {
          "type": "gauge",
          "description": "Number of consumers subscribed to this queue.",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.DequeueCount": {
          "type": "gauge",
          "description": "Number of messages that have been acknowledged and removed from the queue.",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.EnqueueCount": {
          "type": "gauge",
          "description": "Number of messages that have been sent to the queue.",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.ExpiredCount": {
          "type": "gauge",
          "description": "Number of messages that have expired from the queue.",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.ForwardCount": {
          "type": "gauge",
          "description": "Number of messages that have been forwarded from this queue to a networked broker.",
          "group": null,
          "included": false
        },
        "gauge.amq.queue.InFlightCount": {
          "type": "gauge",
          "description": "The number of messages that have been dispatched to consumers, but not acknowledged.",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.ProducerCount": {
          "type": "gauge",
          "description": "Number of producers publishing to this queue",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.QueueSize": {
          "type": "gauge",
          "description": "The number of messages in the queue that have yet to be consumed.",
          "group": null,
          "included": true
        },
        "gauge.amq.queue.TotalBlockedTime": {
          "type": "gauge",
          "description": "The total time (ms) that messages have spent blocked by Flow Control.",
          "group": null,
          "included": false
        },
        "gauge.amq.topic.AverageBlockedTime": {
          "type": "gauge",
          "description": "Average time (ms) that messages have been blocked by Flow Control.",
          "group": null,
          "included": false
        },
        "gauge.amq.topic.AverageEnqueueTime": {
          "type": "gauge",
          "description": "Average time (ms) that messages have been held at this destination.",
          "group": null,
          "included": true
        },
        "gauge.amq.topic.AverageMessageSize": {
          "type": "gauge",
          "description": "Average size of messages on this topic, in bytes.",
          "group": null,
          "included": false
        },
        "gauge.amq.topic.BlockedSends": {
          "type": "gauge",
          "description": "Number of messages blocked by Flow Control",
          "group": null,
          "included": false
        },
        "gauge.amq.topic.ConsumerCount": {
          "type": "gauge",
          "description": "The number of consumers subscribed to this topic",
          "group": null,
          "included": true
        },
        "gauge.amq.topic.DequeueCount": {
          "type": "gauge",
          "description": "Number of messages that have been acknowledged and removed from the topic.",
          "group": null,
          "included": false
        },
        "gauge.amq.topic.EnqueueCount": {
          "type": "gauge",
          "description": "The number of messages that have been sent to the topic.",
          "group": null,
          "included": true
        },
        "gauge.amq.topic.ExpiredCount": {
          "type": "gauge",
          "description": "The number of messages that have expired from this topic.",
          "group": null,
          "included": true
        },
        "gauge.amq.topic.ForwardCount": {
          "type": "gauge",
          "description": "The number of messages that have been forwarded from this topic to a networked broker.",
          "group": null,
          "included": false
        },
        "gauge.amq.topic.InFlightCount": {
          "type": "gauge",
          "description": "The number of messages that have been dispatched to consumers, but have not yet been acknowledged.",
          "group": null,
          "included": true
        },
        "gauge.amq.topic.ProducerCount": {
          "type": "gauge",
          "description": "Number of producers publishing to this topic.",
          "group": null,
          "included": true
        },
        "gauge.amq.topic.QueueSize": {
          "type": "gauge",
          "description": "Number of messages in the topic that have yet to be consumed.",
          "group": null,
          "included": true
        },
        "gauge.amq.topic.TotalBlockedTime": {
          "type": "gauge",
          "description": "The total time (ms) that messages have spent blocked by Flow Control",
          "group": null,
          "included": false
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "included": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "included": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "included": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "internal/monitors/collectd/activemq",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "internal/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "internal/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/apache",
      "sendAll": false,
      "dimensions": {
        "plugin_instance": {
          "description": "Set to whatever you set in the `name` config option."
        }
      },
      "doc": "Monitors Apache webservice instances using\nthe information provided by `mod_status`.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-apache\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: collectd/apache\n   host: localhost\n   port: 80\n```\n\nIf `mod_status` is exposed on an endpoint other than `/mod_status`, you can\nuse the `url` config option to specify the path:\n\n```\nmonitors:\n - type: collectd/apache\n   host: localhost\n   port: 80\n   url: \"http://{{.Host}}:{{.Port}}/server-status?auto\"\n```\n",
      "groups": null,
      "metrics": {
        "apache_bytes": {
          "type": "cumulative",
          "description": "Bytes served by Apache",
          "group": null,
          "included": true
        },
        "apache_connections": {
          "type": "gauge",
          "description": "Connections served by Apache",
          "group": null,
          "included": true
        },
        "apache_idle_workers": {
          "type": "gauge",
          "description": "Apache workers that are idle",
          "group": null,
          "included": true
        },
        "apache_requests": {
          "type": "cumulative",
          "description": "Requests served by Apache",
          "group": null,
          "included": true
        },
        "apache_scoreboard.closing": {
          "type": "gauge",
          "description": "Number of workers in the process of closing connections",
          "group": null,
          "included": false
        },
        "apache_scoreboard.dnslookup": {
          "type": "gauge",
          "description": "Number of workers performing DNS lookup",
          "group": null,
          "included": false
        },
        "apache_scoreboard.finishing": {
          "type": "gauge",
          "description": "Number of workers that are finishing",
          "group": null,
          "included": false
        },
        "apache_scoreboard.idle_cleanup": {
          "type": "gauge",
          "description": "Number of idle threads ready for cleanup",
          "group": null,
          "included": false
        },
        "apache_scoreboard.keepalive": {
          "type": "gauge",
          "description": "Number of keep-alive connections",
          "group": null,
          "included": false
        },
        "apache_scoreboard.logging": {
          "type": "gauge",
          "description": "Number of workers writing to log file",
          "group": null,
          "included": false
        },
        "apache_scoreboard.open": {
          "type": "gauge",
          "description": "Number of worker thread slots that are open",
          "group": null,
          "included": true
        },
        "apache_scoreboard.reading": {
          "type": "gauge",
          "description": "Number of workers reading requests",
          "group": null,
          "included": false
        },
        "apache_scoreboard.sending": {
          "type": "gauge",
          "description": "Number of workers sending responses",
          "group": null,
          "included": false
        },
        "apache_scoreboard.starting": {
          "type": "gauge",
          "description": "Number of workers starting up",
          "group": null,
          "included": false
        },
        "apache_scoreboard.waiting": {
          "type": "gauge",
          "description": "Number of workers waiting for requests",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/apache",
        "fields": [
          {
            "yamlName": "host",
            "doc": "The hostname of the Apache server",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "The port number of the Apache server",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "This will be sent as the `plugin_instance` dimension and can be any name you like.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "url",
            "doc": "The URL, either a final URL or a Go template that will be populated with the host and port values.",
            "default": "http://{{.Host}}:{{.Port}}/mod_status?auto",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/cassandra",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors Cassandra using the GenericJMX collectd\nplugin.\n",
      "groups": null,
      "metrics": {
        "counter.cassandra.ClientRequest.RangeSlice.Latency.Count": {
          "type": "cumulative",
          "description": "Count of range slice operations since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.ClientRequest.RangeSlice.Timeouts.Count": {
          "type": "cumulative",
          "description": "Count of range slice timeouts since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.ClientRequest.RangeSlice.Unavailables.Count": {
          "type": "cumulative",
          "description": "Count of range slice unavailables since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.ClientRequest.Read.Latency.Count": {
          "type": "cumulative",
          "description": "Count of read operations since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.ClientRequest.Read.Timeouts.Count": {
          "type": "cumulative",
          "description": "Count of read timeouts since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.ClientRequest.Read.Unavailables.Count": {
          "type": "cumulative",
          "description": "Count of read unavailables since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.ClientRequest.Write.Latency.Count": {
          "type": "cumulative",
          "description": "Count of write operations since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.ClientRequest.Write.Timeouts.Count": {
          "type": "cumulative",
          "description": "Count of write timeouts since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.ClientRequest.Write.Unavailables.Count": {
          "type": "cumulative",
          "description": "Count of write unavailables since server start",
          "group": null,
          "included": true
        },
        "counter.cassandra.Compaction.TotalCompactionsCompleted.Count": {
          "type": "cumulative",
          "description": "Number of compaction operations since node start",
          "group": null,
          "included": false
        },
        "gauge.cassandra.ClientRequest.RangeSlice.Latency.50thPercentile": {
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra range slice latency",
          "group": null,
          "included": false
        },
        "gauge.cassandra.ClientRequest.RangeSlice.Latency.99thPercentile": {
          "type": "gauge",
          "description": "99th percentile of Cassandra range slice latency",
          "group": null,
          "included": true
        },
        "gauge.cassandra.ClientRequest.RangeSlice.Latency.Max": {
          "type": "gauge",
          "description": "Maximum Cassandra range slice latency",
          "group": null,
          "included": false
        },
        "gauge.cassandra.ClientRequest.Read.Latency.50thPercentile": {
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra read latency",
          "group": null,
          "included": true
        },
        "gauge.cassandra.ClientRequest.Read.Latency.99thPercentile": {
          "type": "gauge",
          "description": "99th percentile of Cassandra read latency",
          "group": null,
          "included": true
        },
        "gauge.cassandra.ClientRequest.Read.Latency.Max": {
          "type": "gauge",
          "description": "Maximum Cassandra read latency",
          "group": null,
          "included": true
        },
        "gauge.cassandra.ClientRequest.Write.Latency.50thPercentile": {
          "type": "gauge",
          "description": "50th percentile (median) of Cassandra write latency",
          "group": null,
          "included": true
        },
        "gauge.cassandra.ClientRequest.Write.Latency.99thPercentile": {
          "type": "gauge",
          "description": "99th percentile of Cassandra write latency",
          "group": null,
          "included": true
        },
        "gauge.cassandra.ClientRequest.Write.Latency.Max": {
          "type": "gauge",
          "description": "Maximum Cassandra write latency",
          "group": null,
          "included": true
        },
        "gauge.cassandra.Compaction.PendingTasks.Value": {
          "type": "gauge",
          "description": "Number of compaction operations waiting to run",
          "group": null,
          "included": true
        },
        "gauge.cassandra.Storage.Load.Count": {
          "type": "gauge",
          "description": "Storage used for Cassandra data in bytes",
          "group": null,
          "included": true
        },
        "gauge.cassandra.Storage.TotalHints.Count": {
          "type": "gauge",
          "description": "Total hints since node start",
          "group": null,
          "included": false
        },
        "gauge.cassandra.Storage.TotalHintsInProgress.Count": {
          "type": "gauge",
          "description": "Total pending hints",
          "group": null,
          "included": true
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "included": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "included": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "included": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "internal/monitors/collectd/cassandra",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "internal/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "internal/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/chrony",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collectd NTP data from a chronyd instance\n\nSee https://collectd.org/documentation/manpages/collectd.conf.5.shtml#plugin_chrony\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/chrony",
        "fields": [
          {
            "yamlName": "host",
            "doc": "The hostname of the chronyd instance",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "The UDP port number of the chronyd instance.  Defaults to 323 in collectd if unspecified.",
            "default": null,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "timeout",
            "doc": "How long to wait for a response from chronyd before considering it down. Defaults to 2 seconds in the collectd plugin if not specified",
            "default": null,
            "required": false,
            "type": "uint",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/consul",
      "sendAll": false,
      "dimensions": {
        "consul_mode": {
          "description": "Whether this consul instance is running as a server or client"
        },
        "consul_node": {
          "description": "The name of the consul node"
        },
        "datacenter": {
          "description": "The name of the consul datacenter"
        }
      },
      "doc": "Monitors the Consul data store by using the\n[Consul collectd Python\nplugin](https://github.com/signalfx/collectd-consul), which collects metrics\nfrom Consul instances by hitting these endpoints:\n- [/agent/self](https://www.consul.io/api/agent.html#read-configuration)\n- [/agent/metrics](https://www.consul.io/api/agent.html#view-metrics)\n- [/catalog/nodes](https://www.consul.io/api/catalog.html#list-nodes)\n- [/catalog/node/:node](https://www.consul.io/api/catalog.html#list-services-for-node)\n- [/status/leader](https://www.consul.io/api/status.html#get-raft-leader)\n- [/status/peers](https://www.consul.io/api/status.html#list-raft-peers)\n- [/coordinate/datacenters](https://www.consul.io/api/coordinate.html#read-wan-coordinates)\n- [/coordinate/nodes](https://www.consul.io/api/coordinate.html#read-lan-coordinates)\n- [/health/state/any](https://www.consul.io/api/health.html#list-checks-in-state)\n",
      "groups": null,
      "metrics": {
        "consul.dns.stale_queries": {
          "type": "gauge",
          "description": "Number of times an agent serves a DNS query with stale information",
          "group": null,
          "included": false
        },
        "consul.memberlist.msg.suspect": {
          "type": "gauge",
          "description": "Number of suspect messages received per interval",
          "group": null,
          "included": false
        },
        "consul.serf.member.flap": {
          "type": "gauge",
          "description": "Tracks flapping agents",
          "group": null,
          "included": false
        },
        "gauge.consul.catalog.nodes.total": {
          "type": "gauge",
          "description": "Number of nodes in the Consul datacenter",
          "group": null,
          "included": true
        },
        "gauge.consul.catalog.nodes_by_service": {
          "type": "gauge",
          "description": "Number of nodes providing a given service",
          "group": null,
          "included": true
        },
        "gauge.consul.catalog.services.total": {
          "type": "gauge",
          "description": "Total number of services registered with Consul in the given datacenter",
          "group": null,
          "included": true
        },
        "gauge.consul.catalog.services_by_node": {
          "type": "gauge",
          "description": "Number of services registered with a node",
          "group": null,
          "included": true
        },
        "gauge.consul.consul.dns.domain_query.AGENT.avg": {
          "type": "gauge",
          "description": "Average time to complete a forward DNS query",
          "group": null,
          "included": false
        },
        "gauge.consul.consul.dns.domain_query.AGENT.max": {
          "type": "gauge",
          "description": "Max time to complete a forward DNS query",
          "group": null,
          "included": false
        },
        "gauge.consul.consul.dns.domain_query.AGENT.min": {
          "type": "gauge",
          "description": "Min time to complete a forward DNS query",
          "group": null,
          "included": false
        },
        "gauge.consul.consul.dns.ptr_query.AGENT.avg": {
          "type": "gauge",
          "description": "Average time to complete a Reverse DNS query",
          "group": null,
          "included": false
        },
        "gauge.consul.consul.dns.ptr_query.AGENT.max": {
          "type": "gauge",
          "description": "Max time to complete a Reverse DNS query",
          "group": null,
          "included": false
        },
        "gauge.consul.consul.dns.ptr_query.AGENT.min": {
          "type": "gauge",
          "description": "Min time to complete a Reverse DNS query",
          "group": null,
          "included": false
        },
        "gauge.consul.consul.leader.reconcile.avg": {
          "type": "gauge",
          "description": "Leader time to reconcile the differences between Serf membership and Consul's store",
          "group": null,
          "included": true
        },
        "gauge.consul.health.nodes.critical": {
          "type": "gauge",
          "description": "Number of nodes for which health checks are reporting Critical state",
          "group": null,
          "included": true
        },
        "gauge.consul.health.nodes.passing": {
          "type": "gauge",
          "description": "Number of nodes for which health checks are reporting Passing state",
          "group": null,
          "included": true
        },
        "gauge.consul.health.nodes.warning": {
          "type": "gauge",
          "description": "Number of nodes for which health checks are reporting Warning state",
          "group": null,
          "included": true
        },
        "gauge.consul.health.services.critical": {
          "type": "gauge",
          "description": "Number of services for which health checks are reporting Critical state",
          "group": null,
          "included": true
        },
        "gauge.consul.health.services.passing": {
          "type": "gauge",
          "description": "Number of services for which health checks are reporting Passing state",
          "group": null,
          "included": true
        },
        "gauge.consul.health.services.warning": {
          "type": "gauge",
          "description": "Number of services for which health checks are reporting Warning state",
          "group": null,
          "included": true
        },
        "gauge.consul.is_leader": {
          "type": "gauge",
          "description": "Metric to map consul server's in leader or follower state",
          "group": null,
          "included": true
        },
        "gauge.consul.network.dc.latency.avg": {
          "type": "gauge",
          "description": "Average network latency between 2 datacenters",
          "group": null,
          "included": true
        },
        "gauge.consul.network.dc.latency.max": {
          "type": "gauge",
          "description": "Maximum network latency between 2 datacenters",
          "group": null,
          "included": false
        },
        "gauge.consul.network.dc.latency.min": {
          "type": "gauge",
          "description": "Minimum network latency between 2 datacenters",
          "group": null,
          "included": false
        },
        "gauge.consul.network.node.latency.avg": {
          "type": "gauge",
          "description": "Average network latency between given node and other nodes in the datacenter",
          "group": null,
          "included": true
        },
        "gauge.consul.network.node.latency.max": {
          "type": "gauge",
          "description": "Minimum network latency between given node and other nodes in the datacenter",
          "group": null,
          "included": true
        },
        "gauge.consul.network.node.latency.min": {
          "type": "gauge",
          "description": "Minimum network latency between given node and other nodes in the datacenter",
          "group": null,
          "included": true
        },
        "gauge.consul.peers": {
          "type": "gauge",
          "description": "Number of Raft peers in Consul datacenter",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.apply": {
          "type": "gauge",
          "description": "Number of raft transactions",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.commitTime.avg": {
          "type": "gauge",
          "description": "Average of the time it takes to commit an entry on the leader",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.commitTime.max": {
          "type": "gauge",
          "description": "Max of the time it takes to commit an entry on the leader",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.commitTime.min": {
          "type": "gauge",
          "description": "Minimum of the time it takes to commit an entry on the leader",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.leader.dispatchLog.avg": {
          "type": "gauge",
          "description": "Average of the time it takes for the leader to write log entries to disk",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.leader.dispatchLog.max": {
          "type": "gauge",
          "description": "Maximum of the time it takes for the leader to write log entries to disk",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.leader.dispatchLog.min": {
          "type": "gauge",
          "description": "Minimum of the time it takes for the leader to write log entries to disk",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.leader.lastContact.avg": {
          "type": "gauge",
          "description": "Mean of the time since the leader was last able to contact follower nodes",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.leader.lastContact.max": {
          "type": "gauge",
          "description": "Max of the time since the leader was last able to contact follower nodes",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.leader.lastContact.min": {
          "type": "gauge",
          "description": "Min of the time since the leader was last able to contact follower nodes",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.replication.appendEntries.rpc.AGENT.avg": {
          "type": "gauge",
          "description": "Mean time taken to complete the AppendEntries RPC",
          "group": null,
          "included": false
        },
        "gauge.consul.raft.replication.appendEntries.rpc.AGENT.max": {
          "type": "gauge",
          "description": "Max time taken to complete the AppendEntries RPC",
          "group": null,
          "included": false
        },
        "gauge.consul.raft.replication.appendEntries.rpc.AGENT.min": {
          "type": "gauge",
          "description": "Min time taken to complete the AppendEntries RPC",
          "group": null,
          "included": false
        },
        "gauge.consul.raft.state.candidate": {
          "type": "gauge",
          "description": "Tracks the number of times given node enters the candidate state",
          "group": null,
          "included": true
        },
        "gauge.consul.raft.state.leader": {
          "type": "gauge",
          "description": "Tracks the number of leadership transitions per interval",
          "group": null,
          "included": true
        },
        "gauge.consul.rpc.query": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gauge.consul.runtime.alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated to Consul process on the node",
          "group": null,
          "included": false
        },
        "gauge.consul.runtime.heap_objects": {
          "type": "gauge",
          "description": "Number of heap objects allocated to Consul",
          "group": null,
          "included": false
        },
        "gauge.consul.runtime.num_goroutines": {
          "type": "gauge",
          "description": "Number of GO routines run by Consul process",
          "group": null,
          "included": false
        },
        "gauge.consul.serf.events": {
          "type": "gauge",
          "description": "Number of serf events processed",
          "group": null,
          "included": true
        },
        "gauge.consul.serf.events.consul:new-leader": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gauge.consul.serf.member.join": {
          "type": "gauge",
          "description": "Tracks successful node joins",
          "group": null,
          "included": true
        },
        "gauge.consul.serf.member.left": {
          "type": "gauge",
          "description": "Tracks successful node leaves",
          "group": null,
          "included": true
        },
        "gauge.consul.serf.queue.Event.avg": {
          "type": "gauge",
          "description": "Average number of serf events in queue yet to be processed",
          "group": null,
          "included": true
        },
        "gauge.consul.serf.queue.Event.max": {
          "type": "gauge",
          "description": "Maximum number of serf events in queue yet to be processed during the interval",
          "group": null,
          "included": true
        },
        "gauge.consul.serf.queue.Event.min": {
          "type": "gauge",
          "description": "Minimum number of serf events in queue yet to be processed during the interval",
          "group": null,
          "included": false
        },
        "gauge.consul.serf.queue.Query.avg": {
          "type": "gauge",
          "description": "Average number of serf queries in queue yet to be processed during the interval",
          "group": null,
          "included": false
        },
        "gauge.consul.serf.queue.Query.max": {
          "type": "gauge",
          "description": "Maximum number of serf queries in queue yet to be processed during the interval",
          "group": null,
          "included": false
        },
        "gauge.consul.serf.queue.Query.min": {
          "type": "gauge",
          "description": "Minimum number of serf queries in queue yet to be processed during the interval",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/consul",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "aclToken",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCertificate",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertificate",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientKey",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "signalFxAccessToken",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/couchbase",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors couchbase by using the\n[couchbase collectd Python\nplugin](https://github.com/signalfx/collectd-couchbase), which collects\nmetrics from couchbase instances\n\nSample YAML configuration with custom query:\n\n```yaml\nmonitors:\n- type: collectd/couchbase\n  host: 127.0.0.1\n  port: 8091\n  collectTarget: \"NODE\"\n  clusterName: \"my-cluster\"\n  username: \"user\"\n  password: \"password\"\n```\n",
      "groups": {
        "bucket": {
          "description": "Bucket metrics"
        },
        "nodes": {
          "description": "Node metrics"
        },
        "storage": {
          "description": "Storage metrics"
        }
      },
      "metrics": {
        "gauge.bucket.basic.dataUsed": {
          "type": "gauge",
          "description": "Size of user data within buckets of the specified state that are resident in RAM (%)",
          "group": "bucket",
          "included": false
        },
        "gauge.bucket.basic.diskFetches": {
          "type": "gauge",
          "description": "Number of disk fetches",
          "group": "bucket",
          "included": false
        },
        "gauge.bucket.basic.diskUsed": {
          "type": "gauge",
          "description": "Amount of disk used (bytes)",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.basic.itemCount": {
          "type": "gauge",
          "description": "Number of items associated with the bucket",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.basic.memUsed": {
          "type": "gauge",
          "description": "Amount of memory used by the bucket (bytes)",
          "group": "bucket",
          "included": false
        },
        "gauge.bucket.basic.opsPerSec": {
          "type": "gauge",
          "description": "Number of operations per second",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.basic.quotaPercentUsed": {
          "type": "gauge",
          "description": "Percentage of RAM used (for active objects) against the configure bucket size (%)",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.cmd_get": {
          "type": "gauge",
          "description": "requested objects",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.couch_docs_fragmentation": {
          "type": "gauge",
          "description": "Percent fragmentation of documents in this bucket.",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.couch_views_ops": {
          "type": "gauge",
          "description": "view operations per second",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.curr_connections": {
          "type": "gauge",
          "description": "open connection per bucket",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.curr_items": {
          "type": "gauge",
          "description": "total number of stored items per bucket",
          "group": "bucket",
          "included": false
        },
        "gauge.bucket.op.disk_write_queue": {
          "type": "gauge",
          "description": "number of items waiting to be written to disk",
          "group": "bucket",
          "included": false
        },
        "gauge.bucket.op.ep_bg_fetched": {
          "type": "gauge",
          "description": "number of items fetched from disk",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ep_cache_miss_rate": {
          "type": "gauge",
          "description": "ratio of requested objects found in cache vs retrieved from disk",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ep_diskqueue_drain": {
          "type": "gauge",
          "description": "items removed from disk queue",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ep_diskqueue_fill": {
          "type": "gauge",
          "description": "enqueued items on disk queue",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ep_mem_high_wat": {
          "type": "gauge",
          "description": "memory high water mark - point at which active objects begin to be ejected from bucket",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ep_mem_low_wat": {
          "type": "gauge",
          "description": "memory low water mark",
          "group": "bucket",
          "included": false
        },
        "gauge.bucket.op.ep_num_value_ejects": {
          "type": "gauge",
          "description": "number of objects ejected out of the bucket",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ep_oom_errors": {
          "type": "gauge",
          "description": "request rejected - bucket is at quota, panic",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ep_queue_size": {
          "type": "gauge",
          "description": "number of items queued for storage",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ep_tmp_oom_errors": {
          "type": "gauge",
          "description": "request rejected - couchbase is making room by ejecting objects, try again later",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.mem_used": {
          "type": "gauge",
          "description": "memory used",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.op.ops": {
          "type": "gauge",
          "description": "total of gets, sets, increment and decrement",
          "group": "bucket",
          "included": false
        },
        "gauge.bucket.op.vb_active_resident_items_ratio": {
          "type": "gauge",
          "description": "ratio of items kept in memory vs stored on disk",
          "group": "bucket",
          "included": true
        },
        "gauge.bucket.quota.ram": {
          "type": "gauge",
          "description": "Amount of RAM used by the bucket (bytes).",
          "group": "bucket",
          "included": false
        },
        "gauge.bucket.quota.rawRAM": {
          "type": "gauge",
          "description": "Amount of raw RAM used by the bucket (bytes).",
          "group": "bucket",
          "included": false
        },
        "gauge.nodes.cmd_get": {
          "type": "gauge",
          "description": "Number of get commands",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.couch_docs_actual_disk_size": {
          "type": "gauge",
          "description": "Amount of disk space used by Couch docs.(bytes)",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.couch_docs_data_size": {
          "type": "gauge",
          "description": "Data size of couch documents associated with a node (bytes)",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.couch_spatial_data_size": {
          "type": "gauge",
          "description": "Size of object data for spatial views (bytes)",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.couch_spatial_disk_size": {
          "type": "gauge",
          "description": "Amount of disk space occupied by spatial views, in bytes.",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.couch_views_actual_disk_size": {
          "type": "gauge",
          "description": "Amount of disk space occupied by Couch views (bytes).",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.couch_views_data_size": {
          "type": "gauge",
          "description": "Size of object data for Couch views (bytes).",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.curr_items": {
          "type": "gauge",
          "description": "Number of current items",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.curr_items_tot": {
          "type": "gauge",
          "description": "Total number of items associated with node",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.ep_bg_fetched": {
          "type": "gauge",
          "description": "Number of disk fetches performed since server was started",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.get_hits": {
          "type": "gauge",
          "description": "Number of get hits",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.mcdMemoryAllocated": {
          "type": "gauge",
          "description": "Amount of memcached memory allocated (bytes).",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.mcdMemoryReserved": {
          "type": "gauge",
          "description": "Amount of memcached memory reserved (bytes).",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.mem_used": {
          "type": "gauge",
          "description": "Memory used by the node (bytes)",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.memoryFree": {
          "type": "gauge",
          "description": "Amount of memory free for the node (bytes).",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.memoryTotal": {
          "type": "gauge",
          "description": "Total memory available to the node (bytes).",
          "group": "nodes",
          "included": false
        },
        "gauge.nodes.ops": {
          "type": "gauge",
          "description": "Number of operations performed on Couchbase",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.system.cpu_utilization_rate": {
          "type": "gauge",
          "description": "The CPU utilization rate (%)",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.system.mem_free": {
          "type": "gauge",
          "description": "Free memory available to the node (bytes)",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.system.mem_total": {
          "type": "gauge",
          "description": "Total memory available to the node (bytes)",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.system.swap_total": {
          "type": "gauge",
          "description": "Total swap size allocated (bytes)",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.system.swap_used": {
          "type": "gauge",
          "description": "Amount of swap space used (bytes)",
          "group": "nodes",
          "included": true
        },
        "gauge.nodes.vb_replica_curr_items": {
          "type": "gauge",
          "description": "Number of items/documents that are replicas",
          "group": "nodes",
          "included": false
        },
        "gauge.storage.hdd.free": {
          "type": "gauge",
          "description": "Free harddrive space in the cluster (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.hdd.quotaTotal": {
          "type": "gauge",
          "description": "Harddrive quota total for the cluster (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.hdd.total": {
          "type": "gauge",
          "description": "Total harddrive space available to cluster (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.hdd.used": {
          "type": "gauge",
          "description": "Harddrive space used by the cluster (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.hdd.usedByData": {
          "type": "gauge",
          "description": "Harddrive use by the data in the cluster(bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.ram.quotaTotal": {
          "type": "gauge",
          "description": "Ram quota total for the cluster (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.ram.quotaTotalPerNode": {
          "type": "gauge",
          "description": "Ram quota total per node (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.ram.quotaUsed": {
          "type": "gauge",
          "description": "Ram quota used by the cluster (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.ram.quotaUsedPerNode": {
          "type": "gauge",
          "description": "Ram quota used per node (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.ram.total": {
          "type": "gauge",
          "description": "Total ram available to cluster (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.ram.used": {
          "type": "gauge",
          "description": "Ram used by the cluster (bytes)",
          "group": "storage",
          "included": false
        },
        "gauge.storage.ram.usedByData": {
          "type": "gauge",
          "description": "Ram used by the data in the cluster (bytes)",
          "group": "storage",
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/couchbase",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "collectTarget",
            "doc": "Define what this Module block will monitor: \"NODE\", for a Couchbase node, or \"BUCKET\" for a Couchbase bucket.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "collectBucket",
            "doc": "If CollectTarget is \"BUCKET\", CollectBucket specifies the name of the bucket that this will monitor.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clusterName",
            "doc": "Name of this Couchbase cluster. (**default**:\"default\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "collectMode",
            "doc": "Change to \"detailed\" to collect all available metrics from Couchbase stats API. Defaults to \"default\", collecting a curated set that works well with SignalFx. See [metric_info.py](https://github.com/signalfx/collectd-couchbase/blob/master/metric_info.py) for more information.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate with",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password to authenticate with",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/cpu",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor collects cpu usage data using the\ncollectd `cpu` plugin.  It aggregates the per-core CPU data into a single\nmetric and sends it to the SignalFx Metadata plugin in collectd, where the\nraw jiffy counts from the `cpu` plugin are converted to percent utilization\n(the `cpu.utilization` metric).\n\nSee https://collectd.org/wiki/index.php/Plugin:CPU\n",
      "groups": null,
      "metrics": {
        "cpu.idle": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "cpu.interrupt": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "cpu.nice": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "cpu.softirq": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "cpu.steal": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "cpu.system": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "cpu.user": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "cpu.wait": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/cpu",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/cpufreq",
      "sendAll": true,
      "dimensions": null,
      "doc": "Monitors the actual clock speed of each CPU on a\nhost.  Useful for systems that vary the clock speed to conserve energy.\n\nSee https://collectd.org/wiki/index.php/Plugin:CPUFreq\n",
      "groups": null,
      "metrics": {
        "cpufreq.\u003cN\u003e": {
          "type": "gauge",
          "description": "The processor frequency in Hertz for the \u003cN\u003eth processor on the system.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/cpufreq",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/custom",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor lets you provide custom collectd\nconfiguration to be run by the managed collectd instance.  You can provide\nconfiguration for as many plugins as you want in a single instance of this\nmonitor configuration by either putting multiple `\u003cPlugin\u003e` blocks in a\nsingle `template` option, or specifying multiple `templates`.\n\nNote that a distinct instance of collectd is run for each instance of this\nmonitor, so it is more efficient to group plugin configurations into a\nsingle monitor configuration (either in one big `template` text blob, or\nsplit into multiple `templates`).  You should not group configurations if\nusing a discoveryRule since that would result in duplicate config for each\ninstance of the service endpoint discovered.\n\nYou can also use your own Python plugins in conjunction with the\n`ModulePath` option in\n[collectd-python](https://collectd.org/documentation/manpages/collectd-python.5.shtml).\nIf your Python plugin has dependencies of its own, you can specify the path\nto them by specifying multiple `ModulePath` options with those paths.\n\nHere is an example of a configuration with a custom Python plugin:\n\n```yaml\n  - type: collectd/custom\n    discoveryRule: container_image =~ \"myservice\"\n    template: |\n      LoadPlugin \"python\"\n      \u003cPlugin python\u003e\n        ModulePath \"/usr/lib/python2.7/dist-packages/health_checker\"\n        Import \"health_checker\"\n        \u003cModule health_checker\u003e\n          URL \"http://{{.Host}}:{{.Port}}\"\n          JSONKey \"isRunning\"\n          JSONVal \"1\"\n        \u003c/Module\u003e\n      \u003c/Plugin\u003e\n```\n\nWe have many collectd plugins included in the image that are not exposed as\nmonitors.  You can see the plugins in the `\u003cAGENT_BUNDLE\u003e/lib/collectd`\ndirectory, where `\u003cAGENT_BUNDLE\u003e` is the root of the filesystem in the\ncontainerized version, and is normally `/usr/lib/signalfx-agent` in the\nnon-containerized agent.\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the configuration for the collectd custom monitor",
        "package": "internal/monitors/collectd/custom",
        "fields": [
          {
            "yamlName": "host",
            "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Host}}`.  It will be set to the hostname or IP address of the discovered service. If you aren't using service discovery, you can just hardcode the host/port in the config template and ignore these fields.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Port}}`.  It will be set to the port of the discovered service, if it is a TCP/UDP endpoint.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "This should generally not be set manually, but will be filled in by the agent if using service discovery. It can be accessed in the provided config template with `{{.Name}}`.  It will be set to the name that the observer creates for the endpoint upon discovery.  You can generally ignore this field.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "template",
            "doc": "A config template for collectd.  You can include as many plugin blocks as you want in this value.  It is rendered as a standard Go template, so be mindful of the delimiters `{{` and `}}`.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "templates",
            "doc": "A list of templates, but otherwise equivalent to the above `template` option.  This enables you to have a single directory with collectd configuration files and load them all by using a globbed remote config value:",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "collectdReadThreads",
            "doc": "The number of read threads to use in collectd.  Will default to the number of templates provided, capped at 10, but if you manually specify it there is no limit.",
            "default": 0,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/df",
      "sendAll": false,
      "dimensions": null,
      "doc": "Tracks free disk space on the host.\n",
      "groups": null,
      "metrics": {
        "df_complex.free": {
          "type": "gauge",
          "description": "Free disk space in bytes",
          "group": null,
          "included": true
        },
        "df_complex.reserved": {
          "type": "gauge",
          "description": "Reserved disk space in bytes",
          "group": null,
          "included": false
        },
        "df_complex.used": {
          "type": "gauge",
          "description": "Used disk space in bytes",
          "group": null,
          "included": true
        },
        "df_inodes.free": {
          "type": "gauge",
          "description": "Number of inodes that are free.",
          "group": "inodes",
          "included": false
        },
        "df_inodes.reserved": {
          "type": "gauge",
          "description": "Number of inodes reserved for the super user.",
          "group": "inodes",
          "included": false
        },
        "df_inodes.used": {
          "type": "gauge",
          "description": "Number of inodes that are used.",
          "group": "inodes",
          "included": false
        },
        "percent_bytes.free": {
          "type": "gauge",
          "description": "Free disk space on the file system, expressed as a percentage.",
          "group": "percentage",
          "included": false
        },
        "percent_bytes.reserved": {
          "type": "gauge",
          "description": "Reserved disk space on the filesystem, expressed as a percentage.",
          "group": "percentage",
          "included": false
        },
        "percent_bytes.used": {
          "type": "gauge",
          "description": "Used disk space on the file system, expressed as a percentage.",
          "group": "percentage",
          "included": false
        },
        "percent_inodes.free": {
          "type": "gauge",
          "description": "Free inodes on the file system, expressed as a percentage.",
          "group": null,
          "included": false
        },
        "percent_inodes.reserved": {
          "type": "gauge",
          "description": "Reserved inodes on the file system, expressed as a percentage.",
          "group": null,
          "included": false
        },
        "percent_inodes.used": {
          "type": "gauge",
          "description": "Used inodes on the file system, expressed as a percentage.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/df",
        "fields": [
          {
            "yamlName": "hostFSPath",
            "doc": "Path to the root of the host filesystem.  Useful when running in a container and the host filesystem is mounted in some subdirectory under /.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "ignoreSelected",
            "doc": "If true, the filesystems selected by `fsTypes` and `mountPoints` will be excluded and all others included.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "fsTypes",
            "doc": "The filesystem types to include/exclude.",
            "default": [
              "aufs",
              "overlay",
              "tmpfs",
              "proc",
              "sysfs",
              "nsfs",
              "cgroup",
              "devpts",
              "selinuxfs",
              "devtmpfs",
              "debugfs",
              "mqueue",
              "hugetlbfs",
              "securityfs",
              "pstore",
              "binfmt_misc",
              "autofs"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mountPoints",
            "doc": "The mount paths to include/exclude, is interpreted as a regex if surrounded by `/`.  Note that you need to include the full path as the agent will see it, irrespective of the hostFSPath option.",
            "default": [
              "/^/var/lib/docker/containers/",
              "/^/var/lib/rkt/pods/",
              "/^/net//",
              "/^/smb//"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "reportByDevice",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportInodes",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "valuesPercentage",
            "doc": "If true percent based metrics will be reported.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/disk",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor collects information about the usage of\nphysical disks and logical disks (partitions).\n\nSee https://collectd.org/wiki/index.php/Plugin:Disk.\n",
      "groups": null,
      "metrics": {
        "disk_io_time.io_time": {
          "type": "cumulative",
          "description": "Amount of time spent doing IO in ms",
          "group": null,
          "included": false
        },
        "disk_io_time.weighted_io_time": {
          "type": "cumulative",
          "description": "Amount of time spent doing IO in ms multiplied by the queue length",
          "group": null,
          "included": false
        },
        "disk_merged.read": {
          "type": "cumulative",
          "description": "The number of disk reads merged into single physical disk access operations.",
          "group": null,
          "included": false
        },
        "disk_merged.write": {
          "type": "cumulative",
          "description": "The number of disk writes merged into single physical disk access operations.",
          "group": null,
          "included": false
        },
        "disk_octets.read": {
          "type": "cumulative",
          "description": "The number of bytes (octets) read from a disk.",
          "group": null,
          "included": false
        },
        "disk_octets.write": {
          "type": "cumulative",
          "description": "The number of bytes (octets) written to a disk.",
          "group": null,
          "included": false
        },
        "disk_ops.read": {
          "type": "cumulative",
          "description": "The number of disk read operations.",
          "group": null,
          "included": true
        },
        "disk_ops.write": {
          "type": "cumulative",
          "description": "The number of disk write operations.",
          "group": null,
          "included": true
        },
        "disk_time.read": {
          "type": "cumulative",
          "description": "The average amount of time it took to do a read operation.",
          "group": null,
          "included": false
        },
        "disk_time.write": {
          "type": "cumulative",
          "description": "The average amount of time it took to do a write operation.",
          "group": null,
          "included": false
        },
        "pending_operations": {
          "type": "gauge",
          "description": "Number of pending operations",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/disk",
        "fields": [
          {
            "yamlName": "disks",
            "doc": "Which devices to include/exclude",
            "default": [
              "/^loop[0-9]+$/",
              "/^dm-[0-9]+$/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "ignoreSelected",
            "doc": "If true, the disks selected by `disks` will be excluded and all others included.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/docker",
      "sendAll": false,
      "dimensions": null,
      "doc": "Pulls container stats from the Docker Engine.  We\nstrongly recommend using the\n[docker-container-stats](./docker-container-stats.md) monitor instead, as it\nwill scale to large number of containers much better.\n\nSee https://github.com/signalfx/docker-collectd-plugin.\n",
      "groups": {
        "blkio": {
          "description": "BlockIO metrics"
        },
        "cpu": {
          "description": "CPU metrics"
        },
        "memory": {
          "description": "Memory metrics"
        },
        "network": {
          "description": "Network metrics"
        }
      },
      "metrics": {
        "blkio.io_service_bytes_recursive.async": {
          "type": "cumulative",
          "description": "Volume, in bytes, of asynchronous block I/O",
          "group": "blkio",
          "included": true
        },
        "blkio.io_service_bytes_recursive.read": {
          "type": "cumulative",
          "description": "Volume, in bytes, of reads from block devices",
          "group": "blkio",
          "included": true
        },
        "blkio.io_service_bytes_recursive.sync": {
          "type": "cumulative",
          "description": "Volume, in bytes, of synchronous block I/O",
          "group": "blkio",
          "included": true
        },
        "blkio.io_service_bytes_recursive.total": {
          "type": "cumulative",
          "description": "Total volume, in bytes, of all block I/O",
          "group": "blkio",
          "included": true
        },
        "blkio.io_service_bytes_recursive.write": {
          "type": "cumulative",
          "description": "Volume, in bytes, of writes to block devices",
          "group": "blkio",
          "included": true
        },
        "cpu.usage.kernelmode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in kernel mode by the container",
          "group": "cpu",
          "included": true
        },
        "cpu.usage.system": {
          "type": "gauge",
          "description": "Jiffies of CPU time used by the system",
          "group": "cpu",
          "included": true
        },
        "cpu.usage.total": {
          "type": "gauge",
          "description": "Jiffies of CPU time used by the container",
          "group": "cpu",
          "included": true
        },
        "cpu.usage.usermode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in user mode by the container",
          "group": "cpu",
          "included": true
        },
        "memory.usage.limit": {
          "type": "gauge",
          "description": "Memory usage limit of the container, in bytes",
          "group": "memory",
          "included": true
        },
        "memory.usage.max": {
          "type": "gauge",
          "description": "Maximum measured memory usage of the container, in bytes",
          "group": "memory",
          "included": true
        },
        "memory.usage.total": {
          "type": "gauge",
          "description": "Bytes of memory used by the container",
          "group": "memory",
          "included": true
        },
        "network.usage.rx_bytes": {
          "type": "cumulative",
          "description": "Bytes received by the container via its network interface",
          "group": "network",
          "included": false
        },
        "network.usage.rx_dropped": {
          "type": "cumulative",
          "description": "Number of inbound network packets dropped by the container",
          "group": "network",
          "included": false
        },
        "network.usage.rx_errors": {
          "type": "cumulative",
          "description": "Errors receiving network packets",
          "group": "network",
          "included": false
        },
        "network.usage.rx_packets": {
          "type": "cumulative",
          "description": "Network packets received by the container via its network interface",
          "group": "network",
          "included": false
        },
        "network.usage.tx_bytes": {
          "type": "cumulative",
          "description": "Bytes sent by the container via its network interface",
          "group": "network",
          "included": false
        },
        "network.usage.tx_dropped": {
          "type": "cumulative",
          "description": "Number of outbound network packets dropped by the container",
          "group": "network",
          "included": false
        },
        "network.usage.tx_errors": {
          "type": "cumulative",
          "description": "Errors sending network packets",
          "group": "network",
          "included": false
        },
        "network.usage.tx_packets": {
          "type": "cumulative",
          "description": "Network packets sent by the container via its network interface",
          "group": "network",
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/docker",
        "fields": [
          {
            "yamlName": "dimensions",
            "doc": "A set of dimensions to add to container metrics (see https://github.com/signalfx/docker-collectd-plugin#extracting-additional-dimensions).",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "dockerURL",
            "doc": "URL of the Docker engine, can be a unix socket path.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "excludedImages",
            "doc": "",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedNames",
            "doc": "",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedLabels",
            "doc": "",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "collectNetworkStats",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/elasticsearch",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors ElasticSearch instances. We strongly recommend using the\n[elasticsearch](./elasticsearch.md) monitor instead, as it will\nscale much better.\n\nSee https://github.com/signalfx/collectd-elasticsearch and\nhttps://github.com/signalfx/integrations/tree/master/collectd-elasticsearch\n",
      "groups": null,
      "metrics": {
        "counter.indices.get.total": {
          "type": "cumulative",
          "description": "The total number of get requests since node startup",
          "group": null,
          "included": true
        },
        "counter.indices.indexing.index-total": {
          "type": "cumulative",
          "description": "The total number of index requests since node startup",
          "group": null,
          "included": true
        },
        "counter.indices.merges.total": {
          "type": "cumulative",
          "description": "Total number of merges since node startup",
          "group": null,
          "included": true
        },
        "counter.indices.search.query-time": {
          "type": "cumulative",
          "description": "Total time spent in search queries (milliseconds)",
          "group": null,
          "included": true
        },
        "counter.indices.search.query-total": {
          "type": "cumulative",
          "description": "The total number of search requests since node startup",
          "group": null,
          "included": true
        },
        "counter.indices.total.indexing.index-total": {
          "type": "cumulative",
          "description": "The total number of index requests per cluster",
          "group": null,
          "included": true
        },
        "counter.indices.total.merges.total": {
          "type": "cumulative",
          "description": "Total number of merges per cluster",
          "group": null,
          "included": true
        },
        "counter.indices.total.search.query-total": {
          "type": "cumulative",
          "description": "The total number of search requests per cluster",
          "group": null,
          "included": true
        },
        "counter.jvm.gc.time": {
          "type": "cumulative",
          "description": "Total garbage collection time (milliseconds)",
          "group": null,
          "included": true
        },
        "counter.thread_pool.bulk.rejected": {
          "type": "cumulative",
          "description": "Number of rejected bulk requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.flush.rejected": {
          "type": "cumulative",
          "description": "Number of rejected flush requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.generic.rejected": {
          "type": "cumulative",
          "description": "Number of rejected generic requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.get.rejected": {
          "type": "cumulative",
          "description": "Number of rejected get requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.index.rejected": {
          "type": "cumulative",
          "description": "Number of rejected index requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.merge.rejected": {
          "type": "cumulative",
          "description": "Number of rejected merge requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.optimize.rejected": {
          "type": "cumulative",
          "description": "Number of rejected optimize requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.refresh.rejected": {
          "type": "cumulative",
          "description": "Number of rejected refresh requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.rejected": {
          "type": "cumulative",
          "description": "Number of rejected thread pool requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.search.rejected": {
          "type": "cumulative",
          "description": "Number of rejected search requests",
          "group": null,
          "included": true
        },
        "counter.thread_pool.snapshot.rejected": {
          "type": "cumulative",
          "description": "Number of rejected snapshot requests",
          "group": null,
          "included": true
        },
        "gauge.cluster.active-primary-shards": {
          "type": "gauge",
          "description": "The number of active primary shards",
          "group": null,
          "included": true
        },
        "gauge.cluster.active-shards": {
          "type": "gauge",
          "description": "The number of active shards",
          "group": null,
          "included": true
        },
        "gauge.cluster.initializing-shards": {
          "type": "gauge",
          "description": "The number of currently initializing shards",
          "group": null,
          "included": false
        },
        "gauge.cluster.number-of-data_nodes": {
          "type": "gauge",
          "description": "The current number of data nodes in the cluster",
          "group": null,
          "included": true
        },
        "gauge.cluster.number-of-nodes": {
          "type": "gauge",
          "description": "Total number of nodes in the cluster",
          "group": null,
          "included": true
        },
        "gauge.cluster.relocating-shards": {
          "type": "gauge",
          "description": "The number of shards that are currently being relocated",
          "group": null,
          "included": true
        },
        "gauge.cluster.status": {
          "type": "gauge",
          "description": "The health status of the cluster",
          "group": null,
          "included": false
        },
        "gauge.cluster.unassigned-shards": {
          "type": "gauge",
          "description": "The number of shards that are currently unassigned",
          "group": null,
          "included": true
        },
        "gauge.indices.cache.field.size": {
          "type": "gauge",
          "description": "Field data size (bytes)",
          "group": null,
          "included": true
        },
        "gauge.indices.cache.filter.size": {
          "type": "gauge",
          "description": "Filter cache size (bytes)",
          "group": null,
          "included": true
        },
        "gauge.indices.docs.count": {
          "type": "gauge",
          "description": "Number of documents on this node",
          "group": null,
          "included": true
        },
        "gauge.indices.docs.deleted": {
          "type": "gauge",
          "description": "Number of deleted documents on this node",
          "group": null,
          "included": true
        },
        "gauge.indices.merges.current": {
          "type": "gauge",
          "description": "Number of active merges",
          "group": null,
          "included": true
        },
        "gauge.indices.segments.count": {
          "type": "gauge",
          "description": "Number of segments on this node",
          "group": null,
          "included": true
        },
        "gauge.indices.total.docs.count": {
          "type": "gauge",
          "description": "Number of documents in the cluster",
          "group": null,
          "included": true
        },
        "gauge.indices.total.fielddata.memory-size": {
          "type": "gauge",
          "description": "Field data size (bytes)",
          "group": null,
          "included": true
        },
        "gauge.indices.total.filter-cache.memory-size": {
          "type": "gauge",
          "description": "Filter cache size (bytes)",
          "group": null,
          "included": true
        },
        "gauge.jvm.mem.heap-committed": {
          "type": "gauge",
          "description": "Total heap committed by the process (bytes)",
          "group": null,
          "included": true
        },
        "gauge.jvm.mem.heap-used": {
          "type": "gauge",
          "description": "Total heap used (bytes)",
          "group": null,
          "included": true
        },
        "gauge.process.open_file_descriptors": {
          "type": "gauge",
          "description": "Number of currently open file descriptors",
          "group": null,
          "included": true
        },
        "gauge.thread_pool.active": {
          "type": "gauge",
          "description": "Number of active threads",
          "group": null,
          "included": false
        },
        "gauge.thread_pool.largest": {
          "type": "gauge",
          "description": "Highest active threads in thread pool",
          "group": null,
          "included": false
        },
        "gauge.thread_pool.queue": {
          "type": "gauge",
          "description": "Number of Tasks in thread pool",
          "group": null,
          "included": false
        },
        "gauge.thread_pool.threads": {
          "type": "gauge",
          "description": "Number of Threads in thread pool",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/elasticsearch",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "additionalMetrics",
            "doc": "AdditionalMetrics to report on",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "cluster",
            "doc": "Cluster name to which the node belongs. This is an optional config that will override the cluster name fetched from a node and will be used to populate the plugin_instance dimension",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "detailedMetrics",
            "doc": "DetailedMetrics turns on additional metric time series",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableClusterHealth",
            "doc": "EnableClusterHealth enables reporting on the cluster health",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableIndexStats",
            "doc": "EnableIndexStats reports metrics about indexes",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "indexes",
            "doc": "Indexes to report on",
            "default": [
              "_all"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "indexInterval",
            "doc": "IndexInterval is an interval in seconds at which the plugin will report index stats. It must be greater than or equal, and divisible by the Interval configuration",
            "default": 300,
            "required": false,
            "type": "uint",
            "elementKind": ""
          },
          {
            "yamlName": "indexStatsMasterOnly",
            "doc": "IndexStatsMasterOnly sends index stats from the master only",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "indexSummaryOnly",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password used to access elasticsearch stats api",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "protocol",
            "doc": "Protocol used to connect: http or https",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "threadPools",
            "doc": "ThreadPools to report on",
            "default": [
              "search",
              "index"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "username",
            "doc": "Username used to access elasticsearch stats api",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "version",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/etcd",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an etcd key/value store.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-etcd and\nhttps://github.com/signalfx/collectd-etcd\n",
      "groups": null,
      "metrics": {
        "counter.etcd.leader.counts.fail": {
          "type": "counter",
          "description": "Total number of failed rpc requests to with a follower",
          "group": null,
          "included": true
        },
        "counter.etcd.leader.counts.success": {
          "type": "counter",
          "description": "Total number of successful rpc requests to with a follower",
          "group": null,
          "included": true
        },
        "counter.etcd.self.recvappendreq.cnt": {
          "type": "counter",
          "description": "Total number of append requests received by a member",
          "group": null,
          "included": true
        },
        "counter.etcd.self.sendappendreq.cnt": {
          "type": "counter",
          "description": "Total number of append requests sent by a member",
          "group": null,
          "included": true
        },
        "counter.etcd.store.compareanddelete.fail": {
          "type": "counter",
          "description": "Total number of failed compare-and-delete operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.compareanddelete.success": {
          "type": "counter",
          "description": "Total number of successful compare-and-delete operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.compareandswap.fail": {
          "type": "counter",
          "description": "Total number of failed compare-and-swap operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.compareandswap.success": {
          "type": "counter",
          "description": "Total number of successful compare-and-swap operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.create.fail": {
          "type": "counter",
          "description": "Total number of failed create operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.create.success": {
          "type": "counter",
          "description": "Total number of successful create operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.delete.fail": {
          "type": "counter",
          "description": "Total number of failed delete operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.delete.success": {
          "type": "counter",
          "description": "Total number of successful delete operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.expire.count": {
          "type": "counter",
          "description": "Total number of items expired due to TTL",
          "group": null,
          "included": true
        },
        "counter.etcd.store.gets.fail": {
          "type": "counter",
          "description": "Total number of failed get operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.gets.success": {
          "type": "counter",
          "description": "Total number of successful get operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.sets.fail": {
          "type": "counter",
          "description": "Total number of failed set operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.sets.success": {
          "type": "counter",
          "description": "Total number of successful set operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.update.fail": {
          "type": "counter",
          "description": "Total number of failed update operations",
          "group": null,
          "included": true
        },
        "counter.etcd.store.update.success": {
          "type": "counter",
          "description": "Total number of successful update operations",
          "group": null,
          "included": true
        },
        "gauge.etcd.leader.latency.average": {
          "type": "gauge",
          "description": "Average latency of a follower with respect to the leader",
          "group": null,
          "included": false
        },
        "gauge.etcd.leader.latency.current": {
          "type": "gauge",
          "description": "Current latency of a follower with respect to the leader",
          "group": null,
          "included": true
        },
        "gauge.etcd.leader.latency.max": {
          "type": "gauge",
          "description": "Max latency of a follower with respect to the leader",
          "group": null,
          "included": false
        },
        "gauge.etcd.leader.latency.min": {
          "type": "gauge",
          "description": "Min latency of a follower with respect to the leader",
          "group": null,
          "included": false
        },
        "gauge.etcd.leader.latency.stddev": {
          "type": "gauge",
          "description": "Std dev latency of a follower with respect to the leader",
          "group": null,
          "included": false
        },
        "gauge.etcd.self.recvbandwidth.rate": {
          "type": "gauge",
          "description": "Bandwidth rate of a follower",
          "group": null,
          "included": true
        },
        "gauge.etcd.self.recvpkg.rate": {
          "type": "gauge",
          "description": "Rate at which a follower receives packages",
          "group": null,
          "included": true
        },
        "gauge.etcd.self.sendbandwidth.rate": {
          "type": "gauge",
          "description": "Bandwidth rate of a leader",
          "group": null,
          "included": true
        },
        "gauge.etcd.self.sendpkg.rate": {
          "type": "gauge",
          "description": "Rate at which a leader sends packages",
          "group": null,
          "included": true
        },
        "gauge.etcd.store.watchers": {
          "type": "gauge",
          "description": "Number of watchers",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/etcd",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "clusterName",
            "doc": "An arbitrary name of the etcd cluster to make it easier to group together and identify instances.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslKeyFile",
            "doc": "Client private key if using client certificate authentication.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslCertificate",
            "doc": "Client public key if using client certificate authentication.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslCACerts",
            "doc": "Certificate authority or host certificate to trust.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "skipSSLValidation",
            "doc": "If `true`, etcd's SSL certificate will not be verified. Enabling this option results in the `sslCACerts` option being ignored.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/genericjmx",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors Java services that expose metrics on\nJMX using collectd's GenericJMX plugin.\n\nSee the following for more information\n- https://github.com/signalfx/integrations/tree/master/collectd-genericjmx\n- https://collectd.org/documentation/manpages/collectd-java.5.shtml\n- https://collectd.org/wiki/index.php/Plugin:GenericJMX\n\nExample (gets the thread count from a standard JMX MBean available on all\nJava JMX-enabled apps):\n\n```yaml\n\nmonitors:\n - type: collectd/genericjmx\n   host: my-java-app\n   port: 7099\n   mBeanDefinitions:\n     threading:\n       objectName: java.lang:type=Threading\n       values:\n       - type: gauge\n         table: false\n         instancePrefix: jvm.threads.count\n         attribute: ThreadCount\n```\n## Troubleshooting\n\nExposing JMX in your Java application can be a tricky process.  Oracle has a\n[helpful guide for Java\n8](https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html)\nthat explains how to expose JMX metrics automatically by setting Java\nproperties on your application.  Here are a set of Java properties that are\nknown to work with Java 7+:\n\n```\njava \\\n  -Dcom.sun.management.jmxremote.port=5000 \\\n  -Dcom.sun.management.jmxremote.authenticate=false \\\n  -Dcom.sun.management.jmxremote.ssl=false \\\n  -Dcom.sun.management.jmxremote.rmi.port=5000 \\\n  ...\n```\n\nThis should work as long as the agent is allowed to access port 5000 on the\nJava app's host (i.e. there is no firewall blocking it).  Note that this\ndoes not enable authentication or encryption, but these can be added if\ndesired.\n\nAssuming you have the `host` config set to `172.17.0.3` and the port set to\n`5000` (this is a totally arbitrary port and your JMX app will probably be\nsomething different), here are some errors you might receive and their\nmeanings:\n\n### Connection Refused\n```\nCreating MBean server connection failed: java.io.IOException: Failed to retrieve RMIServer stub: javax.naming.ServiceUnavailableException [Root exception is java.rmi.ConnectException: Connection refused to host: 172.17.0.3; nested exception is:\n     java.net.ConnectException: Connection refused (Connection refused)]\n```\n\nThis error indicates that the JMX connect port is not open on the specified\nhost.  Confirm (via netstat/ss or some other tool) that this port\nis indeed open on the configured host, and is listening on an appropriate\naddress (i.e. if the agent is running on a remote server then JMX should not\nbe listening on localhost only).\n\n### RMI Connection Issues\n\n```\nCreating MBean server connection failed: java.rmi.ConnectException: Connection refused to host: 172.17.0.3; nested exception is:\n     java.net.ConnectException: Connection timed out (Connection timed out)\n```\n\nThis indicates that the JMX connect port was reached successfully, but the\nRMI port that it was directed to is being blocked, probably by a firewall.\nThe easiest thing to do here is to make sure the\n`com.sun.management.jmxremote.rmi.port` property in your Java app is set to\nthe same port as the JMX connect port.  There may be other variations of\nthis that say `Connection reset` or `Connection refused` but they all\ngeneraly indicate a similar cause.\n\n## Useful links\n\n - https://realjenius.com/2012/11/21/java7-jmx-tunneling-freedom/\n",
      "groups": null,
      "metrics": {
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "included": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "included": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "included": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "internal/monitors/collectd/genericjmx",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "internal/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "internal/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/hadoop",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects metrics about a Hadoop cluster using the\n[collectd Hadoop Python plugin](https://github.com/signalfx/collectd-hadoop).\nAlso see\nhttps://github.com/signalfx/integrations/tree/master/collectd-hadoop.\n\nThe `collectd/hadoop` monitor will collect metrics from the Resource Manager\nREST API for the following:\n- Cluster Metrics\n- Cluster Scheduler\n- Cluster Applications\n- Cluster Nodes\n- MapReduce Jobs\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/hadoop\n  host: 127.0.0.1\n  port: 8088\n```\n\nIf a remote JMX port is exposed in the hadoop cluster, then\nyou may also configure the [collectd/hadoopjmx](https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/collectd-hadoopjmx.md)\nmonitor to collect additional metrics about the hadoop cluster.\n",
      "groups": null,
      "metrics": {
        "gauge.hadoop.cluster.metrics.active_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.allocated_mb": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.allocated_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.apps_completed": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.apps_failed": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.apps_running": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.apps_submitted": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.available_mb": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.available_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.decommissioned_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.lost_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.rebooted_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.reserved_mb": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.reserved_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.total_mb": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.total_virtual_cores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.cluster.metrics.unhealthy_nodes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.mapreduce.job.elapsedTime": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.mapreduce.job.failedMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.mapreduce.job.failedReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.mapreduce.job.mapsTotal": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.mapreduce.job.successfulMapAttempts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.mapreduce.job.successfulReduceAttempts": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.allocatedMB": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.allocatedVCores": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.clusterUsagePercentage": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.memorySeconds": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.priority": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.progress": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.queueUsagePercentage": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.runningContainers": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.apps.vcoreSeconds": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gauge.hadoop.resource.manager.scheduler.leaf.queue.usedCapacity": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/hadoop",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Resource Manager Hostname",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Resource Manager Port",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "verbose",
            "doc": "Log verbose information about the plugin",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/hadoopjmx",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects metrics about a Hadoop cluster using using collectd's GenericJMX plugin.\n\nAlso see https://github.com/signalfx/integrations/tree/master/collectd-hadoop.\n\nTo enable JMX in Hadoop, add the following JVM options to hadoop-env.sh and yarn-env.sh respectively\n\n**hadoop-env.sh:**\n```sh\nexport HADOOP_NAMENODE_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5677 $HADOOP_NAMENODE_OPTS\"\nexport HADOOP_DATANODE_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5679 $HADOOP_DATANODE_OPTS\"\n```\n\n**yarn-env.sh:**\n```sh\nexport YARN_NODEMANAGER_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=8002 $YARN_NODEMANAGER_OPTS\"\nexport YARN_RESOURCEMANAGER_OPTS=\"-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=5680 $YARN_RESOURCEMANAGER_OPTS\"\n```\n\nThis monitor has a set of built in MBeans configured for:\n  - [Name Nodes](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/hadoopjmx/nameNodeMBeans.go)\n  - [Resource Manager](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/hadoopjmx/resourceManagerMBeans.go)\n  - [Node Manager](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/hadoopjmx/nodeManagerMBeans.go)\n  - [Data Nodes](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/hadoopjmx/dataNodeMBeans.go)\n\nSample YAML configuration:\n\nName Node\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5677\n  nodeType: nameNode\n```\n\nResource Manager\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5680\n  nodeType: resourceManager\n```\n\nNode Manager\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 8002\n  nodeType: nodeManager\n```\n\nData Node\n```yaml\nmonitors:\n- type: collectd/hadoopjmx\n  host: 127.0.0.1\n  port: 5679\n  nodeType: dataNode\n```\n\nYou may also configure the [collectd/hadoop](https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/collectd-hadoop.md)\nmonitor to collect additional metrics about the hadoop cluster from the REST API\n",
      "groups": {
        "data-node": {
          "description": "Metrics for DataNodes containing HDFS files"
        },
        "jvm": {
          "description": "JVM metrics"
        },
        "name-node": {
          "description": "Metrics for NameNodes containing HDFS metadata"
        },
        "node-manager": {
          "description": "Metrics for Node Manager"
        },
        "resource-manager": {
          "description": "Metrics for Hadoop resource management"
        }
      },
      "metrics": {
        "counter.hadoop-datanode-blocks-read": {
          "type": "cumulative",
          "description": "",
          "group": "data-node",
          "included": false
        },
        "counter.hadoop-datanode-blocks-written": {
          "type": "cumulative",
          "description": "",
          "group": "data-node",
          "included": false
        },
        "counter.hadoop-datanode-bytes-read": {
          "type": "cumulative",
          "description": "",
          "group": "data-node",
          "included": false
        },
        "counter.hadoop-datanode-bytes-written": {
          "type": "cumulative",
          "description": "",
          "group": "data-node",
          "included": false
        },
        "counter.hadoop-namenode-files-total": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "included": false
        },
        "counter.hadoop-namenode-gc-count": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "counter.hadoop-namenode-gc-time": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "counter.hadoop-namenode-rpc-total-calls": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "counter.hadoop-namenode-total-load": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "counter.hadoop-namenode-volume-failures": {
          "type": "cumulative",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "counter.hadoop-nodeManager-containers-failed": {
          "type": "cumulative",
          "description": "",
          "group": "node-manager",
          "included": false
        },
        "counter.hadoop-nodeManager-containers-launched": {
          "type": "cumulative",
          "description": "",
          "group": "node-manager",
          "included": false
        },
        "gauge.hadoop-datanode-fs-capacity": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": true
        },
        "gauge.hadoop-datanode-fs-dfs-remaining": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": true
        },
        "gauge.hadoop-datanode-fs-dfs-used": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": true
        },
        "gauge.hadoop-datanode-info-xceiver": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": false
        },
        "gauge.hadoop-datanode-jvm-heap-used": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": true
        },
        "gauge.hadoop-datanode-jvm-non-heap-used": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": false
        },
        "gauge.hadoop-datanode-rpc-call-queue-length": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": true
        },
        "gauge.hadoop-datanode-rpc-open-connections": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": true
        },
        "gauge.hadoop-datanode-rpc-processing-avg": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": true
        },
        "gauge.hadoop-datanode-rpc-queue-time-avg": {
          "type": "gauge",
          "description": "",
          "group": "data-node",
          "included": true
        },
        "gauge.hadoop-namenode-blocks-with-corrupt-replicas": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": false
        },
        "gauge.hadoop-namenode-capacity-remaining": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": false
        },
        "gauge.hadoop-namenode-capacity-total": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-capacity-used": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-corrupt-blocks": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": false
        },
        "gauge.hadoop-namenode-current-heap-used": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-dead-datanodes": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-dfs-free": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-live-datanodes": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-max-heap": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-missing-blocks": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": false
        },
        "gauge.hadoop-namenode-percent-dfs-used": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": false
        },
        "gauge.hadoop-namenode-percent-remaining": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-rpc-avg-process-time": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-rpc-avg-queue": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-namenode-stale-datanodes": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": false
        },
        "gauge.hadoop-namenode-under-replicated-blocks": {
          "type": "gauge",
          "description": "",
          "group": "name-node",
          "included": true
        },
        "gauge.hadoop-nodeManager-allocated-memory": {
          "type": "gauge",
          "description": "",
          "group": "node-manager",
          "included": false
        },
        "gauge.hadoop-nodeManager-allocated-vcores": {
          "type": "gauge",
          "description": "",
          "group": "node-manager",
          "included": false
        },
        "gauge.hadoop-nodeManager-available-memory": {
          "type": "gauge",
          "description": "",
          "group": "node-manager",
          "included": false
        },
        "gauge.hadoop-nodeManager-available-vcores": {
          "type": "gauge",
          "description": "",
          "group": "node-manager",
          "included": false
        },
        "gauge.hadoop-resourceManager-active-apps": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": false
        },
        "gauge.hadoop-resourceManager-active-nms": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": false
        },
        "gauge.hadoop-resourceManager-active-users": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": false
        },
        "gauge.hadoop-resourceManager-allocated-containers": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": false
        },
        "gauge.hadoop-resourceManager-allocated-memory": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": false
        },
        "gauge.hadoop-resourceManager-allocated-vcores": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": true
        },
        "gauge.hadoop-resourceManager-available-memory": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": false
        },
        "gauge.hadoop-resourceManager-available-vcores": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": true
        },
        "gauge.hadoop-resourceManager-heap-max": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": false
        },
        "gauge.hadoop-resourceManager-heap-used": {
          "type": "gauge",
          "description": "",
          "group": "resource-manager",
          "included": false
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "included": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "included": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "included": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/hadoopjmx",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "internal/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "internal/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          },
          {
            "yamlName": "nodeType",
            "doc": "Hadoop Node Type",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/haproxy",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an HAProxy instance.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-haproxy.\n",
      "groups": null,
      "metrics": {
        "counter.connection_total": {
          "type": "counter",
          "description": "Cumulative number of connections (frontend). This corresponds to HAProxy's \"conn_tot\" metric.",
          "group": null,
          "included": false
        },
        "counter.server_selected_total": {
          "type": "counter",
          "description": "Number of times a server was selected, either for new sessions or when re-dispatching. This corresponds to HAProxy's \"lbtot\" metric.",
          "group": null,
          "included": true
        },
        "derive.bytes_in": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `bin` metric -  Bytes in",
          "group": null,
          "included": true
        },
        "derive.bytes_out": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `bout` metric -  Bytes out",
          "group": null,
          "included": true
        },
        "derive.cli_abrt": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `cli_abrt` metric -  Number of data transfers aborted by the client",
          "group": null,
          "included": false
        },
        "derive.comp_byp": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_byp` metric -  Number of bytes that bypassed the HTTP compressor (CPU/BW limit)",
          "group": null,
          "included": false
        },
        "derive.comp_in": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_in` metric -  Number of HTTP response bytes fed to the compressor",
          "group": null,
          "included": false
        },
        "derive.comp_out": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_out` metric -  Number of HTTP response bytes emitted by the compressor",
          "group": null,
          "included": false
        },
        "derive.comp_rsp": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `comp_rsp` metric -  Number of HTTP responses that were compressed",
          "group": null,
          "included": false
        },
        "derive.compress_bps_in": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CompressBpsIn` metric.",
          "group": null,
          "included": false
        },
        "derive.compress_bps_out": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CompressBpsOut` metric.",
          "group": null,
          "included": false
        },
        "derive.connections": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumConns` metric. Cumulative number of connections.",
          "group": null,
          "included": false
        },
        "derive.denied_request": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `dreq` metric -  Requests denied because of security concerns. - For tcp this is because of a matched tcp-request content rule.",
          "group": null,
          "included": true
        },
        "derive.denied_response": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `dresp` metric -  Responses denied because of security concerns. - For http this is because of a matched http-request rule, or",
          "group": null,
          "included": true
        },
        "derive.downtime": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `downtime` metric -  Total downtime (in seconds). The value for the backend is the downtime for the whole backend, not the sum of the server downtime.",
          "group": null,
          "included": false
        },
        "derive.error_connection": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `econ` metric -  Number of requests that encountered an error trying to connect to a backend server. The backend stat is the sum of the stat",
          "group": null,
          "included": true
        },
        "derive.error_request": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `ereq` metric -  Request errors.",
          "group": null,
          "included": true
        },
        "derive.error_response": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `eresp` metric -  Response errors. srv_abrt will be counted here also. Responses denied because of security concerns.",
          "group": null,
          "included": true
        },
        "derive.failed_checks": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `chkfail` metric -  Number of failed checks. (Only counts checks failed when the server is up.)",
          "group": null,
          "included": false
        },
        "derive.redispatched": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `wredis` metric -  Number of times a request was redispatched to another server. The server value counts the number of times that server was",
          "group": null,
          "included": true
        },
        "derive.request_total": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `req_tot` metric -  Total number of HTTP requests received",
          "group": null,
          "included": false
        },
        "derive.requests": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumReq` metric.",
          "group": null,
          "included": true
        },
        "derive.response_1xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_1xx` metric -  Http responses with 1xx code",
          "group": null,
          "included": false
        },
        "derive.response_2xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_2xx` metric -  Http responses with 2xx code",
          "group": null,
          "included": true
        },
        "derive.response_3xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_3xx` metric -  Http responses with 3xx code",
          "group": null,
          "included": false
        },
        "derive.response_4xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_4xx` metric -  Http responses with 4xx code",
          "group": null,
          "included": true
        },
        "derive.response_5xx": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_5xx` metric -  Http responses with 5xx code",
          "group": null,
          "included": true
        },
        "derive.response_other": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `hrsp_other` metric -  Http responses with other codes (protocol error)",
          "group": null,
          "included": false
        },
        "derive.retries": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `wretr` metric -  Number of times a connection to a server was retried.",
          "group": null,
          "included": true
        },
        "derive.session_total": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `stot` metric -  Cumulative number of connections",
          "group": null,
          "included": false
        },
        "derive.srv_abrt": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `srv_abrt` metric -  Number of data transfers aborted by the server (inc. in eresp)",
          "group": null,
          "included": false
        },
        "derive.ssl_cache_lookups": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `SslCacheLookups` metric.",
          "group": null,
          "included": false
        },
        "derive.ssl_cache_misses": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `SslCacheMisses` metric.",
          "group": null,
          "included": false
        },
        "derive.ssl_connections": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `CumSslConns` metric.",
          "group": null,
          "included": false
        },
        "derive.uptime_seconds": {
          "type": "cumulative",
          "description": "Corresponds to HAProxy's `Uptime_sec` metric.",
          "group": null,
          "included": false
        },
        "gauge.active_servers": {
          "type": "gauge",
          "description": "Number of active servers. This corresponds to HAProxy's \"act\" metric.",
          "group": null,
          "included": false
        },
        "gauge.backup_servers": {
          "type": "gauge",
          "description": "Number of backup servers. This corresponds to HAProxy's \"bck\" metric.",
          "group": null,
          "included": false
        },
        "gauge.check_duration": {
          "type": "gauge",
          "description": "Time in ms took to finish to last health check. This corresponds to HAProxy's \"check_duration\" metric.",
          "group": null,
          "included": false
        },
        "gauge.connection_rate": {
          "type": "gauge",
          "description": "Number of connections over the last elapsed second (frontend). This corresponds to HAProxy's \"conn_rate\" metric.",
          "group": null,
          "included": true
        },
        "gauge.connection_rate_max": {
          "type": "gauge",
          "description": "Highest known connection rate. This corresponds to HAProxy's \"conn_rate_max\" metric.",
          "group": null,
          "included": false
        },
        "gauge.current_connections": {
          "type": "gauge",
          "description": "Current number of connections. Corresponds to HAProxy's `CurrConns` metric.",
          "group": null,
          "included": false
        },
        "gauge.current_ssl_connections": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `CurrSslConns` metric.",
          "group": null,
          "included": false
        },
        "gauge.denied_tcp_connections": {
          "type": "gauge",
          "description": "Requests denied by 'tcp-request connection' rules. This corresponds to HAProxy's \"dcon\" metric.",
          "group": null,
          "included": false
        },
        "gauge.denied_tcp_sessions": {
          "type": "gauge",
          "description": "Requests denied by 'tcp-request session' rules. This corresponds to HAProxy's \"dses\" metric.",
          "group": null,
          "included": false
        },
        "gauge.idle_pct": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's \"Idle_pct\" metric. Ratio of system polling time versus total time.",
          "group": null,
          "included": true
        },
        "gauge.intercepted_requests": {
          "type": "gauge",
          "description": "Cumulative number of intercepted requests, corresponds to HAProxys metric 'intercepted'",
          "group": null,
          "included": false
        },
        "gauge.last_session": {
          "type": "gauge",
          "description": "Number of seconds since last session was assigned to server/backend. This corresponds to HAProxy's \"lastsess\" metric.",
          "group": null,
          "included": false
        },
        "gauge.max_connection_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxConnRate` metric.",
          "group": null,
          "included": false
        },
        "gauge.max_connections": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxConn` metric.",
          "group": null,
          "included": false
        },
        "gauge.max_pipes": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxPipes` metric.",
          "group": null,
          "included": false
        },
        "gauge.max_session_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxSessRate` metric.",
          "group": null,
          "included": false
        },
        "gauge.max_ssl_connections": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `MaxSslConns` metric.",
          "group": null,
          "included": false
        },
        "gauge.pipes_free": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `PipesFree` metric.",
          "group": null,
          "included": false
        },
        "gauge.pipes_used": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `PipesUsed` metric.",
          "group": null,
          "included": false
        },
        "gauge.queue_current": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `qcur` metric -  Current queued requests. For the backend this reports the number queued without a server assigned.",
          "group": null,
          "included": true
        },
        "gauge.queue_limit": {
          "type": "gauge",
          "description": "Configured max queue for the server, 0 being no limit. Corresponds to HAProxy's \"qlimit\" metric.",
          "group": null,
          "included": false
        },
        "gauge.queue_max": {
          "type": "gauge",
          "description": "Max number of queued requests, queue_current, corresponds to HAProxy's 'qmax' metric.",
          "group": null,
          "included": false
        },
        "gauge.queue_time_avg": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gauge.request_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `req_rate` metric -  HTTP requests per second over last elapsed second",
          "group": null,
          "included": true
        },
        "gauge.request_rate_max": {
          "type": "gauge",
          "description": "Max number of HTTP requests per second observed. Corresponds to HAProxy's \"req_rate_max\" metric.",
          "group": null,
          "included": false
        },
        "gauge.response_time_avg": {
          "type": "gauge",
          "description": "Average total session time in ms over the last 1024 requests. Corresponds to HAProxy's \"ttime\" metric.",
          "group": null,
          "included": false
        },
        "gauge.run_queue": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `Run_queue` metric.",
          "group": null,
          "included": false
        },
        "gauge.session_current": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `scur` metric -  Current sessions",
          "group": null,
          "included": true
        },
        "gauge.session_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `rate` metric -  Number of sessions per second over last elapsed second",
          "group": null,
          "included": true
        },
        "gauge.session_rate_all": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gauge.session_rate_limit": {
          "type": "gauge",
          "description": "Configured limit on number of new sessions per second. Corresponds to HAProxy's \"rate_lim\" metric.",
          "group": null,
          "included": false
        },
        "gauge.session_rate_max": {
          "type": "gauge",
          "description": "Max number of new sessions per second",
          "group": null,
          "included": false
        },
        "gauge.session_time_average": {
          "type": "gauge",
          "description": "Average total session time in ms over the last 1024 requests. Corresponds to HAProxy's \"ttime\" metric.",
          "group": null,
          "included": false
        },
        "gauge.session_time_avg": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gauge.ssl_backend_key_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslBackendKeyRate` metric.",
          "group": null,
          "included": false
        },
        "gauge.ssl_frontend_key_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslFrontendKeyRate` metric.",
          "group": null,
          "included": false
        },
        "gauge.ssl_rate": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `SslRate` metric.",
          "group": null,
          "included": false
        },
        "gauge.tasks": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `Tasks` metric.",
          "group": null,
          "included": false
        },
        "gauge.throttle": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `throttle` metric -  Current throttle percentage for the server, when slowstart is active, or no value if not in slowstart.",
          "group": null,
          "included": false
        },
        "gauge.zlib_mem_usage": {
          "type": "gauge",
          "description": "Corresponds to HAProxy's `ZlibMemUsage` metric.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/haproxy",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "proxiesToMonitor",
            "doc": "",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedMetrics",
            "doc": "Deprecated.  Please use `datapointsToExclude` on the monitor config block instead.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/health-checker",
      "sendAll": true,
      "dimensions": null,
      "doc": "A simple Collectd Python-based monitor\nthat hits an endpoint and checks if the configured JSON value is returned in\nthe response body.\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/healthchecker",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "path",
            "doc": "The HTTP path that contains a JSON document to verify",
            "default": "/",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "jsonKey",
            "doc": "If `jsonKey` and `jsonVal` are given, the given endpoint will be interpreted as a JSON document and will be expected to contain the given key and value for the service to be considered healthy.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "jsonVal",
            "doc": "This can be either a string or numeric type",
            "default": null,
            "required": false,
            "type": "interface",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the endpoint will be connected to on HTTPS instead of plain HTTP.  It is invalid to specify this if `tcpCheck` is true.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipSecurity",
            "doc": "If true, and `useHTTPS` is true, the server's SSL/TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "tcpCheck",
            "doc": "If true, the plugin will verify that it can connect to the given host/port value. JSON checking is not supported.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/interface",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collectd stats about network interfaces on the\nsystem by using the [collectd interface\nplugin](https://collectd.org/wiki/index.php/Plugin:Interface).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-interface)\nfor more information.\n",
      "groups": null,
      "metrics": {
        "if_dropped.rx": {
          "type": "cumulative",
          "description": "Count of received packets dropped by the interface",
          "group": null,
          "included": false
        },
        "if_dropped.tx": {
          "type": "cumulative",
          "description": "Count of transmitted packets dropped by the interface",
          "group": null,
          "included": false
        },
        "if_errors.rx": {
          "type": "cumulative",
          "description": "Count of receive errors on the interface",
          "group": null,
          "included": true
        },
        "if_errors.tx": {
          "type": "cumulative",
          "description": "Count of transmit errors on the interface",
          "group": null,
          "included": true
        },
        "if_octets.rx": {
          "type": "cumulative",
          "description": "Count of bytes (octets) received on the interface",
          "group": null,
          "included": true
        },
        "if_octets.tx": {
          "type": "cumulative",
          "description": "Count of bytes (octets) transmitted by the interface",
          "group": null,
          "included": true
        },
        "if_packets.rx": {
          "type": "cumulative",
          "description": "Count of packets received on the interface",
          "group": null,
          "included": false
        },
        "if_packets.tx": {
          "type": "cumulative",
          "description": "Count of packets transmitted by the interface",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/netinterface",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/jenkins",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors jenkins by using the\n[jenkins collectd Python\nplugin](https://github.com/signalfx/collectd-jenkins), which collects\nmetrics from jenkins instances\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n```\n\nSample YAML configuration with specific enhanced metrics included\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n  includeMetrics:\n  - \"vm.daemon.count\"\n  - \"vm.terminated.count\"\n```\n\nSample YAML configuration with all enhanced metrics included\n\n```yaml\nmonitors:\n- type: collectd/jenkins\n  host: 127.0.0.1\n  port: 8080\n  metricsKey: reallylongmetricskey\n  enhancedMetrics: true\n```\n",
      "groups": null,
      "metrics": {
        "gauge.jenkins.job.duration": {
          "type": "gauge",
          "description": "Time taken to complete the job in ms.",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.executor.count.value": {
          "type": "gauge",
          "description": "Total Number of executors in an instance",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.executor.in-use.value": {
          "type": "gauge",
          "description": "Total number of executors being used in an instance",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.health-check.score": {
          "type": "gauge",
          "description": "Mean health score of an instance",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.health.disk.space": {
          "type": "gauge",
          "description": "Binary value of disk space health",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.health.plugins": {
          "type": "gauge",
          "description": "Boolean value indicating state of plugins",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.health.temporary.space": {
          "type": "gauge",
          "description": "Binary value of temporary space health",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.health.thread-deadlock": {
          "type": "gauge",
          "description": "Boolean value indicating a deadlock",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.online.status": {
          "type": "gauge",
          "description": "Boolean value of instance is reachable or not",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.queue.size.value": {
          "type": "gauge",
          "description": "Total number pending jobs in queue",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.slave.online.status": {
          "type": "gauge",
          "description": "Boolean value for slave is reachable or not",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.vm.memory.heap.usage": {
          "type": "gauge",
          "description": "Percent utilization of the heap memory",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.vm.memory.non-heap.used": {
          "type": "gauge",
          "description": "Total amount of non-heap memory used",
          "group": null,
          "included": true
        },
        "gauge.jenkins.node.vm.memory.total.used": {
          "type": "gauge",
          "description": "Total Memory used by instance",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/jenkins",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "metricsKey",
            "doc": "Key required for collecting metrics.  The access key located at `Manage Jenkins \u003e Configure System \u003e Metrics \u003e ADD.` If empty, click `Generate`.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "Whether to enable enhanced metrics",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "includeMetrics",
            "doc": "Used to enable individual enhanced metrics when `enhancedMetrics` is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "username",
            "doc": "User with security access to jenkins",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "apiToken",
            "doc": "API Token of the user",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslKeyFile",
            "doc": "Path to the keyfile",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslCertificate",
            "doc": "Path to the certificate",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sslCACerts",
            "doc": "Path to the ca file",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/kafka",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Kafka instance using collectd's\nGenericJMX plugin.\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/kafka/mbeans.go)\nfor which it pulls metrics from Kafka's JMX endpoint.\n\nNote that this monitor supports Kafka v0.8.2.x and above. For Kafka v1.x.x and above,\napart from the list of default metrics, kafka.server:type=ZooKeeperClientMetrics,name=ZooKeeperRequestLatencyMs\nis a good metric to monitor since it gives an understanding of how long brokers wait for\nrequests to Zookeeper to be completed. Since Zookeeper is an integral part of a Kafka cluster,\nmonitoring it using the [Zookeeper\nmonitor] (https://docs.signalfx.com/en/latest/integrations/agent/monitors/collectd-zookeeper.html)\nis recommended. It is also a good idea to monitor disk utilization and network metrics of\nthe underlying host.\n\nSee https://github.com/signalfx/integrations/tree/master/collectd-kafka.\n",
      "groups": null,
      "metrics": {
        "counter.kafka-bytes-in": {
          "type": "cumulative",
          "description": "Number of bytes received per second across all topics",
          "group": null,
          "included": true
        },
        "counter.kafka-bytes-out": {
          "type": "cumulative",
          "description": "Number of bytes transmitted per second across all topics",
          "group": null,
          "included": true
        },
        "counter.kafka-isr-expands": {
          "type": "cumulative",
          "description": "When a broker is brought up after a failure, it starts catching up by reading from the leader. Once it is caught up, it gets added back to the ISR.",
          "group": null,
          "included": true
        },
        "counter.kafka-isr-shrinks": {
          "type": "cumulative",
          "description": "When a broker goes down, ISR for some of partitions will shrink. When that broker is up again, ISR will be expanded once the replicas are fully caught up. Other than that, the expected value for both ISR shrink rate and expansion rate is 0.",
          "group": null,
          "included": true
        },
        "counter.kafka-leader-election-rate": {
          "type": "cumulative",
          "description": "Number of leader elections",
          "group": null,
          "included": false
        },
        "counter.kafka-messages-in": {
          "type": "cumulative",
          "description": "Number of messages received per second across all topics",
          "group": null,
          "included": true
        },
        "counter.kafka-unclean-elections-rate": {
          "type": "cumulative",
          "description": "Number of unclean leader elections. This happens when a leader goes down and an out-of-sync replica is chosen to be the leader",
          "group": null,
          "included": true
        },
        "counter.kafka.fetch-consumer.total-time.count": {
          "type": "cumulative",
          "description": "Number of fetch requests from consumers per second across all partitions",
          "group": null,
          "included": true
        },
        "counter.kafka.fetch-follower.total-time.count": {
          "type": "cumulative",
          "description": "Number of fetch requests from followers per second across all partitions",
          "group": null,
          "included": false
        },
        "counter.kafka.logs.flush-time.count": {
          "type": "cumulative",
          "description": "Number of log flushes",
          "group": null,
          "included": false
        },
        "counter.kafka.produce.total-time.count": {
          "type": "cumulative",
          "description": "Number of producer requests",
          "group": null,
          "included": true
        },
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "included": true
        },
        "gauge.kafka-active-controllers": {
          "type": "gauge",
          "description": "Specifies if the broker an active controller",
          "group": null,
          "included": true
        },
        "gauge.kafka-max-lag": {
          "type": "gauge",
          "description": "Maximum lag in messages between the follower and leader replicas",
          "group": null,
          "included": true
        },
        "gauge.kafka-offline-partitions-count": {
          "type": "gauge",
          "description": "Number of partitions that don’t have an active leader and are hence not writable or readable",
          "group": null,
          "included": true
        },
        "gauge.kafka-request-queue": {
          "type": "gauge",
          "description": "Number of requests in the request queue across all partitions on the broker",
          "group": null,
          "included": true
        },
        "gauge.kafka-underreplicated-partitions": {
          "type": "gauge",
          "description": "Number of underreplicated partitions across all topics on the broker",
          "group": null,
          "included": true
        },
        "gauge.kafka.fetch-consumer.total-time.99th": {
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process fetch requests from consumers",
          "group": null,
          "included": true
        },
        "gauge.kafka.fetch-consumer.total-time.median": {
          "type": "gauge",
          "description": "Median time it takes to process a fetch request from consumers",
          "group": null,
          "included": true
        },
        "gauge.kafka.fetch-follower.total-time.99th": {
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process fetch requests from followers",
          "group": null,
          "included": true
        },
        "gauge.kafka.fetch-follower.total-time.median": {
          "type": "gauge",
          "description": "Median time it takes to process a fetch request from follower",
          "group": null,
          "included": true
        },
        "gauge.kafka.logs.flush-time.99th": {
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to flush logs",
          "group": null,
          "included": false
        },
        "gauge.kafka.logs.flush-time.median": {
          "type": "gauge",
          "description": "Median time it takes to flush logs",
          "group": null,
          "included": false
        },
        "gauge.kafka.produce.total-time.99th": {
          "type": "gauge",
          "description": "99th percentile of time in milliseconds to process produce requests",
          "group": null,
          "included": true
        },
        "gauge.kafka.produce.total-time.median": {
          "type": "gauge",
          "description": "Median time it takes to process a produce request",
          "group": null,
          "included": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "included": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "included": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/kafka",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "internal/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "internal/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          },
          {
            "yamlName": "clusterName",
            "doc": "Cluster name to which the broker belongs",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/kafka_consumer",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Java based Kafka consumer using GenericJMX.\n\nSee the [integration documentation](https://github.com/signalfx/integrations/tree/master/collectd-kafka)\nfor more information.\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/kafkaconsumer/mbeans.go)\nfor which it pulls metrics from the Kafka consumer's JMX endpoint.\n\nSample YAML configuration:\n```yaml\nmonitors:\n  - type: collectd/kafka_consumer\n    host: localhost\n    port: 9099\n    mBeansToOmit:\n      - fetch-size-avg-per-topic\n```\n\nNote that this monitor requires Kafka v0.9.0.0 or above and collects metrics from the new consumer API.\nAlso, per-topic metrics that are collected by default are not available through the new consumer API in\nv0.9.0.0 which can cause the logs to flood with warnings related to the MBean not being found.\nUse the `mBeansToOmit` config option in such cases. The above example configuration will not attempt to\ncollect the MBean referenced by `fetch-size-avg-per-topic`. Here is a\n[list](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/kafkaconsumer/mbeans.go)\nof metrics collected by default\n",
      "groups": null,
      "metrics": {
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "included": true
        },
        "gauge.kafka.consumer.bytes-consumed-rate": {
          "type": "gauge",
          "description": "Average number of bytes consumed per second. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter.",
          "group": null,
          "included": true
        },
        "gauge.kafka.consumer.fetch-rate": {
          "type": "gauge",
          "description": "Number of records consumed per second.",
          "group": null,
          "included": true
        },
        "gauge.kafka.consumer.fetch-size-avg": {
          "type": "gauge",
          "description": "Average number of bytes fetched per request. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter.",
          "group": null,
          "included": true
        },
        "gauge.kafka.consumer.records-consumed-rate": {
          "type": "gauge",
          "description": "Average number of records consumed per second. This metric has either client-id dimension or, both client-id and topic dimensions. The former is an aggregate across all topics of the latter.",
          "group": null,
          "included": true
        },
        "gauge.kafka.consumer.records-lag-max": {
          "type": "gauge",
          "description": "Maximum lag in of records for any partition in this window. An increasing value over time is your best indication that the consumer group is not keeping up with the producers.",
          "group": null,
          "included": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "included": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "included": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "internal/monitors/collectd/kafkaconsumer",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "internal/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "internal/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/kafka_producer",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Java based Kafka producer using GenericJMX.\n\nSee the [integration documentation](https://github.com/signalfx/integrations/tree/master/collectd-kafka)\nfor more information.\n\nThis monitor has a set of [built in MBeans\nconfigured](https://github.com/signalfx/signalfx-agent/tree/master/internal/monitors/collectd/kafkaproducer/mbeans.go)\nfor which it pulls metrics from the Kafka producer's JMX endpoint.\n\nSample YAML configuration:\n```yaml\nmonitors:\n  - type: collectd/kafka_producer\n    host: localhost\n    port: 8099\n```\n\nNote that this monitor requires Kafka v0.9.0.0 or above and collects metrics from the new producer API.\n",
      "groups": null,
      "metrics": {
        "gauge.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of JVM threads",
          "group": "jvm",
          "included": true
        },
        "gauge.kafka.producer.byte-rate": {
          "type": "gauge",
          "description": "Average number of bytes sent per second for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.compression-rate": {
          "type": "gauge",
          "description": "Average compression rate of record batches for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.io-wait-time-ns-avg": {
          "type": "gauge",
          "description": "Average length of time the I/O thread spent waiting for a socket ready for reads or writes in nanoseconds. This metric has client-id dimension.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.outgoing-byte-rate": {
          "type": "gauge",
          "description": "Average number of outgoing bytes sent per second to all servers. This metric has client-id dimension.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.record-error-rate": {
          "type": "gauge",
          "description": "Average per-second number of record sends that resulted in errors for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.record-retry-rate": {
          "type": "gauge",
          "description": "Average per-second number of retried record sends for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.record-send-rate": {
          "type": "gauge",
          "description": "Average number of records sent per second for a topic. This metric has client-id and topic dimensions.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.request-latency-avg": {
          "type": "gauge",
          "description": "Average request latency in ms. Time it takes on average for the producer to get responses from the broker. This metric has client-id dimension.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.request-rate": {
          "type": "gauge",
          "description": "Average number of requests sent per second. This metric has client-id dimension.",
          "group": null,
          "included": true
        },
        "gauge.kafka.producer.response-rate": {
          "type": "gauge",
          "description": "Average number of responses received per second. This metric has client-id dimension.",
          "group": null,
          "included": true
        },
        "gauge.loaded_classes": {
          "type": "gauge",
          "description": "Number of classes loaded in the JVM",
          "group": "jvm",
          "included": true
        },
        "invocations": {
          "type": "cumulative",
          "description": "Total number of garbage collection events",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.committed": {
          "type": "gauge",
          "description": "Amount of memory guaranteed to be available in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.init": {
          "type": "gauge",
          "description": "Amount of initial memory at startup in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.max": {
          "type": "gauge",
          "description": "Maximum amount of memory that can be used in bytes",
          "group": "jvm",
          "included": true
        },
        "jmx_memory.used": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": "jvm",
          "included": true
        },
        "total_time_in_ms.collection_time": {
          "type": "cumulative",
          "description": "Amount of time spent garbage collecting in milliseconds",
          "group": "jvm",
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config has configuration that is specific to GenericJMX. This config should be used by a monitors that use the generic JMX collectd plugin.",
        "package": "internal/monitors/collectd/kafkaproducer",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host to connect to -- JMX must be configured for remote access and accessible from the agent",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "JMX connection port (NOT the RMI port) on the application.  This correponds to the `com.sun.management.jmxremote.port` Java property that should be set on the JVM when running the application.",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceName",
            "doc": "This is how the service type is identified in the SignalFx UI so that you can get built-in content for it.  For custom JMX integrations, it can be set to whatever you like and metrics will get the special property `sf_hostHasService` set to this value.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceURL",
            "doc": "The JMX connection string.  This is rendered as a Go template and has access to the other values in this config. NOTE: under normal circumstances it is not advised to set this string directly - setting the host and port as specified above is preferred.",
            "default": "service:jmx:rmi:///jndi/rmi://{{.Host}}:{{.Port}}/jmxrmi",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "instancePrefix",
            "doc": "Prefixes the generated plugin instance with prefix. If a second `instancePrefix` is specified in a referenced MBean block, the prefix specified in the Connection block will appear at the beginning of the plugin instance, and the prefix specified in the MBean block will be appended to it",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "User password to authenticate to the server",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customDimensions",
            "doc": "Takes in key-values pairs of custom dimensions at the connection level.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToCollect",
            "doc": "A list of the MBeans defined in `mBeanDefinitions` to actually collect. If not provided, then all defined MBeans will be collected.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeansToOmit",
            "doc": "A list of the MBeans to omit. This will come handy in cases where only a few MBeans need to omitted from the default list",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mBeanDefinitions",
            "doc": "Specifies how to map JMX MBean values to metrics.  If using a specific service monitor such as cassandra, kafka, or activemq, they come pre-loaded with a set of mappings, and any that you add in this option will be merged with those.  See [collectd GenericJMX](https://collectd.org/documentation/manpages/collectd-java.5.shtml#genericjmx_plugin) for more details.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MBean",
              "doc": "MBean represents the \u003cMBean\u003e config object in the collectd config for generic jmx.",
              "package": "internal/monitors/collectd/genericjmx",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "Sets the pattern which is used to retrieve MBeans from the MBeanServer. If more than one MBean is returned you should use the `instanceFrom` option to make the identifiers unique",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instancePrefix",
                  "doc": "Prefixes the generated plugin instance with prefix",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "instanceFrom",
                  "doc": "The object names used by JMX to identify MBeans include so called \"properties\" which are basically key-value-pairs. If the given object name is not unique and multiple MBeans are returned, the values of those properties usually differ. You can use this option to build the plugin instance from the appropriate property values. This option is optional and may be repeated to generate the plugin instance from multiple property values",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "values",
                  "doc": "The `value` blocks map one or more attributes of an MBean to a value list in collectd. There must be at least one `value` block within each MBean block",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "MBeanValue",
                    "doc": "MBeanValue specifies a particular value to pull from the MBean.",
                    "package": "internal/monitors/collectd/genericjmx",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Sets the data set used within collectd to handle the values of the MBean attribute",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "table",
                        "doc": "Set this to true if the returned attribute is a composite type. If set to true, the keys within the composite type is appended to the type instance.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instanceFrom",
                        "doc": "Works like the option of the same name directly beneath the MBean block, but sets the type instance instead",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "attribute",
                        "doc": "Sets the name of the attribute from which to read the value. You can access the keys of composite types by using a dot to concatenate the key name to the attribute name. For example: “attrib0.key42”. If `table` is set to true, path must point to a composite type, otherwise it must point to a numeric type.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "dimensions",
                  "doc": "",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/kong",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Kong instance using [collectd-kong](https://github.com/signalfx/collectd-kong).\n\nSee the [integration documentation](https://github.com/signalfx/integrations/tree/master/collectd-kong)\nfor more information.\n\nThe `metrics` field below is populated with a set of metrics that are\ndescribed at https://github.com/signalfx/collectd-kong/blob/master/README.md.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n  - type: collectd/kong\n    host: 127.0.0.1\n    port: 8001\n    metrics:\n      - metric: request_latency\n        report: true\n      - metric: connections_accepted\n        report: false\n```\n\nSample YAML configuration with custom /signalfx route and white and blacklists\n\n```yaml\nmonitors:\n  - type: collectd/kong\n    host: 127.0.0.1\n    port: 8443\n    url: https://127.0.0.1:8443/routed_signalfx\n    authHeader:\n      header: Authorization\n      value: HeaderValue\n    metrics:\n      - metric: request_latency\n        report: true\n    reportStatusCodeGroups: true\n    statusCodes:\n      - 202\n      - 403\n      - 405\n      - 419\n      - \"5*\"\n    serviceNamesBlacklist:\n      - \"*SomeService*\"\n```\n",
      "groups": null,
      "metrics": {
        "counter.kong.connections.accepted": {
          "type": "cumulative",
          "description": "Total number of all accepted connections.",
          "group": null,
          "included": false
        },
        "counter.kong.connections.handled": {
          "type": "cumulative",
          "description": "Total number of all handled connections (accounting for resource limits).",
          "group": null,
          "included": false
        },
        "counter.kong.kong.latency": {
          "type": "cumulative",
          "description": "Time spent in Kong request handling and balancer (ms).",
          "group": null,
          "included": true
        },
        "counter.kong.requests.count": {
          "type": "cumulative",
          "description": "Total number of all requests made to Kong API and proxy server.",
          "group": null,
          "included": true
        },
        "counter.kong.requests.latency": {
          "type": "cumulative",
          "description": "Time elapsed between the first bytes being read from each client request and the log writes after the last bytes were sent to the clients (ms).",
          "group": null,
          "included": true
        },
        "counter.kong.requests.size": {
          "type": "cumulative",
          "description": "Total bytes received/proxied from client requests.",
          "group": null,
          "included": true
        },
        "counter.kong.responses.count": {
          "type": "cumulative",
          "description": "Total number of responses provided to clients.",
          "group": null,
          "included": true
        },
        "counter.kong.responses.size": {
          "type": "cumulative",
          "description": "Total bytes sent/proxied to clients.",
          "group": null,
          "included": true
        },
        "counter.kong.upstream.latency": {
          "type": "cumulative",
          "description": "Time spent waiting for upstream response (ms).",
          "group": null,
          "included": true
        },
        "gauge.kong.connections.active": {
          "type": "gauge",
          "description": "The current number of active client connections (includes waiting).",
          "group": null,
          "included": true
        },
        "gauge.kong.connections.reading": {
          "type": "gauge",
          "description": "The current number of connections where nginx is reading the request header.",
          "group": null,
          "included": true
        },
        "gauge.kong.connections.waiting": {
          "type": "gauge",
          "description": "The current number of idle client connections waiting for a request.",
          "group": null,
          "included": true
        },
        "gauge.kong.connections.writing": {
          "type": "gauge",
          "description": "The current number of connections where nginx is writing the response back to the client.",
          "group": null,
          "included": true
        },
        "gauge.kong.database.reachable": {
          "type": "gauge",
          "description": "kong.dao:db.reachable() at time of metric query",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/kong",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Kong host to connect with (used for autodiscovery and URL)",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port for kong-plugin-signalfx hosting server (used for autodiscovery and URL)",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "Registration name when using multiple instances in Smart Agent",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "url",
            "doc": "kong-plugin-signalfx metric plugin",
            "default": "http://{{.Host}}:{{.Port}}/signalfx",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "authHeader",
            "doc": "Header and its value to use for requests to SFx metric endpoint",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "Header",
              "doc": "Header defines name/value pair for AuthHeader option",
              "package": "internal/monitors/collectd/kong",
              "fields": [
                {
                  "yamlName": "header",
                  "doc": "Name of header to include with GET",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "value",
                  "doc": "Value of header",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "verifyCerts",
            "doc": "Whether to verify certificates when using ssl/tls",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caBundle",
            "doc": "CA Bundle file or directory",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCert",
            "doc": "Client certificate file (with or without included key)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "clientCertKey",
            "doc": "Client cert key if not bundled with clientCert",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "verbose",
            "doc": "Whether to use debug logging for collectd-kong",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metrics",
            "doc": "List of metric names and report flags. See monitor description for more details.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Metric",
              "doc": "Metric is for use with `Metric \"metric_name\" bool` collectd plugin format",
              "package": "internal/monitors/collectd/kong",
              "fields": [
                {
                  "yamlName": "metric",
                  "doc": "Name of metric, per collectd-kong",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "report",
                  "doc": "Whether to report this metric",
                  "default": null,
                  "required": true,
                  "type": "bool",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "reportApiIds",
            "doc": "Report metrics for distinct API IDs where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportApiNames",
            "doc": "Report metrics for distinct API names where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportServiceIds",
            "doc": "Report metrics for distinct Service IDs where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportServiceNames",
            "doc": "Report metrics for distinct Service names where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportRouteIds",
            "doc": "Report metrics for distinct Route IDs where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportHttpMethods",
            "doc": "Report metrics for distinct HTTP methods where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportStatusCodeGroups",
            "doc": "Report metrics for distinct HTTP status code groups (eg. \"5xx\") where applicable",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportStatusCodes",
            "doc": "Report metrics for distinct HTTP status codes where applicable (mutually exclusive with ReportStatusCodeGroups)",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "apiIds",
            "doc": "List of API ID patterns to report distinct metrics for, if reportApiIds is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "apiIdsBlacklist",
            "doc": "List of API ID patterns to not report distinct metrics for, if reportApiIds is true or apiIds are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "apiNames",
            "doc": "List of API name patterns to report distinct metrics for, if reportApiNames is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "apiNamesBlacklist",
            "doc": "List of API name patterns to not report distinct metrics for, if reportApiNames is true or apiNames are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "serviceIds",
            "doc": "List of Service ID patterns to report distinct metrics for, if reportServiceIds is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "serviceIdsBlacklist",
            "doc": "List of Service ID patterns to not report distinct metrics for, if reportServiceIds is true or serviceIds are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "serviceNames",
            "doc": "List of Service name patterns to report distinct metrics for, if reportServiceNames is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "serviceNamesBlacklist",
            "doc": "List of Service name patterns to not report distinct metrics for, if reportServiceNames is true or serviceNames are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "routeIds",
            "doc": "List of Route ID patterns to report distinct metrics for, if reportRouteIds is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "routeIdsBlacklist",
            "doc": "List of Route ID patterns to not report distinct metrics for, if reportRouteIds is true or routeIds are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "httpMethods",
            "doc": "List of HTTP method patterns to report distinct metrics for, if reportHttpMethods is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "httpMethodsBlacklist",
            "doc": "List of HTTP method patterns to not report distinct metrics for, if reportHttpMethods is true or httpMethods are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "statusCodes",
            "doc": "List of HTTP status code patterns to report distinct metrics for, if reportStatusCodes is false",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "statusCodesBlacklist",
            "doc": "List of HTTP status code patterns to not report distinct metrics for, if reportStatusCodes is true or statusCodes are specified",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/load",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors process load on the host using the collectd\n[Load plugin](https://collectd.org/wiki/index.php/Plugin:Load).\n",
      "groups": null,
      "metrics": {
        "load.longterm": {
          "type": "gauge",
          "description": "Average CPU load per core over the last 15 minutes",
          "group": null,
          "included": true
        },
        "load.midterm": {
          "type": "gauge",
          "description": "Average CPU load per core over the last five minutes",
          "group": null,
          "included": true
        },
        "load.shortterm": {
          "type": "gauge",
          "description": "Average CPU load per core over the last one minute",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/load",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/marathon",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a Mesos Marathon instance using the\n[collectd Marathon Python plugin](https://github.com/signalfx/collectd-marathon).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-marathon)\nfor more information on configuration.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n  - type: collectd/marathon\n    host: 127.0.0.1\n    port: 8080\n    scheme: http\n```\n\nSample YAML configuration for DC/OS:\n\n```yaml\nmonitors:\n  - type: collectd/marathon\n    host: 127.0.0.1\n    port: 8080\n    scheme: https\n    dcosAuthURL: https://leader.mesos/acs/api/v1/auth/login\n```\n",
      "groups": null,
      "metrics": {
        "gauge.marathon-api-metric": {
          "type": "gauge",
          "description": "Metrics reported by the Marathon Metrics API",
          "group": null,
          "included": false
        },
        "gauge.marathon.app.cpu.allocated": {
          "type": "gauge",
          "description": "Number of CPUs allocated to an application",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.cpu.allocated.per.instance": {
          "type": "gauge",
          "description": "Configured number of CPUs allocated to each application instance",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.delayed": {
          "type": "gauge",
          "description": "Indicates if the application is delayed or not",
          "group": null,
          "included": false
        },
        "gauge.marathon.app.deployments.total": {
          "type": "gauge",
          "description": "Number of application deployments",
          "group": null,
          "included": false
        },
        "gauge.marathon.app.disk.allocated": {
          "type": "gauge",
          "description": "Storage allocated to a Marathon application",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.disk.allocated.per.instance": {
          "type": "gauge",
          "description": "Configured storage allocated each to application instance",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.gpu.allocated": {
          "type": "gauge",
          "description": "GPU Allocated to a Marathon application",
          "group": null,
          "included": false
        },
        "gauge.marathon.app.gpu.allocated.per.instance": {
          "type": "gauge",
          "description": "Configured number of GPUs allocated to each application instance",
          "group": null,
          "included": false
        },
        "gauge.marathon.app.instances.total": {
          "type": "gauge",
          "description": "Number of application instances",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.memory.allocated": {
          "type": "gauge",
          "description": "Memory Allocated to a Marathon application",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.memory.allocated.per.instance": {
          "type": "gauge",
          "description": "Configured amount of memory allocated to each application instance",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.tasks.running": {
          "type": "gauge",
          "description": "Number tasks running for an application",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.tasks.staged": {
          "type": "gauge",
          "description": "Number tasks staged for an application",
          "group": null,
          "included": true
        },
        "gauge.marathon.app.tasks.unhealthy": {
          "type": "gauge",
          "description": "Number unhealthy tasks for an application",
          "group": null,
          "included": true
        },
        "gauge.marathon.task.healthchecks.failing.total": {
          "type": "gauge",
          "description": "The number of failing health checks for a task",
          "group": null,
          "included": true
        },
        "gauge.marathon.task.healthchecks.passing.total": {
          "type": "gauge",
          "description": "The number of passing health checks for a task",
          "group": null,
          "included": true
        },
        "gauge.marathon.task.staged.time.elapsed": {
          "type": "gauge",
          "description": "The amount of time the task spent in staging",
          "group": null,
          "included": false
        },
        "gauge.marathon.task.start.time.elapsed": {
          "type": "gauge",
          "description": "Time elapsed since the task started",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/marathon",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username used to authenticate with Marathon.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password used to authenticate with Marathon.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "scheme",
            "doc": "Set to either `http` or `https`.",
            "default": "http",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "dcosAuthURL",
            "doc": "The dcos authentication URL which the plugin uses to get authentication tokens from. Set scheme to \"https\" if operating DC/OS in strict mode and dcosAuthURL to \"https://leader.mesos/acs/api/v1/auth/login\" (which is the default DNS entry provided by DC/OS)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/memcached",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an instance of memcached using the\n[collectd memcached\nplugin](https://collectd.org/wiki/index.php/Plugin:memcached).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-memcached)\nfor more information.\n",
      "groups": null,
      "metrics": {
        "connections.opened": {
          "type": "cumulative",
          "description": "Number of connections opened since server began running",
          "group": null,
          "included": false
        },
        "df.cache.free": {
          "type": "gauge",
          "description": "Unused storage bytes",
          "group": null,
          "included": true
        },
        "df.cache.used": {
          "type": "gauge",
          "description": "Current number of bytes used to store items",
          "group": null,
          "included": true
        },
        "memcached_command.flush": {
          "type": "cumulative",
          "description": "Number of flush requests",
          "group": null,
          "included": false
        },
        "memcached_command.get": {
          "type": "cumulative",
          "description": "Number of retrieval requests",
          "group": null,
          "included": true
        },
        "memcached_command.set": {
          "type": "cumulative",
          "description": "Number of storage requests",
          "group": null,
          "included": true
        },
        "memcached_command.touch": {
          "type": "cumulative",
          "description": "Number of touch requests",
          "group": null,
          "included": false
        },
        "memcached_connections.current": {
          "type": "gauge",
          "description": "Current number of open connections",
          "group": null,
          "included": true
        },
        "memcached_items.current": {
          "type": "gauge",
          "description": "Current number of items stored by this instance",
          "group": null,
          "included": true
        },
        "memcached_octets.rx": {
          "type": "cumulative",
          "description": "Total network bytes read by this server",
          "group": null,
          "included": true
        },
        "memcached_octets.tx": {
          "type": "cumulative",
          "description": "Total network bytes written by this server",
          "group": null,
          "included": true
        },
        "memcached_ops.decr_hits": {
          "type": "cumulative",
          "description": "Number of successful Decr requests",
          "group": null,
          "included": false
        },
        "memcached_ops.decr_misses": {
          "type": "cumulative",
          "description": "Number of decr requests against missing keys",
          "group": null,
          "included": false
        },
        "memcached_ops.delete_hits": {
          "type": "cumulative",
          "description": "Number of successful delete requests",
          "group": null,
          "included": false
        },
        "memcached_ops.delete_misses": {
          "type": "cumulative",
          "description": "Number of delete requests against missing keys",
          "group": null,
          "included": false
        },
        "memcached_ops.evictions": {
          "type": "cumulative",
          "description": "Number of valid items removed from cache",
          "group": null,
          "included": true
        },
        "memcached_ops.hits": {
          "type": "cumulative",
          "description": "Number of keys that have been requested and found present",
          "group": null,
          "included": true
        },
        "memcached_ops.incr_hits": {
          "type": "cumulative",
          "description": "Number of successful incr requests",
          "group": null,
          "included": false
        },
        "memcached_ops.incr_misses": {
          "type": "cumulative",
          "description": "Number of incr requests against missing keys",
          "group": null,
          "included": false
        },
        "memcached_ops.misses": {
          "type": "cumulative",
          "description": "Number of items that have been requested and not found",
          "group": null,
          "included": true
        },
        "ps_count.threads": {
          "type": "gauge",
          "description": "Number of worker threads requested",
          "group": null,
          "included": false
        },
        "ps_cputime.syst": {
          "type": "cumulative",
          "description": "Total system time for this instance",
          "group": null,
          "included": false
        },
        "ps_cputime.user": {
          "type": "cumulative",
          "description": "Total user time for this instance",
          "group": null,
          "included": false
        },
        "total_events.listen_disabled": {
          "type": "cumulative",
          "description": "Number of times connection limit has been exceeded",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/memcached",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "reportHost",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/memory",
      "sendAll": false,
      "dimensions": null,
      "doc": "Sends memory usage stats for the underlying host.\nSee https://collectd.org/wiki/index.php/Plugin:Memory\n",
      "groups": null,
      "metrics": {
        "memory.buffered": {
          "type": "gauge",
          "description": "Bytes of memory used for buffering I/O",
          "group": null,
          "included": true
        },
        "memory.cached": {
          "type": "gauge",
          "description": "Bytes of memory used for disk caching",
          "group": null,
          "included": true
        },
        "memory.free": {
          "type": "gauge",
          "description": "Bytes of memory available for use",
          "group": null,
          "included": true
        },
        "memory.slab_recl": {
          "type": "gauge",
          "description": "Bytes of memory, used for SLAB-allocation of kernel objects, that can be reclaimed.",
          "group": null,
          "included": true
        },
        "memory.slab_unrecl": {
          "type": "gauge",
          "description": "Bytes of memory, used for SLAB-allocation of kernel objects, that can't be reclaimed",
          "group": null,
          "included": true
        },
        "memory.used": {
          "type": "gauge",
          "description": "Bytes of memory in use by the system.",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/memory",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/mongodb",
      "sendAll": false,
      "dimensions": {
        "plugin_instance": {
          "description": "Port number of the MongoDB instance"
        }
      },
      "doc": "Monitors an instance of MongoDB using the\n[collectd MongoDB Python plugin](https://github.com/signalfx/collectd-mongodb).\n\nAlso see https://github.com/signalfx/integrations/tree/master/collectd-mongodb.\n",
      "groups": null,
      "metrics": {
        "counter.asserts.regular": {
          "type": "cumulative",
          "description": "The number of regular assertions raised since the MongoDB process started. Check the log file for more information about these messages.",
          "group": null,
          "included": false
        },
        "counter.asserts.warning": {
          "type": "cumulative",
          "description": "In MongoDB 3.x and earlier, the field returns the number of warnings raised since the MongoDB process started.  In MongodDB 4, this is always 0.",
          "group": null,
          "included": false
        },
        "counter.backgroundFlushing.flushes": {
          "type": "gauge",
          "description": "Number of times the database has been flushed",
          "group": null,
          "included": true
        },
        "counter.collection.commandsCount": {
          "type": "counter",
          "description": "Number of commands issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.commandsTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing commands issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.getmoreCount": {
          "type": "counter",
          "description": "Number of getMore requests issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.getmoreTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing getMore requests for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.index.accesses.ops": {
          "type": "counter",
          "description": "Number of times an index has been used (only on Mongo 3.2+)",
          "group": "collection",
          "included": false
        },
        "counter.collection.insertCount": {
          "type": "counter",
          "description": "Number of inserts issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.insertTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing insert requests for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.queriesCount": {
          "type": "counter",
          "description": "Number of queries issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.queriesTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing query requests for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.readLockCount": {
          "type": "counter",
          "description": "Number of read locks issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.readLockTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing read locks for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.removeCount": {
          "type": "counter",
          "description": "Number of remove requests issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.removeTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing remove requests for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.totalCount": {
          "type": "counter",
          "description": "Total number of operations issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.totalTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing all operations for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.updateCount": {
          "type": "counter",
          "description": "Number of update requests issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.updateTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing update requests for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.writeLockCount": {
          "type": "counter",
          "description": "Number of write locks issued for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.collection.writeLockTime": {
          "type": "counter",
          "description": "Time spent in microseconds processing write locks for a collection",
          "group": "collection-top",
          "included": false
        },
        "counter.extra_info.page_faults": {
          "type": "gauge",
          "description": "Mongod page faults",
          "group": null,
          "included": true
        },
        "counter.lock.Database.acquireCount.intentExclusive": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "counter.lock.Database.acquireCount.intentShared": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "counter.lock.Database.acquireCount.read": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "counter.lock.Database.acquireCount.write": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "counter.lock.Global.acquireCount.intentExclusive": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "counter.lock.Global.acquireCount.intentShared": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "counter.lock.Global.acquireCount.write": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "counter.network.bytesIn": {
          "type": "gauge",
          "description": "Network bytes received by the database server",
          "group": null,
          "included": true
        },
        "counter.network.bytesOut": {
          "type": "gauge",
          "description": "Network bytes sent by the database server",
          "group": null,
          "included": true
        },
        "counter.network.numRequests": {
          "type": "cumulative",
          "description": "Requests received by the server",
          "group": null,
          "included": true
        },
        "counter.opcounters.command": {
          "type": "cumulative",
          "description": "Number of commands since last restart",
          "group": null,
          "included": false
        },
        "counter.opcounters.delete": {
          "type": "cumulative",
          "description": "Number of deletes since last restart",
          "group": null,
          "included": true
        },
        "counter.opcounters.getmore": {
          "type": "cumulative",
          "description": "Number of getmore operations since last restart",
          "group": null,
          "included": false
        },
        "counter.opcounters.insert": {
          "type": "cumulative",
          "description": "Number of inserts since last restart",
          "group": null,
          "included": true
        },
        "counter.opcounters.query": {
          "type": "cumulative",
          "description": "Number of queries since last restart",
          "group": null,
          "included": true
        },
        "counter.opcounters.update": {
          "type": "cumulative",
          "description": "Number of updates since last restart",
          "group": null,
          "included": true
        },
        "counter.opcountersRepl.command": {
          "type": "cumulative",
          "description": "Number of replicated commands since last restart",
          "group": null,
          "included": false
        },
        "counter.opcountersRepl.delete": {
          "type": "cumulative",
          "description": "Number of replicated deletes since last restart",
          "group": null,
          "included": false
        },
        "counter.opcountersRepl.getmore": {
          "type": "cumulative",
          "description": "Number of replicated getmore operations since last restart",
          "group": null,
          "included": false
        },
        "counter.opcountersRepl.insert": {
          "type": "cumulative",
          "description": "Number of replicated inserts since last restart",
          "group": null,
          "included": false
        },
        "counter.opcountersRepl.query": {
          "type": "cumulative",
          "description": "Number of replicated queries since last restart",
          "group": null,
          "included": false
        },
        "counter.opcountersRepl.update": {
          "type": "cumulative",
          "description": "Number of replicated updates since last restart",
          "group": null,
          "included": false
        },
        "gauge.backgroundFlushing.average_ms": {
          "type": "gauge",
          "description": "Average time (ms) to write data to disk",
          "group": null,
          "included": true
        },
        "gauge.backgroundFlushing.last_ms": {
          "type": "gauge",
          "description": "Most recent time (ms) spent writing data to disk",
          "group": null,
          "included": true
        },
        "gauge.collection.avgObjSize": {
          "type": "gauge",
          "description": "Mean object/document size of a collection",
          "group": "collection",
          "included": false
        },
        "gauge.collection.count": {
          "type": "gauge",
          "description": "Number of objects/documents in a collection",
          "group": "collection",
          "included": false
        },
        "gauge.collection.indexSize": {
          "type": "gauge",
          "description": "Size of a particular index on a collection",
          "group": "collection",
          "included": false
        },
        "gauge.collection.max": {
          "type": "gauge",
          "description": "Maximum number of documents in a capped collection",
          "group": null,
          "included": false
        },
        "gauge.collection.maxSize": {
          "type": "gauge",
          "description": "Maximum disk usage of a capped collection",
          "group": null,
          "included": false
        },
        "gauge.collection.size": {
          "type": "gauge",
          "description": "Size of a collection in bytes, not including indexes",
          "group": "collection",
          "included": false
        },
        "gauge.collection.storageSize": {
          "type": "gauge",
          "description": "Size of the collection on disk in bytes, never decreases.",
          "group": "collection",
          "included": false
        },
        "gauge.collections": {
          "type": "gauge",
          "description": "Number of collections",
          "group": null,
          "included": false
        },
        "gauge.connections.available": {
          "type": "gauge",
          "description": "Number of available incoming connections",
          "group": null,
          "included": false
        },
        "gauge.connections.current": {
          "type": "gauge",
          "description": "Number of current client connections",
          "group": null,
          "included": true
        },
        "gauge.connections.totalCreated": {
          "type": "cumulative",
          "description": "Count of all incoming connections created to the server. This number includes connections that have since closed.",
          "group": null,
          "included": false
        },
        "gauge.dataSize": {
          "type": "gauge",
          "description": "Total size of data, in bytes",
          "group": null,
          "included": true
        },
        "gauge.extra_info.heap_usage_bytes": {
          "type": "gauge",
          "description": "Heap size used by the mongod process, in bytes",
          "group": null,
          "included": true
        },
        "gauge.globalLock.activeClients.readers": {
          "type": "gauge",
          "description": "Number of active client connections performing reads",
          "group": null,
          "included": true
        },
        "gauge.globalLock.activeClients.total": {
          "type": "gauge",
          "description": "Total number of active client connections",
          "group": null,
          "included": false
        },
        "gauge.globalLock.activeClients.writers": {
          "type": "gauge",
          "description": "Number of active client connections performing writes",
          "group": null,
          "included": true
        },
        "gauge.globalLock.currentQueue.readers": {
          "type": "gauge",
          "description": "Read operations currently in queue",
          "group": null,
          "included": true
        },
        "gauge.globalLock.currentQueue.total": {
          "type": "gauge",
          "description": "Total operations currently in queue",
          "group": null,
          "included": false
        },
        "gauge.globalLock.currentQueue.writers": {
          "type": "gauge",
          "description": "Write operations currently in queue",
          "group": null,
          "included": true
        },
        "gauge.indexSize": {
          "type": "gauge",
          "description": "Total size of indexes, in bytes",
          "group": null,
          "included": true
        },
        "gauge.indexes": {
          "type": "gauge",
          "description": "Number of indexes across all collections",
          "group": null,
          "included": false
        },
        "gauge.mem.mapped": {
          "type": "gauge",
          "description": "Mongodb mapped memory usage, in MB",
          "group": null,
          "included": true
        },
        "gauge.mem.resident": {
          "type": "gauge",
          "description": "Mongodb resident memory usage, in MB",
          "group": null,
          "included": true
        },
        "gauge.mem.virtual": {
          "type": "gauge",
          "description": "Mongodb virtual memory usage, in MB",
          "group": null,
          "included": true
        },
        "gauge.numExtents": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gauge.objects": {
          "type": "gauge",
          "description": "Number of documents across all collections",
          "group": null,
          "included": true
        },
        "gauge.storageSize": {
          "type": "gauge",
          "description": "Total bytes allocated to collections for document storage",
          "group": null,
          "included": true
        },
        "gauge.uptime": {
          "type": "counter",
          "description": "Uptime of this server in milliseconds",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/mongodb",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "databases",
            "doc": "",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "username",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useTLS",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "caCerts",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tlsClientCert",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tlsClientKey",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "tlsClientKeyPassPhrase",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendCollectionMetrics",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "sendCollectionTopMetrics",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/mysql",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a MySQL database server using collectd's\n[MySQL plugin](https://collectd.org/wiki/index.php/Plugin:MySQL).\n\nOn Unix, MySQL programs treat the host name `localhost` specially, in a way\nthat is likely different from what is expected compared to other\nnetwork-based programs. For connections to `localhost`, MySQL programs\nattempt to connect to the local server by using a Unix socket file. To ensure\nthat the client makes a TCP/IP connection to the local server specify a host\nname value of `127.0.0.1`, or the IP address or name of the local server.\n\nYou have to specify each database you want to monitor individually under the\n`databases` key.  If you have a common authentication to all databases being\nmonitored, you can specify that in the top-level `username`/`password`\noptions, otherwise they can be specified at the database level.\n\n**Note:** The MySQL monitor supports MySQL versions 5.x or later.\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: collectd/mysql\n   host: 127.0.0.1\n   port: 3306\n   databases:\n     - name: dbname\n     - name: securedb\n       username: admin\n       password: s3cr3t\n   username: dbuser\n   password: passwd\n```\n",
      "groups": null,
      "metrics": {
        "cache_result.cache_size": {
          "type": "gauge",
          "description": "MySQL Qcache Size",
          "group": null,
          "included": false
        },
        "cache_result.qcache-hits": {
          "type": "cumulative",
          "description": "The number of hits on MySQL query cache.",
          "group": null,
          "included": true
        },
        "cache_result.qcache-inserts": {
          "type": "cumulative",
          "description": "The number of inserts into MySQL query cache.",
          "group": null,
          "included": true
        },
        "cache_result.qcache-not_cached": {
          "type": "cumulative",
          "description": "The number of MySQL queries that were not cacheable or not cached.",
          "group": null,
          "included": false
        },
        "cache_result.qcache-prunes": {
          "type": "cumulative",
          "description": "The number of queries that were pruned from query cache because of low-memory condition.",
          "group": null,
          "included": false
        },
        "cache_size.qcache": {
          "type": "gauge",
          "description": "The number of queries in MySQL query cache.",
          "group": null,
          "included": true
        },
        "mysql_commands.admin_commands": {
          "type": "cumulative",
          "description": "The number of MySQL ADMIN commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_db": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER DB commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_db_upgrade": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER DB UPGRADE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_event": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER EVENT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_function": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER FUNCTION commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_procedure": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER PROCEDURE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_server": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER SERVER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_table": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER TABLE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_tablespace": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER TABLESPACE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.alter_user": {
          "type": "cumulative",
          "description": "The number of MySQL ALTER USER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.analyze": {
          "type": "cumulative",
          "description": "The number of MySQL ANALYZE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.assign_to_keycache": {
          "type": "cumulative",
          "description": "The number of MySQL ASSIGN TO KEYCACHE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.begin": {
          "type": "cumulative",
          "description": "The number of MySQL BEGIN commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.binlog": {
          "type": "cumulative",
          "description": "The number of MySQL BINLOG commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.call_procedure": {
          "type": "cumulative",
          "description": "The number of MySQL CALL PROCEDURE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.change_db": {
          "type": "cumulative",
          "description": "The number of MySQL CHANGE DB commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.change_master": {
          "type": "cumulative",
          "description": "The number of MySQL CHANGE MASTER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.check": {
          "type": "cumulative",
          "description": "The number of MySQL CHECK commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.checksum": {
          "type": "cumulative",
          "description": "The number of MySQL CHECKSUM commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.commit": {
          "type": "cumulative",
          "description": "The number of MySQL COMMIT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_db": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE DB commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_event": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE EVENT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_function": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE FUNCTION commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_index": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE INDEX commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_procedure": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE PROCEDURE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_server": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE SERVER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_table": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE TABLE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_trigger": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE TRIGGER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_udf": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE UDF commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_user": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE USER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.create_view": {
          "type": "cumulative",
          "description": "The number of MySQL CREATE VIEW commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.dealloc_sql": {
          "type": "cumulative",
          "description": "The number of MySQL DEALLOC SQL commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.delete": {
          "type": "cumulative",
          "description": "The number of MySQL DELETE commands executed",
          "group": null,
          "included": true
        },
        "mysql_commands.delete_multi": {
          "type": "cumulative",
          "description": "The number of MySQL DELETE MULTI commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.do": {
          "type": "cumulative",
          "description": "The number of MySQL DO commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_db": {
          "type": "cumulative",
          "description": "The number of MySQL DROP DB commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_event": {
          "type": "cumulative",
          "description": "The number of MySQL DROP EVENT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_function": {
          "type": "cumulative",
          "description": "The number of MySQL DROP FUNCTION commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_index": {
          "type": "cumulative",
          "description": "The number of MySQL DROP INDEX commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_procedure": {
          "type": "cumulative",
          "description": "The number of MySQL DROP PROCEDURE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_server": {
          "type": "cumulative",
          "description": "The number of MySQL DROP SERVER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_table": {
          "type": "cumulative",
          "description": "The number of MySQL DROP TABLE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_trigger": {
          "type": "cumulative",
          "description": "The number of MySQL DROP TRIGGER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_user": {
          "type": "cumulative",
          "description": "The number of MySQL DROP USER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.drop_view": {
          "type": "cumulative",
          "description": "The number of MySQL DROP VIEW commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.empty_query": {
          "type": "cumulative",
          "description": "The number of MySQL EMPTY QUERY commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.execute_sql": {
          "type": "cumulative",
          "description": "The number of MySQL EXECUTE SQL commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.flush": {
          "type": "cumulative",
          "description": "The number of MySQL FLUSH commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.get_diagnostics": {
          "type": "cumulative",
          "description": "The number of MySQL GET DIAGNOSTICS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.grant": {
          "type": "cumulative",
          "description": "The number of MySQL GRANT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.ha_close": {
          "type": "cumulative",
          "description": "The number of MySQL HA CLOSE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.ha_open": {
          "type": "cumulative",
          "description": "The number of MySQL HA OPEN commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.ha_read": {
          "type": "cumulative",
          "description": "The number of MySQL HA READ commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.help": {
          "type": "cumulative",
          "description": "The number of MySQL HELP commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.insert": {
          "type": "cumulative",
          "description": "The number of MySQL INSERT commands executed",
          "group": null,
          "included": true
        },
        "mysql_commands.insert_select": {
          "type": "cumulative",
          "description": "The number of MySQL INSERT SELECT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.install_plugin": {
          "type": "cumulative",
          "description": "The number of MySQL INSTALL PLUGIN commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.kill": {
          "type": "cumulative",
          "description": "The number of MySQL KILL commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.load": {
          "type": "cumulative",
          "description": "The number of MySQL LOAD commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.lock_tables": {
          "type": "cumulative",
          "description": "The number of MySQL LOCK TABLES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.optimize": {
          "type": "cumulative",
          "description": "The number of MySQL OPTIMIZE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.preload_keys": {
          "type": "cumulative",
          "description": "The number of MySQL PRELOAD KEYS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.prepare_sql": {
          "type": "cumulative",
          "description": "The number of MySQL PREPARE SQL commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.purge": {
          "type": "cumulative",
          "description": "The number of MySQL PURGE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.purge_before_date": {
          "type": "cumulative",
          "description": "The number of MySQL PURGE BEFORE DATE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.release_savepoint": {
          "type": "cumulative",
          "description": "The number of MySQL RELEASE SAVEPOINT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.rename_table": {
          "type": "cumulative",
          "description": "The number of MySQL RENAME TABLE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.rename_user": {
          "type": "cumulative",
          "description": "The number of MySQL RENAME USER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.repair": {
          "type": "cumulative",
          "description": "The number of MySQL REPAIR commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.replace": {
          "type": "cumulative",
          "description": "The number of MySQL REPLACE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.replace_select": {
          "type": "cumulative",
          "description": "The number of MySQL REPLACE SELECT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.reset": {
          "type": "cumulative",
          "description": "The number of MySQL RESET commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.resignal": {
          "type": "cumulative",
          "description": "The number of MySQL RESIGNAL commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.revoke": {
          "type": "cumulative",
          "description": "The number of MySQL REVOKE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.revoke_all": {
          "type": "cumulative",
          "description": "The number of MySQL REVOKE ALL commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.rollback": {
          "type": "cumulative",
          "description": "The number of MySQL ROLLBACK commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.rollback_to_savepoint": {
          "type": "cumulative",
          "description": "The number of MySQL ROLLBACK TO SAVEPOINT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.savepoint": {
          "type": "cumulative",
          "description": "The number of MySQL SAVEPOINT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.select": {
          "type": "cumulative",
          "description": "The number of MySQL SELECT commands executed",
          "group": null,
          "included": true
        },
        "mysql_commands.set_option": {
          "type": "cumulative",
          "description": "The number of MySQL SET OPTION commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_binlog_events": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW BINLOG EVENTS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_binlogs": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW BINLOGS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_charsets": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CHARSETS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_collations": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW COLLATIONS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_create_db": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE DB commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_create_event": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE EVENT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_create_func": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE FUNC commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_create_proc": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE PROC commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_create_table": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE TABLE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_create_trigger": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW CREATE TRIGGER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_databases": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW DATABASES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_engine_logs": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW ENGINE LOGS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_engine_mutex": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW ENGINE MUTEX commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_engine_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW ENGINE STATUS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_errors": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW ERRORS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_events": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW EVENTS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_fields": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW FIELDS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_function_code": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW FUNCTION CODE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_function_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW FUNCTION STATUS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_grants": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW GRANTS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_keys": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW KEYS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_master_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW MASTER STATUS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_open_tables": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW OPEN TABLES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_plugins": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PLUGINS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_privileges": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PRIVILEGES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_procedure_code": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROCEDURE CODE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_procedure_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROCEDURE STATUS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_processlist": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROCESSLIST commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_profile": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROFILE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_profiles": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW PROFILES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_relaylog_events": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW RELAYLOG EVENTS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_slave_hosts": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW SLAVE HOSTS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_slave_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW SLAVE STATUS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW STATUS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_storage_engines": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW STORAGE ENGINES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_table_status": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW TABLE STATUS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_tables": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW TABLES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_triggers": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW TRIGGERS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_variables": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW VARIABLES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.show_warnings": {
          "type": "cumulative",
          "description": "The number of MySQL SHOW WARNINGS commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.signal": {
          "type": "cumulative",
          "description": "The number of MySQL SIGNAL commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.slave_start": {
          "type": "cumulative",
          "description": "The number of MySQL SLAVE START commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.slave_stop": {
          "type": "cumulative",
          "description": "The number of MySQL SLAVE STOP commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.truncate": {
          "type": "cumulative",
          "description": "The number of MySQL TRUNCATE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.uninstall_plugin": {
          "type": "cumulative",
          "description": "The number of MySQL UNINSTALL PLUGIN commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.unlock_tables": {
          "type": "cumulative",
          "description": "The number of MySQL UNLOCK TABLES commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.update": {
          "type": "cumulative",
          "description": "The number of MySQL UPDATE commands executed",
          "group": null,
          "included": true
        },
        "mysql_commands.update_multi": {
          "type": "cumulative",
          "description": "The number of MySQL UPDATE MULTI commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.xa_commit": {
          "type": "cumulative",
          "description": "The number of MySQL XA COMMIT commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.xa_end": {
          "type": "cumulative",
          "description": "The number of MySQL XA END commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.xa_prepare": {
          "type": "cumulative",
          "description": "The number of MySQL XA PREPARE commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.xa_recover": {
          "type": "cumulative",
          "description": "The number of MySQL XA RECOVER commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.xa_rollback": {
          "type": "cumulative",
          "description": "The number of MySQL XA ROLLBACK commands executed",
          "group": null,
          "included": false
        },
        "mysql_commands.xa_start": {
          "type": "cumulative",
          "description": "The number of MySQL XA START commands executed",
          "group": null,
          "included": false
        },
        "mysql_handler.commit": {
          "type": "cumulative",
          "description": "The number of internal COMMIT statements.",
          "group": null,
          "included": false
        },
        "mysql_handler.delete": {
          "type": "cumulative",
          "description": "The number of times rows have been deleted from tables.",
          "group": null,
          "included": false
        },
        "mysql_handler.external_lock": {
          "type": "cumulative",
          "description": "The number of external_lock occurences.",
          "group": null,
          "included": false
        },
        "mysql_handler.prepare": {
          "type": "cumulative",
          "description": "The number of times \"Prepare\" phase was executed in the two-phase commit operations.",
          "group": null,
          "included": false
        },
        "mysql_handler.read_first": {
          "type": "cumulative",
          "description": "The number of times the first entry in an index was read.",
          "group": null,
          "included": false
        },
        "mysql_handler.read_key": {
          "type": "cumulative",
          "description": "The number of times a row was read based on a key.",
          "group": null,
          "included": false
        },
        "mysql_handler.read_next": {
          "type": "cumulative",
          "description": "The number of requests to read the next row in key order.",
          "group": null,
          "included": false
        },
        "mysql_handler.read_prev": {
          "type": "cumulative",
          "description": "The number of requests to read the previous row in key order.",
          "group": null,
          "included": false
        },
        "mysql_handler.read_rnd": {
          "type": "cumulative",
          "description": "The number of requests that read a random fixed position in the data file.",
          "group": null,
          "included": false
        },
        "mysql_handler.read_rnd_next": {
          "type": "cumulative",
          "description": "The number of requests for the next row in the data file.",
          "group": null,
          "included": false
        },
        "mysql_handler.rollback": {
          "type": "cumulative",
          "description": "The number of requests for a rollback operation on the storage engine.",
          "group": null,
          "included": false
        },
        "mysql_handler.savepoint": {
          "type": "cumulative",
          "description": "The number of requests to place a savepoint on the storage engine.  This can be used to roll back later.",
          "group": null,
          "included": false
        },
        "mysql_handler.savepoint_rollback": {
          "type": "cumulative",
          "description": "The number of requests to roll back to a savepoint.",
          "group": null,
          "included": false
        },
        "mysql_handler.update": {
          "type": "cumulative",
          "description": "The number of requests to update a row in a table.",
          "group": null,
          "included": false
        },
        "mysql_handler.write": {
          "type": "cumulative",
          "description": "The number of requests to insert a row in a table.",
          "group": null,
          "included": false
        },
        "mysql_locks.immediate": {
          "type": "cumulative",
          "description": "The number of MySQL table locks which were granted immediately.",
          "group": null,
          "included": true
        },
        "mysql_locks.waited": {
          "type": "cumulative",
          "description": "The number of MySQL table locks which had to wait before being granted.",
          "group": null,
          "included": true
        },
        "mysql_octets.rx": {
          "type": "cumulative",
          "description": "The number of bytes received by MySQL server from all clients.",
          "group": null,
          "included": true
        },
        "mysql_octets.tx": {
          "type": "cumulative",
          "description": "The number of bytes sent by MySQL server to all clients.",
          "group": null,
          "included": true
        },
        "mysql_select.full_join": {
          "type": "cumulative",
          "description": "The number of joins that perform full table scans.",
          "group": null,
          "included": false
        },
        "mysql_select.full_range_join": {
          "type": "cumulative",
          "description": "The number of joins that used a range search on a reference table.",
          "group": null,
          "included": false
        },
        "mysql_select.range": {
          "type": "cumulative",
          "description": "The number of joins that used a range on the first table.",
          "group": null,
          "included": false
        },
        "mysql_select.range_check": {
          "type": "cumulative",
          "description": "The number of joins without keys that check for key usage after each row.",
          "group": null,
          "included": false
        },
        "mysql_select.scan": {
          "type": "cumulative",
          "description": "The number of joins that did a full scan of the first table.",
          "group": null,
          "included": false
        },
        "mysql_slow_queries": {
          "type": "cumulative",
          "description": "The number of queries that have taken more than long_query_time seconds.",
          "group": null,
          "included": false
        },
        "mysql_sort.range": {
          "type": "cumulative",
          "description": "The number of sorts that were done using ranges.",
          "group": null,
          "included": false
        },
        "mysql_sort.scan": {
          "type": "cumulative",
          "description": "The number of sorts that were done by scanning the table.",
          "group": null,
          "included": false
        },
        "mysql_sort_merge_passes": {
          "type": "cumulative",
          "description": "The number of merge passes done by the sorting algorithm.",
          "group": null,
          "included": false
        },
        "mysql_sort_rows": {
          "type": "cumulative",
          "description": "The number of rows that were sorted.",
          "group": null,
          "included": false
        },
        "threads.cached": {
          "type": "gauge",
          "description": "The number of threads cached by MySQL for re-use on a new client connection.  A MySQL thread corresponds to a single MySQL connection.",
          "group": null,
          "included": true
        },
        "threads.connected": {
          "type": "gauge",
          "description": "The number of currently open MySQL connections.  A MySQL thread corresponds to a single MySQL connection.",
          "group": null,
          "included": true
        },
        "threads.running": {
          "type": "gauge",
          "description": "The number of MySQL threads that are processing a query.  A MySQL thread corresponds to a single MySQL connection.",
          "group": null,
          "included": false
        },
        "total_threads.created": {
          "type": "cumulative",
          "description": "The total number of threads created by MySQL for client connections.  A MySQL thread corresponds to a single MySQL connection.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/mysql",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "databases",
            "doc": "A list of databases along with optional authentication credentials.",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Database",
              "doc": "Database configures a particular MySQL database",
              "package": "internal/monitors/collectd/mysql",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "username",
                  "doc": "",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "password",
                  "doc": "",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "username",
            "doc": "These credentials serve as defaults for all databases if not overridden",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "reportHost",
            "doc": "A SignalFx extension to the plugin that allows us to disable the normal behavior of the MySQL collectd plugin where the `host` dimension is set to the hostname of the MySQL database server.  When `false` (the recommended and default setting), the globally configured `hostname` config is used instead.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/nginx",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an nginx instance using our fork of the\ncollectd nginx plugin based on the [collectd nginx\nplugin](https://collectd.org/wiki/index.php/Plugin:nginx).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-nginx)\nfor more information.\n",
      "groups": null,
      "metrics": {
        "connections.accepted": {
          "type": "cumulative",
          "description": "Connections accepted by Nginx Web Server",
          "group": null,
          "included": true
        },
        "connections.failed": {
          "type": "cumulative",
          "description": "Connections failed by the Nginx Web Server",
          "group": null,
          "included": false
        },
        "connections.handled": {
          "type": "cumulative",
          "description": "Connections handled by Nginx Web Server",
          "group": null,
          "included": true
        },
        "nginx_connections.active": {
          "type": "gauge",
          "description": "Connections active in Nginx Web Server",
          "group": null,
          "included": true
        },
        "nginx_connections.reading": {
          "type": "gauge",
          "description": "Connections being read by Nginx Web Server",
          "group": null,
          "included": true
        },
        "nginx_connections.waiting": {
          "type": "gauge",
          "description": "Connections waited on by Nginx Web Server",
          "group": null,
          "included": true
        },
        "nginx_connections.writing": {
          "type": "gauge",
          "description": "Connections being written by Nginx Web Server",
          "group": null,
          "included": true
        },
        "nginx_requests": {
          "type": "cumulative",
          "description": "Requests handled by Nginx Web Server",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/nginx",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "url",
            "doc": "The full URL of the status endpoint; can be a template",
            "default": "http://{{.Host}}:{{.Port}}/nginx_status",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "timeout",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/openstack",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors Openstack by using the\n[Openstack collectd Python\nplugin](https://github.com/signalfx/collectd-openstack), which collects metrics\nfrom Openstack instances\n\n```yaml\nmonitors:\n- type: collectd/openstack\n  authURL: \"http://192.168.11.111/identity/v3\"\n  username: \"admin\"\n  password: \"secret\"\n```\n",
      "groups": null,
      "metrics": {
        "counter.openstack.nova.server.cpu_time": {
          "type": "counter",
          "description": "Virtual CPU time consumed in nanoseconds",
          "group": null,
          "included": false
        },
        "counter.openstack.nova.server.rx": {
          "type": "counter",
          "description": "Size of network packet received in bytes",
          "group": null,
          "included": true
        },
        "counter.openstack.nova.server.rx_packets": {
          "type": "counter",
          "description": "Received packets at an instance",
          "group": null,
          "included": true
        },
        "counter.openstack.nova.server.tx": {
          "type": "counter",
          "description": "Size of network packet transmitted in bytes",
          "group": null,
          "included": true
        },
        "counter.openstack.nova.server.tx_packets": {
          "type": "counter",
          "description": "Transmitted packets at an instance",
          "group": null,
          "included": true
        },
        "gauge.openstack.cinder.limit.maxTotalVolumeGigabytes": {
          "type": "gauge",
          "description": "Total available block storage at cinder component for project",
          "group": null,
          "included": true
        },
        "gauge.openstack.cinder.limit.maxTotalVolumes": {
          "type": "gauge",
          "description": "Maximum volume resources available at cinder component for project",
          "group": null,
          "included": true
        },
        "gauge.openstack.cinder.limit.totalGigabytesUsed": {
          "type": "gauge",
          "description": "Total block storage used at cinder component for project",
          "group": null,
          "included": true
        },
        "gauge.openstack.cinder.limit.totalVolumesUsed": {
          "type": "gauge",
          "description": "Volume resources used at cinder component for project",
          "group": null,
          "included": true
        },
        "gauge.openstack.neutron.floatingip.count": {
          "type": "gauge",
          "description": "Overall floating IPs used across projects",
          "group": null,
          "included": true
        },
        "gauge.openstack.neutron.network.count": {
          "type": "gauge",
          "description": "Overall Network resources used across projects",
          "group": null,
          "included": true
        },
        "gauge.openstack.neutron.router.count": {
          "type": "gauge",
          "description": "Overall router resources used across projects",
          "group": null,
          "included": true
        },
        "gauge.openstack.neutron.securitygroup.count": {
          "type": "gauge",
          "description": "Overall securitygroup resources used across projects",
          "group": null,
          "included": true
        },
        "gauge.openstack.neutron.subnet.count": {
          "type": "gauge",
          "description": "Overall subnet resources used in all projects",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.disk_available_least": {
          "type": "gauge",
          "description": "Minimum free disk space available in Gigabyte",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.free_disk_gb": {
          "type": "gauge",
          "description": "Maximum free disk space available in Gigabyte",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.load_average": {
          "type": "gauge",
          "description": "Average CPU load on the hypervisor",
          "group": null,
          "included": false
        },
        "gauge.openstack.nova.hypervisor.local_gb": {
          "type": "gauge",
          "description": "Maximum available local disk space in Gigabyte",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.local_gb_used": {
          "type": "gauge",
          "description": "Total disk space used in Gigabyte",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.memory_mb": {
          "type": "gauge",
          "description": "Maximum available memory in MB at hypervisor",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.memory_mb_used": {
          "type": "gauge",
          "description": "Total memory used in MB at hypervisor",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.running_vms": {
          "type": "gauge",
          "description": "Total running VMs at hypervisor",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.vcpus": {
          "type": "gauge",
          "description": "Available physical cores at hypervisor",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.hypervisor.vcpus_used": {
          "type": "gauge",
          "description": "Used virtual CPUs used",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.limit.maxSecurityGroups": {
          "type": "gauge",
          "description": "Maximum available security groups for project",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.limit.maxTotalCores": {
          "type": "gauge",
          "description": "Maximum available VCPUs in project",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.limit.maxTotalFloatingIps": {
          "type": "gauge",
          "description": "Maximum available floating IPs for project",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.limit.maxTotalInstances": {
          "type": "gauge",
          "description": "Maximum available instances in project",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.limit.maxTotalRAMSize": {
          "type": "gauge",
          "description": "Maximum available RAM size for project",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.limit.totalCoresUsed": {
          "type": "gauge",
          "description": "Total cores used in the project",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.limit.totalInstancesUsed": {
          "type": "gauge",
          "description": "Total instances used in the project",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.limit.totalRAMUsed": {
          "type": "gauge",
          "description": "Total RAM used in the project",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.server.memory": {
          "type": "gauge",
          "description": "Memory provisioned at an instance",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.server.memory-actual": {
          "type": "gauge",
          "description": "Actual memory used at an instance",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.server.memory-rss": {
          "type": "gauge",
          "description": "Memory used not including disk pages at an instance",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.server.vda_read": {
          "type": "gauge",
          "description": "Size of virtual disk read requests in bytes",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.server.vda_read_req": {
          "type": "gauge",
          "description": "Virtual disk read requests from an instance",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.server.vda_write": {
          "type": "gauge",
          "description": "Size of virtual disk write requests in bytes",
          "group": null,
          "included": true
        },
        "gauge.openstack.nova.server.vda_write_req": {
          "type": "gauge",
          "description": "Virtual disk write requests from an instance",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/openstack",
        "fields": [
          {
            "yamlName": "authURL",
            "doc": "Keystone authentication URL/endpoint for the OpenStack cloud",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username to authenticate with keystone identity",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password to authenticate with keystone identity",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "projectName",
            "doc": "Specify the name of Project to be monitored (**default**:\"demo\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "projectDomainID",
            "doc": "The project domain (**default**:\"default\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "userDomainID",
            "doc": "The user domain id (**default**:\"default\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/postgresql",
      "sendAll": false,
      "dimensions": null,
      "doc": "**This monitor is deprecated in favor of the [postgresql monitor](./postgresql.md).**\n\nMonitors a PostgreSQL database server using collectd's\n[PostgreSQL plugin](https://collectd.org/wiki/index.php/Plugin:PostgreSQL).\n\nYou have to specify each database you want to monitor individually under the\n`databases` key.  If you have a common authentication to all databases being\nmonitored, you can specify that in the top-level `username`/`password`\noptions, otherwise they can be specified at the database level.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/postgresql\n  host: 127.0.0.1\n  port: 5432\n  username: \"username1\"\n  password: \"password1\"\n  databases:\n  - name: \"testdb\"\n    username: \"test_user\"\n    password: \"test_pwd\"\n```\n\nSample YAML configuration with custom query:\n\n```yaml\nmonitors:\n- type: collectd/postgresql\n  host: 127.0.0.1\n  port: 5432\n  username: \"username1\"\n  password: \"password1\"\n  queries:\n  - name: \"exampleQuery\"\n    params:\n    - \"hostname\"\n    statement: \"Select * From test Where host = $1;\"\n    results:\n    - type: \"gauge\"\n      valuesFrom:\n      - \"test\"\n      instancePrefix: \"test\"\n databases:\n - name: \"test\"\n   username: \"username2\"\n   password: \"password2\"\n   queries:\n   - \"exampleQuery\"\n\nmetricsToInclude:\n   - metricNames:\n     - gauge.test\n     monitorType: collectd/postgresql\n```\nNote that the metric names for the additional metrics picked up from the\nqueries provided depend on the type, instancePrefix and/or instancesFrom\nparameters being passed in.\nSee [PostgreSQL plugin](https://collectd.org/wiki/index.php/Plugin:PostgreSQL)\nfor details.\n",
      "groups": null,
      "metrics": {
        "pg_blks.heap_hit": {
          "type": "gauge",
          "description": "Number of buffer hits",
          "group": null,
          "included": true
        },
        "pg_blks.heap_read": {
          "type": "gauge",
          "description": "Number of disk blocks read",
          "group": null,
          "included": true
        },
        "pg_blks.idx_hit": {
          "type": "gauge",
          "description": "Number of index buffer hits",
          "group": null,
          "included": true
        },
        "pg_blks.idx_read": {
          "type": "gauge",
          "description": "Number of index blocks read",
          "group": null,
          "included": true
        },
        "pg_blks.tidx_hit": {
          "type": "gauge",
          "description": "Number of TOAST index buffer hits",
          "group": null,
          "included": false
        },
        "pg_blks.tidx_read": {
          "type": "gauge",
          "description": "Number of TOAST index blocks read",
          "group": null,
          "included": false
        },
        "pg_blks.toast_hit": {
          "type": "gauge",
          "description": "Number of TOAST buffer hits",
          "group": null,
          "included": false
        },
        "pg_blks.toast_read": {
          "type": "gauge",
          "description": "Number of disk blocks read",
          "group": null,
          "included": false
        },
        "pg_db_size": {
          "type": "gauge",
          "description": "Size of the database on disk, in bytes",
          "group": null,
          "included": true
        },
        "pg_n_tup_c.del": {
          "type": "gauge",
          "description": "Number of delete operations",
          "group": null,
          "included": true
        },
        "pg_n_tup_c.hot_upd": {
          "type": "gauge",
          "description": "Number of update operations not requiring index update",
          "group": null,
          "included": false
        },
        "pg_n_tup_c.ins": {
          "type": "gauge",
          "description": "Number of insert operations",
          "group": null,
          "included": true
        },
        "pg_n_tup_c.upd": {
          "type": "gauge",
          "description": "Number of update operations",
          "group": null,
          "included": true
        },
        "pg_n_tup_g.dead": {
          "type": "gauge",
          "description": "Number of dead rows in the database",
          "group": null,
          "included": false
        },
        "pg_n_tup_g.live": {
          "type": "gauge",
          "description": "Number of live rows in the database",
          "group": null,
          "included": true
        },
        "pg_numbackends": {
          "type": "gauge",
          "description": "Number of server processes",
          "group": null,
          "included": true
        },
        "pg_scan.idx": {
          "type": "gauge",
          "description": "Number of index scans",
          "group": null,
          "included": true
        },
        "pg_scan.idx_tup_fetch": {
          "type": "gauge",
          "description": "Number of rows read from index scans",
          "group": null,
          "included": true
        },
        "pg_scan.seq": {
          "type": "gauge",
          "description": "Number of sequential scans",
          "group": null,
          "included": true
        },
        "pg_scan.seq_tup_read": {
          "type": "gauge",
          "description": "Number of rows read from sequential scans",
          "group": null,
          "included": true
        },
        "pg_xact.commit": {
          "type": "gauge",
          "description": "Number of commits",
          "group": null,
          "included": true
        },
        "pg_xact.num_deadlocks": {
          "type": "gauge",
          "description": "Number of deadlocks detected by the database",
          "group": null,
          "included": false
        },
        "pg_xact.rollback": {
          "type": "gauge",
          "description": "Number of rollbacks",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/postgresql",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "databases",
            "doc": "A list of databases along with optional authentication credentials.",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Database",
              "doc": "Database configures a particular PostgreSQL database",
              "package": "internal/monitors/collectd/postgresql",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "The name of the database",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "username",
                  "doc": "Username used to access the database",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "password",
                  "doc": "Password used to access the database",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "interval",
                  "doc": "Interval to query the database in seconds",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "expireDelay",
                  "doc": "Skip expired values in query output",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "sslMode",
                  "doc": "Specify whether to use an ssl connection with PostgreSQL. (prefer(default), disable, allow, require)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "krbSrvName",
                  "doc": "Specify the Kerberos service name used to authenticate with kerberos 5 or GSSAPI",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "queries",
                  "doc": "Queries used to generate metrics. These will override the default set. If no queries are specified, the default set will be used [`custom_deadlocks`, `backends`, `transactions`, `queries`, `queries_by_table`, `query_plans`, `table_states`, `query_plans_by_table`, `table_states_by_table`, `disk_io`, `disk_io_by_table`, `disk_usage`]",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                }
              ]
            }
          },
          {
            "yamlName": "queries",
            "doc": "PostgreSQL queries and metric mappings",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Query",
              "doc": "Query adds a new query for retrieving metrics",
              "package": "internal/monitors/collectd/postgresql",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "Name used to refer to the query in the database block",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "statement",
                  "doc": "Statement is a SQL statement to execute",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "results",
                  "doc": "Result blocks that define mappings of SQL query results to metrics",
                  "default": null,
                  "required": true,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "Result",
                    "doc": "Result maps values from a query to a metric",
                    "package": "internal/monitors/collectd/postgresql",
                    "fields": [
                      {
                        "yamlName": "type",
                        "doc": "Type defines a metric type",
                        "default": null,
                        "required": true,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "valuesFrom",
                        "doc": "Specifies columns in the SQL result to use as the metric value.  The number of columns must match the expected number of values for the metric type.",
                        "default": null,
                        "required": true,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "instancePrefix",
                        "doc": "A prefix for the type instance",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "instancesFrom",
                        "doc": "Specifies columns in the SQL result to uses for the type instance.  Multiple columns are joined with a hyphen \"-\".",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      }
                    ]
                  }
                },
                {
                  "yamlName": "params",
                  "doc": "Parameters used to fill in $1,$2,$... tokens in the SQL statement.  Acceptable values are hostname, database, instance, username, interval",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "pluginInstanceFrom",
                  "doc": "Specifies the column that should be used to populate plugin instance",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "minVersion",
                  "doc": "The minimum version of PostgreSQL that the query is compatible with.  The version must be specified as a two decimal digit. Ex. 7.2.3 -\u003e 70203",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "maxVersion",
                  "doc": "The maximum version of PostgreSQL that the query is compatible with.  The version must be specified as a two decimal digit. Ex. 7.2.3 -\u003e 70203",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "username",
            "doc": "A username that serves as a default for all databases if not overridden",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "A password that serves as a default for all databases if not overridden",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "reportHost",
            "doc": "A SignalFx extension to the plugin that allows us to disable the normal behavior of the PostgreSQL collectd plugin where the `host` dimension is set to the hostname of the PostgreSQL database server.  When `false` (the recommended and default setting), the globally configured `hostname` config is used instead.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/processes",
      "sendAll": true,
      "dimensions": null,
      "doc": "Gathers information about processes running on\nthe host.  See\nhttps://collectd.org/documentation/manpages/collectd.conf.5.shtml#plugin_processes\nand https://collectd.org/wiki/index.php/Plugin:Processes for more\ninformation on the configuration options.\n\nExample:\n\n```yaml\n procPath: /proc\n monitors:\n  - type: collectd/processes\n    processes:\n      - mysql\n      - myapp\n    processMatch:\n      docker: \"docker.*\"\n    collectContextSwitch: true\n```\n\nThe above config will send process metrics for processes named *mysql* and\n*myapp*, along with additional metrics on the number of context switches the\nprocess has made.  Also, all processes that start with `docker` will have\ntheir process metrics aggregated together and sent with a `plugin_instance`\nvalue of `docker`.\n",
      "groups": null,
      "metrics": {
        "disk_octets.read": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "disk_octets.write": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "fork_rate": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "io_octets.rx": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "io_octets.tx": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "io_ops.read": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "io_ops.write": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_code": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_count.processes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_count.threads": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_cputime.syst": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_cputime.user": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_data": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_pagefaults.majflt": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_pagefaults.minflt": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_rss": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_stacksize": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_state.blocked": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_state.paging": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_state.running": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_state.sleeping": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_state.stopped": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_state.zombies": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ps_vm": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/processes",
        "fields": [
          {
            "yamlName": "processes",
            "doc": "A list of process names to match",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "processMatch",
            "doc": "A map with keys specifying the `plugin_instance` value to be sent for the values which are regexes that match process names.  See example in description.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "collectContextSwitch",
            "doc": "Collect metrics on the number of context switches made by the process",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "procFSPath",
            "doc": "(Deprecated) Please set the agent configuration `procPath` instead of this monitor configuration option. The path to the proc filesystem -- useful to override if the agent is running in a container.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/protocols",
      "sendAll": false,
      "dimensions": null,
      "doc": "Gathers metrics about the network protocol\nstacks running on the system by using the [collectd protocols\nplugin](https://collectd.org/wiki/index.php/Plugin:Protocols).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-protocols)\nfor more information.\n",
      "groups": null,
      "metrics": {
        "protocol_counter.ActiveOpens": {
          "type": "cumulative",
          "description": "The number of times TCP connections transitioned from the CLOSED state to the SYN-SENT state.",
          "group": null,
          "included": true
        },
        "protocol_counter.CurrEstab": {
          "type": "cumulative",
          "description": "The number of TCP connections currently in either ESTABLISHED or CLOSE-WAIT state.",
          "group": null,
          "included": false
        },
        "protocol_counter.DelayedACKs": {
          "type": "cumulative",
          "description": "The number of acknowledgements delayed by TCP Delayed Acknowledgement",
          "group": null,
          "included": false
        },
        "protocol_counter.InDestUnreachs": {
          "type": "cumulative",
          "description": "The number of ICMP Destination Unreachable messages received",
          "group": null,
          "included": false
        },
        "protocol_counter.OutSegs": {
          "type": "cumulative",
          "description": "The total number of segments that have been sent, including those on current connections but excluding those containing only retransmitted octets.\n",
          "group": null,
          "included": false
        },
        "protocol_counter.PassiveOpens": {
          "type": "cumulative",
          "description": "The number of times that a server opened a connection, due to receiving a TCP SYN packet.",
          "group": null,
          "included": false
        },
        "protocol_counter.RetransSegs": {
          "type": "cumulative",
          "description": "The total number of segments retransmitted",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/protocols",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/python",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor runs arbitrary collectd Python\nplugins directly, apart from collectd.  It implements a mock collectd Python\ninterface that supports most, but not all, of the real collectd.\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config specifies configurations that are specific to the individual python based monitor",
        "package": "internal/monitors/collectd/python",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host will be filled in by auto-discovery if this monitor has a discovery rule.  It can then be used under pluginConfig by the template `{{.Host}}`",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port will be filled in by auto-discovery if this monitor has a discovery rule.  It can then be used under pluginConfig by the template `{{.Port}}`",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "moduleName",
            "doc": "Corresponds to the ModuleName option in collectd-python",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "modulePaths",
            "doc": "Corresponds to a set of ModulePath options in collectd-python",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "pluginConfig",
            "doc": "This is a yaml form of the collectd config.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "interface"
          },
          {
            "yamlName": "typesDBPaths",
            "doc": "A set of paths to [../types.db files](https://collectd.org/documentation/manpages/types.db.5.shtml) that are needed by your plugin.  If not specified, the runner will use the global collectd ../types.db file.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/rabbitmq",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an instance of RabbitMQ using the\n[collectd RabbitMQ Python\nPlugin](https://github.com/signalfx/collectd-rabbitmq).\n\nSee the [integration\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-rabbitmq)\nfor more information.\n\n**Note that you must individually enable each of the five `collect*` options\nto get metrics pertaining to those facets of a RabbitMQ instance.  If none\nof them are enabled, no metrics will be sent.**\n",
      "groups": {
        "channel": {
          "description": "Channels metrics"
        },
        "connection": {
          "description": "Connections metrics"
        },
        "exchange": {
          "description": "Exchanges metrics"
        },
        "node": {
          "description": "Nodes metrics"
        },
        "queue": {
          "description": "Queues metrics"
        }
      },
      "metrics": {
        "counter.channel.message_stats.ack": {
          "type": "counter",
          "description": "The number of acknowledged messages",
          "group": "channel",
          "included": false
        },
        "counter.channel.message_stats.confirm": {
          "type": "counter",
          "description": "Count of messages confirmed.",
          "group": "channel",
          "included": false
        },
        "counter.channel.message_stats.deliver": {
          "type": "counter",
          "description": "Count of messages delivered in acknowledgement mode to consumers.",
          "group": "channel",
          "included": false
        },
        "counter.channel.message_stats.deliver_get": {
          "type": "counter",
          "description": "Count of all messages delivered on the channel",
          "group": "channel",
          "included": false
        },
        "counter.channel.message_stats.publish": {
          "type": "counter",
          "description": "Count of messages published.",
          "group": "channel",
          "included": false
        },
        "counter.connection.channel_max": {
          "type": "counter",
          "description": "The maximum number of channels on the connection",
          "group": "connection",
          "included": false
        },
        "counter.connection.recv_cnt": {
          "type": "counter",
          "description": "Number of packets received on the connection",
          "group": "connection",
          "included": false
        },
        "counter.connection.recv_oct": {
          "type": "counter",
          "description": "Number of octets received on the connection",
          "group": "connection",
          "included": false
        },
        "counter.connection.send_cnt": {
          "type": "counter",
          "description": "Number of packets sent by the connection",
          "group": "connection",
          "included": false
        },
        "counter.connection.send_oct": {
          "type": "counter",
          "description": "Number of octets sent by the connection",
          "group": "connection",
          "included": false
        },
        "counter.exchange.message_stats.confirm": {
          "type": "counter",
          "description": "Count of messages confirmed.",
          "group": "exchange",
          "included": false
        },
        "counter.exchange.message_stats.publish_in": {
          "type": "counter",
          "description": "Count of messages published \"in\" to an exchange, i.e. not taking account of routing.",
          "group": "exchange",
          "included": true
        },
        "counter.exchange.message_stats.publish_out": {
          "type": "counter",
          "description": "Count of messages published \"out\" of an exchange, i.e. taking account of routing.",
          "group": "exchange",
          "included": false
        },
        "counter.node.io_read_bytes": {
          "type": "counter",
          "description": "Total number of bytes read from disk by the persister.",
          "group": "node",
          "included": false
        },
        "counter.node.io_read_count": {
          "type": "counter",
          "description": "Total number of read operations by the persister.",
          "group": "node",
          "included": false
        },
        "counter.node.mnesia_disk_tx_count": {
          "type": "counter",
          "description": "Number of Mnesia transactions which have been performed that required writes to disk.",
          "group": "node",
          "included": false
        },
        "counter.node.mnesia_ram_tx_count": {
          "type": "counter",
          "description": "Number of Mnesia transactions which have been performed that did not require writes to disk.",
          "group": "node",
          "included": false
        },
        "counter.queue.disk_reads": {
          "type": "counter",
          "description": "Total number of times messages have been read from disk by this queue since it started.",
          "group": "queue",
          "included": false
        },
        "counter.queue.disk_writes": {
          "type": "counter",
          "description": "Total number of times messages have been written to disk by this queue since it started.",
          "group": "queue",
          "included": false
        },
        "counter.queue.message_stats.ack": {
          "type": "counter",
          "description": "Number of acknowledged messages processed by the queue",
          "group": "queue",
          "included": false
        },
        "counter.queue.message_stats.deliver": {
          "type": "counter",
          "description": "Count of messages delivered in acknowledgement mode to consumers.",
          "group": "queue",
          "included": true
        },
        "counter.queue.message_stats.deliver_get": {
          "type": "counter",
          "description": "Count of all messages delivered on the queue",
          "group": "queue",
          "included": false
        },
        "counter.queue.message_stats.publish": {
          "type": "counter",
          "description": "Count of messages published.",
          "group": "queue",
          "included": false
        },
        "gauge.channel.connection_details.peer_port": {
          "type": "gauge",
          "description": "The peer port number of the channel",
          "group": "channel",
          "included": false
        },
        "gauge.channel.consumer_count": {
          "type": "gauge",
          "description": "The number of consumers the channel has",
          "group": "channel",
          "included": false
        },
        "gauge.channel.global_prefetch_count": {
          "type": "gauge",
          "description": "QoS prefetch limit for the entire channel, 0 if unlimited.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.message_stats.ack_details.rate": {
          "type": "gauge",
          "description": "How much the channel message ack count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.message_stats.confirm_details.rate": {
          "type": "gauge",
          "description": "How much the channel message confirm count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.message_stats.deliver_details.rate": {
          "type": "gauge",
          "description": "How much the channel deliver count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.message_stats.deliver_get_details.rate": {
          "type": "gauge",
          "description": "How much the channel message count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.message_stats.publish_details.rate": {
          "type": "gauge",
          "description": "How much the channel message publish count has changed per second in the most recent sampling interval.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.messages_unacknowledged": {
          "type": "gauge",
          "description": "Number of messages delivered via this channel but not yet acknowledged.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.messages_uncommitted": {
          "type": "gauge",
          "description": "Number of messages received in an as yet uncommitted transaction.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.messages_unconfirmed": {
          "type": "gauge",
          "description": "Number of published messages not yet confirmed. On channels not in confirm mode, this remains 0.",
          "group": "channel",
          "included": false
        },
        "gauge.channel.number": {
          "type": "gauge",
          "description": "The number of the channel, which uniquely identifies it within a connection.",
          "group": "channel",
          "included": true
        },
        "gauge.channel.prefetch_count": {
          "type": "gauge",
          "description": "QoS prefetch limit for new consumers, 0 if unlimited.",
          "group": "channel",
          "included": false
        },
        "gauge.connection.channels": {
          "type": "gauge",
          "description": "The current number of channels on the connection",
          "group": "connection",
          "included": false
        },
        "gauge.connection.connected_at": {
          "type": "gauge",
          "description": "The integer timestamp of the most recent time the connection was established",
          "group": "connection",
          "included": false
        },
        "gauge.connection.frame_max": {
          "type": "gauge",
          "description": "Maximum permissible size of a frame (in bytes) to negotiate with clients.",
          "group": "connection",
          "included": false
        },
        "gauge.connection.peer_port": {
          "type": "gauge",
          "description": "The peer port of the connection",
          "group": "connection",
          "included": false
        },
        "gauge.connection.port": {
          "type": "gauge",
          "description": "The port the connection is established on",
          "group": "connection",
          "included": false
        },
        "gauge.connection.recv_oct_details.rate": {
          "type": "gauge",
          "description": "How much the connection's octets received count has changed per second in the most recent sampling interval.",
          "group": "connection",
          "included": false
        },
        "gauge.connection.send_oct_details.rate": {
          "type": "gauge",
          "description": "How much the connection's octets sent count has changed per second in the most recent sampling interval.",
          "group": "connection",
          "included": false
        },
        "gauge.connection.send_pend": {
          "type": "gauge",
          "description": "The number of messages in the send queue of the connection",
          "group": "connection",
          "included": false
        },
        "gauge.connection.timeout": {
          "type": "gauge",
          "description": "The current timeout setting (in seconds) of the connection",
          "group": "connection",
          "included": false
        },
        "gauge.exchange.message_stats.confirm_details.rate": {
          "type": "gauge",
          "description": "How much the message confirm count has changed per second in the most recent sampling interval.",
          "group": "exchange",
          "included": false
        },
        "gauge.exchange.message_stats.publish_in_details.rate": {
          "type": "gauge",
          "description": "How much the exchange publish-in count has changed per second in the most recent sampling interval.",
          "group": "exchange",
          "included": false
        },
        "gauge.exchange.message_stats.publish_out_details.rate": {
          "type": "gauge",
          "description": "How much the exchange publish-out count has changed per second in the most recent sampling interval.",
          "group": "exchange",
          "included": false
        },
        "gauge.node.disk_free": {
          "type": "gauge",
          "description": "Disk free space (in bytes) on the node",
          "group": "node",
          "included": true
        },
        "gauge.node.disk_free_details.rate": {
          "type": "gauge",
          "description": "How much the disk free space has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.disk_free_limit": {
          "type": "gauge",
          "description": "Point (in bytes) at which the disk alarm will go off.",
          "group": "node",
          "included": true
        },
        "gauge.node.fd_total": {
          "type": "gauge",
          "description": "Total number of file descriptors available.",
          "group": "node",
          "included": true
        },
        "gauge.node.fd_used": {
          "type": "gauge",
          "description": "Number of used file descriptors.",
          "group": "node",
          "included": true
        },
        "gauge.node.fd_used_details.rate": {
          "type": "gauge",
          "description": "How much the number of used file descriptors has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.io_read_avg_time": {
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each disk read operation in the last statistics interval.",
          "group": "node",
          "included": true
        },
        "gauge.node.io_read_avg_time_details.rate": {
          "type": "gauge",
          "description": "How much the I/O read average time has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.io_read_bytes_details.rate": {
          "type": "gauge",
          "description": "How much the number of bytes read from disk has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.io_read_count_details.rate": {
          "type": "gauge",
          "description": "How much the number of read operations has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.io_sync_avg_time": {
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each fsync() operation in the last statistics interval.",
          "group": "node",
          "included": true
        },
        "gauge.node.io_sync_avg_time_details.rate": {
          "type": "gauge",
          "description": "How much the average I/O sync time has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.io_write_avg_time": {
          "type": "gauge",
          "description": "Average wall time (milliseconds) for each disk write operation in the last statistics interval.",
          "group": "node",
          "included": true
        },
        "gauge.node.io_write_avg_time_details.rate": {
          "type": "gauge",
          "description": "How much the I/O write time has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.mem_limit": {
          "type": "gauge",
          "description": "Point (in bytes) at which the memory alarm will go off.",
          "group": "node",
          "included": true
        },
        "gauge.node.mem_used": {
          "type": "gauge",
          "description": "Memory used in bytes.",
          "group": "node",
          "included": true
        },
        "gauge.node.mem_used_details.rate": {
          "type": "gauge",
          "description": "How much the count has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.mnesia_disk_tx_count_details.rate": {
          "type": "gauge",
          "description": "How much the Mnesia disk transaction count has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.mnesia_ram_tx_count_details.rate": {
          "type": "gauge",
          "description": "How much the RAM-only Mnesia transaction count has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.net_ticktime": {
          "type": "gauge",
          "description": "Current kernel net_ticktime setting for the node.",
          "group": "node",
          "included": false
        },
        "gauge.node.proc_total": {
          "type": "gauge",
          "description": "The maximum number of Erlang processes that can run in an Erlang VM.",
          "group": "node",
          "included": false
        },
        "gauge.node.proc_used": {
          "type": "gauge",
          "description": "Number of Erlang processes currently running in use.",
          "group": "node",
          "included": false
        },
        "gauge.node.proc_used_details.rate": {
          "type": "gauge",
          "description": "How much the number of erlang processes in use has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.processors": {
          "type": "gauge",
          "description": "Number of cores detected and usable by Erlang.",
          "group": "node",
          "included": false
        },
        "gauge.node.run_queue": {
          "type": "gauge",
          "description": "Average number of Erlang processes waiting to run.",
          "group": "node",
          "included": false
        },
        "gauge.node.sockets_total": {
          "type": "gauge",
          "description": "Number of file descriptors available for use as sockets.",
          "group": "node",
          "included": false
        },
        "gauge.node.sockets_used": {
          "type": "gauge",
          "description": "Number of file descriptors used as sockets.",
          "group": "node",
          "included": false
        },
        "gauge.node.sockets_used_details.rate": {
          "type": "gauge",
          "description": "How much the number of sockets used has changed per second in the most recent sampling interval.",
          "group": "node",
          "included": false
        },
        "gauge.node.uptime": {
          "type": "gauge",
          "description": "Time since the Erlang VM started, in milliseconds.",
          "group": "node",
          "included": true
        },
        "gauge.queue.backing_queue_status.avg_ack_egress_rate": {
          "type": "gauge",
          "description": "Rate at which unacknowledged message records leave RAM, e.g. because acks arrive or unacked messages are paged out",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.avg_ack_ingress_rate": {
          "type": "gauge",
          "description": "Rate at which unacknowledged message records enter RAM, e.g. because messages are delivered requiring acknowledgement",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.avg_egress_rate": {
          "type": "gauge",
          "description": "Average egress (outbound) rate, not including messages that are sent straight through to auto-acking consumers.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.avg_ingress_rate": {
          "type": "gauge",
          "description": "Average ingress (inbound) rate, not including messages that are sent straight through to auto-acking consumers.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.len": {
          "type": "gauge",
          "description": "Total backing queue length, in messages",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.next_seq_id": {
          "type": "gauge",
          "description": "The next sequence ID to be used in the backing queue",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.q1": {
          "type": "gauge",
          "description": "Number of messages in backing queue q1",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.q2": {
          "type": "gauge",
          "description": "Number of messages in backing queue q2",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.q3": {
          "type": "gauge",
          "description": "Number of messages in backing queue q3",
          "group": "queue",
          "included": false
        },
        "gauge.queue.backing_queue_status.q4": {
          "type": "gauge",
          "description": "Number of messages in backing queue q4",
          "group": "queue",
          "included": false
        },
        "gauge.queue.consumer_utilisation": {
          "type": "gauge",
          "description": "Fraction of the time (between 0.0 and 1.0) that the queue is able to immediately deliver messages to consumers.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.consumers": {
          "type": "gauge",
          "description": "Number of consumers of the queue",
          "group": "queue",
          "included": true
        },
        "gauge.queue.memory": {
          "type": "gauge",
          "description": "Bytes of memory consumed by the Erlang process associated with the queue, including stack, heap and internal structures.",
          "group": "queue",
          "included": true
        },
        "gauge.queue.message_bytes": {
          "type": "gauge",
          "description": "Sum of the size of all message bodies in the queue. This does not include the message properties (including headers) or any overhead.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.message_bytes_persistent": {
          "type": "gauge",
          "description": "Total number of persistent messages in the queue (will always be 0 for transient queues).",
          "group": "queue",
          "included": false
        },
        "gauge.queue.message_bytes_ram": {
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages which are in RAM.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.message_bytes_ready": {
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages ready to be delivered to clients.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.message_bytes_unacknowledged": {
          "type": "gauge",
          "description": "Like message_bytes but counting only those messages delivered to clients but not yet acknowledged.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.message_stats.ack_details.rate": {
          "type": "gauge",
          "description": "How much the number of acknowledged messages has changed per second in the most recent sampling interval.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.message_stats.deliver_details.rate": {
          "type": "gauge",
          "description": "How much the count of messages delivered has changed per second in the most recent sampling interval.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.message_stats.deliver_get_details.rate": {
          "type": "gauge",
          "description": "How much the count of all messages delivered has changed per second in the most recent sampling interval.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.message_stats.publish_details.rate": {
          "type": "gauge",
          "description": "How much the count of messages published has changed per second in the most recent sampling interval.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages": {
          "type": "gauge",
          "description": "Sum of ready and unacknowledged messages (queue depth).",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages_details.rate": {
          "type": "gauge",
          "description": "How much the queue depth has changed per second in the most recent sampling interval.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages_persistent": {
          "type": "gauge",
          "description": "Total number of persistent messages in the queue (will always be 0 for transient queues).",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages_ram": {
          "type": "gauge",
          "description": "Total number of messages which are resident in RAM.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages_ready": {
          "type": "gauge",
          "description": "Number of messages ready to be delivered to clients.",
          "group": "queue",
          "included": true
        },
        "gauge.queue.messages_ready_details.rate": {
          "type": "gauge",
          "description": "How much the count of messages ready has changed per second in the most recent sampling interval.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages_ready_ram": {
          "type": "gauge",
          "description": "Number of messages from messages_ready which are resident in RAM.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages_unacknowledged": {
          "type": "gauge",
          "description": "Number of messages delivered to clients but not yet acknowledged.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages_unacknowledged_details.rate": {
          "type": "gauge",
          "description": "How much the count of unacknowledged messages has changed per second in the most recent sampling interval.",
          "group": "queue",
          "included": false
        },
        "gauge.queue.messages_unacknowledged_ram": {
          "type": "gauge",
          "description": "Number of messages from messages_unacknowledged which are resident in RAM.",
          "group": "queue",
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/rabbitmq",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "brokerName",
            "doc": "The name of the particular RabbitMQ instance.  Can be a Go template using other config options. This will be used as the `plugin_instance` dimension.",
            "default": "{{.host}}-{{.port}}",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "collectChannels",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "collectConnections",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "collectExchanges",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "collectNodes",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "collectQueues",
            "doc": "",
            "default": "false",
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "httpTimeout",
            "doc": "",
            "default": null,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "verbosityLevel",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/redis",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors a redis instance using the [collectd\nPython Redis plugin](https://github.com/signalfx/redis-collectd-plugin).\n\nSee the [integrations\ndoc](https://github.com/signalfx/integrations/tree/master/collectd-redis)\nfor more information.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/redis\n  host: 127.0.0.1\n  port: 9100\n```\n\nSample YAML configuration with list lengths:\n\n```yaml\nmonitors:\n- type: collectd/redis\n  host: 127.0.0.1\n  port: 9100\n  sendListLengths:\n  - databaseIndex: 0\n    keyPattern: 'mylist*'\n```\n",
      "groups": null,
      "metrics": {
        "bytes.used_memory": {
          "type": "gauge",
          "description": "Number of bytes allocated by Redis",
          "group": null,
          "included": true
        },
        "bytes.used_memory_lua": {
          "type": "gauge",
          "description": "Number of bytes used by the Lua engine",
          "group": null,
          "included": false
        },
        "bytes.used_memory_peak": {
          "type": "gauge",
          "description": "Peak Number of bytes allocated by Redis",
          "group": null,
          "included": false
        },
        "bytes.used_memory_rss": {
          "type": "gauge",
          "description": "Number of bytes allocated by Redis as seen by the OS",
          "group": null,
          "included": true
        },
        "counter.commands_processed": {
          "type": "cumulative",
          "description": "Total number of commands processed by the server",
          "group": null,
          "included": true
        },
        "counter.connections_received": {
          "type": "cumulative",
          "description": "Total number of connections accepted by the server",
          "group": null,
          "included": false
        },
        "counter.evicted_keys": {
          "type": "cumulative",
          "description": "Number of evicted keys due to maxmemory limit",
          "group": null,
          "included": true
        },
        "counter.expired_keys": {
          "type": "cumulative",
          "description": "Total number of key expiration events",
          "group": null,
          "included": true
        },
        "counter.lru_clock": {
          "type": "cumulative",
          "description": "Clock incrementing every minute, for LRU management",
          "group": null,
          "included": false
        },
        "counter.rejected_connections": {
          "type": "cumulative",
          "description": "Number of connections rejected because of maxclients limit",
          "group": null,
          "included": true
        },
        "counter.total_net_input_bytes": {
          "type": "cumulative",
          "description": "Total number of bytes inputted",
          "group": null,
          "included": true
        },
        "counter.total_net_output_bytes": {
          "type": "cumulative",
          "description": "Total number of bytes outputted",
          "group": null,
          "included": true
        },
        "counter.used_cpu_sys": {
          "type": "cumulative",
          "description": "System CPU consumed by the Redis server",
          "group": null,
          "included": true
        },
        "counter.used_cpu_sys_children": {
          "type": "cumulative",
          "description": "System CPU consumed by the background processes",
          "group": null,
          "included": false
        },
        "counter.used_cpu_user": {
          "type": "cumulative",
          "description": "User CPU consumed by the Redis server",
          "group": null,
          "included": true
        },
        "counter.used_cpu_user_children": {
          "type": "cumulative",
          "description": "User CPU consumed by the background processes",
          "group": null,
          "included": false
        },
        "derive.keyspace_hits": {
          "type": "cumulative",
          "description": "Number of successful lookup of keys in the main dictionary",
          "group": null,
          "included": true
        },
        "derive.keyspace_misses": {
          "type": "cumulative",
          "description": "Number of failed lookup of keys in the main dictionary",
          "group": null,
          "included": true
        },
        "gauge.blocked_clients": {
          "type": "gauge",
          "description": "Number of clients pending on a blocking call",
          "group": null,
          "included": true
        },
        "gauge.changes_since_last_save": {
          "type": "gauge",
          "description": "Number of changes since the last dump",
          "group": null,
          "included": false
        },
        "gauge.client_biggest_input_buf": {
          "type": "gauge",
          "description": "Biggest input buffer among current client connections",
          "group": null,
          "included": false
        },
        "gauge.client_longest_output_list": {
          "type": "gauge",
          "description": "Longest output list among current client connections",
          "group": null,
          "included": false
        },
        "gauge.connected_clients": {
          "type": "gauge",
          "description": "Number of client connections (excluding connections from slaves)",
          "group": null,
          "included": true
        },
        "gauge.connected_slaves": {
          "type": "gauge",
          "description": "Number of connected slaves",
          "group": null,
          "included": false
        },
        "gauge.db0_avg_ttl": {
          "type": "gauge",
          "description": "The average time to live for all keys in redis",
          "group": null,
          "included": false
        },
        "gauge.db0_expires": {
          "type": "gauge",
          "description": "The total number of keys in redis that will expire",
          "group": null,
          "included": false
        },
        "gauge.db0_keys": {
          "type": "gauge",
          "description": "The total number of keys stored in redis",
          "group": null,
          "included": false
        },
        "gauge.instantaneous_ops_per_sec": {
          "type": "gauge",
          "description": "Number of commands processed per second",
          "group": null,
          "included": false
        },
        "gauge.key_llen": {
          "type": "gauge",
          "description": "Length of an list key",
          "group": null,
          "included": false
        },
        "gauge.latest_fork_usec": {
          "type": "gauge",
          "description": "Duration of the latest fork operation in microseconds",
          "group": null,
          "included": false
        },
        "gauge.master_last_io_seconds_ago": {
          "type": "gauge",
          "description": "Number of seconds since the last interaction with master",
          "group": null,
          "included": false
        },
        "gauge.master_repl_offset": {
          "type": "gauge",
          "description": "Master replication offset",
          "group": null,
          "included": true
        },
        "gauge.mem_fragmentation_ratio": {
          "type": "gauge",
          "description": "Ratio between used_memory_rss and used_memory",
          "group": null,
          "included": false
        },
        "gauge.rdb_bgsave_in_progress": {
          "type": "gauge",
          "description": "Flag indicating a RDB save is on-going",
          "group": null,
          "included": false
        },
        "gauge.repl_backlog_first_byte_offset": {
          "type": "gauge",
          "description": "Slave replication backlog offset",
          "group": null,
          "included": false
        },
        "gauge.slave_repl_offset": {
          "type": "gauge",
          "description": "Slave replication offset",
          "group": null,
          "included": true
        },
        "gauge.uptime_in_days": {
          "type": "gauge",
          "description": "Number of days up",
          "group": null,
          "included": false
        },
        "gauge.uptime_in_seconds": {
          "type": "gauge",
          "description": "Number of seconds up",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/redis",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "The name for the node is a canonical identifier which is used as plugin instance. It is limited to 64 characters in length.  (**default**: \"{host}:{port}\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "auth",
            "doc": "Password to use for authentication.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendListLengths",
            "doc": "Specify a pattern of keys to lists for which to send their length as a metric. See below for more details.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "ListLength",
              "doc": "ListLength defines a database index and key pattern for sending list lengths",
              "package": "internal/monitors/collectd/redis",
              "fields": [
                {
                  "yamlName": "databaseIndex",
                  "doc": "The database index.",
                  "default": null,
                  "required": true,
                  "type": "uint16",
                  "elementKind": ""
                },
                {
                  "yamlName": "keyPattern",
                  "doc": "Can be a globbed pattern (only * is supported), in which case all keys matching that glob will be processed.  The pattern should be placed in single quotes (').  Ex. `'mylist*'`",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/signalfx-metadata",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collectd Python plugin that aggregates\nvarious metrics from other collectd plugins.  It also sends host metadata to\nSignalFx through specially formatted events, and sends active process\n(\"top\") lists on a periodic basis.\n\nSee [Python plugin code](https://github.com/signalfx/collectd-signalfx/) and\n[Integrations docs](https://github.com/signalfx/integrations/tree/master/signalfx-metadata).\n",
      "groups": null,
      "metrics": {
        "cpu.utilization": {
          "type": "gauge",
          "description": "Percent of CPU used on this host.",
          "group": null,
          "included": true
        },
        "cpu.utilization_per_core": {
          "type": "gauge",
          "description": "Percent of CPU used on each core. `perCoreCPUUtil` config must be set to true.",
          "group": null,
          "included": false
        },
        "disk.summary_utilization": {
          "type": "gauge",
          "description": "Percent of disk space utilized on all volumes on this host.",
          "group": null,
          "included": true
        },
        "disk.utilization": {
          "type": "gauge",
          "description": "Percent of disk used on this volume.",
          "group": null,
          "included": true
        },
        "disk_ops.total": {
          "type": "cumulative",
          "description": "Total number of disk read and write operations on this host.",
          "group": null,
          "included": true
        },
        "memory.utilization": {
          "type": "gauge",
          "description": "Percent of memory in use on this host.",
          "group": null,
          "included": true
        },
        "network.total": {
          "type": "cumulative",
          "description": "Total amount of inbound and outbound network traffic on this host, in bytes.",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/metadata",
        "fields": [
          {
            "yamlName": "writeServerURL",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "procFSPath",
            "doc": "(Deprecated) Please set the agent configuration `procPath` instead of this monitor configuration option. The path to the proc filesystem. Useful to override in containerized environments.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "etcPath",
            "doc": "(Deprecated) Please set the agent configuration `etcPath` instead of this monitor configuration option. The path to the main host config dir. Useful to override in containerized environments.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "perCoreCPUUtil",
            "doc": "Collect the cpu utilization per core, reported as `cpu.utilization_per_core`.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "persistencePath",
            "doc": "A directory where the metadata plugin can persist the history of successful host metadata syncs so that host metadata is not sent redundantly.",
            "default": "/var/run/signalfx-agent",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "omitProcessInfo",
            "doc": "If true, process \"top\" information will not be sent.  This can be useful if you have an extremely high number of processes and performance of the plugin is poor.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "dogStatsDPort",
            "doc": "Set this to a non-zero value to enable the DogStatsD listener as part of this monitor.  The listener will accept metrics on the DogStatsD format, and sends them as SignalFx datapoints to our backend.  Setting to a value setting the `DogStatsDPort` to `0` will result in a random port assignment. **Note: The listener emits directly to SignalFx and will not be subject to filters configured with the SignalFx Smart Agent.  Internal stats about the SignalFx Smart Agent will not reflect datapoints set through the DogStatsD listener**",
            "default": null,
            "required": false,
            "type": "uint",
            "elementKind": ""
          },
          {
            "yamlName": "token",
            "doc": "This is only required when running the DogStatsD listener.  Set this to your SignalFx access token.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "dogStatsDIP",
            "doc": "Optionally override the default ip that the DogStatsD listener listens on.  (**default**: \"0.0.0.0\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "ingestEndpoint",
            "doc": "This is optional only used when running the DogStatsD listener. By default the DogStatsD listener will emit to SignalFx Ingest. (**default**: \"https://ingest.signalfx.com\")",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "verbose",
            "doc": "Set this to enable verbose logging from the monitor",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/solr",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors Solr instances.\n\nSee https://github.com/signalfx/collectd-solr and\nhttps://github.com/signalfx/integrations/tree/master/collectd-solr\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n- type: collectd/solr\n  host: 127.0.0.1\n  port: 8983\n```\n",
      "groups": null,
      "metrics": {
        "counter.solr.http_2xx_responses": {
          "type": "counter",
          "description": "Total number of 2xx http responses",
          "group": null,
          "included": true
        },
        "counter.solr.http_4xx_responses": {
          "type": "counter",
          "description": "Total number of 4xx http responses",
          "group": null,
          "included": true
        },
        "counter.solr.http_5xx_responses": {
          "type": "counter",
          "description": "Total number of 5xx http responses",
          "group": null,
          "included": true
        },
        "counter.solr.http_requests": {
          "type": "counter",
          "description": "Total number of http requests",
          "group": null,
          "included": true
        },
        "counter.solr.jvm_classes_loaded": {
          "type": "counter",
          "description": "Number of JVM classes loaded",
          "group": null,
          "included": false
        },
        "counter.solr.node_collections_requests": {
          "type": "counter",
          "description": "Number of collection level requets to Solr node",
          "group": null,
          "included": true
        },
        "counter.solr.node_cores_requests": {
          "type": "counter",
          "description": "Number of core level requets to Solr node",
          "group": null,
          "included": true
        },
        "counter.solr.node_metric_request_count": {
          "type": "counter",
          "description": "Number of metric requests",
          "group": null,
          "included": false
        },
        "counter.solr.node_metrics_requests": {
          "type": "counter",
          "description": "Number of metrics level requets to Solr node",
          "group": null,
          "included": true
        },
        "counter.solr.node_zookeeper_requests": {
          "type": "counter",
          "description": "Number of zookeeper level requets to Solr node",
          "group": null,
          "included": true
        },
        "counter.solr.openFileDescriptorCount": {
          "type": "counter",
          "description": "Number of open file descriptors",
          "group": null,
          "included": false
        },
        "counter.solr.replication_handler_requests": {
          "type": "counter",
          "description": "Number of replication handler requets",
          "group": null,
          "included": false
        },
        "counter.solr.search_query_requests": {
          "type": "counter",
          "description": "Number of search query requests",
          "group": null,
          "included": true
        },
        "counter.solr.update_handler_requests": {
          "type": "counter",
          "description": "Number of update handler requets",
          "group": null,
          "included": true
        },
        "counter.solr.zookeeper_errors": {
          "type": "counter",
          "description": "Number of failures/error at Zookeeper",
          "group": null,
          "included": false
        },
        "gauge.solr.core_deleted_docs": {
          "type": "gauge",
          "description": "Number of deleted docs in Solr core",
          "group": null,
          "included": true
        },
        "gauge.solr.core_index_size": {
          "type": "gauge",
          "description": "Size of a core index",
          "group": null,
          "included": true
        },
        "gauge.solr.core_max_docs": {
          "type": "gauge",
          "description": "Total number of docs in Solr core",
          "group": null,
          "included": true
        },
        "gauge.solr.core_num_docs": {
          "type": "gauge",
          "description": "Total number of indexed docs in Solr core",
          "group": null,
          "included": true
        },
        "gauge.solr.core_totalspace": {
          "type": "gauge",
          "description": "Total space allocated for core",
          "group": null,
          "included": true
        },
        "gauge.solr.core_usablespace": {
          "type": "gauge",
          "description": "Usable space available in core",
          "group": null,
          "included": true
        },
        "gauge.solr.document_cache_cumulative_hitratio": {
          "type": "gauge",
          "description": "Cummulative hit ration of document cache",
          "group": null,
          "included": true
        },
        "gauge.solr.field_value_cache_cumulative_hitratio": {
          "type": "gauge",
          "description": "Cummulative hit ration of filed value cache",
          "group": null,
          "included": true
        },
        "gauge.solr.http_active_requests": {
          "type": "gauge",
          "description": "Number of http active requests",
          "group": null,
          "included": false
        },
        "gauge.solr.jetty_get_request_latency": {
          "type": "gauge",
          "description": "Time to process http get request",
          "group": null,
          "included": false
        },
        "gauge.solr.jetty_post_request_latency": {
          "type": "gauge",
          "description": "Time to process http post request",
          "group": null,
          "included": false
        },
        "gauge.solr.jetty_request_latency": {
          "type": "gauge",
          "description": "Http request response time",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_gc_cms_count": {
          "type": "gauge",
          "description": "JVM Garbage Collector - CMS invocation count",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_gc_cms_time": {
          "type": "gauge",
          "description": "JVM Garbage Collector - CMS prcoess time",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_gc_parnew_count": {
          "type": "gauge",
          "description": "JVM Garbage Collector - Parnew invocation count",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_gc_parnew_time": {
          "type": "gauge",
          "description": "JVM Garbage Collector - Parnew process time",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_heap_usage": {
          "type": "gauge",
          "description": "JVM Heap usage",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_mapped_memory_capacity": {
          "type": "gauge",
          "description": "Total JVM mapped memory capacity",
          "group": null,
          "included": false
        },
        "gauge.solr.jvm_mapped_memory_used": {
          "type": "gauge",
          "description": "Total JVM mapped memory used",
          "group": null,
          "included": false
        },
        "gauge.solr.jvm_memory_pools_Code-Cache_usage": {
          "type": "gauge",
          "description": "JVM memory pools - PCode Cache usage",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_memory_pools_Metaspace_usage": {
          "type": "gauge",
          "description": "JVM memory pools - Metaspace usage",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_memory_pools_Par-Eden-Space_usage": {
          "type": "gauge",
          "description": "JVM memory pools - Par Eden space usage",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_memory_pools_Par-Survivor-Space_usage": {
          "type": "gauge",
          "description": "JVM memory pools - Par Survivor space usage",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_total_memory": {
          "type": "gauge",
          "description": "JVM total memory allocated",
          "group": null,
          "included": true
        },
        "gauge.solr.jvm_total_memory_used": {
          "type": "gauge",
          "description": "JVM memory used",
          "group": null,
          "included": true
        },
        "gauge.solr.node_metric_request_time": {
          "type": "gauge",
          "description": "Time to process a metric request",
          "group": null,
          "included": false
        },
        "gauge.solr.query_result_cache_cumulative_hitratio": {
          "type": "gauge",
          "description": "Cummulative hit ration of query cache",
          "group": null,
          "included": true
        },
        "gauge.solr.replication_handler_response": {
          "type": "gauge",
          "description": "Resplication handler response time",
          "group": null,
          "included": false
        },
        "gauge.solr.search_query_response": {
          "type": "gauge",
          "description": "Search query response time",
          "group": null,
          "included": true
        },
        "gauge.solr.searcher_warmup": {
          "type": "gauge",
          "description": "Time to new searcher to warm up",
          "group": null,
          "included": true
        },
        "gauge.solr.shard_cumulative_docs": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gauge.solr.update_request_handler_response": {
          "type": "gauge",
          "description": "Update request handler response time",
          "group": null,
          "included": true
        },
        "gauge.solr.zookeeper_request_time": {
          "type": "gauge",
          "description": "Time to process a request at zookeeper",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/solr",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "cluster",
            "doc": "Cluster name of this solr cluster.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "EnhancedMetrics boolean to indicate whether stats from /metrics are needed",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "includeMetrics",
            "doc": "IncludeMetrics metric names from the /admin/metrics endpoint to include (valid when EnhancedMetrics is \"false\")",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "excludeMetrics",
            "doc": "ExcludeMetrics metric names from the /admin/metrics endpoint to exclude (valid when EnhancedMetrics is \"true\")",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/spark",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects metrics about a Spark cluster using the\n[collectd Spark Python plugin](https://github.com/signalfx/collectd-spark).\nAlso see\nhttps://github.com/signalfx/integrations/tree/master/collectd-spark.\n\nYou have to specify distinct monitor configurations and discovery rules for\nmaster and worker processes.  For the master configuration, set `isMaster`\nto true.\n\nWe only support HTTP endpoints for now.\n\nWhen running Spark on Apache Hadoop / Yarn, this integration is only capable\nof reporting application metrics from the master node.  Please use the\ncollectd/hadoop monitor to report on the health of the cluster.\n\nAn example configuration for monitoring applications on Yarn\n```yaml\nmonitors:\n  - type: collectd/spark\n    host: 000.000.000.000\n    port: 8088\n    clusterType: Yarn\n    isMaster: true\n    collectApplicationMetrics: true\n```\n",
      "groups": null,
      "metrics": {
        "counter.HiveExternalCatalog.counter.HiveClientCalls": {
          "type": "counter",
          "description": "Total number of client calls sent to Hive for query processing",
          "group": null,
          "included": false
        },
        "counter.HiveExternalCatalog.fileCacheHits": {
          "type": "counter",
          "description": "Total number of file level cache hits occurred",
          "group": null,
          "included": false
        },
        "counter.HiveExternalCatalog.filesDiscovered": {
          "type": "counter",
          "description": "Total number of files discovered",
          "group": null,
          "included": false
        },
        "counter.HiveExternalCatalog.parallelListingJobCount": {
          "type": "counter",
          "description": "Total number of Hive-specific jobs running in parallel",
          "group": null,
          "included": false
        },
        "counter.HiveExternalCatalog.partitionsFetched": {
          "type": "counter",
          "description": "Total number of partitions fetched",
          "group": null,
          "included": false
        },
        "counter.spark.driver.completed_tasks": {
          "type": "counter",
          "description": "Total number of completed tasks in driver mapped to a particular application",
          "group": null,
          "included": false
        },
        "counter.spark.driver.disk_used": {
          "type": "counter",
          "description": "Amount of disk used by driver mapped to a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.driver.failed_tasks": {
          "type": "counter",
          "description": "Total number of failed tasks in driver mapped to a particular application",
          "group": null,
          "included": false
        },
        "counter.spark.driver.memory_used": {
          "type": "counter",
          "description": "Amount of memory used by driver mapped to a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.driver.total_duration": {
          "type": "counter",
          "description": "Fraction of time spent by driver mapped to a particular application",
          "group": null,
          "included": false
        },
        "counter.spark.driver.total_input_bytes": {
          "type": "counter",
          "description": "Number of input bytes in driver mapped to a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.driver.total_shuffle_read": {
          "type": "counter",
          "description": "Size read during a shuffle in driver mapped to a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.driver.total_shuffle_write": {
          "type": "counter",
          "description": "Size written to during a shuffle in driver mapped to a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.driver.total_tasks": {
          "type": "counter",
          "description": "Total number of tasks in driver mapped to a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.executor.completed_tasks": {
          "type": "counter",
          "description": "Completed tasks across executors working for a particular application",
          "group": null,
          "included": false
        },
        "counter.spark.executor.disk_used": {
          "type": "counter",
          "description": "Amount of disk used across executors working for a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.executor.failed_tasks": {
          "type": "counter",
          "description": "Failed tasks across executors working for a particular application",
          "group": null,
          "included": false
        },
        "counter.spark.executor.memory_used": {
          "type": "counter",
          "description": "Amount of memory used across executors working for a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.executor.total_duration": {
          "type": "counter",
          "description": "Fraction of time spent across executors working for a particular application",
          "group": null,
          "included": false
        },
        "counter.spark.executor.total_input_bytes": {
          "type": "counter",
          "description": "Number of input bytes across executors working for a particular application",
          "group": null,
          "included": true
        },
        "counter.spark.executor.total_shuffle_read": {
          "type": "counter",
          "description": "Size read during a shuffle in a particular application's executors",
          "group": null,
          "included": true
        },
        "counter.spark.executor.total_shuffle_write": {
          "type": "counter",
          "description": "Size written to during a shuffle in a particular application's executors",
          "group": null,
          "included": true
        },
        "counter.spark.executor.total_tasks": {
          "type": "counter",
          "description": "Total tasks across executors working for a particular application",
          "group": null,
          "included": false
        },
        "counter.spark.streaming.num_processed_records": {
          "type": "counter",
          "description": "Number of processed records in a streaming application",
          "group": null,
          "included": true
        },
        "counter.spark.streaming.num_received_records": {
          "type": "counter",
          "description": "Number of received records in a streaming application",
          "group": null,
          "included": true
        },
        "counter.spark.streaming.num_total_completed_batches": {
          "type": "counter",
          "description": "Number of batches completed in a streaming application",
          "group": null,
          "included": true
        },
        "gauge.jvm.MarkSweepCompact.count": {
          "type": "gauge",
          "description": "Garbage collection count",
          "group": null,
          "included": false
        },
        "gauge.jvm.MarkSweepCompact.time": {
          "type": "gauge",
          "description": "Garbage collection time",
          "group": null,
          "included": false
        },
        "gauge.jvm.heap.committed": {
          "type": "gauge",
          "description": "Amount of committed heap memory (in MB)",
          "group": null,
          "included": true
        },
        "gauge.jvm.heap.used": {
          "type": "gauge",
          "description": "Amount of used heap memory (in MB)",
          "group": null,
          "included": true
        },
        "gauge.jvm.non-heap.committed": {
          "type": "gauge",
          "description": "Amount of committed non-heap memory (in MB)",
          "group": null,
          "included": true
        },
        "gauge.jvm.non-heap.used": {
          "type": "gauge",
          "description": "Amount of used non-heap memory (in MB)",
          "group": null,
          "included": true
        },
        "gauge.jvm.pools.Code-Cache.committed": {
          "type": "gauge",
          "description": "Amount of memory committed for compilation and storage of native code",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Code-Cache.used": {
          "type": "gauge",
          "description": "Amount of memory used to compile and store native code",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Compressed-Class-Space.committed": {
          "type": "gauge",
          "description": "Amount of memory committed for compressing a class object",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Compressed-Class-Space.used": {
          "type": "gauge",
          "description": "Amount of memory used to compress a class object",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Eden-Space.committed": {
          "type": "gauge",
          "description": "Amount of memory committed for the initial allocation of objects",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Eden-Space.used": {
          "type": "gauge",
          "description": "Amount of memory used for the initial allocation of objects",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Metaspace.committed": {
          "type": "gauge",
          "description": "Amount of memory committed for storing classes and classloaders",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Metaspace.used": {
          "type": "gauge",
          "description": "Amount of memory used to store classes and classloaders",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Survivor-Space.committed": {
          "type": "gauge",
          "description": "Amount of memory committed specifically for objects that have survived GC of the Eden Space",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Survivor-Space.used": {
          "type": "gauge",
          "description": "Amount of memory used for objects that have survived GC of the Eden Space",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Tenured-Gen.committed": {
          "type": "gauge",
          "description": "Amount of memory committed to store objects that have lived in the survivor space for a given period of time",
          "group": null,
          "included": false
        },
        "gauge.jvm.pools.Tenured-Gen.used": {
          "type": "gauge",
          "description": "Amount of memory used for objects that have lived in the survivor space for a given period of time",
          "group": null,
          "included": false
        },
        "gauge.jvm.total.committed": {
          "type": "gauge",
          "description": "Amount of committed JVM memory (in MB)",
          "group": null,
          "included": true
        },
        "gauge.jvm.total.used": {
          "type": "gauge",
          "description": "Amount of used JVM memory (in MB)",
          "group": null,
          "included": true
        },
        "gauge.master.aliveWorkers": {
          "type": "gauge",
          "description": "Total functioning workers",
          "group": null,
          "included": true
        },
        "gauge.master.apps": {
          "type": "gauge",
          "description": "Total number of active applications in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.master.waitingApps": {
          "type": "gauge",
          "description": "Total number of waiting applications in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.master.workers": {
          "type": "gauge",
          "description": "Total number of workers in spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.driver.active_tasks": {
          "type": "gauge",
          "description": "Total number of active tasks in driver mapped to a particular application",
          "group": null,
          "included": false
        },
        "gauge.spark.driver.max_memory": {
          "type": "gauge",
          "description": "Maximum memory used by driver mapped to a particular application",
          "group": null,
          "included": true
        },
        "gauge.spark.driver.rdd_blocks": {
          "type": "gauge",
          "description": "Number of RDD blocks in the driver mapped to a particular application",
          "group": null,
          "included": false
        },
        "gauge.spark.executor.active_tasks": {
          "type": "gauge",
          "description": "Total number of active tasks across all executors working for a particular application",
          "group": null,
          "included": false
        },
        "gauge.spark.executor.count": {
          "type": "gauge",
          "description": "Total number of executors performing for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.executor.max_memory": {
          "type": "gauge",
          "description": "Max memory across all executors working for a particular application",
          "group": null,
          "included": true
        },
        "gauge.spark.executor.rdd_blocks": {
          "type": "gauge",
          "description": "Number of RDD blocks across all executors working for a particular application",
          "group": null,
          "included": false
        },
        "gauge.spark.job.num_active_stages": {
          "type": "gauge",
          "description": "Total number of active stages for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.job.num_active_tasks": {
          "type": "gauge",
          "description": "Total number of active tasks for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.job.num_completed_stages": {
          "type": "gauge",
          "description": "Total number of completed stages for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.job.num_completed_tasks": {
          "type": "gauge",
          "description": "Total number of completed tasks for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.job.num_failed_stages": {
          "type": "gauge",
          "description": "Total number of failed stages for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.job.num_failed_tasks": {
          "type": "gauge",
          "description": "Total number of failed tasks for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.job.num_skipped_stages": {
          "type": "gauge",
          "description": "Total number of skipped stages for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.job.num_skipped_tasks": {
          "type": "gauge",
          "description": "Total number of skipped tasks for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.job.num_tasks": {
          "type": "gauge",
          "description": "Total number of tasks for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.num_active_stages": {
          "type": "gauge",
          "description": "Total number of active stages for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.num_running_jobs": {
          "type": "gauge",
          "description": "Total number of running jobs for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.stage.disk_bytes_spilled": {
          "type": "gauge",
          "description": "Actual size written to disk for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.stage.executor_run_time": {
          "type": "gauge",
          "description": "Fraction of time spent by (and averaged across) executors for a particular application",
          "group": null,
          "included": true
        },
        "gauge.spark.stage.input_bytes": {
          "type": "gauge",
          "description": "Input size for a particular application",
          "group": null,
          "included": true
        },
        "gauge.spark.stage.input_records": {
          "type": "gauge",
          "description": "Input records received for a particular application",
          "group": null,
          "included": true
        },
        "gauge.spark.stage.memory_bytes_spilled": {
          "type": "gauge",
          "description": "Size spilled to disk from memory for an active application in the spark cluster",
          "group": null,
          "included": true
        },
        "gauge.spark.stage.output_bytes": {
          "type": "gauge",
          "description": "Output size for a particular application",
          "group": null,
          "included": true
        },
        "gauge.spark.stage.output_records": {
          "type": "gauge",
          "description": "Output records written to for a particular application",
          "group": null,
          "included": true
        },
        "gauge.spark.stage.shuffle_read_bytes": {
          "type": "gauge",
          "description": "Read size during shuffle phase for a particular application",
          "group": null,
          "included": false
        },
        "gauge.spark.stage.shuffle_read_records": {
          "type": "gauge",
          "description": "Number of records read during shuffle phase for a particular application",
          "group": null,
          "included": false
        },
        "gauge.spark.stage.shuffle_write_bytes": {
          "type": "gauge",
          "description": "Size written during shuffle phase for a particular application",
          "group": null,
          "included": false
        },
        "gauge.spark.stage.shuffle_write_records": {
          "type": "gauge",
          "description": "Number of records written to during shuffle phase for a particular application",
          "group": null,
          "included": false
        },
        "gauge.spark.streaming.avg_input_rate": {
          "type": "gauge",
          "description": "Average input rate of records across retained batches in a streaming application",
          "group": null,
          "included": true
        },
        "gauge.spark.streaming.avg_processing_time": {
          "type": "gauge",
          "description": "Average processing time in a streaming application",
          "group": null,
          "included": true
        },
        "gauge.spark.streaming.avg_scheduling_delay": {
          "type": "gauge",
          "description": "Average scheduling delay in a streaming application",
          "group": null,
          "included": true
        },
        "gauge.spark.streaming.avg_total_delay": {
          "type": "gauge",
          "description": "Average total delay in a streaming application",
          "group": null,
          "included": true
        },
        "gauge.spark.streaming.num_active_batches": {
          "type": "gauge",
          "description": "Number of active batches in a streaming application",
          "group": null,
          "included": true
        },
        "gauge.spark.streaming.num_inactive_receivers": {
          "type": "gauge",
          "description": "Number of inactive receivers in a streaming application",
          "group": null,
          "included": true
        },
        "gauge.worker.coresFree": {
          "type": "gauge",
          "description": "Total cores free for a particular worker process",
          "group": null,
          "included": true
        },
        "gauge.worker.coresUsed": {
          "type": "gauge",
          "description": "Total cores used by a particular worker process",
          "group": null,
          "included": true
        },
        "gauge.worker.executors": {
          "type": "gauge",
          "description": "Total number of executors for a particular worker process",
          "group": null,
          "included": true
        },
        "gauge.worker.memFree_MB": {
          "type": "gauge",
          "description": "Total memory free for a particular worker process",
          "group": null,
          "included": true
        },
        "gauge.worker.memUsed_MB": {
          "type": "gauge",
          "description": "Memory used by a particular worker process",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/spark",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "isMaster",
            "doc": "Set to `true` when monitoring a master Spark node",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "clusterType",
            "doc": "Should be one of `Standalone` or `Mesos` or `Yarn`.  Cluster metrics will not be collected on Yarn.  Please use the collectd/hadoop monitor to gain insights to your cluster's health.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "collectApplicationMetrics",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/statsd",
      "sendAll": true,
      "dimensions": null,
      "doc": "The StatsD plugin for collectd listens for StatsD\nevents, aggregates them and transmits them according to collectd's\nconfiguration. Use this plugin to send data from StatsD to SignalFx [statsd\nplugin](https://collectd.org/wiki/index.php/Plugin:StatsD).\n\nSignalFx supports `Counter`, `Timer` and `Gauge` types which are dispatched\nas the collectd types - `derive`, `latency` and `gauge` respectively.\nIn SignalFx, for a statsd metric, its collectd type is attached as a\nprefix to the metric name. As an example, if you send in the gauge -\n\n```\n$ echo \"statsd.test:1|g\" | nc -w 1 -u 127.0.0.1 8125\n```\n\nThis will be reported to SignalFx as \"gauge.statsd.test\"\n\n### USAGE\n\n#### Adding dimensions to StatsD metrics\n\nAdd dimensions to your metrics by adding key-value pairs to your StatsD\nmetric names as follows:\n\n```\n$ echo \"statsd.[foo=bar,dim=val]test:1|g\" | nc -w 1 -u 127.0.0.1 8125\n```\n\nThis creates a metric called `statsd.test` of type gauge, with dimensions\n`foo=bar` and `dim=val`.\n\n#### Delete[Type]s boolean setting\n\nThese options control what happens if metrics are not updated in an\ninterval. If set to False, the default, metrics are dispatched unchanged,\ni.e. the rate of counters and size of sets will be zero, timers report NaN\nand gauges are unchanged. If set to True, the such metrics are not\ndispatched and removed from the internal cache.\n\nSignalFx's default configuration for this plugin sets all `Delete[Type]s`\nconfiguration options to `True`. We strongly recommend this in order to\nensure that metrics that have stopped reporting are not reported as 0 in\nperpetuity. Setting these parameters to `False` results in collectd's memory\nusage increasing over time, as the set of metrics reported from StatsD grows\nindefinitely. This is especially important in environments that are\nlong-running or whose metrics change frequently.\n\n#### CounterSum boolean setting\n\nWhen enabled, creates a count metric which reports the change since the last\nread. This option primarily exists for compatibility with the statsd\nimplementation by Etsy.\n\nIf you are only looking at the counts generated by each reporting interval,\nequivalent to\n[Counters](https://docs.signalfx.com/en/latest/concepts/metric-types.html?highlight=Counters)\nin SignalFx then we'd recommend that you set CounterSum to `True`. It will\nsend in an additional counter metric with a prefix of `count`.\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: collectd/statsd\n   listenAddress: \"0.0.0.0\"\n   listenPort: 8125\n   deleteSets: true\n   timerPercentile: 90.0\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/statsd",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host/address on which to bind the UDP listener that accepts statsd datagrams",
            "default": "localhost",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "listenPort",
            "doc": "The port on which to listen for statsd messages",
            "default": 8125,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "deleteSets",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteCounters",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteTimers",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteGauges",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timerPercentile",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "float64",
            "elementKind": ""
          },
          {
            "yamlName": "timerUpper",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timerCount",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timerSum",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "timerLower",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "counterSum",
            "doc": "",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/systemd",
      "sendAll": true,
      "dimensions": {
        "plugin": {
          "description": "The name of the collectd plugin. Facilitates filtering operations in the SignalFx app"
        },
        "systemd_service": {
          "description": "The name of the systemd service that the reported metric applies to"
        }
      },
      "doc": "This [SignalFx Smart Agent](https://github.com/signalfx/signalfx-agent) monitor collects metrics about the state of\nconfigured systemd services using the [collectd-systemd](https://github.com/signalfx/collectd-systemd)\nplugin. A service is in the state that a metric represents if the metric value is 1 and not in that state if the\nmetric value is 0. The name of the service that the metric is reporiting about is assigned to dimension\n`systemd_service`.\n\nThe collectd-systemd plugin reads the status of systemd services from host location `/var/run/dbus/system_bus_socket`.\nThis means that the host location must be mounted to the container in which the SignalFx Smart Agent is running.\nThe agent container must also run in privilege mode. Below is an excerpt of the docker run command.\n```yaml\ndocker run ...\\\n  --privileged \\\n  -v /var/run/dbus/system_bus_socket:/var/run/dbus/system_bus_socket:ro \\\n...\n```\nBelow is a sample SignalFx Smart Agent YAML configuration for monitoring the state of `docker` and `ubuntu-fan`\nservices. See [here](https://github.com/signalfx/signalfx-agent#configuration) for SignalFx Smart Agent\nconfiguration details.\n```yaml\nmonitors:\n- type: collectd/systemd\n  intervalSeconds: 10\n  services:\n    - docker\n    - ubuntu-fan\n```\nOnly the metric `gauge.substate.running`, which indicates whether a service is running or not, gets reported by default.\nThe other metrics must be configure explicitly using the `sendActiveState`, `sendSubState` and `sendLoadState`\nconfiguration flags (see below). The metrics are grouped into `ActiveState`, `SubState` and `LoadState` groups.\n```\nmonitors:\n- type: collectd/systemd\n  intervalSeconds: 10\n  services:\n    - docker\n    - ubuntu-fan\n  sendActiveState: true\n```\n",
      "groups": {
        "ActiveState": {
          "description": "Metrics which indicate whether a service is currently active or not"
        },
        "LoadState": {
          "description": "Metrics which indicate whether a service's unit configuration file has been loaded"
        },
        "SubState": {
          "description": "Metrics which provide further clarification of a service's active state"
        }
      },
      "metrics": {
        "gauge.active_state.activating": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service has previously been inactive but is currently in the process of entering an active state",
          "group": null,
          "included": false
        },
        "gauge.active_state.active": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is active",
          "group": null,
          "included": false
        },
        "gauge.active_state.deactivating": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is currently in the process of deactivation",
          "group": null,
          "included": false
        },
        "gauge.active_state.failed": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is inactive the previous run was not successful",
          "group": null,
          "included": false
        },
        "gauge.active_state.inactive": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is inactive and the previous run was successful or no previous run has taken place yet",
          "group": null,
          "included": false
        },
        "gauge.active_state.reloading": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is active and currently reloading its configuration",
          "group": null,
          "included": false
        },
        "gauge.load_state.error": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service configuration failed to load",
          "group": null,
          "included": false
        },
        "gauge.load_state.loaded": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service configuration was loaded and parsed successfully",
          "group": null,
          "included": false
        },
        "gauge.load_state.masked": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is currently masked out (i.e. symlinked to /dev/null etc)",
          "group": null,
          "included": false
        },
        "gauge.load_state.not-found": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service configuration was not found",
          "group": null,
          "included": false
        },
        "gauge.substate.dead": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service died",
          "group": null,
          "included": false
        },
        "gauge.substate.exited": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service exited",
          "group": null,
          "included": false
        },
        "gauge.substate.failed": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service failed",
          "group": null,
          "included": false
        },
        "gauge.substate.running": {
          "type": "gauge",
          "description": "Indicates that the systemd unit/service is running",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/systemd",
        "fields": [
          {
            "yamlName": "services",
            "doc": "Systemd services to report on",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "sendActiveState",
            "doc": "Flag for sending metrics about the state of systemd services",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "sendSubState",
            "doc": "Flag for sending more detailed metrics about the state of systemd services",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "sendLoadState",
            "doc": "Flag for sending metrics about the load state of systemd services",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "collectd/uptime",
      "sendAll": false,
      "dimensions": null,
      "doc": "Sends a single metric of the total number of\nseconds the host has been up, using the [collectd uptime\nplugin](https://collectd.org/wiki/index.php/Plugin:Uptime).\n",
      "groups": null,
      "metrics": {
        "uptime": {
          "type": "gauge",
          "description": "Seconds since system boot",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/uptime",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/vmem",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects information about the virtual memory\nsubsystem of the kernel using the [collectd vmem\nplugin](https://collectd.org/wiki/index.php/Plugin:vmem).  There is no\nconfiguration available for this plugin.\n",
      "groups": null,
      "metrics": {
        "vmpage_faults.majflt": {
          "type": "cumulative",
          "description": "Number of major page faults on the system",
          "group": null,
          "included": false
        },
        "vmpage_faults.minflt": {
          "type": "cumulative",
          "description": "Number of minor page faults on the system",
          "group": null,
          "included": false
        },
        "vmpage_io.memory.in": {
          "type": "cumulative",
          "description": "Page Ins for Memory",
          "group": null,
          "included": false
        },
        "vmpage_io.memory.out": {
          "type": "cumulative",
          "description": "Page Outs for Memory",
          "group": null,
          "included": false
        },
        "vmpage_io.swap.in": {
          "type": "cumulative",
          "description": "Page Ins for Swap",
          "group": null,
          "included": true
        },
        "vmpage_io.swap.out": {
          "type": "cumulative",
          "description": "Page Outs for Swap",
          "group": null,
          "included": true
        },
        "vmpage_number.free_pages": {
          "type": "cumulative",
          "description": "Number of free memory pages",
          "group": null,
          "included": false
        },
        "vmpage_number.mapped": {
          "type": "cumulative",
          "description": "Number of mapped pages",
          "group": null,
          "included": false
        },
        "vmpage_number.shmem_pmdmapped": {
          "type": "gauge",
          "description": "The amount of shared (shmem/tmpfs) memory backed by huge pages",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/vmem",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "collectd/zookeeper",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitors an Apache Zookeeper instance.\n\nSee the [Python plugin\nsource](https://github.com/signalfx/collectd-zookeeper) and the\n[integrations repo\npage](https://github.com/signalfx/integrations/tree/master/collectd-zookeeper)\nfor more information.\n",
      "groups": null,
      "metrics": {
        "counter.zk_fsync_threshold_exceed_count": {
          "type": "cumulative",
          "description": "Number of times fsync duration has exceeded warning threshold",
          "group": null,
          "included": false
        },
        "counter.zk_packets_received": {
          "type": "cumulative",
          "description": "Count of the number of ZooKeeper packets received by a server",
          "group": null,
          "included": true
        },
        "counter.zk_packets_sent": {
          "type": "cumulative",
          "description": "Count of the number of ZooKeeper packets sent from a server",
          "group": null,
          "included": true
        },
        "gauge.zk_approximate_data_size": {
          "type": "gauge",
          "description": "Size of data in bytes that a ZooKeeper server has in its data tree",
          "group": null,
          "included": true
        },
        "gauge.zk_avg_latency": {
          "type": "gauge",
          "description": "Average time in milliseconds for requests to be processed",
          "group": null,
          "included": true
        },
        "gauge.zk_ephemerals_count": {
          "type": "gauge",
          "description": "Number of ephemeral nodes that a ZooKeeper server has in its data tree",
          "group": null,
          "included": true
        },
        "gauge.zk_is_leader": {
          "type": "gauge",
          "description": "1 if the node is a leader, 0 if the node is a follower",
          "group": null,
          "included": false
        },
        "gauge.zk_max_file_descriptor_count": {
          "type": "gauge",
          "description": "Maximum number of file descriptors that a ZooKeeper server can open",
          "group": null,
          "included": true
        },
        "gauge.zk_max_latency": {
          "type": "gauge",
          "description": "Maximum time in milliseconds for a request to be processed",
          "group": null,
          "included": false
        },
        "gauge.zk_min_latency": {
          "type": "gauge",
          "description": "Minimum time in milliseconds for a request to be processed",
          "group": null,
          "included": false
        },
        "gauge.zk_num_alive_connections": {
          "type": "gauge",
          "description": "Number of active clients connected to a ZooKeeper server",
          "group": null,
          "included": true
        },
        "gauge.zk_open_file_descriptor_count": {
          "type": "gauge",
          "description": "Number of file descriptors that a ZooKeeper server has open",
          "group": null,
          "included": true
        },
        "gauge.zk_outstanding_requests": {
          "type": "gauge",
          "description": "Number of currently executing requests",
          "group": null,
          "included": false
        },
        "gauge.zk_service_health": {
          "type": "gauge",
          "description": "1 if server is running, otherwise 0",
          "group": null,
          "included": false
        },
        "gauge.zk_watch_count": {
          "type": "gauge",
          "description": "Number of watches placed on Z-Nodes on a ZooKeeper server",
          "group": null,
          "included": true
        },
        "gauge.zk_znode_count": {
          "type": "gauge",
          "description": "Number of z-nodes that a ZooKeeper server has in its data tree",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config is the monitor-specific config with the generic config embedded",
        "package": "internal/monitors/collectd/zookeeper",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "conviva",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor uses version 2.4 of the Conviva Experience Insights REST APIs to pull\n`Real-Time/Live` video playing experience metrics from Conviva.\n\nOnly `Live` conviva metrics listed\n[here](https://community.conviva.com/site/global/apis_data/experience_insights_api/index.gsp#metrics)\nare supported. All metrics are gauges. The Conviva metrics are converted to SignalFx metrics with dimensions\nnamed account and filter. The account dimension is the name of the Conviva account and the filter dimension\nis the name of the Conviva filter applied to the metric. In the case of MetricLenses, the constituent\nMetricLens metrics and MetricLens dimensions are included. The values of the MetricLens dimensions are\nderived from the values of the associated MetricLens dimension entities.\n\nBelow is a sample YAML configuration showing the most basic configuration of the Conviva monitor\nusing only the required fields. For this configuration the monitor will default to fetching quality MetricLens\nmetrics for all dimensions from the default Conviva account using the `All Traffic` filter.\n\n```\nmonitors:\n- type: conviva\n pulseUsername: \u003cusername\u003e\n pulsePassword: \u003cpassword\u003e\n```\n\nIndividual metrics are configured as a list of metricConfigs as shown in sample configuration below. The\nmetrics a fetched using the specified metricParameter. Find the list of metric parameters\n[here](https://github.com/signalfx/integrations/blob/master/conviva/docs/conviva_metrics.md).\nThe Conviva metrics reported to SignalFx are prefixed by `conviva.`, `conviva.quality_metriclens.` and\n`conviva.audience_metriclens.` accordingly. The metric names are the `titles` of the metrics\n[here](https://github.com/signalfx/integrations/tree/master/conviva/docs) which correspond to the Conviva\n`metric parameters` [here](https://community.conviva.com/site/global/apis_data/experience_insights_api/index.gsp#metrics).\nWhere an account is not provided the default account is fetched and used. Where no filters are specified the\n`All Traffic` filter is used. Where MetricLens dimensions are not specified all MetricLens dimensions\nare fetched and used. The `_ALL_` keyword means all. MetricLens dimension configuration applies only to MetricLenses.\nIf specified for a regular metric they will be ignored. MetricLens dimensions listed in `excludeMetricLensDimensions`\nwill be excluded.\n\n```\nmonitors:\n- type: conviva\n pulseUsername: \u003cusername\u003e\n pulsePassword: \u003cpassword\u003e\n metricConfigs:\n   - account: c3.NBC\n     metricParameter: quality_metriclens\n     filters:\n       - All Traffic\n     metricLensDimensions:\n       - Cities\n   - metricParameter: avg_bitrate\n     maxFiltersPerRequest: 99\n     filters:\n       - _ALL_\n   - metricParameter: concurrent_plays\n   - metricParameter: audience_metriclens\n     filters:\n       - All Traffic\n     metricLensDimensions:\n       - _ALL_\n     excludeMetricLensDimensions:\n       - CDNs\n```\n\nAdd the extra dimension metric_source as shown in sample configuration below for the convenience of searching\nfor your metrics in SignalFx using the metric_source value you specify. Also, version 2.4 of the Conviva Experience\nInsights REST APIs limits the number of filters per request to 99. Specify the maximum number of filters per request\nusing `maxFiltersPerRequest` as shown in the example above in order to limit the number of filters per request.\n\n```\nmonitors:\n- type: conviva\n pulseUsername: \u003cusername\u003e\n pulsePassword: \u003cpassword\u003e\n extraDimensions:\n   metric_source: conviva\n```\n",
      "groups": null,
      "metrics": {
        "conviva.attempts": {
          "type": "gauge",
          "description": "Attempts time-series",
          "group": "attempts",
          "included": true
        },
        "conviva.audience_metriclens.concurrent_plays": {
          "type": "gauge",
          "description": "Concurrent Plays",
          "group": "audience_metriclens",
          "included": true
        },
        "conviva.audience_metriclens.ended_plays": {
          "type": "gauge",
          "description": "Ended Plays",
          "group": "audience_metriclens",
          "included": true
        },
        "conviva.audience_metriclens.plays": {
          "type": "gauge",
          "description": "Plays",
          "group": "audience_metriclens",
          "included": true
        },
        "conviva.avg_bitrate": {
          "type": "gauge",
          "description": "Average bitrate time-series",
          "group": "avg_bitrate",
          "included": true
        },
        "conviva.concurrent_plays": {
          "type": "gauge",
          "description": "Concurrent plays time-series",
          "group": "concurrent_plays",
          "included": true
        },
        "conviva.connection_induced_rebuffering_ratio": {
          "type": "gauge",
          "description": "Connection induced rebuffering ratio simple-series",
          "group": "connection_induced_rebuffering_ratio",
          "included": true
        },
        "conviva.connection_induced_rebuffering_ratio_timeseries": {
          "type": "gauge",
          "description": "Connection induced rebuffering ratio time-series",
          "group": "connection_induced_rebuffering_ratio_timeseries",
          "included": true
        },
        "conviva.duration_connection_induced_rebuffering_ratio_distribution": {
          "type": "gauge",
          "description": "Duration vs. connection induced rebuffering ratio distribution label-series",
          "group": "duration_connection_induced_rebuffering_ratio_distribution",
          "included": true
        },
        "conviva.ended_plays": {
          "type": "gauge",
          "description": "Ended plays simple-series",
          "group": "ended_plays",
          "included": true
        },
        "conviva.ended_plays_timeseries": {
          "type": "gauge",
          "description": "Ended plays time-series",
          "group": "ended_plays_timeseries",
          "included": true
        },
        "conviva.exits_before_video_start": {
          "type": "gauge",
          "description": "Exits before video start time-series",
          "group": "exits_before_video_start",
          "included": true
        },
        "conviva.play_bitrate_distribution": {
          "type": "gauge",
          "description": "Play bitrate distribution label-series",
          "group": "play_bitrate_distribution",
          "included": true
        },
        "conviva.play_buffering_ratio_distribution": {
          "type": "gauge",
          "description": "Play buffering ratio distribution label-series",
          "group": "play_buffering_ratio_distribution",
          "included": true
        },
        "conviva.play_connection_induced_rebuffering_ratio_distribution": {
          "type": "gauge",
          "description": "Play connection induced rebuffering ratio distribution label-series",
          "group": "play_connection_induced_rebuffering_ratio_distribution",
          "included": true
        },
        "conviva.plays": {
          "type": "gauge",
          "description": "Plays time-series",
          "group": "plays",
          "included": true
        },
        "conviva.quality_metriclens.average_bitrate_kbps": {
          "type": "gauge",
          "description": "Average Bitrate (bps). This metric can be returned in kbps with the ab_units=kbps parameter. Unless this parameter is specified, average bitrate is bps",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.connection_induced_rebuffering_ratio_percent": {
          "type": "gauge",
          "description": "Connection Induced ReBuffering Ratio (%)",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.ended_plays": {
          "type": "gauge",
          "description": "Ended Plays",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.exits_before_video_start_percent": {
          "type": "gauge",
          "description": "Exits Before Video Starts (EBVS) (%)",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.plays_percent": {
          "type": "gauge",
          "description": "Plays (%)",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.rebuffering_ratio_percent": {
          "type": "gauge",
          "description": "Rebuffering Ratio (%)",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.total_attempts": {
          "type": "gauge",
          "description": "Attempts",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.video_playback_failures_percent": {
          "type": "gauge",
          "description": "Video Playback Failures (%)",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.video_restart_time": {
          "type": "gauge",
          "description": "Video Restart Time",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.video_start_failures_percent": {
          "type": "gauge",
          "description": "Video Start Failures(VSF) (%)",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_metriclens.video_startup_time_sec": {
          "type": "gauge",
          "description": "Video Startup Time (sec)",
          "group": "quality_metriclens",
          "included": true
        },
        "conviva.quality_summary": {
          "type": "gauge",
          "description": "Quality summary label-series",
          "group": "quality_summary",
          "included": true
        },
        "conviva.rebuffered_plays": {
          "type": "gauge",
          "description": "Rebuffered plays time-series",
          "group": "rebuffered_plays",
          "included": true
        },
        "conviva.rebuffering_ratio": {
          "type": "gauge",
          "description": "Rebuffering ratio time-series",
          "group": "rebuffering_ratio",
          "included": true
        },
        "conviva.top_assets_15_mins": {
          "type": "gauge",
          "description": "Top assets over last 15 minutes simple-table",
          "group": "top_assets_15_mins",
          "included": true
        },
        "conviva.top_assets_summary": {
          "type": "gauge",
          "description": "Top assets summary label-series",
          "group": "top_assets_summary",
          "included": true
        },
        "conviva.video_playback_failures": {
          "type": "gauge",
          "description": "Video playback failures simple-series",
          "group": "video_playback_failures",
          "included": true
        },
        "conviva.video_playback_failures_distribution": {
          "type": "gauge",
          "description": "Video playback failures distribution label-series",
          "group": "video_playback_failures_distribution",
          "included": true
        },
        "conviva.video_playback_failures_timeseries": {
          "type": "gauge",
          "description": "Video playback failures time-series",
          "group": "video_playback_failures_timeseries",
          "included": true
        },
        "conviva.video_restart_time": {
          "type": "gauge",
          "description": "Video restart time simple-series",
          "group": "video_restart_time",
          "included": true
        },
        "conviva.video_restart_time_distribution": {
          "type": "gauge",
          "description": "Video restart time distribution label-series",
          "group": "video_restart_time_distribution",
          "included": true
        },
        "conviva.video_restart_time_timeseries": {
          "type": "gauge",
          "description": "Video restart time time-series",
          "group": "video_restart_time_timeseries",
          "included": true
        },
        "conviva.video_start_failures": {
          "type": "gauge",
          "description": "Video start failures time-series",
          "group": "video_start_failures",
          "included": true
        },
        "conviva.video_start_failures_errornames": {
          "type": "gauge",
          "description": "Video start failures by error names simple-table",
          "group": "video_start_failures_errornames",
          "included": true
        },
        "conviva.video_startup_time": {
          "type": "gauge",
          "description": "Video startup time label-series",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/conviva",
        "fields": [
          {
            "yamlName": "pulseUsername",
            "doc": "Conviva Pulse username required with each API request.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pulsePassword",
            "doc": "Conviva Pulse password required with each API request.",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "timeoutSeconds",
            "doc": "",
            "default": 10,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "metricConfigs",
            "doc": "Conviva metrics to fetch. The default is quality_metriclens metric with the \"All Traffic\" filter applied and all quality_metriclens dimensions.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "metricConfig",
              "doc": "metricConfig for configuring individual metric",
              "package": "internal/monitors/conviva",
              "fields": [
                {
                  "yamlName": "account",
                  "doc": "Conviva customer account name. The default account is fetched used if not specified.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "metricParameter",
                  "doc": "",
                  "default": "quality_metriclens",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "filters",
                  "doc": "Filter names. The default is `All Traffic` filter",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "metricLensDimensions",
                  "doc": "MetricLens dimension names. The default is names of all MetricLens dimensions of the account",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "excludeMetricLensDimensions",
                  "doc": "MetricLens dimension names to exclude.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "maxFiltersPerRequest",
                  "doc": "Max number of filters per request. The default is the number of filters. Multiple requests are made if the number of filters is more than maxFiltersPerRequest",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "cpu",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports cpu metrics.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: cpu\n```\n",
      "groups": null,
      "metrics": {
        "cpu.utilization": {
          "type": "gauge",
          "description": "Percent of CPU used on this host. This metric is emitted with a plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "included": true
        },
        "cpu.utilization_per_core": {
          "type": "gauge",
          "description": "Percent of CPU used on each core. This metric is emitted with the plugin dimension set to \"signalfx-metadata\"",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/cpu",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "disk-io",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reports I/O metrics about disks.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: disk-io\n```\n",
      "groups": null,
      "metrics": {
        "disk_merged.read": {
          "type": "cumulative",
          "description": "(Linux Only) The number of disk reads merged into single physical disk access operations.",
          "group": null,
          "included": false
        },
        "disk_merged.write": {
          "type": "cumulative",
          "description": "(Linux Only) The number of disk writes merged into single physical disk access operations.",
          "group": null,
          "included": false
        },
        "disk_octets.avg_read": {
          "type": "gauge",
          "description": "(Windows Only) The average number of octets (bytes) read.",
          "group": null,
          "included": false
        },
        "disk_octets.avg_write": {
          "type": "gauge",
          "description": "(Windows Only) The average number of octets (bytes) written.",
          "group": null,
          "included": false
        },
        "disk_octets.read": {
          "type": "cumulative",
          "description": "(Linux Only) The number of bytes (octets) read from a disk.",
          "group": null,
          "included": false
        },
        "disk_octets.write": {
          "type": "cumulative",
          "description": "(Linux Only) The number of bytes (octets) written to a disk.",
          "group": null,
          "included": false
        },
        "disk_ops.avg_read": {
          "type": "gauge",
          "description": "(Windows Only) The average disk read queue length.",
          "group": null,
          "included": false
        },
        "disk_ops.avg_write": {
          "type": "gauge",
          "description": "(Windows Only) The average disk write queue length.",
          "group": null,
          "included": false
        },
        "disk_ops.read": {
          "type": "cumulative",
          "description": "(Linux Only) The number of disk read operations.",
          "group": null,
          "included": true
        },
        "disk_ops.write": {
          "type": "cumulative",
          "description": "(Linux Only) The number of disk write operations.",
          "group": null,
          "included": true
        },
        "disk_time.avg_read": {
          "type": "gauge",
          "description": "(Windows Only) The average time spent reading from the disk.",
          "group": null,
          "included": false
        },
        "disk_time.avg_write": {
          "type": "gauge",
          "description": "(Windows Only) The average time spent writing to the disk",
          "group": null,
          "included": false
        },
        "disk_time.read": {
          "type": "cumulative",
          "description": "(Linux Only) The average amount of time it took to do a read operation.",
          "group": null,
          "included": false
        },
        "disk_time.write": {
          "type": "cumulative",
          "description": "(Linux Only) The average amount of time it took to do a write operation.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/diskio",
        "fields": [
          {
            "yamlName": "disks",
            "doc": "The devices to include/exclude. This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters).",
            "default": [
              "*",
              "!/^loop[0-9]+$/",
              "!/^dm-[0-9]+$/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) The frequency that wildcards in counter paths should be expanded and how often to refresh counters from configuration. This is expressed as a duration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "docker-container-stats",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reads container stats from a\nDocker API server.  It is meant as a metric-compatible replacement of our\n[docker-collectd](https://github.com/signalfx/docker-collectd-plugin)\nplugin, which scales rather poorly against a large number of containers.\n\nThis currently does not support CPU share/quota metrics.\n\nFor more information on block IO metrics, see [the Linux cgroup block io\ncontroller\ndoc](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).\n\nIf you are running the agent directly on a host (outside of a container\nitself) and you are using the default Docker UNIX socket URL, you will\nprobably need to add the `signalfx-agent` user to the `docker` group in\norder to have permission to access the Docker API via the socket.\n\nRequires Docker API version 1.22+.\n",
      "groups": {
        "blkio": {
          "description": "BlockIO metrics"
        },
        "cpu": {
          "description": "CPU metrics"
        },
        "memory": {
          "description": "Memory metrics"
        },
        "network": {
          "description": "Network metrics"
        }
      },
      "metrics": {
        "blkio.io_merged_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_merged_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_merged_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_merged_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_merged_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_queue_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_queue_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_queue_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_queue_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_queue_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_bytes_recursive.async": {
          "type": "cumulative",
          "description": "Volume, in bytes, of asynchronous block I/O",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_bytes_recursive.read": {
          "type": "cumulative",
          "description": "Volume, in bytes, of reads from block devices",
          "group": "blkio",
          "included": true
        },
        "blkio.io_service_bytes_recursive.sync": {
          "type": "cumulative",
          "description": "Volume, in bytes, of synchronous block I/O",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_bytes_recursive.total": {
          "type": "cumulative",
          "description": "Total volume, in bytes, of all block I/O",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_bytes_recursive.write": {
          "type": "cumulative",
          "description": "Volume, in bytes, of writes to block devices",
          "group": "blkio",
          "included": true
        },
        "blkio.io_service_time_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_time_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_time_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_time_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_time_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.async": {
          "type": "cumulative",
          "description": "Number of asynchronous block I/O requests",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.read": {
          "type": "cumulative",
          "description": "Number of reads requests from block devices",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.sync": {
          "type": "cumulative",
          "description": "Number of synchronous block I/O requests",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.total": {
          "type": "cumulative",
          "description": "Total number of block I/O requests",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.write": {
          "type": "cumulative",
          "description": "Number of write requests to block devices",
          "group": "blkio",
          "included": false
        },
        "blkio.io_time_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_time_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_time_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_time_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_time_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_wait_time_recursive.async": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_wait_time_recursive.read": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_wait_time_recursive.sync": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_wait_time_recursive.total": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "blkio.io_wait_time_recursive.write": {
          "type": "cumulative",
          "description": "",
          "group": "blkio",
          "included": false
        },
        "cpu.percent": {
          "type": "gauge",
          "description": "Percentage of host CPU resources used by the container",
          "group": "cpu",
          "included": false
        },
        "cpu.percpu.usage": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent by the container, per CPU core",
          "group": "cpu",
          "included": false
        },
        "cpu.throttling_data.periods": {
          "type": "cumulative",
          "description": "Number of periods",
          "group": "cpu",
          "included": false
        },
        "cpu.throttling_data.throttled_periods": {
          "type": "cumulative",
          "description": "Number of periods throttled",
          "group": "cpu",
          "included": false
        },
        "cpu.throttling_data.throttled_time": {
          "type": "cumulative",
          "description": "Throttling time in nano seconds",
          "group": "cpu",
          "included": false
        },
        "cpu.usage.kernelmode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in kernel mode by the container",
          "group": "cpu",
          "included": false
        },
        "cpu.usage.system": {
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the system",
          "group": "cpu",
          "included": true
        },
        "cpu.usage.total": {
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the container",
          "group": "cpu",
          "included": true
        },
        "cpu.usage.usermode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in user mode by the container",
          "group": "cpu",
          "included": false
        },
        "memory.percent": {
          "type": "gauge",
          "description": "Percent of memory (0-100) used by the container relative to its limit (excludes page cache usage)",
          "group": "memory",
          "included": false
        },
        "memory.stats.active_anon": {
          "type": "gauge",
          "description": "Amount of memory that has been identified as active by the kernel. Anonymous memory is memory that is not linked to disk pages.",
          "group": "memory",
          "included": false
        },
        "memory.stats.active_file": {
          "type": "gauge",
          "description": "Amount of active file cache memory. Cache memory = active_file + inactive_file + tmpfs",
          "group": "memory",
          "included": false
        },
        "memory.stats.cache": {
          "type": "gauge",
          "description": "The amount of memory used by the processes of this control group that can be associated with a block on a block device. Also accounts for memory used by tmpfs.",
          "group": "memory",
          "included": false
        },
        "memory.stats.dirty": {
          "type": "gauge",
          "description": "The amount of memory waiting to get written to disk",
          "group": "memory",
          "included": false
        },
        "memory.stats.hierarchical_memory_limit": {
          "type": "gauge",
          "description": "The memory limit in place by the hierarchy cgroup",
          "group": "memory",
          "included": false
        },
        "memory.stats.hierarchical_memsw_limit": {
          "type": "gauge",
          "description": "The memory+swap limit in place by the hierarchy cgroup",
          "group": "memory",
          "included": false
        },
        "memory.stats.inactive_anon": {
          "type": "gauge",
          "description": "Amount of memory that has been identified as inactive by the kernel. Anonymous memory is memory that is not linked to disk pages.",
          "group": "memory",
          "included": false
        },
        "memory.stats.inactive_file": {
          "type": "gauge",
          "description": "Amount of inactive file cache memory. Cache memory = active_file + inactive_file + tmpfs",
          "group": "memory",
          "included": false
        },
        "memory.stats.mapped_file": {
          "type": "gauge",
          "description": "Indicates the amount of memory mapped by the processes in the control group. It doesn’t give you information about how much memory is used; it rather tells you how it is used.",
          "group": "memory",
          "included": false
        },
        "memory.stats.pgfault": {
          "type": "cumulative",
          "description": "Number of times that a process of the cgroup triggered a page fault. Page faults occur when a process accesses part of its virtual memory space which is nonexistent or protected. See https://docs.docker.com/config/containers/runmetrics for more info.",
          "group": "memory",
          "included": false
        },
        "memory.stats.pgmajfault": {
          "type": "cumulative",
          "description": "Number of times that a process of the cgroup triggered a major page fault. Page faults occur when a process accesses part of its virtual memory space which is nonexistent or protected. See https://docs.docker.com/config/containers/runmetrics for more info.",
          "group": "memory",
          "included": false
        },
        "memory.stats.pgpgin": {
          "type": "cumulative",
          "description": "Number of charging events to the memory cgroup. Charging events happen each time a page is accounted as either mapped anon page(RSS) or cache page to the cgroup.",
          "group": "memory",
          "included": false
        },
        "memory.stats.pgpgout": {
          "type": "cumulative",
          "description": "Number of uncharging events to the memory cgroup. Uncharging events happen each time a page is unaccounted from the cgroup.",
          "group": "memory",
          "included": false
        },
        "memory.stats.rss": {
          "type": "gauge",
          "description": "The amount of memory that doesn’t correspond to anything on disk: stacks, heaps, and anonymous memory maps.",
          "group": "memory",
          "included": false
        },
        "memory.stats.rss_huge": {
          "type": "gauge",
          "description": "Amount of memory due to anonymous transparent hugepages.",
          "group": "memory",
          "included": false
        },
        "memory.stats.swap": {
          "type": "gauge",
          "description": "Bytes of swap memory used by container",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_active_anon": {
          "type": "gauge",
          "description": "Total amount of memory that has been identified as active by the kernel. Anonymous memory is memory that is not linked to disk pages.",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_active_file": {
          "type": "gauge",
          "description": "Total amount of active file cache memory. Cache memory = active_file + inactive_file + tmpfs",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_cache": {
          "type": "gauge",
          "description": "Total amount of memory used by the processes of this control group that can be associated with a block on a block device. Also accounts for memory used by tmpfs.",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_dirty": {
          "type": "gauge",
          "description": "Total amount of memory waiting to get written to disk",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_inactive_anon": {
          "type": "gauge",
          "description": "Total amount of memory that has been identified as inactive by the kernel. Anonymous memory is memory that is not linked to disk pages.",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_inactive_file": {
          "type": "gauge",
          "description": "Total amount of inactive file cache memory. Cache memory = active_file + inactive_file + tmpfs",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_mapped_file": {
          "type": "gauge",
          "description": "Total amount of memory mapped by the processes in the control group. It doesn’t give you information about how much memory is used; it rather tells you how it is used.",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_pgfault": {
          "type": "cumulative",
          "description": "Total number of page faults",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_pgmajfault": {
          "type": "cumulative",
          "description": "Total number of major page faults",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_pgpgin": {
          "type": "cumulative",
          "description": "Total number of charging events",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_pgpgout": {
          "type": "cumulative",
          "description": "Total number of uncharging events",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_rss": {
          "type": "gauge",
          "description": "Total amount of memory that doesn’t correspond to anything on disk: stacks, heaps, and anonymous memory maps.",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_rss_huge": {
          "type": "gauge",
          "description": "Total amount of memory due to anonymous transparent hugepages.",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_unevictable": {
          "type": "gauge",
          "description": "Total amount of memory that can not be reclaimed",
          "group": "memory",
          "included": false
        },
        "memory.stats.total_writeback": {
          "type": "gauge",
          "description": "Total amount of memory from file/anon cache that are queued for syncing to the disk",
          "group": "memory",
          "included": false
        },
        "memory.stats.unevictable": {
          "type": "gauge",
          "description": "The amount of memory that cannot be reclaimed.",
          "group": "memory",
          "included": false
        },
        "memory.stats.writeback": {
          "type": "gauge",
          "description": "The amount of memory from file/anon cache that are queued for syncing to the disk",
          "group": "memory",
          "included": false
        },
        "memory.usage.limit": {
          "type": "gauge",
          "description": "Memory usage limit of the container, in bytes",
          "group": "memory",
          "included": true
        },
        "memory.usage.max": {
          "type": "gauge",
          "description": "Maximum measured memory usage of the container, in bytes",
          "group": "memory",
          "included": false
        },
        "memory.usage.total": {
          "type": "gauge",
          "description": "Bytes of memory used by the container",
          "group": "memory",
          "included": true
        },
        "network.usage.rx_bytes": {
          "type": "cumulative",
          "description": "Bytes received by the container via its network interface",
          "group": "network",
          "included": true
        },
        "network.usage.rx_dropped": {
          "type": "cumulative",
          "description": "Number of inbound network packets dropped by the container",
          "group": "network",
          "included": false
        },
        "network.usage.rx_errors": {
          "type": "cumulative",
          "description": "Errors receiving network packets",
          "group": "network",
          "included": false
        },
        "network.usage.rx_packets": {
          "type": "cumulative",
          "description": "Network packets received by the container via its network interface",
          "group": "network",
          "included": false
        },
        "network.usage.tx_bytes": {
          "type": "cumulative",
          "description": "Bytes sent by the container via its network interface",
          "group": "network",
          "included": true
        },
        "network.usage.tx_dropped": {
          "type": "cumulative",
          "description": "Number of outbound network packets dropped by the container",
          "group": "network",
          "included": false
        },
        "network.usage.tx_errors": {
          "type": "cumulative",
          "description": "Errors sending network packets",
          "group": "network",
          "included": false
        },
        "network.usage.tx_packets": {
          "type": "cumulative",
          "description": "Network packets sent by the container via its network interface",
          "group": "network",
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/docker",
        "fields": [
          {
            "yamlName": "enableExtraBlockIOMetrics",
            "doc": "Whether it will send all extra block IO metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraCPUMetrics",
            "doc": "Whether it will send all extra CPU metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraMemoryMetrics",
            "doc": "Whether it will send all extra memory metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraNetworkMetrics",
            "doc": "Whether it will send all extra network metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "dockerURL",
            "doc": "The URL of the docker server",
            "default": "unix:///var/run/docker.sock",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "timeoutSeconds",
            "doc": "The maximum amount of time to wait for docker API requests",
            "default": 5,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "labelsToDimensions",
            "doc": "A mapping of container label names to dimension names. The corresponding label values will become the dimension value for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "envToDimensions",
            "doc": "A mapping of container environment variable names to dimension names.  The corresponding env var values become the dimension values on the emitted metrics.  E.g. `APP_VERSION: version` would result in datapoints having a dimension called `version` whose value is the value of the `APP_VERSION` envvar configured for that particular container, if present.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedImages",
            "doc": "A list of filters of images to exclude.  Supports literals, globs, and regex.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "dotnet",
      "sendAll": true,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics for .NET applications.\n\nThe most critical .NET performance counters\n* exceptions\n* logical threads\n* physical threads\n* heap bytes\n* time in GC\n* committed bytes\n* pinned objects\n\n## Windows Performance Counters\nThe underlying source for these metrics are Windows Performance Counters.\nMost of the performance counters that we query in this monitor are actually Gauges\nthat represent rates per second and percentages.\n\nThis monitor reports the instantaneous values for these Windows Performance Counters.\nThis means that in between a collection interval, spikes could occur on the\nPerformance Counters.  The best way to mitigate this limitation is to increase\nthe reporting interval on this monitor to collect more frequently.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: dotnet\n```\n",
      "groups": null,
      "metrics": {
        "net_clr_exceptions.num_exceps_thrown_sec": {
          "type": "gauge",
          "description": "The number of exceptions thrown by .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_locksandthreads.contention_rate_sec": {
          "type": "gauge",
          "description": "The rate of thread of thread contention per second for .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_locksandthreads.current_queue_length": {
          "type": "gauge",
          "description": "The current thread queue length for .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_locksandthreads.num_of_current_logical_threads": {
          "type": "gauge",
          "description": "The number of current logical threads for .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_locksandthreads.num_of_current_physical_threads": {
          "type": "gauge",
          "description": "The number of current physical threads for .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_memory.num_bytes_in_all_heaps": {
          "type": "gauge",
          "description": "The number of bytes in all heaps for .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_memory.num_gc_handles": {
          "type": "gauge",
          "description": "The number of garbage collection handles held by .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_memory.num_of_pinned_objects": {
          "type": "gauge",
          "description": "The number of objects pinned in memory by .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_memory.num_total_committed_bytes": {
          "type": "gauge",
          "description": "The total number of bytes committed to memory by .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_memory.num_total_reserved_bytes": {
          "type": "gauge",
          "description": "The total number of bytes reserved by .NET applications.",
          "group": null,
          "included": false
        },
        "net_clr_memory.pct_time_in_gc": {
          "type": "gauge",
          "description": "The percentage of time spent garbage collecting by .NET applications.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/dotnet",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) Number of seconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "ecs-metadata",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reads container stats from a\n[ECS Task Metadata Endpoint version 2](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v2.html).\n\nThis currently does not support CPU share/quota metrics.\n",
      "groups": {
        "blkio": {
          "description": "BlockIO metrics"
        },
        "cpu": {
          "description": "CPU metrics"
        },
        "memory": {
          "description": "Memory metrics"
        },
        "network": {
          "description": "Network metrics"
        }
      },
      "metrics": {
        "blkio.io_service_bytes_recursive.async": {
          "type": "cumulative",
          "description": "Volume, in bytes, of asynchronous block I/O",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_bytes_recursive.read": {
          "type": "cumulative",
          "description": "Volume, in bytes, of reads from block devices",
          "group": "blkio",
          "included": true
        },
        "blkio.io_service_bytes_recursive.sync": {
          "type": "cumulative",
          "description": "Volume, in bytes, of synchronous block I/O",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_bytes_recursive.total": {
          "type": "cumulative",
          "description": "Total volume, in bytes, of all block I/O",
          "group": "blkio",
          "included": false
        },
        "blkio.io_service_bytes_recursive.write": {
          "type": "cumulative",
          "description": "Volume, in bytes, of writes to block devices",
          "group": "blkio",
          "included": true
        },
        "blkio.io_serviced_recursive.async": {
          "type": "cumulative",
          "description": "Number of asynchronous block I/O requests",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.read": {
          "type": "cumulative",
          "description": "Number of reads requests from block devices",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.sync": {
          "type": "cumulative",
          "description": "Number of synchronous block I/O requests",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.total": {
          "type": "cumulative",
          "description": "Total number of block I/O requests",
          "group": "blkio",
          "included": false
        },
        "blkio.io_serviced_recursive.write": {
          "type": "cumulative",
          "description": "Number of write requests to block devices",
          "group": "blkio",
          "included": false
        },
        "cpu.limit": {
          "type": "gauge",
          "description": "CPU usage limit of the container, in ECS vCPU units",
          "group": "cpu",
          "included": false
        },
        "cpu.percent": {
          "type": "gauge",
          "description": "Percentage of host CPU resources used by the container",
          "group": "cpu",
          "included": false
        },
        "cpu.percpu.usage": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent by the container, per CPU core",
          "group": "cpu",
          "included": false
        },
        "cpu.throttling_data.periods": {
          "type": "cumulative",
          "description": "Number of periods",
          "group": "cpu",
          "included": false
        },
        "cpu.throttling_data.throttled_periods": {
          "type": "cumulative",
          "description": "Number of periods throttled",
          "group": "cpu",
          "included": false
        },
        "cpu.throttling_data.throttled_time": {
          "type": "cumulative",
          "description": "Throttling time in nano seconds",
          "group": "cpu",
          "included": false
        },
        "cpu.usage.kernelmode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in kernel mode by the container",
          "group": "cpu",
          "included": false
        },
        "cpu.usage.system": {
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the system",
          "group": "cpu",
          "included": true
        },
        "cpu.usage.total": {
          "type": "cumulative",
          "description": "Jiffies of CPU time used by the container",
          "group": "cpu",
          "included": true
        },
        "cpu.usage.usermode": {
          "type": "cumulative",
          "description": "Jiffies of CPU time spent in user mode by the container",
          "group": "cpu",
          "included": false
        },
        "memory.percent": {
          "type": "gauge",
          "description": "Percent of memory (0-100) used by the container relative to its limit (excludes page cache usage)",
          "group": "memory",
          "included": false
        },
        "memory.stats.swap": {
          "type": "gauge",
          "description": "Bytes of swap memory used by container",
          "group": "memory",
          "included": false
        },
        "memory.usage.limit": {
          "type": "gauge",
          "description": "Memory usage limit of the container, in bytes",
          "group": "memory",
          "included": true
        },
        "memory.usage.max": {
          "type": "gauge",
          "description": "Maximum measured memory usage of the container, in bytes",
          "group": "memory",
          "included": false
        },
        "memory.usage.total": {
          "type": "gauge",
          "description": "Bytes of memory used by the container",
          "group": "memory",
          "included": true
        },
        "network.usage.rx_bytes": {
          "type": "cumulative",
          "description": "Bytes received by the container via its network interface",
          "group": "network",
          "included": true
        },
        "network.usage.rx_dropped": {
          "type": "cumulative",
          "description": "Number of inbound network packets dropped by the container",
          "group": "network",
          "included": false
        },
        "network.usage.rx_errors": {
          "type": "cumulative",
          "description": "Errors receiving network packets",
          "group": "network",
          "included": false
        },
        "network.usage.rx_packets": {
          "type": "cumulative",
          "description": "Network packets received by the container via its network interface",
          "group": "network",
          "included": false
        },
        "network.usage.tx_bytes": {
          "type": "cumulative",
          "description": "Bytes sent by the container via its network interface",
          "group": "network",
          "included": true
        },
        "network.usage.tx_dropped": {
          "type": "cumulative",
          "description": "Number of outbound network packets dropped by the container",
          "group": "network",
          "included": false
        },
        "network.usage.tx_errors": {
          "type": "cumulative",
          "description": "Errors sending network packets",
          "group": "network",
          "included": false
        },
        "network.usage.tx_packets": {
          "type": "cumulative",
          "description": "Network packets sent by the container via its network interface",
          "group": "network",
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/ecs",
        "fields": [
          {
            "yamlName": "enableExtraBlockIOMetrics",
            "doc": "Whether it will send all extra block IO metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraCPUMetrics",
            "doc": "Whether it will send all extra CPU metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraMemoryMetrics",
            "doc": "Whether it will send all extra memory metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableExtraNetworkMetrics",
            "doc": "Whether it will send all extra network metrics as well.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metadataEndpoint",
            "doc": "The URL of the ECS task metadata. Default is http://169.254.170.2/v2/metadata, which is hardcoded by AWS for version 2.",
            "default": "http://169.254.170.2/v2/metadata",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "statsEndpoint",
            "doc": "The URL of the ECS container stats. Default is http://169.254.170.2/v2/stats, which is hardcoded by AWS for version 2.",
            "default": "http://169.254.170.2/v2/stats",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "timeoutSeconds",
            "doc": "The maximum amount of time to wait for API requests",
            "default": 5,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "labelsToDimensions",
            "doc": "A mapping of container label names to dimension names. The corresponding label values will become the dimension value for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "excludedImages",
            "doc": "A list of filters of images to exclude.  Supports literals, globs, and regex.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "elasticsearch",
      "sendAll": false,
      "dimensions": {
        "aggregation": {
          "description": "Aggregation of index metrics. Whether the value of the metric is from the primary shard only or across all shards. Valid values - primaries, total respectively (only on index stats)"
        },
        "cluster": {
          "description": "Name of Elasticsearch the cluster."
        },
        "index": {
          "description": "Name of index (only on per index mertics)"
        },
        "node_id": {
          "description": "ID of a Elasticsearch node (only on node mertics)"
        },
        "node_name": {
          "description": "Human readable name of a node (only on node mertics)"
        },
        "plugin_instance": {
          "description": "Name of the Elasticsearch cluster. For compatibility with collectd/elasticsearch built-in content"
        },
        "thread_pool": {
          "description": "Name of thread pool (only on thread pool mertics)"
        }
      },
      "doc": "This monitor collects stats from Elasticsearch. It collects node, cluster\nand index level stats. This monitor is compatible with the current collectd\nplugin found [here] (https://github.com/signalfx/collectd-elasticsearch) in\nterms of metric naming.\n\nThis monitor collects cluster level and index level stats only from the current master\nin an Elasticsearch cluster by default. It is possible to override this with the\n`clusterHealthStatsMasterOnly` and `indexStatsMasterOnly` config options respectively.\n\nA simple configuration that collects only default (non-custom) metrics\nlooks like the following:\n\n```yaml\nmonitors:\n- type: elasticsearch\n  host: localhost\n  port: 9200\n```\n\n## Enhanced (custom) metrics\n\nThe monitor collects a subset of node stats of JVM, process, HTTP,\ntransport, indices and thread pool stats. It is possible to enable\nenhanced stats for each stat group separately.  Note that these metrics\nget categorized under the _custom_ group if you are on host-based\npricing. Here's an example:\n\n```yaml\nmonitors:\n- type: elasticsearch\n  host: localhost\n  port: 9200\n  enableEnhancedHTTPStats: true\n  enableEnhancedJVMStats: true\n  enableEnhancedProcessStats: true\n  enableEnhancedThreadPoolStats: true\n  enableEnhancedTransportStats: true\n  enableEnhancedNodeIndicesStats:\n   - indexing\n   - warmer\n   - get\n\n```\n\nThe `enableEnhancedNodeIndicesStats` option takes a list of index stats groups\nfor which enhanced stats will be collected. A comprehensive list of all\nsuch available groups can be found [here](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html#node-indices-stats).\n\nNote that the `enableEnhancedIndexStatsForIndexGroups` is similar to\n`enableEnhancedNodeIndicesStats`, but for index level stats.\n\n## Thread Pools\n\nBy default thread pool stats from the \"search\" and \"index\" thread pools are collected. To collect\nstats from other thread pools specify the `threadPools` config option:\n\n```yaml\nmonitors:\n- type: elasticsearch\n  host: localhost\n  port: 9200\n  threadPools:\n  - bulk\n  - warmer\n  - listener\n```\n\nHere is a list of valid thread pools by Elasticsearch version:\n\n| thread pool name | ES 1.x | ES 2.0 | ES 2.1+ |\n|------------------|--------|--------|--------|\n| merge            | \u0026#x2713;      |        |        |\n| optimize         |\u0026#x2713;     |        |        |\n| bulk             |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| flush            |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| generic          |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| get              |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| snapshot         |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| warmer           |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| refresh          |\u0026#x2713;     |\u0026#x2713;     |\u0026#x2713;     |\n| fetch\\_shard\\_started|      |\u0026#x2713;     |\u0026#x2713;     |\n| fetch\\_shard\\_store|        |\u0026#x2713;     |\u0026#x2713;     |\n| listener         |        |\u0026#x2713;     |\u0026#x2713;     |\n| management       |        |\u0026#x2713;     |\u0026#x2713;     |\n| percolate        |        |\u0026#x2713;     |\u0026#x2713;     |\n| suggest          |        |\u0026#x2713;     |\u0026#x2713;     |\n| force\\_merge      |        |        |\u0026#x2713;     |\n\n\n## Collecting index statistics\n\nBy default, the configuration parameter `indexes` is empty, which means\ncollect stats on all indexes. To collect statistics from a subset of\nindexes, set the configuration parameter `indexes` to a list of the index\nnames you want to collect stats for.\n\nThe call to collect index statistics can be CPU-intensive. For this reason\nSignalFx recommends using the `indexStatsIntervalSeconds` configuration\nparameter to decrease the reporting interval for nodes that report index\nstatistics.\n\n### Primaries vs total\nBy default the monitor collects a subset of index stats of total aggregation\ntype (see docs for details). It is possible to enable index stats of primaries\naggregation type too. Total for an index stat aggregates across all shards.\nWhereas, Primaries only reflect the stats from primary shards. An example\nconfiguration to enable index stats from Primary shards too:\n\n```yaml\nmonitors:\n- type: elasticsearch\n  host: localhost\n  port: 9200\n  enableIndexStatsPrimaries: true\n```\n\n## Built-in content\n\nFor more information on the built-in content we have for Elasticsearch,\n[see\nhere](https://github.com/signalfx/integrations/tree/master/collectd-elasticsearch)\n",
      "groups": null,
      "metrics": {
        "elasticsearch.cluster.active-primary-shards": {
          "type": "gauge",
          "description": "Number of active primary shards",
          "group": "cluster",
          "included": true
        },
        "elasticsearch.cluster.active-shards": {
          "type": "gauge",
          "description": "Number of active shards",
          "group": "cluster",
          "included": true
        },
        "elasticsearch.cluster.active-shards-percent": {
          "type": "gauge",
          "description": "Percentaage of shards active",
          "group": "cluster",
          "included": false
        },
        "elasticsearch.cluster.delayed-unassigned-shards": {
          "type": "gauge",
          "description": "Number of delayed unassigned shards",
          "group": "cluster",
          "included": false
        },
        "elasticsearch.cluster.in-flight-fetches": {
          "type": "gauge",
          "description": "Number of fetches in-flight",
          "group": "cluster",
          "included": false
        },
        "elasticsearch.cluster.initializing-shards": {
          "type": "gauge",
          "description": "Number of shards being initialized",
          "group": "cluster",
          "included": false
        },
        "elasticsearch.cluster.number-of-data_nodes": {
          "type": "gauge",
          "description": "Number of data nodes",
          "group": "cluster",
          "included": true
        },
        "elasticsearch.cluster.number-of-nodes": {
          "type": "gauge",
          "description": "Number of nodes",
          "group": "cluster",
          "included": true
        },
        "elasticsearch.cluster.pending-tasks": {
          "type": "gauge",
          "description": "Number of pending tasks",
          "group": "cluster",
          "included": false
        },
        "elasticsearch.cluster.relocating-shards": {
          "type": "gauge",
          "description": "Number of shards being relocated",
          "group": "cluster",
          "included": true
        },
        "elasticsearch.cluster.status": {
          "type": "gauge",
          "description": "Cluster stats (0, 1, 2 for green, yellow and red respectively)",
          "group": "cluster",
          "included": false
        },
        "elasticsearch.cluster.task-max-wait-time": {
          "type": "gauge",
          "description": "Max time a task has to wait",
          "group": "cluster",
          "included": false
        },
        "elasticsearch.cluster.unassigned-shards": {
          "type": "gauge",
          "description": "Number of unassigned shards",
          "group": "cluster",
          "included": true
        },
        "elasticsearch.http.current_open": {
          "type": "gauge",
          "description": "Number of currently open HTTP connections",
          "group": "node/http",
          "included": false
        },
        "elasticsearch.http.total_open": {
          "type": "cumulative",
          "description": "Total number of opened HTTP connections",
          "group": "node/http",
          "included": false
        },
        "elasticsearch.indices.completion.size": {
          "type": "gauge",
          "description": "Size used by suggest completion (in bytes)",
          "group": "indices/completion",
          "included": false
        },
        "elasticsearch.indices.docs.count": {
          "type": "gauge",
          "description": "Number of docs",
          "group": "indices/docs",
          "included": true
        },
        "elasticsearch.indices.docs.deleted": {
          "type": "gauge",
          "description": "Number of docs deleted",
          "group": "indices/docs",
          "included": true
        },
        "elasticsearch.indices.fielddata.evictions": {
          "type": "cumulative",
          "description": "Number of evictions from fielddata cache",
          "group": "indices/fielddata",
          "included": false
        },
        "elasticsearch.indices.fielddata.memory-size": {
          "type": "gauge",
          "description": "Size of fielddata cache (in bytes)",
          "group": "indices/fielddata",
          "included": false
        },
        "elasticsearch.indices.filter-cache.evictions": {
          "type": "cumulative",
          "description": "Number of evicttions from filter cache",
          "group": "indices/filter-cache",
          "included": false
        },
        "elasticsearch.indices.filter-cache.memory-size": {
          "type": "gauge",
          "description": "Filter cache size (in bytes)",
          "group": "indices/filter-cache",
          "included": false
        },
        "elasticsearch.indices.flush.periodic": {
          "type": "gauge",
          "description": "How long to wait before triggering a flush regardless of translog size",
          "group": "indices/flush",
          "included": false
        },
        "elasticsearch.indices.flush.total": {
          "type": "cumulative",
          "description": "Number of index flushes to disk",
          "group": "indices/flush",
          "included": false
        },
        "elasticsearch.indices.flush.total-time": {
          "type": "cumulative",
          "description": "Time spent flushing the index to disk",
          "group": "indices/flush",
          "included": false
        },
        "elasticsearch.indices.get.current": {
          "type": "gauge",
          "description": "Number of get requests running",
          "group": "indices/get",
          "included": false
        },
        "elasticsearch.indices.get.exists-time": {
          "type": "cumulative",
          "description": "Time spent on get requests where the document existed",
          "group": "indices/get",
          "included": false
        },
        "elasticsearch.indices.get.exists-total": {
          "type": "cumulative",
          "description": "Number of get requests where the document existed",
          "group": "indices/get",
          "included": false
        },
        "elasticsearch.indices.get.missing-time": {
          "type": "cumulative",
          "description": "Time spent on get requests where the document was missing",
          "group": "indices/get",
          "included": false
        },
        "elasticsearch.indices.get.missing-total": {
          "type": "cumulative",
          "description": "Number of get requests where the document was missing",
          "group": "indices/get",
          "included": false
        },
        "elasticsearch.indices.get.time": {
          "type": "cumulative",
          "description": "Time spent on get requests",
          "group": "indices/get",
          "included": false
        },
        "elasticsearch.indices.get.total": {
          "type": "cumulative",
          "description": "Total number of get requests",
          "group": "indices/get",
          "included": true
        },
        "elasticsearch.indices.id-cache.memory-size": {
          "type": "gauge",
          "description": "Size of id cache (in bytes)",
          "group": "indices/id-cache",
          "included": false
        },
        "elasticsearch.indices.indexing.delete-current": {
          "type": "gauge",
          "description": "Number of documents currently being deleted from an index",
          "group": "indices/indexing",
          "included": false
        },
        "elasticsearch.indices.indexing.delete-time": {
          "type": "cumulative",
          "description": "Time spent deleting documents from an index",
          "group": "indices/indexing",
          "included": false
        },
        "elasticsearch.indices.indexing.delete-total": {
          "type": "cumulative",
          "description": "Number of documents deleted from an index",
          "group": "indices/indexing",
          "included": false
        },
        "elasticsearch.indices.indexing.index-current": {
          "type": "gauge",
          "description": "Number of documents currently being indexed to an index",
          "group": "indices/indexing",
          "included": false
        },
        "elasticsearch.indices.indexing.index-failed": {
          "type": "gauge",
          "description": "Number of failed indices",
          "group": "indices/indexing",
          "included": false
        },
        "elasticsearch.indices.indexing.index-time": {
          "type": "cumulative",
          "description": "Time spent indexing documents to an index",
          "group": "indices/indexing",
          "included": false
        },
        "elasticsearch.indices.indexing.index-total": {
          "type": "cumulative",
          "description": "Total number of documents indexed to an index",
          "group": "indices/indexing",
          "included": true
        },
        "elasticsearch.indices.indexing.noop-update-total": {
          "type": "cumulative",
          "description": "Number of noop updates",
          "group": "indices/indexing",
          "included": false
        },
        "elasticsearch.indices.indexing.throttle-time": {
          "type": "cumulative",
          "description": "Throttle time",
          "group": "indices/indexing",
          "included": false
        },
        "elasticsearch.indices.merges.auto-throttle-size": {
          "type": "cumulative",
          "description": "Merging throttled due to auto-throttling (in bytes)",
          "group": "indices/merges",
          "included": false
        },
        "elasticsearch.indices.merges.current": {
          "type": "gauge",
          "description": "Number of currently active segment merges",
          "group": "indices/merges",
          "included": true
        },
        "elasticsearch.indices.merges.current-docs": {
          "type": "gauge",
          "description": "Number of docs currently being merged",
          "group": "indices/merges",
          "included": false
        },
        "elasticsearch.indices.merges.current-size": {
          "type": "gauge",
          "description": "Size of the segments currently being merged",
          "group": "indices/merges",
          "included": false
        },
        "elasticsearch.indices.merges.stopped-time": {
          "type": "cumulative",
          "description": "Total time merges were stopped for",
          "group": "indices/merges",
          "included": false
        },
        "elasticsearch.indices.merges.throttle-time": {
          "type": "cumulative",
          "description": "Total time merges spent waiting due to throttling",
          "group": "indices/merges",
          "included": false
        },
        "elasticsearch.indices.merges.total": {
          "type": "cumulative",
          "description": "Number of segment merges",
          "group": "indices/merges",
          "included": true
        },
        "elasticsearch.indices.merges.total-docs": {
          "type": "cumulative",
          "description": "Number of merged docs across merged segments",
          "group": "indices/merges",
          "included": false
        },
        "elasticsearch.indices.merges.total-size": {
          "type": "cumulative",
          "description": "Total size of merged segments",
          "group": "indices/merges",
          "included": false
        },
        "elasticsearch.indices.merges.total-time": {
          "type": "cumulative",
          "description": "Total time spent on merging",
          "group": "indices/merges",
          "included": false
        },
        "elasticsearch.indices.percolate.current": {
          "type": "gauge",
          "description": "Number of percolator queries currently running",
          "group": "indices/percolate",
          "included": false
        },
        "elasticsearch.indices.percolate.queries": {
          "type": "cumulative",
          "description": "Number of percolator queries",
          "group": "indices/percolate",
          "included": false
        },
        "elasticsearch.indices.percolate.time": {
          "type": "cumulative",
          "description": "Total time spent on percolate requests",
          "group": "indices/percolate",
          "included": false
        },
        "elasticsearch.indices.percolate.total": {
          "type": "cumulative",
          "description": "Total number of suggest requests",
          "group": "indices/percolate",
          "included": false
        },
        "elasticsearch.indices.query-cache.cache-count": {
          "type": "gauge",
          "description": "Number of items in query cache",
          "group": "indices/query-cache",
          "included": false
        },
        "elasticsearch.indices.query-cache.cache-size": {
          "type": "gauge",
          "description": "Size of query cache (in bytes)",
          "group": "indices/query-cache",
          "included": false
        },
        "elasticsearch.indices.query-cache.evictions": {
          "type": "cumulative",
          "description": "Number of query cache evictions",
          "group": "indices/query-cache",
          "included": false
        },
        "elasticsearch.indices.query-cache.hit-count": {
          "type": "cumulative",
          "description": "Number of query cache hits",
          "group": "indices/query-cache",
          "included": false
        },
        "elasticsearch.indices.query-cache.memory-size": {
          "type": "gauge",
          "description": "Size of query cache (in bytes)",
          "group": "indices/query-cache",
          "included": false
        },
        "elasticsearch.indices.query-cache.miss-count": {
          "type": "cumulative",
          "description": "Number of query cache misses",
          "group": "indices/request-cache",
          "included": false
        },
        "elasticsearch.indices.query-cache.total-count": {
          "type": "cumulative",
          "description": "Total number of items in the query cache",
          "group": "indices/query-cache",
          "included": false
        },
        "elasticsearch.indices.recovery.current-as-source": {
          "type": "gauge",
          "description": "Number of ongoing recoveries for which a shard serves as a source",
          "group": "indices/recovery",
          "included": false
        },
        "elasticsearch.indices.recovery.current-as-target": {
          "type": "gauge",
          "description": "Number of ongoing recoveries for which a shard serves as a target",
          "group": "indices/recovery",
          "included": false
        },
        "elasticsearch.indices.recovery.throttle-time": {
          "type": "cumulative",
          "description": "Total time recoveries waited due to throttling",
          "group": "indices/recovery",
          "included": false
        },
        "elasticsearch.indices.refresh.listeners": {
          "type": "gauge",
          "description": "Number of listeners waiting for a refresh",
          "group": "indices/refresh",
          "included": false
        },
        "elasticsearch.indices.refresh.total": {
          "type": "cumulative",
          "description": "Total number of index refreshes",
          "group": "indices/refresh",
          "included": false
        },
        "elasticsearch.indices.refresh.total-time": {
          "type": "cumulative",
          "description": "Total time spent on index refreshes",
          "group": "indices/refresh",
          "included": false
        },
        "elasticsearch.indices.request-cache.evictions": {
          "type": "cumulative",
          "description": "Number of request cache evictions",
          "group": "indices/request-cache",
          "included": false
        },
        "elasticsearch.indices.request-cache.hit-count": {
          "type": "cumulative",
          "description": "Number of request cache hits",
          "group": "indices/request-cache",
          "included": false
        },
        "elasticsearch.indices.request-cache.memory-size": {
          "type": "gauge",
          "description": "Memory used by request cache (in bytes)",
          "group": "indices/request-cache",
          "included": false
        },
        "elasticsearch.indices.request-cache.miss-count": {
          "type": "cumulative",
          "description": "Number of request cache misses",
          "group": "indices/request-cache",
          "included": false
        },
        "elasticsearch.indices.search.fetch-current": {
          "type": "gauge",
          "description": "Number of query fetches currently running",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.fetch-time": {
          "type": "cumulative",
          "description": "Total time spent on query fetches",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.fetch-total": {
          "type": "cumulative",
          "description": "Total number of query feches",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.open-contexts": {
          "type": "gauge",
          "description": "Number of open contexts",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.query-current": {
          "type": "gauge",
          "description": "Number of currently active queries",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.query-time": {
          "type": "cumulative",
          "description": "Total time spent querying on the primary",
          "group": "indices/search",
          "included": true
        },
        "elasticsearch.indices.search.query-total": {
          "type": "cumulative",
          "description": "Total number of queries",
          "group": "indices/search",
          "included": true
        },
        "elasticsearch.indices.search.scroll-current": {
          "type": "gauge",
          "description": "Currently active scroll queries count",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.scroll-time": {
          "type": "cumulative",
          "description": "Total time spent on scroll queries",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.scroll-total": {
          "type": "cumulative",
          "description": "Total number of scroll queries",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.suggest-current": {
          "type": "gauge",
          "description": "Number of suggest requests currently active",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.suggest-time": {
          "type": "cumulative",
          "description": "Total time spent on search suggest",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.search.suggest-total": {
          "type": "cumulative",
          "description": "Total number of suggest requests",
          "group": "indices/search",
          "included": false
        },
        "elasticsearch.indices.segments.count": {
          "type": "gauge",
          "description": "Number of segments in an index shard",
          "group": "indices/segments",
          "included": true
        },
        "elasticsearch.indices.segments.doc-values-memory-size": {
          "type": "gauge",
          "description": "Memory used by doc values",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.fixed-bit-set-memory-size": {
          "type": "gauge",
          "description": "Memory used by fixed bit set",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.index-writer-max-memory-size": {
          "type": "gauge",
          "description": "Maximum memory used by the index writer",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.index-writer-memory-size": {
          "type": "gauge",
          "description": "Memory used by the index writer",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.memory-size": {
          "type": "gauge",
          "description": "Memory used by index segments (in bytes)",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.norms-memory-size": {
          "type": "gauge",
          "description": "Memory used by norms (in bytes)",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.points-memory-size": {
          "type": "gauge",
          "description": "Memory used by points",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.stored-field-memory-size": {
          "type": "gauge",
          "description": "Memory used by stored fields (in bytes)",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.term-vectors-memory-size": {
          "type": "gauge",
          "description": "Memory used by term vectors (in bytes)",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.terms-memory-size": {
          "type": "gauge",
          "description": "Memory used by terms (in bytes)",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.segments.version-map-memory-size": {
          "type": "gauge",
          "description": "Memory used by segment version map (in bytes)",
          "group": "indices/segments",
          "included": false
        },
        "elasticsearch.indices.store.size": {
          "type": "gauge",
          "description": "Total size (in bytes)",
          "group": "indices/store",
          "included": false
        },
        "elasticsearch.indices.store.throttle-time": {
          "type": "cumulative",
          "description": "Total time requests are throttled for",
          "group": "indices/store",
          "included": false
        },
        "elasticsearch.indices.suggest.current": {
          "type": "gauge",
          "description": "Number of currently active suggest requests",
          "group": "indices/suggest",
          "included": false
        },
        "elasticsearch.indices.suggest.time": {
          "type": "cumulative",
          "description": "Total time spent in suggest requests",
          "group": "indices/suggest",
          "included": false
        },
        "elasticsearch.indices.suggest.total": {
          "type": "cumulative",
          "description": "Total number of suggest requests",
          "group": "indices/suggest",
          "included": false
        },
        "elasticsearch.indices.translog.earliest_last_modified_age": {
          "type": "gauge",
          "description": "Earliest last modified age on transaction logs",
          "group": "indices/translog",
          "included": false
        },
        "elasticsearch.indices.translog.operations": {
          "type": "gauge",
          "description": "Number of operations in the transaction log",
          "group": "indices/translog",
          "included": false
        },
        "elasticsearch.indices.translog.size": {
          "type": "gauge",
          "description": "Size of the transaction log",
          "group": "indices/translog",
          "included": false
        },
        "elasticsearch.indices.translog.uncommitted_operations": {
          "type": "gauge",
          "description": "Number of uncommitted operations in the transaction log",
          "group": "indices/translog",
          "included": false
        },
        "elasticsearch.indices.translog.uncommitted_size_in_bytes": {
          "type": "gauge",
          "description": "Size of uncommitted transaction logs (in bytes)",
          "group": "indices/translog",
          "included": false
        },
        "elasticsearch.indices.warmer.current": {
          "type": "gauge",
          "description": "Number of currently active warmers",
          "group": "indices/warmer",
          "included": false
        },
        "elasticsearch.indices.warmer.total": {
          "type": "cumulative",
          "description": "Total number of warmers",
          "group": "indices/warmer",
          "included": false
        },
        "elasticsearch.indices.warmer.total-time": {
          "type": "cumulative",
          "description": "Total time spent by warmers",
          "group": "indices/warmer",
          "included": false
        },
        "elasticsearch.jvm.classes.current-loaded-count": {
          "type": "gauge",
          "description": "Number of classes currently loaded",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.classes.total-loaded-count": {
          "type": "cumulative",
          "description": "Number of classes loaded",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.classes.total-unloaded-count": {
          "type": "cumulative",
          "description": "Total number of classes unloaded",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.gc.count": {
          "type": "cumulative",
          "description": "Total number of garbage collections",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.gc.old-count": {
          "type": "cumulative",
          "description": "Total number of garbage collections on Old Gen",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.gc.old-time": {
          "type": "cumulative",
          "description": "Total time spent in garbage collections on Old Gen",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.gc.time": {
          "type": "cumulative",
          "description": "Total time spent on GC",
          "group": "node/jvm",
          "included": true
        },
        "elasticsearch.jvm.mem.buffer_pools.direct.count": {
          "type": "gauge",
          "description": "Number of direct buffer pools",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.buffer_pools.direct.total_capacity_in_bytes": {
          "type": "gauge",
          "description": "Total capacity of direct buffer pools",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.buffer_pools.direct.used_in_bytes": {
          "type": "gauge",
          "description": "Memory used by direct buffer pools (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.buffer_pools.mapped.count": {
          "type": "gauge",
          "description": "Number of buffers in the mapped pool",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.buffer_pools.mapped.total_capacity_in_bytes": {
          "type": "gauge",
          "description": "Total capacity of the buffers in the mapped pool",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.buffer_pools.mapped.used_in_bytes": {
          "type": "gauge",
          "description": "Memory used by mapped buffer pools (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.heap-committed": {
          "type": "gauge",
          "description": "Memory guaranteed to be available to JVM heap",
          "group": "node/jvm",
          "included": true
        },
        "elasticsearch.jvm.mem.heap-max": {
          "type": "gauge",
          "description": "Max memory that can be used by JVM heap (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.heap-used": {
          "type": "gauge",
          "description": "Memory current being used by JVM heap (in bytes)",
          "group": "node/jvm",
          "included": true
        },
        "elasticsearch.jvm.mem.heap-used-percent": {
          "type": "gauge",
          "description": "Percent of heap being used",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.non-heap-committed": {
          "type": "gauge",
          "description": "Memory guaranteed to be available to JVM non-heap",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.non-heap-used": {
          "type": "gauge",
          "description": "Memory current being used by JVM non-heap (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.old.max_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Old Gen (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.old.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory pool Old Gen peak max (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.old.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Peak memory used by Old Gen (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.old.used_in_bytes": {
          "type": "gauge",
          "description": "Memory being used by Old Gen (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.survivor.max_in_bytes": {
          "type": "gauge",
          "description": "Max memory that can be used by Survivor space (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.survivor.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Survivor space (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.survivor.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Peak memory used by Survivor space (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.survivor.used_in_bytes": {
          "type": "gauge",
          "description": "Memory being used currently by Survivor space (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.young.max_in_bytes": {
          "type": "gauge",
          "description": "Max memory (in bytes) that can be used by Young Gen",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.young.peak_max_in_bytes": {
          "type": "gauge",
          "description": "Memory pool Young Gen peak max (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.young.peak_used_in_bytes": {
          "type": "gauge",
          "description": "Memory pool Young Gen peak used (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.mem.pools.young.used_in_bytes": {
          "type": "gauge",
          "description": "Memory used by Young Gen (in bytes)",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.threads.count": {
          "type": "gauge",
          "description": "Number of active threads in the JVM",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.threads.peak": {
          "type": "gauge",
          "description": "Peak number of threads used",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.jvm.uptime": {
          "type": "cumulative",
          "description": "Uptime of JVM",
          "group": "node/jvm",
          "included": false
        },
        "elasticsearch.process.cpu.percent": {
          "type": "gauge",
          "description": "CPU usage in percent",
          "group": "node/process",
          "included": false
        },
        "elasticsearch.process.cpu.time": {
          "type": "cumulative",
          "description": "CPU time (in milliseconds) used by the process on which the Java virtual machine is running",
          "group": "node/process",
          "included": false
        },
        "elasticsearch.process.max_file_descriptors": {
          "type": "gauge",
          "description": "Number of opened file descriptors associated with the current process",
          "group": "node/process",
          "included": false
        },
        "elasticsearch.process.mem.total-virtual-size": {
          "type": "cumulative",
          "description": "Size in bytes of virtual memory that is guaranteed to be available to the running process",
          "group": "node/process",
          "included": false
        },
        "elasticsearch.process.open_file_descriptors": {
          "type": "gauge",
          "description": "Number of currently open file descriptors",
          "group": "node/process",
          "included": true
        },
        "elasticsearch.thread_pool.active": {
          "type": "gauge",
          "description": "Number of active threads",
          "group": "node/thread-pool",
          "included": false
        },
        "elasticsearch.thread_pool.completed": {
          "type": "cumulative",
          "description": "Number of threads completed in thread pool",
          "group": "node/thread-pool",
          "included": false
        },
        "elasticsearch.thread_pool.largest": {
          "type": "gauge",
          "description": "Highest active threads in thread pool",
          "group": "node/thread-pool",
          "included": false
        },
        "elasticsearch.thread_pool.queue": {
          "type": "gauge",
          "description": "Number of Tasks in thread pool",
          "group": "node/thread-pool",
          "included": false
        },
        "elasticsearch.thread_pool.rejected": {
          "type": "cumulative",
          "description": "Number of rejected threads in thread pool",
          "group": "node/thread-pool",
          "included": true
        },
        "elasticsearch.thread_pool.threads": {
          "type": "cumulative",
          "description": "Number of Threads in thread pool",
          "group": "node/thread-pool",
          "included": false
        },
        "elasticsearch.transport.rx.count": {
          "type": "cumulative",
          "description": "Total size of data received in cluster communication (in bytes)",
          "group": "node/transport",
          "included": false
        },
        "elasticsearch.transport.rx.size": {
          "type": "cumulative",
          "description": "Total size of data received in cluster communication",
          "group": "node/transport",
          "included": false
        },
        "elasticsearch.transport.server_open": {
          "type": "gauge",
          "description": "Total number of connections opened for cluster communication",
          "group": "node/transport",
          "included": false
        },
        "elasticsearch.transport.tx.count": {
          "type": "cumulative",
          "description": "Total number of packets sent in cluster communication",
          "group": "node/transport",
          "included": false
        },
        "elasticsearch.transport.tx.size": {
          "type": "cumulative",
          "description": "Total size of data sent in cluster communication",
          "group": "node/transport",
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/elasticsearch",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Username used to access Elasticsearch stats API",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password used to access Elasticsearch stats API",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "Whether to use https or not",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "cluster",
            "doc": "Cluster name to which the node belongs. This is an optional config that will override the cluster name fetched from a node and will be used to populate the plugin_instance dimension",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "enableIndexStats",
            "doc": "Enable Index stats. If set to true, by default the a subset of index stats will be collected (see docs for list of default index metrics collected).",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "indexes",
            "doc": "Indexes to collect stats from (by default stats from all indexes are collected)",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "indexStatsIntervalSeconds",
            "doc": "Interval to report IndexStats on",
            "default": 60,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "indexSummaryOnly",
            "doc": "Collect only aggregated index stats across all indexes",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "indexStatsMasterOnly",
            "doc": "Collect index stats only from Master node",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableClusterHealth",
            "doc": "EnableClusterHealth enables reporting on the cluster health",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "clusterHealthStatsMasterOnly",
            "doc": "Whether or not non master nodes should report cluster health",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedHTTPStats",
            "doc": "Enable enhanced HTTP stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedJVMStats",
            "doc": "Enable enhanced JVM stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedProcessStats",
            "doc": "Enable enhanced Process stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedThreadPoolStats",
            "doc": "Enable enhanced ThreadPool stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedTransportStats",
            "doc": "Enable enhanced Transport stats",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedNodeIndicesStats",
            "doc": "Enable enhanced node level index stats groups. A list of index stats groups for which to collect enhanced stats",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "threadPools",
            "doc": "ThreadPools to report threadpool node stats on",
            "default": [
              "search",
              "index"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "enableEnhancedClusterHealthStats",
            "doc": "Enable Cluster level stats. These stats report only from master Elasticserach nodes",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "enableEnhancedIndexStatsForIndexGroups",
            "doc": "Enable enhanced index level index stats groups. A list of index stats groups for which to collect enhanced stats",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "enableIndexStatsPrimaries",
            "doc": "To enable index stats from only primary shards. By default the index stats collected are aggregated across all shards",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metadataRefreshIntervalSeconds",
            "doc": "How often to refresh metadata about the node and cluster",
            "default": 30,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "expvar",
      "sendAll": false,
      "dimensions": null,
      "doc": "The expvar monitor is a SignalFx Smart Agent monitor that scrapes metrics from variables exposed in JSON\nformat at an HTTP endpoint by [expvar](https://golang.org/pkg/expvar/). The monitor uses configured paths\nto get metric and dimension values from fetched JSON objects.\n\nThe Metrics section in this document shows metrics derived from expvar variable\n[memstats](https://golang.org/pkg/runtime/). The memstat variable is exposed by default. These memstat\nmetrics are referred to as standard or default metrics. The configuration examples shown are excerpts\nlimited to the monitor configuration section of the SignalFx Smart Agent configuration file `agent.yml`.\n\nBelow is an example showing the minimal required expvar monitor configuration for exporting\nthe default metrics from endpoint `http://172.17.0.3:8000/debug/vars`. `/debug/vars` is the default path.\n```\nmonitors:\n- type: expvar\n  host: 172.17.0.3\n  path: /debug/vars\n  port: 8000\n```\nWe recommend you include the extra dimension `metric_source` with a meaningful value in order to facilitate\nfiltering in the SignalFx app. See below.\n```\nmonitors:\n- type: expvar\n  host: 172.17.0.3\n  path: /debug/vars\n  port: 8000\n  extraDimensions:\n    metric_source: expvar\n```\nBelow is an example showing part of a JSON payload containing the exposed variable requestsPerSecond containing\nrequests per second metric information.\n```\n{\n  ...\n  \"requestsPerSecond\": 919,\n  ...\n}\n```\nSuppose that the payload is emanating from endpoint `http://172.17.0.4:6000/appmetrics`. The monitor can be\nconfigured as shown below in order to scrape requestsPerSecond. The metric name is optional. If not provided,\nthe JSONPath value `requestsPerSecond` snake cased to `requests_per_second` will be used instead.\n```\nmonitors:\n- type: expvar\n  host: 172.17.0.4\n  path: /debug/vars\n  port: 6000\n  metrics:\n    - name: requests.sec\n      JSONPath: requestsPerSecond\n      type: gauge\n  extraDimensions:\n    metric_source: expvar-aws\n```\nThe expvar monitor can be configured to extract metric values from complex JSON objects such as the one shown\nbelow. Suppose the `memstats` variable shown below is exposed at endpoint `http://172.17.0.5:5000/debug/vars`\nand you want to extract the cumulative `Mallocs` values.\n```\n{\n  ...\n  \"memstats\": {\n                ...\n                \"GCCPUFraction\": 0.0000032707490586459204,\n                \"BySize\": [\n                  {\n                      \"Size\": 32,\n                      \"Mallocs\": 35387,\n                      \"Frees\": 35021\n                  },\n                  {\n                      \"Size\": 48,\n                      \"Mallocs\": 35387,\n                      \"Frees\": 63283\n                  }\n                ]\n                \"HeapAlloc\": 2138088,\n                ...\n              }\n  ...\n}\n```\nThe should be configured as shown below so as to fetch the `Mallocs` values. The JSONPath is what maps the\nlocation of values with the JSON object. The path must terminate primitive values or an array containing\nprimitive values. It cannot terminated on embedded object(s).\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.Mallocs\n      type: cumulative\n  extraDimensions:\n    metric_source: expvar\n```\nNo metric name was provided for this configuration so the metric name defaults to memstats.by_size.mallocs.\nBecause memstats.BySize is an array of size 2 there are 2 values for memstats.BySize.Mallocs (35387 and 35387).\nTwo data points are created for metric memstats.by_size.mallocs for the 2 values. Additionaly, a dimension\nname memstats.by_size containing array index created for each respective datapoint.\n\nAlso, custom dimensions can be added to metric as shown below. The dimension name required if a dimension\nvalue is provided whereas it is optional when a JSONPath is provided instead.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.Mallocs\n      type: cumulative\n      - dimensions:\n        name: physical_memory\n        value: 4GiB\n      - name: app_mem\n        value: \"10 MiB\"\n  extraDimensions:\n    metric_source: expvar\n```\nA dimension JSONPath is configured as shown below. The monitor gets JSON key at the specified path as the\ndimension value. The dimension name is optional if the dimension JSONPath is specified. When not provided\nthe monitor snake cases the dimension JSONPath and uses that for the dimension name. The dimension JSONPath\nmust be shorter than the metric JSONPath and have the same root.\n```\nmonitors:\n- type: expvar\n  host: 172.12.0.5\n  path: /debug/vars\n  port: 5000\n  metrics:\n    - JSONPath: memstats.BySize.Mallocs\n      type: cumulative\n      - dimensions:\n        JSONPath: memstats\n      - dimensions:\n        name: by_size_index\n        JSONPath: memstats.BySize\n  extraDimensions:\n    metric_source: expvar\n```\nDO NOT configure the monitor for memstats metrics because they are standard metrics provided by default.\nmemstats was used to provide a realistic example.\n",
      "groups": null,
      "metrics": {
        "memstats.alloc": {
          "type": "gauge",
          "description": "Bytes of allocated heap objects. Same as memstats.heap_alloc",
          "group": null,
          "included": false
        },
        "memstats.buck_hash_sys": {
          "type": "gauge",
          "description": "Bytes of memory in profiling bucket hash tables",
          "group": null,
          "included": true
        },
        "memstats.by_size.frees": {
          "type": "counter",
          "description": "Cumulative count of heap objects freed in a class. The class is identified by dimension class and it is as described for metric memstats.by_size.size",
          "group": null,
          "included": false
        },
        "memstats.by_size.mallocs": {
          "type": "counter",
          "description": "Cumulative count of heap objects allocated in a class. The class is identified by dimension class and it is as described for metric memstats.by_size.size",
          "group": null,
          "included": false
        },
        "memstats.by_size.size": {
          "type": "counter",
          "description": "The maximum byte size of a class as identified by dimension class. It is the class interval upper limit. The values of dimension class are numbers between 0 and 60 inclusive. Consecutive classes are of consecutive dimension class values. The lower limit of a class is the upper limit of the consecutive class below. Metrics memstats.by_size.size, memstats.by_size.mallocs and memstats.by_size.frees of the same class are related",
          "group": null,
          "included": false
        },
        "memstats.debug_gc": {
          "type": "gauge",
          "description": "memstats.debug_gc is currently unused",
          "group": null,
          "included": false
        },
        "memstats.enable_gc": {
          "type": "gauge",
          "description": "Boolean that indicates that GC is enabled. It is always true, even if GOGC=off",
          "group": null,
          "included": true
        },
        "memstats.frees": {
          "type": "counter",
          "description": "Cumulative count of heap objects freed",
          "group": null,
          "included": true
        },
        "memstats.gc_sys": {
          "type": "gauge",
          "description": "Bytes of memory in garbage collection metadata",
          "group": null,
          "included": true
        },
        "memstats.gccpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started",
          "group": null,
          "included": true
        },
        "memstats.heap_alloc": {
          "type": "gauge",
          "description": "Bytes of allocated heap objects",
          "group": null,
          "included": true
        },
        "memstats.heap_idle": {
          "type": "gauge",
          "description": "Bytes in idle (unused) spans",
          "group": null,
          "included": true
        },
        "memstats.heap_inuse": {
          "type": "gauge",
          "description": "Bytes in in-use spans",
          "group": null,
          "included": true
        },
        "memstats.heap_objects": {
          "type": "gauge",
          "description": "Number of allocated heap objects",
          "group": null,
          "included": true
        },
        "memstats.heap_released": {
          "type": "gauge",
          "description": "Bytes of physical memory returned to the OS",
          "group": null,
          "included": true
        },
        "memstats.heap_sys": {
          "type": "gauge",
          "description": "Bytes of heap memory obtained from the OS",
          "group": null,
          "included": false
        },
        "memstats.last_gc": {
          "type": "gauge",
          "description": "The time the last garbage collection finished, as nanoseconds since 1970 (the UNIX epoch)",
          "group": null,
          "included": true
        },
        "memstats.lookups": {
          "type": "counter",
          "description": "Number of pointer lookups performed by the runtime",
          "group": null,
          "included": true
        },
        "memstats.m_cache_inuse": {
          "type": "gauge",
          "description": "Bytes of allocated mcache structures",
          "group": null,
          "included": true
        },
        "memstats.m_cache_sys": {
          "type": "gauge",
          "description": "Bytes of memory obtained from the OS for mcache structures",
          "group": null,
          "included": true
        },
        "memstats.m_span_inuse": {
          "type": "gauge",
          "description": "Bytes of allocated mspan structures",
          "group": null,
          "included": true
        },
        "memstats.m_span_sys": {
          "type": "gauge",
          "description": "Bytes of memory obtained from the OS for mspan",
          "group": null,
          "included": true
        },
        "memstats.mallocs": {
          "type": "counter",
          "description": "Cumulative count of heap objects allocated",
          "group": null,
          "included": true
        },
        "memstats.most_recent_gc_pause_end": {
          "type": "gauge",
          "description": "Most recent GC pause end time, as nanoseconds since 1970 (the UNIX epoch)",
          "group": null,
          "included": true
        },
        "memstats.most_recent_gc_pause_ns": {
          "type": "gauge",
          "description": "Most recent GC stop-the-world pause time in nanoseconds",
          "group": null,
          "included": true
        },
        "memstats.next_gc": {
          "type": "gauge",
          "description": "Target heap size of the next GC cycle",
          "group": null,
          "included": true
        },
        "memstats.num_forced_gc": {
          "type": "counter",
          "description": "Number of GC cycles that were forced by the application calling the GC function",
          "group": null,
          "included": true
        },
        "memstats.num_gc": {
          "type": "counter",
          "description": "Number of completed GC cycles",
          "group": null,
          "included": true
        },
        "memstats.other_sys": {
          "type": "gauge",
          "description": "Bytes of memory in miscellaneous off-heap runtime allocations",
          "group": null,
          "included": true
        },
        "memstats.pause_total_ns": {
          "type": "counter",
          "description": "Cumulative nanoseconds in GC stop-the-world pauses since the program started",
          "group": null,
          "included": true
        },
        "memstats.stack_inuse": {
          "type": "gauge",
          "description": "Bytes in stack spans",
          "group": null,
          "included": true
        },
        "memstats.stack_sys": {
          "type": "gauge",
          "description": "Bytes of stack memory obtained from the OS",
          "group": null,
          "included": true
        },
        "memstats.sys": {
          "type": "gauge",
          "description": "total bytes of memory obtained from the OS",
          "group": null,
          "included": true
        },
        "memstats.total_alloc": {
          "type": "counter",
          "description": "Cumulative bytes allocated for heap objects",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for monitor configuration",
        "package": "internal/monitors/expvar",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the expvar endpoint",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the expvar endpoint",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the host using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the host's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "path",
            "doc": "Path to the expvar endpoint, usually `/debug/vars` (the default).",
            "default": "/debug/vars",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "enhancedMetrics",
            "doc": "If true, sends metrics memstats.alloc, memstats.by_size.size, memstats.by_size.mallocs and memstats.by_size.frees",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metrics",
            "doc": "Metrics configurations",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "MetricConfig",
              "doc": "MetricConfig for metric configuration",
              "package": "internal/monitors/expvar",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "Metric name",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONPath",
                  "doc": "JSON path of the metric value",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "type",
                  "doc": "SignalFx metric type. Possible values are \"gauge\" or \"cumulative\"",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dimensions",
                  "doc": "Metric dimensions",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "DimensionConfig",
                    "doc": "DimensionConfig for metric dimension configuration",
                    "package": "internal/monitors/expvar",
                    "fields": [
                      {
                        "yamlName": "name",
                        "doc": "Dimension name",
                        "default": null,
                        "required": true,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "JSONPath",
                        "doc": "JSON path of the dimension value",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "value",
                        "doc": "Dimension value",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "filesystems",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports metrics about free disk space on mounted devices.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /hostfs/proc\nmonitors:\n - type: filesystems\n   hostFSPath: /hostfs\n```\n",
      "groups": null,
      "metrics": {
        "df_complex.free": {
          "type": "gauge",
          "description": "Free disk space in bytes",
          "group": null,
          "included": true
        },
        "df_complex.used": {
          "type": "gauge",
          "description": "Used disk space in bytes",
          "group": null,
          "included": true
        },
        "df_inodes.free": {
          "type": "gauge",
          "description": "(Linux Only) Number of inodes that are free.  This is is only reported if the configuration option `inodes` is set to `true`.",
          "group": "inodes",
          "included": false
        },
        "df_inodes.used": {
          "type": "gauge",
          "description": "(Linux Only) Number of inodes that are used.  This is only reported if the configuration option `inodes` is set to `true`.",
          "group": "inodes",
          "included": false
        },
        "disk.summary_utilization": {
          "type": "gauge",
          "description": "Percent of disk space utilized on all volumes on this host. This metric reports with plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "included": true
        },
        "disk.utilization": {
          "type": "gauge",
          "description": "Percent of disk used on this volume. This metric reports with plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "included": true
        },
        "percent_bytes.free": {
          "type": "gauge",
          "description": "Free disk space on the file system, expressed as a percentage.",
          "group": "logical",
          "included": false
        },
        "percent_bytes.used": {
          "type": "gauge",
          "description": "Used disk space on the file system, expressed as a percentage.",
          "group": "logical",
          "included": false
        },
        "percent_inodes.free": {
          "type": "gauge",
          "description": "(Linux Only) Free inodes on the file system, expressed as a percentage.  This is only reported if the configuration option `inodes` is set to `true`.",
          "group": "inodes",
          "included": false
        },
        "percent_inodes.used": {
          "type": "gauge",
          "description": "(Linux Only) Used inodes on the file system, expressed as a percentage.  This is only reported if the configuration option `inodes` is set to `true`.",
          "group": "inodes",
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/filesystems",
        "fields": [
          {
            "yamlName": "hostFSPath",
            "doc": "Path to the root of the host filesystem.  Useful when running in a container and the host filesystem is mounted in some subdirectory under /.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "fsTypes",
            "doc": "The filesystem types to include/exclude.  This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters).",
            "default": [
              "*",
              "!aufs",
              "!overlay",
              "!tmpfs",
              "!proc",
              "!sysfs",
              "!nsfs",
              "!cgroup",
              "!devpts",
              "!selinuxfs",
              "!devtmpfs",
              "!debugfs",
              "!mqueue",
              "!hugetlbfs",
              "!securityfs",
              "!pstore",
              "!binfmt_misc",
              "!autofs"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "mountPoints",
            "doc": "The mount paths to include/exclude. This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters). NOTE: If you are using the hostFSPath option you should not include the `/hostfs/` mount in the filter.",
            "default": [
              "*",
              "!/^/var/lib/docker/containers/",
              "!/^/var/lib/rkt/pods/",
              "!/^/net//",
              "!/^/smb//",
              "!/^/tmp/scratch/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "includeLogical",
            "doc": "(Linux Only) If true, then metrics will be reported about logical devices.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportByDevice",
            "doc": "If true, then metrics will report with their plugin_instance set to the device's name instead of the mountpoint.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "reportInodes",
            "doc": "(Linux Only) If true metrics will be reported about inodes.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab",
      "sendAll": false,
      "dimensions": null,
      "doc": "GitLab is an open-source web-based git repository manager developed by\nGitLab Inc. GitLab has built-in features for creating wiki pages,\nissue-tracking and CI/CD pipelines. GitLab is bundled with [Prometheus\nexporters](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html)\nthat can be configured to export performance metrics of itself and that of\nthe bundled software that GitLab depends on. These exporters publish\nPrometheus metrics at endpoints are scraped by this monitor.\n\n### REQUIREMENTS AND DEPENDENCIES\n\n| Software | Version |\n|----------|---------|\n| GitLab   | 9.3+    |\n\n### INSTALLATION\n\n### CONFIGURATION\n#### GitLab Configuration\n\nFollow the instructions\n[here](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html)\nto configure the GitLab's Prometheus exporters to expose metric endpoint\ntargets. For GitLab Runner monitoring configuration go\n[here](https://docs.gitlab.com/runner/monitoring/README.html).\n\nNote that configuring GitLab by editing `/etc/gitlab/gitlab.rb` should be\naccompanied by running the command `gitlab-ctl reconfigure` in order for\nthe changes to take effect.\n\nAlso, configuring Nginx by editing the file\n`/var/opt/gitlab/nginx/conf/nginx-status.conf`, for instance, should be\naccompanied by running command `gitlab-ctl restart`. Note that changes to\nthe configuration file `/var/opt/gitlab/nginx/conf/nginx-status.conf` in\nparticular are erased by subsequent runs of command `gitlab-ctl\nreconfigure` because `gitlab-ctl reconfigure` restores the original\nconfiguration file.\n\nBelow is a list of some of the Prometheus endpoint targets with links to\ntheir respective configuration pages. Note that target `gitlab_monitor`\nmetrics are just targets `gitlab_monitor_database`,\n`gitlab_monitor_process` and `gitlab_monitor_sidekiq` metrics combined.\n\n| Agent Monitor Type    |     Gitlab Doc                           | Standard Port | Standard Path |\n|-----------------------|------------------------------------------|---------------|---------------|\n| gitlab | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/gitlab_monitor_exporter.html) | 9168 | /metrics |\n| [gitlab-gitaly](gitlab-gitaly.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/gitaly/#doc-nav) | 9236 | /metrics |\n| [gitlab-sidekiq](gitlab-sidekiq.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 8082 | /metrics |\n| [gitlab-unicorn](gitlab-unicorn.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/gitlab_metrics.html#unicorn-metrics-available) | 8080 | /-/metrics |\n| [gitlab-workhorse](gitlab-workhorse.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 9229 | /metrics |\n| [prometheus/nginx-vts](prometheus-nginx-vts.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 8060 | /metrics |\n| [prometheus/node](prometheus-node.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/node_exporter.html) | 9100 | /metrics |\n| [promteheus/postgres](prometheus-postgres.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/postgres_exporter.html) | 9187 | /metrics |\n| [prometheus/prometheus](prometheus-prometheus.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 9090 | /metrics |\n| [prometheus/redis](prometheus-redis.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/redis_exporter.html) | 9121 | /metrics |\n| [gitlab-runner](gitlab-runner.md) | [Gitlab doc](https://docs.gitlab.com/ee/administration/monitoring/prometheus/index.html) | 9252 | /metrics |\n\nGitLab Prometheus exporters, Nginx and GitLab Runner must be configured to\nlisten to IP address(es) that include the IP address of the host or docker\ncontainer of the SignalFx Smart Agent. For example, the configuration below\nin `/etc/gitlab/gitlab.rb` configures the GitLab Postgres Prometheus\nexporter to allow network connections on port `9187` from any IP address.\n\n```\npostgres_exporter['listen_address'] = '0.0.0.0:9187'\n```\n\nThe above configuration can also be written as:\n\n```\npostgres_exporter['listen_address'] = ':9187'\n```\n\nBelow is part of file `/var/opt/gitlab/nginx/conf/nginx-status.conf`\nshowing the `location /metrics` block for metric related configuration.\nThis file configures Nginx. The statement `allow 172.17.0.0/16;` allows\nnetwork connection in the `172.17.0.0/16` IP range. The assumption is that\nthe IP address associated with the SignalFx Smart Agent is in that IP\nrange.\n\n```\nserver {\n    ...\n    location /metrics {\n    ...\n    allow 172.17.0.0/16;\n    deny all;\n    }\n}\n```\n\nBelow is part of the global section of `/etc/gitlab-runner/config.toml`. This file configures GitLab Runner. The statement below configures GitLab Runner's Prometheus metrics HTTP server to allows network connection on port `9252` from any IP address.\n\n```\nlisten_address = \"0.0.0.0:9252\"\n...\n\n```\n\n#### Sample Config\n\nTo monitor everything we support in Gitlab, use the following configuration in the Smart Agent config:\n\n```\nmonitors:\n - type: gitlab-unicorn\n   host: localhost\n   port: 8080\n\n - type: gitlab\n   host: localhost\n   port: 9168\n\n - type: gitlab-runner\n   host: localhost\n   port: 9252\n\n - type: gitlab-workhorse\n   host: localhost\n   port: 9229\n\n - type: gitlab-sidekiq\n   host: localhost\n   port: 8082\n\n - type: gitlab-gitaly\n   host: localhost\n   port: 9236\n   \n - type: prometheus/postgres\n   host: localhost\n   port: 9187\n\n - type: prometheus/nginx-vts\n   host: localhost\n   port: 8060\n\n```\n\nYou can, of course, use auto-discovery by specifying a `discoveryRule` instead of `host` and `port`.\n",
      "groups": null,
      "metrics": {
        "ci_stale_builds": {
          "type": "gauge",
          "description": "ci_stale_builds metric",
          "group": null,
          "included": false
        },
        "gitlab_cache_misses_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_database_rows": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_projects_with_jid": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_projects_without_jid": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_stuck_import_jobs_worker_runs_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "http_request_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "http_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "http_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "pg_stat_table_idx_tup_fetch": {
          "type": "gauge",
          "description": "pg_stat_table_idx_tup_fetch metric",
          "group": null,
          "included": true
        },
        "pg_stat_table_n_dead_tup": {
          "type": "gauge",
          "description": "pg_stat_table_n_dead_tup metric",
          "group": null,
          "included": false
        },
        "pg_stat_table_n_tup_del": {
          "type": "gauge",
          "description": "pg_stat_table_n_tup_del metric",
          "group": null,
          "included": true
        },
        "pg_stat_table_n_tup_hot_upd": {
          "type": "gauge",
          "description": "pg_stat_table_n_tup_hot_upd metric",
          "group": null,
          "included": false
        },
        "pg_stat_table_n_tup_ins": {
          "type": "gauge",
          "description": "pg_stat_table_n_tup_ins metric",
          "group": null,
          "included": true
        },
        "pg_stat_table_n_tup_upd": {
          "type": "gauge",
          "description": "pg_stat_table_n_tup_upd metric",
          "group": null,
          "included": true
        },
        "pg_stat_table_seq_scan": {
          "type": "gauge",
          "description": "pg_stat_table_seq_scan metric",
          "group": null,
          "included": false
        },
        "pg_stat_table_seq_tup_read": {
          "type": "gauge",
          "description": "pg_stat_table_seq_tup_read metric",
          "group": null,
          "included": true
        },
        "process_age_seconds": {
          "type": "gauge",
          "description": "process_age_seconds metric",
          "group": null,
          "included": false
        },
        "process_count": {
          "type": "gauge",
          "description": "process_count metric",
          "group": null,
          "included": true
        },
        "process_memory_bytes": {
          "type": "gauge",
          "description": "process_memory_bytes metric",
          "group": null,
          "included": false
        },
        "ruby_file_descriptors": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_duration_seconds_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_allocatable_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_allocated_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_available_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_eden_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_final_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_free_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_live_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_marked_slots": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_sorted_length": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_heap_tomb_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_major_gc_count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_malloc_increase_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_malloc_increase_bytes_limit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_minor_gc_count": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_old_objects": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_old_objects_limit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_oldmalloc_increase_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_oldmalloc_increase_bytes_limit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_remembered_wb_unprotected_objects": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_remembered_wb_unprotected_objects_limit": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_total_allocated_objects": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_total_allocated_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_total_freed_objects": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_gc_stat_total_freed_pages": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_memory_bytes": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "ruby_sampler_duration_seconds_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "sidekiq_dead_jobs_total": {
          "type": "gauge",
          "description": "sidekiq_dead_jobs_total metric",
          "group": null,
          "included": false
        },
        "sidekiq_queue_latency": {
          "type": "gauge",
          "description": "sidekiq_queue_latency metric",
          "group": null,
          "included": true
        },
        "sidekiq_queue_size": {
          "type": "gauge",
          "description": "sidekiq_queue_size metric",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/gitlab",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-gitaly",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes the [Gitlab Gitaly GRPC server](https://docs.gitlab.com/ee/administration/gitaly/).  See the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": null,
      "metrics": {
        "gitaly_authentications": {
          "type": "cumulative",
          "description": "Counts of of Gitaly request authentication attempts",
          "group": null,
          "included": false
        },
        "gitaly_connections_total": {
          "type": "cumulative",
          "description": "Total number of connections accepted by this Gitaly process",
          "group": null,
          "included": false
        },
        "gitaly_service_client_requests": {
          "type": "cumulative",
          "description": "Counter of client requests received by client, call_site, auth version, and response code",
          "group": null,
          "included": false
        },
        "gitaly_smarthttp_deepen_count": {
          "type": "cumulative",
          "description": "Number of git-upload-pack requests processed that contained a 'deepen' message",
          "group": null,
          "included": false
        },
        "gitaly_spawn_timeout_count": {
          "type": "cumulative",
          "description": "Number of process spawn timeouts",
          "group": null,
          "included": false
        },
        "gitaly_supervisor_health_checks": {
          "type": "cumulative",
          "description": "Count of Gitaly supervisor health checks",
          "group": null,
          "included": true
        },
        "gitaly_supervisor_rss_bytes": {
          "type": "gauge",
          "description": "Resident set size of supervised processes, in bytes",
          "group": null,
          "included": false
        },
        "gitaly_supervisor_starts_total": {
          "type": "cumulative",
          "description": "Number of starts of supervised processes",
          "group": null,
          "included": false
        },
        "gitlab_build_info": {
          "type": "gauge",
          "description": "Current build info for this GitLab Service",
          "group": null,
          "included": false
        },
        "grpc_server_handled_total": {
          "type": "cumulative",
          "description": "Total number of RPCs completed on the server, regardless of success or failure",
          "group": null,
          "included": true
        },
        "grpc_server_msg_received_total": {
          "type": "cumulative",
          "description": "Total number of RPC stream messages received on the server",
          "group": null,
          "included": false
        },
        "grpc_server_msg_sent_total": {
          "type": "cumulative",
          "description": "Total number of gRPC stream messages sent by the server",
          "group": null,
          "included": false
        },
        "grpc_server_started_total": {
          "type": "cumulative",
          "description": "Total number of RPCs started on the server",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/gitlab",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-runner",
      "sendAll": false,
      "dimensions": null,
      "doc": "Monitor for the [Gitlab runner service](https://docs.gitlab.com/runner/).  This usually runs on port 9252, so to monitor an instance on the same host as the agent, you can do:\n\n```yaml\nmonitors:\n- type: gitlab-runner\n  host: localhost\n  port: 9252\n```\n\nFor more information on configuring monitoring within Gitlab runner itself, see https://docs.gitlab.com/runner/monitoring/README.html.\n\nSee the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": null,
      "metrics": {
        "gitlab_runner_api_request_statuses_total": {
          "type": "cumulative",
          "description": "The total number of API requests, partitioned by runner, endpoint and status",
          "group": null,
          "included": false
        },
        "gitlab_runner_autoscaling_machine_creation_duration_seconds": {
          "type": "cumulative",
          "description": "Histogram of machine creation time",
          "group": null,
          "included": false
        },
        "gitlab_runner_autoscaling_machine_creation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Histogram of machine creation time",
          "group": null,
          "included": false
        },
        "gitlab_runner_autoscaling_machine_creation_duration_seconds_count": {
          "type": "cumulative",
          "description": "Histogram of machine creation time",
          "group": null,
          "included": false
        },
        "gitlab_runner_autoscaling_machine_states": {
          "type": "gauge",
          "description": "The current number of machines per state in this provider",
          "group": null,
          "included": false
        },
        "gitlab_runner_concurrent": {
          "type": "gauge",
          "description": "The current value of concurrent setting",
          "group": null,
          "included": false
        },
        "gitlab_runner_errors_total": {
          "type": "cumulative",
          "description": "The number of catched errors",
          "group": null,
          "included": true
        },
        "gitlab_runner_limit": {
          "type": "gauge",
          "description": "The current value of concurrent setting",
          "group": null,
          "included": false
        },
        "gitlab_runner_request_concurrency": {
          "type": "gauge",
          "description": "The current number of concurrent requests for a new job",
          "group": null,
          "included": true
        },
        "gitlab_runner_request_concurrency_exceeded_total": {
          "type": "cumulative",
          "description": "Counter tracking exceeding of request concurrency",
          "group": null,
          "included": false
        },
        "gitlab_runner_version_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by different build stats fields",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/gitlab",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-sidekiq",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes the Gitlab Sidekiq Prometheus Exporter.  See the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": null,
      "metrics": {
        "gitaly_controller_action_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitaly_controller_action_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitaly_controller_action_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_cache_misses_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_cache_operation_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_cache_operation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_cache_operation_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_repository_archive_clean_up_real_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_repository_archive_clean_up_real_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_repository_archive_clean_up_real_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_sql_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_sql_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_sql_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_cache_read_hit_count_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_cache_read_miss_count_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_sidekiq_queue_duration_total": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/gitlab",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-unicorn",
      "sendAll": false,
      "dimensions": null,
      "doc": "This is a monitor for GitLab's Unicorn server.  The Unicorn server comes\nwith a Prometheus exporter that runs by default on port 8080 at the path\n`/-/metrics`.  The IP address of the SignalFx Smart Agent container or\nhost, **needs to be whitelisted** as described\n[here](https://docs.gitlab.com/ee/administration/monitoring/ip_whitelist.html)\nin order for the agent to access the endpoint.\n\nTo monitor GitLab's Unicorn server using its Prometheus exporter, use a\nmonitor configuration similar to:\n\n```yaml\nmonitors:\n  - type: gitlab-unicorn\n    discoveryRule: port == 8080  # \u0026\u0026 \u003cother expressions to avoid false-positives on port alone\u003e\n    metricPath: /-/metrics\n```\n\nThe available metrics are [documented by GitLab](https://gitlab.com/gitlab-org/gitlab-ee/blob/master/doc/administration/monitoring/prometheus/gitlab_metrics.md#unicorn-metrics-available).\n\nSee the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": null,
      "metrics": {
        "gitlab_auth_user_authenticated_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_auth_user_unauthenticated_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_banzai_cacheless_render_real_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_banzai_cacheless_render_real_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_banzai_cacheless_render_real_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_cache_misses_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_cache_operation_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_cache_operation_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_cache_operation_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_rails_queue_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_rails_queue_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_rails_queue_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_sql_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_sql_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_sql_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_cache_read_hit_count_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_cache_read_miss_count_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_duration_seconds": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_duration_seconds_count": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_new_redis_connections_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_rails_queue_duration_total": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "gitlab_transaction_sidekiq_queue_duration_total": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": true
        },
        "gitlab_transaction_view_duration_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "http_requests_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "job_register_attempts_failed_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "job_register_attempts_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        },
        "unicorn_active_connections": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "unicorn_queued_connections": {
          "type": "gauge",
          "description": "",
          "group": null,
          "included": false
        },
        "user_session_logins_total": {
          "type": "cumulative",
          "description": "",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/gitlab",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "gitlab-workhorse",
      "sendAll": false,
      "dimensions": null,
      "doc": "This is a monitor for [GitLab\nWorkhorse](https://gitlab.com/gitlab-org/gitlab-workhorse), the GitLab\nservice that handles slow HTTP requests.  Workhorse includes a built-in\nPrometheus exporter that this monitor will hit to gather metrics.  By\ndefault, the exporter runs on port 9229.\n\nTo monitor Workhorse using its Prometheus exporter, use a monitor configuration similar to:\n\n```yaml\nmonitors:\n  - type: gitlab-workhorse\n    discoveryRule: port == 9229  # \u0026\u0026 \u003cother expressions to avoid false-positives on port alone\u003e\n```\n\nSee the [Gitlab monitor](gitlab.md) for more information.\n",
      "groups": null,
      "metrics": {
        "gitlab_workhorse_builds_register_handler_open": {
          "type": "gauge",
          "description": "Describes how many requests is currently open in given state",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_builds_register_handler_requests": {
          "type": "cumulative",
          "description": "Describes how many requests in different states hit a register handler",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_git_http_sessions_active": {
          "type": "gauge",
          "description": "Number of Git HTTP request-response cycles currently being handled by gitlab-workhorse",
          "group": null,
          "included": true
        },
        "gitlab_workhorse_http_in_flight_requests": {
          "type": "gauge",
          "description": "A gauge of requests currently being served by workhorse",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_http_request_duration_seconds": {
          "type": "cumulative",
          "description": "A histogram of latencies for requests to workhorse",
          "group": null,
          "included": true
        },
        "gitlab_workhorse_http_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "A histogram of latencies for requests to workhorse",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_http_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "A histogram of latencies for requests to workhorse",
          "group": null,
          "included": true
        },
        "gitlab_workhorse_http_request_size_bytes": {
          "type": "cumulative",
          "description": "A histogram of sizes of requests to workhorse",
          "group": null,
          "included": true
        },
        "gitlab_workhorse_http_request_size_bytes_bucket": {
          "type": "cumulative",
          "description": "A histogram of sizes of requests to workhorse",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_http_request_size_bytes_count": {
          "type": "cumulative",
          "description": "A histogram of sizes of requests to workhorse",
          "group": null,
          "included": true
        },
        "gitlab_workhorse_http_requests_total": {
          "type": "cumulative",
          "description": "A counter for requests to workhorse",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_http_time_to_write_header_seconds": {
          "type": "cumulative",
          "description": "A histogram of request durations until the response headers are written",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_http_time_to_write_header_seconds_bucket": {
          "type": "cumulative",
          "description": "A histogram of request durations until the response headers are written",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_http_time_to_write_header_seconds_count": {
          "type": "cumulative",
          "description": "A histogram of request durations until the response headers are written",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_internal_api_failure_response_bytes": {
          "type": "cumulative",
          "description": "How many bytes have been returned by upstream GitLab in API failure/rejection response bodies",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_keywatcher_keywatchers": {
          "type": "gauge",
          "description": "The number of keys that is being watched by gitlab-workhorse",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_keywather_total_messages": {
          "type": "cumulative",
          "description": "How many messages gitlab-workhorse has received in total on pubsub",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_object_storage_upload_bytes": {
          "type": "cumulative",
          "description": "How many bytes were sent to object storage",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_object_storage_upload_open": {
          "type": "gauge",
          "description": "Describes many object storage requests are open now",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_object_storage_upload_requests": {
          "type": "cumulative",
          "description": "How many object storage requests have been processed",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_redis_errors": {
          "type": "cumulative",
          "description": "Counts different types of Redis errors encountered by workhorse, by type and destination (redis, sentinel)",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_redis_total_connections": {
          "type": "cumulative",
          "description": "How many connections gitlab-workhorse has opened in total. Can be used to track Redis connection rate for this process",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_send_url_bytes": {
          "type": "cumulative",
          "description": "How many bytes were passed with send URL",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_send_url_open_requests": {
          "type": "gauge",
          "description": "Describes how many send URL requests are open now",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_send_url_requests": {
          "type": "cumulative",
          "description": "How many send URL requests have been processed",
          "group": null,
          "included": false
        },
        "gitlab_workhorse_static_error_responses": {
          "type": "cumulative",
          "description": "How many HTTP responses have been changed to a static error page, by HTTP status code.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/gitlab",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "host-metadata",
      "sendAll": false,
      "dimensions": {
        "collectd": {
          "description": "The version of collectd in the signalfx-agent"
        },
        "kernel_name": {
          "description": "The name of the host kernel."
        },
        "kernel_release": {
          "description": "The release of the host kernel."
        },
        "kernel_version": {
          "description": "The version of the host kernel."
        },
        "os_version": {
          "description": "The version of the os on the host."
        },
        "signalfx_agent": {
          "description": "The version of the signalfx-agent"
        }
      },
      "doc": "This monitor collects metadata properties about a\nhost.  It is required for some views in SignalFx to operate.\n\n```yaml\nmonitors:\n  - type: host-metadata\n```\n\nIn containerized environments host `/etc` and `/proc` may not be located\ndirectly under the root path.  You can specify the path to `proc` and `etc`\nusing the top level agent configurations `procPath` and `etcPath`\n\n```yaml\nprocPath: /proc\netcPath: /etc\nmonitors:\n  - type: host-metadata\n```\n\nMetadata updates occur on a sparse interval of approximately\n1m, 1m, 1h, 1d and continues repeating once per day.\nSetting the `Interval` configuration for this monitor will not affect the\nsparse interval on which metadata is collected.\n",
      "groups": null,
      "metrics": {
        "sfxagent.hostmetadata": {
          "type": "gauge",
          "description": "The time the hostmetadata monitor has been running in seconds.  It includes dimensional metadata about the host and agent.",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/metadata/hostmetadata",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "internal-metrics",
      "sendAll": true,
      "dimensions": null,
      "doc": "Emits metrics about the internal state of the\nagent.  Useful for debugging performance issues with the agent and to ensure\nthe agent isn't overloaded.\n\nThis can also scrape any HTTP endpoint that exposes metrics as a JSON array\ncontaining JSON-formatted SignalFx datapoint objects.  It is roughly\nanalogous to the `prometheus-exporter` monitor except for SignalFx\ndatapoints.\n\n```yaml\nmonitors:\n  - type: internal-metrics\n```\n",
      "groups": null,
      "metrics": {
        "sfxagent.active_monitors": {
          "type": "gauge",
          "description": "The total number of monitor instances actively working",
          "group": null,
          "included": false
        },
        "sfxagent.active_observers": {
          "type": "gauge",
          "description": "The number of observers configured and running",
          "group": null,
          "included": false
        },
        "sfxagent.configured_monitors": {
          "type": "gauge",
          "description": "The total number of monitor configurations",
          "group": null,
          "included": false
        },
        "sfxagent.datapoint_channel_len": {
          "type": "gauge",
          "description": "The total number of datapoints that have been emitted by monitors but have yet to be accepted by the writer. This number should be 0 most of the time.  This will max out at 3000, at which point no datapoints will be generated by monitors.  If it does max out, it indicates a bug or extreme CPU starvation of the agent.",
          "group": null,
          "included": false
        },
        "sfxagent.datapoint_requests_active": {
          "type": "gauge",
          "description": "The total number of outstanding requests to ingest currently active.  If this is consistently hovering around the `writer.maxRequests` setting, that setting should probably be increased to give the agent more bandwidth to send datapoints.",
          "group": null,
          "included": false
        },
        "sfxagent.datapoints_filtered": {
          "type": "cumulative",
          "description": "The total number of datapoints that were filtered out in the writer.  This does not include datapoints filtered by monitor-specific filters.",
          "group": null,
          "included": false
        },
        "sfxagent.datapoints_in_flight": {
          "type": "gauge",
          "description": "The total number of datapoints that have been sent out in a request to ingest but have yet to receive confirmation from ingest that they have been received (i.e. the HTTP response hasn't been gotten).",
          "group": null,
          "included": false
        },
        "sfxagent.datapoints_received": {
          "type": "cumulative",
          "description": "The total number of non-filtered datapoints received by the agent writer since it last started.  This number should generally equal `sfxagent.datapoints_sent + sfxagent.datapoints_waiting + sfxagent.datapoints_in_flight`, although sampling timing issues might cause it to temporarily not be.",
          "group": null,
          "included": false
        },
        "sfxagent.datapoints_sent": {
          "type": "cumulative",
          "description": "The total number of datapoints sent by the agent writer since it last started",
          "group": null,
          "included": false
        },
        "sfxagent.datapoints_waiting": {
          "type": "gauge",
          "description": "The total number of datapoints that have been accepted by the writer but have yet to be sent out to ingest over HTTP.  If this continues to grow it indicates that datapoints are not being sent out fast enough and the `writer.maxRequests` setting should be increased.",
          "group": null,
          "included": false
        },
        "sfxagent.dim_request_senders": {
          "type": "gauge",
          "description": "Current number of worker goroutines active that can send dimension updates.",
          "group": null,
          "included": false
        },
        "sfxagent.dim_updates_completed": {
          "type": "cumulative",
          "description": "Total number of dimension property updates successfully completed",
          "group": null,
          "included": false
        },
        "sfxagent.dim_updates_currently_delayed": {
          "type": "gauge",
          "description": "Current number of dimension updates that are being delayed to avoid sending spurious updates due to flappy dimension property sets.",
          "group": null,
          "included": false
        },
        "sfxagent.dim_updates_dropped": {
          "type": "cumulative",
          "description": "Total number of dimension property updates that were dropped, due to an overfull buffer of dimension updates pending.",
          "group": null,
          "included": false
        },
        "sfxagent.dim_updates_failed": {
          "type": "cumulative",
          "description": "Total number of dimension property updates that failed for some reason.  The failures should be logged.",
          "group": null,
          "included": false
        },
        "sfxagent.dim_updates_flappy_total": {
          "type": "cumulative",
          "description": "Total number of dimension property updates that ended up replacing a dimension property set that was being delayed.",
          "group": null,
          "included": false
        },
        "sfxagent.dim_updates_started": {
          "type": "cumulative",
          "description": "Total number of dimension property updates requests started, but not necessarily completed or failed.",
          "group": null,
          "included": false
        },
        "sfxagent.discovered_endpoints": {
          "type": "gauge",
          "description": "The number of discovered service endpoints.  This includes endpoints that do not have any matching monitor configuration discovery rule.",
          "group": null,
          "included": false
        },
        "sfxagent.events_buffered": {
          "type": "gauge",
          "description": "The total number of events that have been emitted by monitors but have yet to be sent to SignalFx",
          "group": null,
          "included": false
        },
        "sfxagent.events_sent": {
          "type": "cumulative",
          "description": "The total number of events sent by the agent since it last started",
          "group": null,
          "included": false
        },
        "sfxagent.go_frees": {
          "type": "cumulative",
          "description": "Total number of heap objects freed throughout the lifetime of the agent",
          "group": null,
          "included": false
        },
        "sfxagent.go_heap_alloc": {
          "type": "gauge",
          "description": "Bytes of live heap memory (memory that has been allocated but not freed)",
          "group": null,
          "included": false
        },
        "sfxagent.go_heap_idle": {
          "type": "gauge",
          "description": "Bytes of memory that consist of idle spans (that is, completely empty spans of memory)",
          "group": null,
          "included": false
        },
        "sfxagent.go_heap_inuse": {
          "type": "gauge",
          "description": "Size in bytes of in use spans",
          "group": null,
          "included": false
        },
        "sfxagent.go_heap_released": {
          "type": "gauge",
          "description": "Bytes of memory that have been returned to the OS.  This is quite often 0.  `sfxagent.go_heap_idle - sfxagent.go_heap_release` is the memory that Go is retaining for future heap allocations.",
          "group": null,
          "included": false
        },
        "sfxagent.go_heap_sys": {
          "type": "gauge",
          "description": "Virtual memory size in bytes of the agent.  This will generally reflect the largest heap size the agent has ever had in its lifetime.",
          "group": null,
          "included": false
        },
        "sfxagent.go_mallocs": {
          "type": "cumulative",
          "description": "Total number of heap objects allocated throughout the lifetime of the agent",
          "group": null,
          "included": false
        },
        "sfxagent.go_next_gc": {
          "type": "gauge",
          "description": "The target heap size -- GC tries to keep the heap smaller than this",
          "group": null,
          "included": false
        },
        "sfxagent.go_num_gc": {
          "type": "gauge",
          "description": "The number of GC cycles that have happened in the agent since it started",
          "group": null,
          "included": false
        },
        "sfxagent.go_stack_inuse": {
          "type": "gauge",
          "description": "Size in bytes of spans that have at least one goroutine stack in them",
          "group": null,
          "included": false
        },
        "sfxagent.go_total_alloc": {
          "type": "cumulative",
          "description": "Total number of bytes allocated to the heap throughout the lifetime of the agent",
          "group": null,
          "included": false
        },
        "sfxgent.go_num_goroutine": {
          "type": "gauge",
          "description": "Number of goroutines in the agent",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for internal metric monitoring",
        "package": "internal/monitors/internalmetrics",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Defaults to the top-level `internalStatusHost` option",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Defaults to the top-level `internalStatusPort` option",
            "default": null,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "path",
            "doc": "The HTTP request path to use to retrieve the metrics",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "kubelet-stats",
      "sendAll": false,
      "dimensions": {
        "container_id": {
          "description": "The ID of the running container"
        },
        "container_image": {
          "description": "The container image name"
        },
        "container_name": {
          "description": "The container's name as it appears in the pod spec, the same as container_spec_name but retained for backwards compatibility."
        },
        "container_spec_name": {
          "description": "The container's name as it appears in the pod spec"
        },
        "kubernetes_namespace": {
          "description": "The K8s namespace the container is part of"
        },
        "kubernetes_pod_name": {
          "description": "The pod instance under which this container runs"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod instance under which this container runs"
        }
      },
      "doc": "This monitor pulls cadvisor metrics through a\nKubernetes kubelet instance via the `/stats/container` endpoint.\n",
      "groups": null,
      "metrics": {
        "container_cpu_cfs_periods": {
          "type": "cumulative",
          "description": "Total number of elapsed CFS enforcement intervals",
          "group": null,
          "included": false
        },
        "container_cpu_cfs_throttled_periods": {
          "type": "cumulative",
          "description": "Total number of times tasks in the cgroup have been throttled",
          "group": null,
          "included": false
        },
        "container_cpu_cfs_throttled_time": {
          "type": "cumulative",
          "description": "Total time duration, in nanoseconds, for which tasks in the cgroup have been throttled",
          "group": null,
          "included": false
        },
        "container_cpu_percent": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization as a percentage of the total host CPU available.  This metric is equivalent to `container_cpu_utilization` / \u003c# of CPUs/cores on host\u003e.",
          "group": null,
          "included": false
        },
        "container_cpu_system_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative system cpu time consumed in nanoseconds",
          "group": null,
          "included": false
        },
        "container_cpu_usage_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative cpu time consumed per cpu in nanoseconds",
          "group": null,
          "included": false
        },
        "container_cpu_user_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative user cpu time consumed in nanoseconds",
          "group": null,
          "included": false
        },
        "container_cpu_utilization": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization in percentages.  This is equivalent to \"centicores\", or hundreths of CPU cores consumed.  This metric is **NOT** normalized by the total # of cores on the system.",
          "group": null,
          "included": true
        },
        "container_cpu_utilization_per_core": {
          "type": "cumulative",
          "description": "Cumulative cpu utilization in percentages per core",
          "group": null,
          "included": false
        },
        "container_fs_io_current": {
          "type": "gauge",
          "description": "Number of I/Os currently in progress",
          "group": null,
          "included": false
        },
        "container_fs_io_time_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent doing I/Os",
          "group": null,
          "included": false
        },
        "container_fs_io_time_weighted_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative weighted I/O time in seconds",
          "group": null,
          "included": false
        },
        "container_fs_limit_bytes": {
          "type": "gauge",
          "description": "Number of bytes that the container may occupy on this filesystem",
          "group": null,
          "included": false
        },
        "container_fs_read_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent reading",
          "group": null,
          "included": false
        },
        "container_fs_reads_merged_total": {
          "type": "cumulative",
          "description": "Cumulative count of reads merged",
          "group": null,
          "included": false
        },
        "container_fs_reads_total": {
          "type": "cumulative",
          "description": "Cumulative count of reads completed",
          "group": null,
          "included": false
        },
        "container_fs_sector_reads_total": {
          "type": "cumulative",
          "description": "Cumulative count of sector reads completed",
          "group": null,
          "included": false
        },
        "container_fs_sector_writes_total": {
          "type": "cumulative",
          "description": "Cumulative count of sector writes completed",
          "group": null,
          "included": false
        },
        "container_fs_usage_bytes": {
          "type": "gauge",
          "description": "Number of bytes that are consumed by the container on this filesystem",
          "group": null,
          "included": false
        },
        "container_fs_write_seconds_total": {
          "type": "cumulative",
          "description": "Cumulative count of seconds spent writing",
          "group": null,
          "included": false
        },
        "container_fs_writes_merged_total": {
          "type": "cumulative",
          "description": "Cumulative count of writes merged",
          "group": null,
          "included": false
        },
        "container_fs_writes_total": {
          "type": "cumulative",
          "description": "Cumulative count of writes completed",
          "group": null,
          "included": false
        },
        "container_last_seen": {
          "type": "gauge",
          "description": "Last time a container was seen by the exporter",
          "group": null,
          "included": false
        },
        "container_memory_failcnt": {
          "type": "cumulative",
          "description": "Number of memory usage hits limits",
          "group": null,
          "included": false
        },
        "container_memory_failures_total": {
          "type": "cumulative",
          "description": "Cumulative count of memory allocation failures",
          "group": null,
          "included": true
        },
        "container_memory_usage_bytes": {
          "type": "gauge",
          "description": "Current memory usage in bytes",
          "group": null,
          "included": true
        },
        "container_memory_working_set_bytes": {
          "type": "gauge",
          "description": "Current working set in bytes",
          "group": null,
          "included": false
        },
        "container_spec_cpu_period": {
          "type": "gauge",
          "description": "The number of microseconds that the [CFS scheduler](https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) uses as a window when limiting container processes",
          "group": null,
          "included": true
        },
        "container_spec_cpu_quota": {
          "type": "gauge",
          "description": "In CPU quota for the CFS process scheduler. In K8s this is equal to the containers's CPU limit as a fraction of 1 core and multiplied by the `container_spec_cpu_period`.  So if the CPU limit is `500m` (500 millicores) for a container and the `container_spec_cpu_period` is set to 100,000, this value will be 50,000.",
          "group": null,
          "included": true
        },
        "container_spec_cpu_shares": {
          "type": "gauge",
          "description": "CPU share of the container",
          "group": null,
          "included": false
        },
        "container_spec_memory_limit_bytes": {
          "type": "gauge",
          "description": "Memory limit for the container.",
          "group": null,
          "included": true
        },
        "container_spec_memory_swap_limit_bytes": {
          "type": "gauge",
          "description": "Memory swap limit for the container.",
          "group": null,
          "included": false
        },
        "container_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the container since unix epoch in seconds.",
          "group": null,
          "included": false
        },
        "container_tasks_state": {
          "type": "gauge",
          "description": "Number of tasks in given state",
          "group": null,
          "included": false
        },
        "machine_cpu_cores": {
          "type": "gauge",
          "description": "Number of CPU cores on the node.",
          "group": null,
          "included": true
        },
        "machine_cpu_frequency_khz": {
          "type": "gauge",
          "description": "Node's CPU frequency.",
          "group": null,
          "included": false
        },
        "machine_memory_bytes": {
          "type": "gauge",
          "description": "Amount of memory installed on the node.",
          "group": null,
          "included": true
        },
        "pod_network_receive_bytes_total": {
          "type": "cumulative",
          "description": "Cumulative count of bytes received",
          "group": null,
          "included": true
        },
        "pod_network_receive_errors_total": {
          "type": "cumulative",
          "description": "Cumulative count of errors encountered while receiving",
          "group": null,
          "included": true
        },
        "pod_network_receive_packets_dropped_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets dropped while receiving",
          "group": null,
          "included": false
        },
        "pod_network_receive_packets_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets received",
          "group": null,
          "included": false
        },
        "pod_network_transmit_bytes_total": {
          "type": "cumulative",
          "description": "Cumulative count of bytes transmitted",
          "group": null,
          "included": true
        },
        "pod_network_transmit_errors_total": {
          "type": "cumulative",
          "description": "Cumulative count of errors encountered while transmitting",
          "group": null,
          "included": true
        },
        "pod_network_transmit_packets_dropped_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets dropped while transmitting",
          "group": null,
          "included": false
        },
        "pod_network_transmit_packets_total": {
          "type": "cumulative",
          "description": "Cumulative count of packets transmitted",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "KubeletStatsConfig",
        "doc": "KubeletStatsConfig respresents config for the Kubelet stats monitor",
        "package": "internal/monitors/cadvisor",
        "fields": [
          {
            "yamlName": "kubeletAPI",
            "doc": "Kubelet client configuration",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains config specific to the KubeletAPI",
              "package": "internal/core/common/kubelet",
              "fields": [
                {
                  "yamlName": "url",
                  "doc": "URL of the Kubelet instance.  This will default to `https://\u003ccurrent node hostname\u003e:10250` if not provided.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "authType",
                  "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                  "default": "none",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verification of the Kubelet's TLS cert",
                  "default": true,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "logResponses",
                  "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-cluster",
      "sendAll": false,
      "dimensions": {
        "kubernetes_name": {
          "description": "The name of the resource that the metric describes"
        },
        "kubernetes_namespace": {
          "description": "The namespace of the resource that the metric describes"
        },
        "kubernetes_node": {
          "description": "The name of the node, as defined by the `name` field of the node resource."
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that the metric describes"
        },
        "machine_id": {
          "description": "The machine ID from /etc/machine-id.  This should be unique across all nodes in your cluster, but some cluster deployment tools don't guarantee this.  This will not be sent if the `useNodeName` config option is set to true."
        },
        "metric_source": {
          "description": "This is always set to `kubernetes`"
        },
        "quota_name": {
          "description": "The name of the k8s ResourceQuota object that the quota is part of"
        },
        "resource": {
          "description": "The k8s resource that the quota applies to"
        }
      },
      "doc": "*If you are using OpenShift there is an* [openshift-cluster](openshift-cluster.md)\n*monitor to be used instead of this monitor that contains additional OpenShift metrics.*\n\nCollects cluster-level metrics from the Kubernetes API server.  It uses the\n_watch_ functionality of the K8s API to listen for updates about the cluster\nand maintains a cache of metrics that get sent on a regular interval.\n\nSince the agent is generally running in multiple places in a K8s cluster and\nsince it is generally more convenient to share the same configuration across\nall agent instances, this monitor by default makes use of a leader election\nprocess to ensure that it is the only agent sending metrics in a cluster.\nAll of the agents running in the same namespace that have this monitor\nconfigured will decide amongst themselves which should send metrics for this\nmonitor, and the rest will stand by ready to activate if the leader agent\ndies.  You can override leader election by setting the config option\n`alwaysClusterReporter` to true, which will make the monitor always report\nmetrics.\n\nThis monitor is similar to\n[kube-state-metrics](https://github.com/kubernetes/kube-state-metrics), and\nsends many of the same metrics, but in a way that is less verbose and better\nfitted for the SignalFx backend.\n",
      "groups": null,
      "metrics": {
        "kubernetes.container_ready": {
          "type": "gauge",
          "description": "Whether a container has passed its readiness probe (0 for no, 1 for yes)",
          "group": null,
          "included": true
        },
        "kubernetes.container_restart_count": {
          "type": "gauge",
          "description": "How many times the container has restarted in the recent past.  This value is pulled directly from [the K8s API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#containerstatus-v1-core) and the value can go indefinitely high and be reset to 0 at any time depending on how your [kubelet is configured to prune dead containers](https://kubernetes.io/docs/concepts/cluster-administration/kubelet-garbage-collection/). It is best to not depend too much on the exact value but rather look at it as either `== 0`, in which case you can conclude there were no restarts in the recent past, or `\u003e 0`, in which case you can conclude there were restarts in the recent past, and not try and analyze the value beyond that.",
          "group": null,
          "included": true
        },
        "kubernetes.daemon_set.current_scheduled": {
          "type": "gauge",
          "description": "The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod",
          "group": null,
          "included": true
        },
        "kubernetes.daemon_set.desired_scheduled": {
          "type": "gauge",
          "description": "The total number of nodes that should be running the daemon pod (including nodes currently running the daemon pod)",
          "group": null,
          "included": true
        },
        "kubernetes.daemon_set.misscheduled": {
          "type": "gauge",
          "description": "The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod",
          "group": null,
          "included": true
        },
        "kubernetes.daemon_set.ready": {
          "type": "gauge",
          "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready",
          "group": null,
          "included": true
        },
        "kubernetes.deployment.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.",
          "group": null,
          "included": true
        },
        "kubernetes.deployment.desired": {
          "type": "gauge",
          "description": "Number of desired pods in this deployment",
          "group": null,
          "included": true
        },
        "kubernetes.namespace_phase": {
          "type": "gauge",
          "description": "The current phase of namespaces (`1` for _active_ and `0` for _terminating_)",
          "group": null,
          "included": true
        },
        "kubernetes.node_ready": {
          "type": "gauge",
          "description": "Whether this node is ready (1), not ready (0) or in an unknown state (-1)",
          "group": null,
          "included": true
        },
        "kubernetes.pod_phase": {
          "type": "gauge",
          "description": "Current phase of the pod (1 - Pending, 2 - Running, 3 - Succeeded, 4 - Failed, 5 - Unknown)",
          "group": null,
          "included": true
        },
        "kubernetes.replica_set.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replica set",
          "group": null,
          "included": true
        },
        "kubernetes.replica_set.desired": {
          "type": "gauge",
          "description": "Number of desired pods in this replica set",
          "group": null,
          "included": true
        },
        "kubernetes.replication_controller.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replication controller.",
          "group": null,
          "included": true
        },
        "kubernetes.replication_controller.desired": {
          "type": "gauge",
          "description": "Number of desired pods",
          "group": null,
          "included": true
        },
        "kubernetes.resource_quota_hard": {
          "type": "gauge",
          "description": "The upper limit for a particular resource in a specific namespace.  Will only be sent if a quota is specified.  CPU requests/limits will be sent as millicores.",
          "group": null,
          "included": true
        },
        "kubernetes.resource_quota_used": {
          "type": "gauge",
          "description": "The usage for a particular resource in a specific namespace.  Will only be sent if a quota is specified.  CPU requests/limits will be sent as millicores.",
          "group": null,
          "included": true
        }
      },
      "properties": {
        "\u003cnode label\u003e": {
          "dimension": "machine_id/kubernetes_node",
          "description": "All non-blank labels on a given node will be synced as properties to the `machine_id` or `kubernetes_node` dimension value for that node.  Which dimension gets the properties is determined by the `useNodeName` config option.  Any blank values will be synced as tags on that same dimension."
        },
        "\u003cpod label\u003e": {
          "dimension": "kubernetes_pod_uid",
          "description": "Any labels with non-blank values on the pod will be synced as properties to the `kubernetes_pod_uid` dimension. Any blank labels will be synced as tags on that same dimension."
        }
      },
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the K8s monitor",
        "package": "internal/monitors/kubernetes/cluster",
        "fields": [
          {
            "yamlName": "alwaysClusterReporter",
            "doc": "If `true`, leader election is skipped and metrics are always reported.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "namespace",
            "doc": "If specified, only resources within the given namespace will be monitored.  If omitted (blank) all supported resources across all namespaces will be monitored.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useNodeName",
            "doc": "If set to true, the Kubernetes node name will be used as the dimension to which to sync properties about each respective node.  This is necessary if your cluster's machines do not have unique machine-id values, as can happen when machine images are improperly cloned.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "kubernetesAPI",
            "doc": "Config for the K8s API client",
            "default": "",
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains options relevant to connecting to the K8s API",
              "package": "internal/core/common/kubernetes",
              "fields": [
                {
                  "yamlName": "authType",
                  "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                  "default": "serviceAccount",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "nodeConditionTypesToReport",
            "doc": "A list of node status condition types to report as metrics.  The metrics will be reported as datapoints of the form `kubernetes.node_\u003ctype_snake_cased\u003e` with a value of `0` corresponding to \"False\", `1` to \"True\", and `-1` to \"Unknown\".",
            "default": [
              "Ready"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-events",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor sends Kubernetes events as SignalFx\nevents.  Upon startup, it will send all of the events that K8s has that are\nstill persisted and then send any new events that come in.  The various\nagents perform leader election amongst themselves to decide which instance\nwill send events, unless the `alwaysClusterReporter` config option is set to\ntrue.\n\nTo use this monitor, will need to configure which events to send. You can\nsee the types of events happening in your cluster with\n`kubectl get events -o yaml --all-namespaces`.\nFrom the output, you can select which events you would like to send by picking\nout the Reason (Started, Created, Scheduled...) and\nKind (Pod, ReplicaSet, Deployment...) combinations. These are placed in the\nwhitelistedEvents configuration option as a list of events you want to send.\n\nExample YAML Configuration\n\n```\n- type: kubernetes-events\n  whitelistedEvents:\n    - reason: Created\n      involvedObjectKind: Pod\n    - reason: SuccessfulCreate\n      invovledObjectKind: ReplicaSet\n```\n\nEvent names will match the `reason` name.\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the K8s event monitor",
        "package": "internal/monitors/kubernetes/events",
        "fields": [
          {
            "yamlName": "kubernetesAPI",
            "doc": "Configuration of the Kubernetes API client",
            "default": "",
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains options relevant to connecting to the K8s API",
              "package": "internal/core/common/kubernetes",
              "fields": [
                {
                  "yamlName": "authType",
                  "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                  "default": "serviceAccount",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "whitelistedEvents",
            "doc": "A list of event types to send events for.  Only events matching these items will be sent.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "EventInclusionSpec",
              "doc": "EventInclusionSpec specifies a type of event to send",
              "package": "internal/monitors/kubernetes/events",
              "fields": [
                {
                  "yamlName": "reason",
                  "doc": "",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "involvedObjectKind",
                  "doc": "",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "alwaysClusterReporter",
            "doc": "Whether to always send events from this agent instance or to do leader election to only send from one agent instance.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "kubernetes-volumes",
      "sendAll": true,
      "dimensions": {
        "VolumeId": {
          "description": "(*EBS volumes only*) The EBS volume id of the underlying volume source"
        },
        "endpoints_name": {
          "description": "(*GlusterFS volumes only*) The endpoint name used for the GlusterFS volume"
        },
        "glusterfs_path": {
          "description": "(*GlusterFS volumes only*) The GlusterFS volume path"
        },
        "kubernetes_namespace": {
          "description": "The namespace of the pod that has this volume"
        },
        "kubernetes_pod_name": {
          "description": "The name of the pod that has this volume"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that has this volume"
        },
        "partition": {
          "description": "(*EBS volumes only*) The partition number of the underlying EBS volume (`0` indicates the entire disk)"
        },
        "volume": {
          "description": "The volume name as given in the pod spec under `volumes`"
        },
        "volume_type": {
          "description": "The type of the underlying volume -- this will be the key used in the k8s volume config spec (e.g. awsElasticBlockStore, etc.)"
        }
      },
      "doc": "This monitor sends usage stats about volumes\nmounted to Kubernetes pods (e.g. free space/inodes).  This information is\ngotten from the Kubelet /stats/summary endpoint.  The normal `collectd/df`\nmonitor generally will not report Persistent Volume usage metrics because\nthose volumes are not seen by the agent since they can be mounted\ndynamically and older versions of K8s don't support mount propagation of\nthose mounts to the agent container.\n\nDimensions that identify the underlying volume source will be added for\n`awsElasticBlockStore` and `glusterfs` volumes.  Support for more can be\neasily added as needed.\n",
      "groups": null,
      "metrics": {
        "kubernetes.volume_available_bytes": {
          "type": "gauge",
          "description": "The number of available bytes in the volume",
          "group": null,
          "included": false
        },
        "kubernetes.volume_capacity_bytes": {
          "type": "gauge",
          "description": "The total capacity in bytes of the volume",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/kubernetes/volumes",
        "fields": [
          {
            "yamlName": "kubeletAPI",
            "doc": "Kubelet kubeletClient configuration",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains config specific to the KubeletAPI",
              "package": "internal/core/common/kubelet",
              "fields": [
                {
                  "yamlName": "url",
                  "doc": "URL of the Kubelet instance.  This will default to `https://\u003ccurrent node hostname\u003e:10250` if not provided.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "authType",
                  "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                  "default": "none",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verification of the Kubelet's TLS cert",
                  "default": true,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "logResponses",
                  "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "kubernetesAPI",
            "doc": "Configuration of the Kubernetes API kubeletClient",
            "default": "",
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains options relevant to connecting to the K8s API",
              "package": "internal/core/common/kubernetes",
              "fields": [
                {
                  "yamlName": "authType",
                  "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                  "default": "serviceAccount",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "memory",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports memory and memory utilization metrics.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: memory\n```\n",
      "groups": null,
      "metrics": {
        "memory.available": {
          "type": "gauge",
          "description": "(Windows Only) Bytes of memory available for use.",
          "group": null,
          "included": false
        },
        "memory.buffered": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory used for buffering I/O.",
          "group": null,
          "included": true
        },
        "memory.cached": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory used for disk caching.",
          "group": null,
          "included": true
        },
        "memory.free": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory available for use.",
          "group": null,
          "included": true
        },
        "memory.slab_recl": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory, used for SLAB-allocation of kernel objects, that can be reclaimed.",
          "group": null,
          "included": true
        },
        "memory.slab_unrecl": {
          "type": "gauge",
          "description": "(Linux Only) Bytes of memory, used for SLAB-allocation of kernel objects, that can't be reclaimed.",
          "group": null,
          "included": true
        },
        "memory.used": {
          "type": "gauge",
          "description": "Bytes of memory in use by the system.",
          "group": null,
          "included": true
        },
        "memory.utilization": {
          "type": "gauge",
          "description": "Percent of memory in use on this host. This metric reports with plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/memory",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "net-io",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports I/O metrics about network interfaces.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: net-io\n```\n",
      "groups": null,
      "metrics": {
        "if_errors.rx": {
          "type": "cumulative",
          "description": "Count of receive errors on the interface",
          "group": null,
          "included": true
        },
        "if_errors.tx": {
          "type": "cumulative",
          "description": "Count of transmit errors on the interface",
          "group": null,
          "included": true
        },
        "if_octets.rx": {
          "type": "cumulative",
          "description": "Count of bytes (octets) received on the interface",
          "group": null,
          "included": true
        },
        "if_octets.tx": {
          "type": "cumulative",
          "description": "Count of bytes (octets) transmitted by the interface",
          "group": null,
          "included": true
        },
        "if_packets.rx": {
          "type": "cumulative",
          "description": "Count of packets received on the interface",
          "group": null,
          "included": false
        },
        "if_packets.tx": {
          "type": "cumulative",
          "description": "Count of packets transmitted by the interface",
          "group": null,
          "included": false
        },
        "network.total": {
          "type": "cumulative",
          "description": "Total amount of inbound and outbound network traffic on this host, in bytes.  This metric reports with plugin dimension set to \"signalfx-metadata\".",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/netio",
        "fields": [
          {
            "yamlName": "interfaces",
            "doc": "The network interfaces to send metrics about. This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters).",
            "default": [
              "*",
              "!/^lo\\d*$/",
              "!/^docker.*/",
              "!/^t(un|ap)\\d*$/",
              "!/^veth.*$/",
              "!/^Loopback*/"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "openshift-cluster",
      "sendAll": false,
      "dimensions": {
        "kubernetes_name": {
          "description": "The name of the resource that the metric describes"
        },
        "kubernetes_namespace": {
          "description": "The namespace of the resource that the metric describes"
        },
        "kubernetes_node": {
          "description": "The name of the node, as defined by the `name` field of the node resource."
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that the metric describes"
        },
        "machine_id": {
          "description": "The machine ID from /etc/machine-id.  This should be unique across all nodes in your cluster, but some cluster deployment tools don't guarantee this.  This will not be sent if the `useNodeName` config option is set to true."
        },
        "metric_source": {
          "description": "This is always set to `openshift`"
        },
        "quota_name": {
          "description": "The name of the k8s ResourceQuota object that the quota is part of"
        },
        "resource": {
          "description": "The k8s resource that the quota applies to"
        }
      },
      "doc": "This monitor is for use with an OpenShift cluster. It includes all metrics\nfrom the [kubernetes-cluster](kubernetes-cluster.md) monitor with additional\nOpenShift-specific metrics. You only need to use one monitor or the other.\n\nCollects cluster-level metrics from the Kubernetes API server.  It uses the\n_watch_ functionality of the K8s API to listen for updates about the cluster\nand maintains a cache of metrics that get sent on a regular interval.\n\nSince the agent is generally running in multiple places in a K8s cluster and\nsince it is generally more convenient to share the same configuration across\nall agent instances, this monitor by default makes use of a leader election\nprocess to ensure that it is the only agent sending metrics in a cluster.\nAll of the agents running in the same namespace that have this monitor\nconfigured will decide amongst themselves which should send metrics for this\nmonitor, and the rest will stand by ready to activate if the leader agent\ndies.  You can override leader election by setting the config option\n`alwaysClusterReporter` to true, which will make the monitor always report\nmetrics.\n\nThis monitor is similar to\n[kube-state-metrics](https://github.com/kubernetes/kube-state-metrics), and\nsends many of the same metrics, but in a way that is less verbose and better\nfitted for the SignalFx backend.\n",
      "groups": null,
      "metrics": {
        "kubernetes.container_ready": {
          "type": "gauge",
          "description": "Whether a container has passed its readiness probe (0 for no, 1 for yes)",
          "group": null,
          "included": true
        },
        "kubernetes.container_restart_count": {
          "type": "gauge",
          "description": "How many times the container has restarted in the recent past.  This value is pulled directly from [the K8s API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#containerstatus-v1-core) and the value can go indefinitely high and be reset to 0 at any time depending on how your [kubelet is configured to prune dead containers](https://kubernetes.io/docs/concepts/cluster-administration/kubelet-garbage-collection/). It is best to not depend too much on the exact value but rather look at it as either `== 0`, in which case you can conclude there were no restarts in the recent past, or `\u003e 0`, in which case you can conclude there were restarts in the recent past, and not try and analyze the value beyond that.",
          "group": null,
          "included": true
        },
        "kubernetes.daemon_set.current_scheduled": {
          "type": "gauge",
          "description": "The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod",
          "group": null,
          "included": true
        },
        "kubernetes.daemon_set.desired_scheduled": {
          "type": "gauge",
          "description": "The total number of nodes that should be running the daemon pod (including nodes currently running the daemon pod)",
          "group": null,
          "included": true
        },
        "kubernetes.daemon_set.misscheduled": {
          "type": "gauge",
          "description": "The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod",
          "group": null,
          "included": true
        },
        "kubernetes.daemon_set.ready": {
          "type": "gauge",
          "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready",
          "group": null,
          "included": true
        },
        "kubernetes.deployment.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.",
          "group": null,
          "included": true
        },
        "kubernetes.deployment.desired": {
          "type": "gauge",
          "description": "Number of desired pods in this deployment",
          "group": null,
          "included": true
        },
        "kubernetes.namespace_phase": {
          "type": "gauge",
          "description": "The current phase of namespaces (`1` for _active_ and `0` for _terminating_)",
          "group": null,
          "included": true
        },
        "kubernetes.node_ready": {
          "type": "gauge",
          "description": "Whether this node is ready (1), not ready (0) or in an unknown state (-1)",
          "group": null,
          "included": true
        },
        "kubernetes.pod_phase": {
          "type": "gauge",
          "description": "Current phase of the pod (1 - Pending, 2 - Running, 3 - Succeeded, 4 - Failed, 5 - Unknown)",
          "group": null,
          "included": true
        },
        "kubernetes.replica_set.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replica set",
          "group": null,
          "included": true
        },
        "kubernetes.replica_set.desired": {
          "type": "gauge",
          "description": "Number of desired pods in this replica set",
          "group": null,
          "included": true
        },
        "kubernetes.replication_controller.available": {
          "type": "gauge",
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replication controller.",
          "group": null,
          "included": true
        },
        "kubernetes.replication_controller.desired": {
          "type": "gauge",
          "description": "Number of desired pods",
          "group": null,
          "included": true
        },
        "kubernetes.resource_quota_hard": {
          "type": "gauge",
          "description": "The upper limit for a particular resource in a specific namespace.  Will only be sent if a quota is specified.  CPU requests/limits will be sent as millicores.",
          "group": null,
          "included": true
        },
        "kubernetes.resource_quota_used": {
          "type": "gauge",
          "description": "The usage for a particular resource in a specific namespace.  Will only be sent if a quota is specified.  CPU requests/limits will be sent as millicores.",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.cpu.hard": {
          "type": "gauge",
          "description": "Hard limit for number of cpu by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.cpu.used": {
          "type": "gauge",
          "description": "Consumed number of cpu by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.memory.hard": {
          "type": "gauge",
          "description": "Hard limit for amount of memory by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.memory.used": {
          "type": "gauge",
          "description": "Consumed amount of memory by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.persistentvolumeclaims.hard": {
          "type": "gauge",
          "description": "Hard limit for number of persistentvolumeclaims by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.persistentvolumeclaims.used": {
          "type": "gauge",
          "description": "Consumed number of persistentvolumeclaims by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.pods.hard": {
          "type": "gauge",
          "description": "Hard limit for number of pods by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.pods.used": {
          "type": "gauge",
          "description": "Consumed number of pods by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.services.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.services.loadbalancers.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services.loadbalancers by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.services.loadbalancers.used": {
          "type": "gauge",
          "description": "Consumed number of services.loadbalancers by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.services.nodeports.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services.nodeports by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.services.nodeports.used": {
          "type": "gauge",
          "description": "Consumed number of services.nodeports by namespace",
          "group": null,
          "included": true
        },
        "openshift.appliedclusterquota.services.used": {
          "type": "gauge",
          "description": "Consumed number of services by namespace",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.cpu.hard": {
          "type": "gauge",
          "description": "Hard limit for number of cpu across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.cpu.used": {
          "type": "gauge",
          "description": "Consumed number of cpu across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.memory.hard": {
          "type": "gauge",
          "description": "Hard limit for amount of memory across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.memory.used": {
          "type": "gauge",
          "description": "Consumed amount of memory across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.persistentvolumeclaims.hard": {
          "type": "gauge",
          "description": "Hard limit for number of persistentvolumeclaims across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.persistentvolumeclaims.used": {
          "type": "gauge",
          "description": "Consumed number of persistentvolumeclaims across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.pods.hard": {
          "type": "gauge",
          "description": "Hard limit for number of pods across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.pods.used": {
          "type": "gauge",
          "description": "Consumed number of pods across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.services.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.services.loadbalancers.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services.loadbalancers across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.services.loadbalancers.used": {
          "type": "gauge",
          "description": "Consumed number of services.loadbalancers across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.services.nodeports.hard": {
          "type": "gauge",
          "description": "Hard limit for number of services.nodeports across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.services.nodeports.used": {
          "type": "gauge",
          "description": "Consumed number of services.nodeports across all namespaces",
          "group": null,
          "included": true
        },
        "openshift.clusterquota.services.used": {
          "type": "gauge",
          "description": "Consumed number of services across all namespaces",
          "group": null,
          "included": true
        }
      },
      "properties": {
        "\u003cnode label\u003e": {
          "dimension": "machine_id/kubernetes_node",
          "description": "All non-blank labels on a given node will be synced as properties to the `machine_id` or `kubernetes_node` dimension value for that node.  Which dimension gets the properties is determined by the `useNodeName` config option.  Any blank values will be synced as tags on that same dimension."
        },
        "\u003cpod label\u003e": {
          "dimension": "kubernetes_pod_uid",
          "description": "Any labels with non-blank values on the pod will be synced as properties to the `kubernetes_pod_uid` dimension. Any blank labels will be synced as tags on that same dimension."
        }
      },
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the K8s monitor",
        "package": "internal/monitors/kubernetes/cluster",
        "fields": [
          {
            "yamlName": "alwaysClusterReporter",
            "doc": "If `true`, leader election is skipped and metrics are always reported.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "namespace",
            "doc": "If specified, only resources within the given namespace will be monitored.  If omitted (blank) all supported resources across all namespaces will be monitored.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useNodeName",
            "doc": "If set to true, the Kubernetes node name will be used as the dimension to which to sync properties about each respective node.  This is necessary if your cluster's machines do not have unique machine-id values, as can happen when machine images are improperly cloned.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "kubernetesAPI",
            "doc": "Config for the K8s API client",
            "default": "",
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "APIConfig",
              "doc": "APIConfig contains options relevant to connecting to the K8s API",
              "package": "internal/core/common/kubernetes",
              "fields": [
                {
                  "yamlName": "authType",
                  "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                  "default": "serviceAccount",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "skipVerify",
                  "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientCertPath",
                  "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "clientKeyPath",
                  "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "caCertPath",
                  "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "nodeConditionTypesToReport",
            "doc": "A list of node status condition types to report as metrics.  The metrics will be reported as datapoints of the form `kubernetes.node_\u003ctype_snake_cased\u003e` with a value of `0` corresponding to \"False\", `1` to \"True\", and `-1` to \"Unknown\".",
            "default": [
              "Ready"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "postgresql",
      "sendAll": false,
      "dimensions": {
        "database": {
          "description": "The name of the database within a PostgreSQL server to which the metric pertains."
        },
        "index": {
          "description": "For index metrics, the name of the index"
        },
        "schemaname": {
          "description": "The name of the schema within which the object being monitored resides (e.g. `public`)."
        },
        "table": {
          "description": "The name of the table to which the metric pertains."
        },
        "tablespace": {
          "description": "For table metrics, the tablespace in which the table belongs, if not null."
        },
        "type": {
          "description": "Whether the object (table, index, function, etc.) belongs to the `system` or `user`."
        },
        "user": {
          "description": "For query metrics, the user name of the user that executed the queries."
        }
      },
      "doc": "This monitor pulls metrics from all PostgreSQL databases from a specific\nPostgres server instance.  It pulls basic information that is applicable\nto any database.\n\n## Metrics about Queries\n\nIn order to get metrics about query execution time, you must enable the\n`pg_stat_statements` extension.  This extension must be specified in the\n`shared_preload_libraries` config option in the main PostgreSQL\nconfiguration at server start up.  Then the extension must be enabled for\neach database by running `CREATE EXTENSION IF NOT EXISTS\npg_stat_statements;` on each database.\n\nNote that in order to get consistent and accurate query execution time\nmetrics, you must set the [pg_stat_statements.max config\noption](https://www.postgresql.org/docs/9.3/pgstatstatements.html#AEN160631)\nto larger than the number of distinct queries on the server.\n\nHere is a [sample configuration of Postgres to enable statement tracking](https://www.postgresql.org/docs/9.3/pgstatstatements.html#AEN160631).\n\nTested with PostgreSQL 9.2+.\n\nIf you want to collect additional metrics about PostgreSQL, use the [sql monitor](./sql.md).\n\n## Example Configuration\n\nThis example uses the [Vault remote config\nsource](https://github.com/signalfx/signalfx-agent/blob/master/docs/remote-config.md#nested-values-vault-only)\nto connect to PostgreSQL using the `params` map that allows you to pull\nout the username and password individually from Vault and interpolate\nthem into the `connectionString` config option.\n\n```\nmonitors:\n - type: postgresql\n   connectionString: 'sslmode=disable user={{.username}} password={{.password}}'\n   params: \u0026psqlParams\n     username: {\"#from\": \"vault:secret/my-database[username]\"}\n     password: {\"#from\": \"vault:secret/my-database[password]\"}\n   discoveryRule: 'container_image =~ \"postgres\" \u0026\u0026 port == 5432'\n\n # This monitor will monitor additional queries from PostgreSQL using the\n # provided SQL queries.\n - type: sql\n   dbDriver: postgres\n   connectionString: 'sslmode=disable user={{.username}} password={{.password}}'\n   # This is a YAML reference to avoid duplicating the above config.\n   params: *psqlParams\n   queries:\n     - query: 'SELECT COUNT(*) as count, country, status FROM customers GROUP BY country, status;'\n       metrics:\n         - metricName: \"customers\"\n           valueColumn: \"count\"\n           dimensionColumns: [\"country\", \"status\"]\n```\n",
      "groups": null,
      "metrics": {
        "postgres_block_hit_ratio": {
          "type": "gauge",
          "description": "The proportion (between 0 and 1, inclusive) of block reads that used the cache and did not have to go to the disk.  Is sent for `table`, `index`, and the `database` as a whole.",
          "group": null,
          "included": true
        },
        "postgres_database_size": {
          "type": "gauge",
          "description": "Size in bytes of the database on disk",
          "group": null,
          "included": true
        },
        "postgres_deadlocks": {
          "type": "cumulative",
          "description": "Total number of deadlocks detected by the system",
          "group": null,
          "included": true
        },
        "postgres_index_scans": {
          "type": "cumulative",
          "description": "Total number of index scans on the `table`.",
          "group": null,
          "included": true
        },
        "postgres_live_rows": {
          "type": "gauge",
          "description": "Number of rows live (not deleted) in the `table`.",
          "group": null,
          "included": true
        },
        "postgres_query_count": {
          "type": "cumulative",
          "description": "Total number of queries executed on the `database`, broken down by\n`user`.  Note that the accuracy of this metric depends on the\nPostgreSQL [pg_stat_statements.max config\noption](https://www.postgresql.org/docs/9.3/pgstatstatements.html#AEN160631)\nbeing large enough to hold all queries.\n",
          "group": null,
          "included": true
        },
        "postgres_query_time": {
          "type": "cumulative",
          "description": "Total time taken to execute queries on the `database`, broken down by `user`.",
          "group": null,
          "included": true
        },
        "postgres_rows_deleted": {
          "type": "cumulative",
          "description": "Number of rows deleted from the `table`.",
          "group": null,
          "included": true
        },
        "postgres_rows_inserted": {
          "type": "cumulative",
          "description": "Number of rows inserted into the `table`.",
          "group": null,
          "included": true
        },
        "postgres_rows_updated": {
          "type": "cumulative",
          "description": "Number of rows updated in the `table`.",
          "group": null,
          "included": true
        },
        "postgres_sequential_scans": {
          "type": "cumulative",
          "description": "Total number of sequential scans on the `table`.",
          "group": null,
          "included": true
        },
        "postgres_sessions": {
          "type": "gauge",
          "description": "Number of sessions currently on the server instance.  The `state` dimension will specify which which type of session (see `state` row of [pg_stat_activity](https://www.postgresql.org/docs/9.2/monitoring-stats.html#PG-STAT-ACTIVITY-VIEW)).",
          "group": null,
          "included": true
        },
        "postgres_table_size": {
          "type": "gauge",
          "description": "The size in bytes of the `table` on disk.",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for the postgresql monitor",
        "package": "internal/monitors/postgresql",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "connectionString",
            "doc": "See https://godoc.org/github.com/lib/pq#hdr-Connection_String_Parameters.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "params",
            "doc": "Parameters to the connection string that can be templated into the connection string with the syntax `{{.key}}`.",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "databases",
            "doc": "List of databases to send database-specific metrics about.  If omitted, metrics about all databases will be sent.  This is an [overridable set](https://docs.signalfx.com/en/latest/integrations/agent/filtering.html#overridable-filters).",
            "default": [
              "*"
            ],
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "databasePollIntervalSeconds",
            "doc": "How frequently to poll for new/deleted databases in the DB server. Defaults to the same as `intervalSeconds` if not set.",
            "default": 0,
            "required": false,
            "type": "int",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "processlist",
      "sendAll": false,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports processlist\ninformation for Windows Hosts.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: processlist\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/processlist",
        "fields": []
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "prometheus-exporter",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reads metrics from a [Prometheus\nexporter](https://prometheus.io/docs/instrumenting/exporters/) endpoint.\n\nAll metric types are supported.  See\nhttps://prometheus.io/docs/concepts/metric_types/ for a description of the\nPrometheus metric types.  The conversion happens as follows:\n\n - Gauges are converted directly to SignalFx gauges\n - Counters are converted directly to SignalFx cumulative counters\n - Untyped metrics are converted directly to SignalFx gauges\n - Summary metrics are converted to three distinct metrics, where\n   `\u003cbasename\u003e` is the root name of the metric:\n   - The total count gets converted to a cumulative counter called `\u003cbasename\u003e_count`\n   - The total sum gets converted to a cumulative counter called `\u003cbasename\u003e`\n   - Each quantile value is converted to a gauge called\n     `\u003cbasename\u003e_quantile` and will include a dimension called `quantile` that\n     specifies the quantile.\n - Histogram metrics are converted to three distinct metrics, where\n   `\u003cbasename\u003e` is the root name of the metric:\n   - The total count gets converted to a cumulative counter called `\u003cbasename\u003e_count`\n   - The total sum gets converted to a cumulative counter called `\u003cbasename\u003e`\n   - Each histogram bucket is converted to a cumulative counter called\n     `\u003cbasename\u003e_bucket` and will include a dimension called `upper_bound` that\n     specifies the maximum value in that bucket.  This metric specifies the\n     number of events with a value that is less than or equal to the upper\n     bound.\n\nAll Prometheus labels will be converted directly to SignalFx dimensions.\n\nThis supports service discovery so you can set a discovery rule such as:\n\n`port \u003e= 9100 \u0026\u0026 port \u003c= 9500 \u0026\u0026 containerImage =~ \"exporter\"`\n\nassuming you are running exporters in container images that have the word\n\"exporter\" in them and fall within the standard exporter port range.  In\nK8s, you could also try matching on the container port name as defined in\nthe pod spec, which is the `name` variable in discovery rules for the\n`k8s-api` observer.\n\nFiltering can be very useful here since exporters tend to be fairly verbose.\n\nSample YAML configuration:\n\n```\nmonitors:\n - type: prometheus-exporter\n   discoveryRule: port \u003e= 9100 \u0026\u0026 port \u003c= 9500 \u0026\u0026 container_image =~ \"exporter\"\n   extraDimensions:\n     metric_source: prometheus\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/prometheusexporter",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/go",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus Go\ncollector](https://godoc.org/github.com/prometheus/client_golang/prometheus#NewGoCollector)\nand [Prometheus process\ncollector](https://godoc.org/github.com/prometheus/client_golang/prometheus#NewProcessCollector)\nmetrics from a Prometheus exporter and sends them to SignalFx.  It is a\nwrapper around the [prometheus-exporter](./prometheus-exporter.md) monitor\nthat provides a restricted but expandable set of metrics.\n",
      "groups": null,
      "metrics": {
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations",
          "group": null,
          "included": false
        },
        "go_gc_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations",
          "group": null,
          "included": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations",
          "group": null,
          "included": false
        },
        "go_goroutines": {
          "type": "gauge",
          "description": "Number of goroutines that currently exist",
          "group": null,
          "included": false
        },
        "go_info": {
          "type": "gauge",
          "description": "Information about the Go environment",
          "group": null,
          "included": false
        },
        "go_memstats_alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated and still in use",
          "group": null,
          "included": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed",
          "group": null,
          "included": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table",
          "group": null,
          "included": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees",
          "group": null,
          "included": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started",
          "group": null,
          "included": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata",
          "group": null,
          "included": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use",
          "group": null,
          "included": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used",
          "group": null,
          "included": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use",
          "group": null,
          "included": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects",
          "group": null,
          "included": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS",
          "group": null,
          "included": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system",
          "group": null,
          "included": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Number of seconds since 1970 of last garbage collection",
          "group": null,
          "included": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups",
          "group": null,
          "included": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs",
          "group": null,
          "included": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures",
          "group": null,
          "included": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system",
          "group": null,
          "included": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures",
          "group": null,
          "included": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system",
          "group": null,
          "included": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place",
          "group": null,
          "included": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations",
          "group": null,
          "included": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator",
          "group": null,
          "included": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator",
          "group": null,
          "included": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system",
          "group": null,
          "included": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created",
          "group": null,
          "included": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent in seconds",
          "group": null,
          "included": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors",
          "group": null,
          "included": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors",
          "group": null,
          "included": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes",
          "group": null,
          "included": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds",
          "group": null,
          "included": true
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes",
          "group": null,
          "included": false
        },
        "process_virtual_memory_max_bytes": {
          "type": "gauge",
          "description": "Maximum amount of virtual memory available in bytes",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/prometheus/go",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/nginx-vts",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus Nginx VTS\nexporter](https://github.com/hnlq715/nginx-vts-exporter) metrics from a\nPrometheus exporter and sends them to SignalFx.  It is a wrapper around the\n[prometheus-exporter](./prometheus-exporter.md) monitor that provides a\nrestricted but expandable set of metrics.\n",
      "groups": null,
      "metrics": {
        "nginx_vts_info": {
          "type": "gauge",
          "description": "Nginx info",
          "group": null,
          "included": false
        },
        "nginx_vts_main_connections": {
          "type": "gauge",
          "description": "connections",
          "group": null,
          "included": true
        },
        "nginx_vts_main_shm_usage_bytes": {
          "type": "gauge",
          "description": "Shared memory [ngx_http_vhost_traffic_status] info",
          "group": null,
          "included": false
        },
        "nginx_vts_server_bytes_total": {
          "type": "cumulative",
          "description": "The request/response bytes",
          "group": null,
          "included": false
        },
        "nginx_vts_server_cache_total": {
          "type": "cumulative",
          "description": "The requests cache counter",
          "group": null,
          "included": false
        },
        "nginx_vts_server_request_duration_seconds": {
          "type": "cumulative",
          "description": "The histogram of request processing time",
          "group": null,
          "included": false
        },
        "nginx_vts_server_request_seconds": {
          "type": "gauge",
          "description": "The average of request processing times in seconds",
          "group": null,
          "included": true
        },
        "nginx_vts_server_request_seconds_total": {
          "type": "cumulative",
          "description": "The request processing time in seconds",
          "group": null,
          "included": false
        },
        "nginx_vts_server_requests_total": {
          "type": "cumulative",
          "description": "The requests counter",
          "group": null,
          "included": true
        },
        "nginx_vts_start_time_seconds": {
          "type": "gauge",
          "description": "Nginx start time",
          "group": null,
          "included": false
        },
        "nginx_vts_upstream_bytes_total": {
          "type": "cumulative",
          "description": "The request/response bytes",
          "group": null,
          "included": false
        },
        "nginx_vts_upstream_request_duration_seconds": {
          "type": "cumulative",
          "description": "The histogram of request processing time including upstream",
          "group": null,
          "included": false
        },
        "nginx_vts_upstream_request_seconds": {
          "type": "gauge",
          "description": "The average of request processing times including upstream in seconds",
          "group": null,
          "included": true
        },
        "nginx_vts_upstream_request_seconds_total": {
          "type": "cumulative",
          "description": "The request Processing time including upstream in seconds",
          "group": null,
          "included": false
        },
        "nginx_vts_upstream_requests_total": {
          "type": "cumulative",
          "description": "The upstream requests counter",
          "group": null,
          "included": false
        },
        "nginx_vts_upstream_response_duration_seconds": {
          "type": "cumulative",
          "description": "The histogram of only upstream response processing time",
          "group": null,
          "included": false
        },
        "nginx_vts_upstream_response_seconds": {
          "type": "gauge",
          "description": "The average of only upstream response processing times in seconds",
          "group": null,
          "included": false
        },
        "nginx_vts_upstream_response_seconds_total": {
          "type": "cumulative",
          "description": "The only upstream response processing time in seconds",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/prometheus/nginxvts",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/node",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus Node\nExporter](https://github.com/prometheus/node_exporter) metrics and sends\nthem to SignalFx.  It is a wrapper around the\n[prometheus-exporter](./prometheus-exporter.md) monitor that provides a\nrestricted but expandable set of metrics.\n",
      "groups": null,
      "metrics": {
        "node_arp_entries": {
          "type": "gauge",
          "description": "ARP entries by device",
          "group": null,
          "included": false
        },
        "node_boot_time_seconds": {
          "type": "gauge",
          "description": "Node boot time, in unixtime",
          "group": null,
          "included": false
        },
        "node_context_switches_total": {
          "type": "cumulative",
          "description": "Total number of context switches",
          "group": null,
          "included": false
        },
        "node_cpu_guest_seconds_total": {
          "type": "cumulative",
          "description": "Seconds the cpus spent in guests (VMs) for each mode",
          "group": null,
          "included": false
        },
        "node_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Seconds the cpus spent in each mode",
          "group": null,
          "included": false
        },
        "node_disk_io_now": {
          "type": "gauge",
          "description": "The number of I/Os currently in progress",
          "group": null,
          "included": false
        },
        "node_disk_io_time_seconds_total": {
          "type": "cumulative",
          "description": "Total seconds spent doing I/Os",
          "group": null,
          "included": false
        },
        "node_disk_io_time_weighted_seconds_total": {
          "type": "cumulative",
          "description": "The weighted number of seconds spent doing I/Os. See https://www.kernel.org/doc/Documentation/iostats.txt",
          "group": null,
          "included": false
        },
        "node_disk_read_bytes_total": {
          "type": "cumulative",
          "description": "The total number of bytes read successfully",
          "group": null,
          "included": false
        },
        "node_disk_read_time_seconds_total": {
          "type": "cumulative",
          "description": "The total number of milliseconds spent by all reads",
          "group": null,
          "included": false
        },
        "node_disk_reads_completed_total": {
          "type": "cumulative",
          "description": "The total number of reads completed successfully",
          "group": null,
          "included": false
        },
        "node_disk_reads_merged_total": {
          "type": "cumulative",
          "description": "The total number of reads merged. See https://www.kernel.org/doc/Documentation/iostats.txt",
          "group": null,
          "included": false
        },
        "node_disk_write_time_seconds_total": {
          "type": "cumulative",
          "description": "This is the total number of seconds spent by all writes",
          "group": null,
          "included": false
        },
        "node_disk_writes_completed_total": {
          "type": "cumulative",
          "description": "The total number of writes completed successfully",
          "group": null,
          "included": false
        },
        "node_disk_writes_merged_total": {
          "type": "cumulative",
          "description": "The number of writes merged. See https://www.kernel.org/doc/Documentation/iostats.txt",
          "group": null,
          "included": false
        },
        "node_disk_written_bytes_total": {
          "type": "cumulative",
          "description": "The total number of bytes written successfully",
          "group": null,
          "included": false
        },
        "node_entropy_available_bits": {
          "type": "gauge",
          "description": "Bits of available entropy",
          "group": null,
          "included": false
        },
        "node_exporter_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by version, revision, branch, and goversion from which node_exporter was built",
          "group": null,
          "included": false
        },
        "node_filefd_allocated": {
          "type": "gauge",
          "description": "File descriptor statistics: allocated",
          "group": null,
          "included": false
        },
        "node_filefd_maximum": {
          "type": "gauge",
          "description": "File descriptor statistics: maximum",
          "group": null,
          "included": false
        },
        "node_filesystem_avail_bytes": {
          "type": "gauge",
          "description": "Filesystem space available to non-root users in bytes",
          "group": null,
          "included": false
        },
        "node_filesystem_device_error": {
          "type": "gauge",
          "description": "Whether an error occurred while getting statistics for the given device",
          "group": null,
          "included": false
        },
        "node_filesystem_files": {
          "type": "gauge",
          "description": "Filesystem total file nodes",
          "group": null,
          "included": false
        },
        "node_filesystem_files_free": {
          "type": "gauge",
          "description": "Filesystem total free file nodes",
          "group": null,
          "included": false
        },
        "node_filesystem_free_bytes": {
          "type": "gauge",
          "description": "Filesystem free space in bytes",
          "group": null,
          "included": false
        },
        "node_filesystem_readonly": {
          "type": "gauge",
          "description": "Filesystem read-only status",
          "group": null,
          "included": false
        },
        "node_filesystem_size_bytes": {
          "type": "gauge",
          "description": "Filesystem size in bytes",
          "group": null,
          "included": false
        },
        "node_forks_total": {
          "type": "cumulative",
          "description": "Total number of forks",
          "group": null,
          "included": false
        },
        "node_intr_total": {
          "type": "cumulative",
          "description": "Total number of interrupts serviced",
          "group": null,
          "included": false
        },
        "node_ipvs_connections_total": {
          "type": "cumulative",
          "description": "The total number of connections made",
          "group": null,
          "included": false
        },
        "node_ipvs_incoming_bytes_total": {
          "type": "cumulative",
          "description": "The total amount of incoming data",
          "group": null,
          "included": false
        },
        "node_ipvs_incoming_packets_total": {
          "type": "cumulative",
          "description": "The total number of incoming packets",
          "group": null,
          "included": false
        },
        "node_ipvs_outgoing_bytes_total": {
          "type": "cumulative",
          "description": "The total amount of outgoing data",
          "group": null,
          "included": false
        },
        "node_ipvs_outgoing_packets_total": {
          "type": "cumulative",
          "description": "The total number of outgoing packets",
          "group": null,
          "included": false
        },
        "node_load1": {
          "type": "gauge",
          "description": "1m load average",
          "group": null,
          "included": false
        },
        "node_load15": {
          "type": "gauge",
          "description": "15m load average",
          "group": null,
          "included": false
        },
        "node_load5": {
          "type": "gauge",
          "description": "5m load average",
          "group": null,
          "included": false
        },
        "node_memory_Active_anon_bytes": {
          "type": "gauge",
          "description": "Memory information field Active_anon_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Active_bytes": {
          "type": "gauge",
          "description": "Memory information field Active_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Active_file_bytes": {
          "type": "gauge",
          "description": "Memory information field Active_file_bytes",
          "group": null,
          "included": false
        },
        "node_memory_AnonHugePages_bytes": {
          "type": "gauge",
          "description": "Memory information field AnonHugePages_bytes",
          "group": null,
          "included": false
        },
        "node_memory_AnonPages_bytes": {
          "type": "gauge",
          "description": "Memory information field AnonPages_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Bounce_bytes": {
          "type": "gauge",
          "description": "Memory information field Bounce_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Buffers_bytes": {
          "type": "gauge",
          "description": "Memory information field Buffers_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Cached_bytes": {
          "type": "gauge",
          "description": "Memory information field Cached_bytes",
          "group": null,
          "included": false
        },
        "node_memory_CommitLimit_bytes": {
          "type": "gauge",
          "description": "Memory information field CommitLimit_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Committed_AS_bytes": {
          "type": "gauge",
          "description": "Memory information field Committed_AS_bytes",
          "group": null,
          "included": false
        },
        "node_memory_DirectMap1G_bytes": {
          "type": "gauge",
          "description": "Memory information field DirectMap1G_bytes",
          "group": null,
          "included": false
        },
        "node_memory_DirectMap2M_bytes": {
          "type": "gauge",
          "description": "Memory information field DirectMap2M_bytes",
          "group": null,
          "included": false
        },
        "node_memory_DirectMap4k_bytes": {
          "type": "gauge",
          "description": "Memory information field DirectMap4k_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Dirty_bytes": {
          "type": "gauge",
          "description": "Memory information field Dirty_bytes",
          "group": null,
          "included": false
        },
        "node_memory_HugePages_Free": {
          "type": "gauge",
          "description": "Memory information field HugePages_Free",
          "group": null,
          "included": false
        },
        "node_memory_HugePages_Rsvd": {
          "type": "gauge",
          "description": "Memory information field HugePages_Rsvd",
          "group": null,
          "included": false
        },
        "node_memory_HugePages_Surp": {
          "type": "gauge",
          "description": "Memory information field HugePages_Surp",
          "group": null,
          "included": false
        },
        "node_memory_HugePages_Total": {
          "type": "gauge",
          "description": "Memory information field HugePages_Total",
          "group": null,
          "included": false
        },
        "node_memory_Hugepagesize_bytes": {
          "type": "gauge",
          "description": "Memory information field Hugepagesize_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Inactive_anon_bytes": {
          "type": "gauge",
          "description": "Memory information field Inactive_anon_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Inactive_bytes": {
          "type": "gauge",
          "description": "Memory information field Inactive_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Inactive_file_bytes": {
          "type": "gauge",
          "description": "Memory information field Inactive_file_bytes",
          "group": null,
          "included": false
        },
        "node_memory_KernelStack_bytes": {
          "type": "gauge",
          "description": "Memory information field KernelStack_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Mapped_bytes": {
          "type": "gauge",
          "description": "Memory information field Mapped_bytes",
          "group": null,
          "included": false
        },
        "node_memory_MemAvailable_bytes": {
          "type": "gauge",
          "description": "Memory information field MemAvailable_bytes",
          "group": null,
          "included": false
        },
        "node_memory_MemFree_bytes": {
          "type": "gauge",
          "description": "Memory information field MemFree_bytes",
          "group": null,
          "included": false
        },
        "node_memory_MemTotal_bytes": {
          "type": "gauge",
          "description": "Memory information field MemTotal_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Mlocked_bytes": {
          "type": "gauge",
          "description": "Memory information field Mlocked_bytes",
          "group": null,
          "included": false
        },
        "node_memory_NFS_Unstable_bytes": {
          "type": "gauge",
          "description": "Memory information field NFS_Unstable_bytes",
          "group": null,
          "included": false
        },
        "node_memory_PageTables_bytes": {
          "type": "gauge",
          "description": "Memory information field PageTables_bytes",
          "group": null,
          "included": false
        },
        "node_memory_SReclaimable_bytes": {
          "type": "gauge",
          "description": "Memory information field SReclaimable_bytes",
          "group": null,
          "included": false
        },
        "node_memory_SUnreclaim_bytes": {
          "type": "gauge",
          "description": "Memory information field SUnreclaim_bytes",
          "group": null,
          "included": false
        },
        "node_memory_ShmemHugePages_bytes": {
          "type": "gauge",
          "description": "Memory information field ShmemHugePages_bytes",
          "group": null,
          "included": false
        },
        "node_memory_ShmemPmdMapped_bytes": {
          "type": "gauge",
          "description": "Memory information field ShmemPmdMapped_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Shmem_bytes": {
          "type": "gauge",
          "description": "Memory information field Shmem_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Slab_bytes": {
          "type": "gauge",
          "description": "Memory information field Slab_bytes",
          "group": null,
          "included": false
        },
        "node_memory_SwapCached_bytes": {
          "type": "gauge",
          "description": "Memory information field SwapCached_bytes",
          "group": null,
          "included": false
        },
        "node_memory_SwapFree_bytes": {
          "type": "gauge",
          "description": "Memory information field SwapFree_bytes",
          "group": null,
          "included": false
        },
        "node_memory_SwapTotal_bytes": {
          "type": "gauge",
          "description": "Memory information field SwapTotal_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Unevictable_bytes": {
          "type": "gauge",
          "description": "Memory information field Unevictable_bytes",
          "group": null,
          "included": false
        },
        "node_memory_VmallocChunk_bytes": {
          "type": "gauge",
          "description": "Memory information field VmallocChunk_bytes",
          "group": null,
          "included": false
        },
        "node_memory_VmallocTotal_bytes": {
          "type": "gauge",
          "description": "Memory information field VmallocTotal_bytes",
          "group": null,
          "included": false
        },
        "node_memory_VmallocUsed_bytes": {
          "type": "gauge",
          "description": "Memory information field VmallocUsed_bytes",
          "group": null,
          "included": false
        },
        "node_memory_WritebackTmp_bytes": {
          "type": "gauge",
          "description": "Memory information field WritebackTmp_bytes",
          "group": null,
          "included": false
        },
        "node_memory_Writeback_bytes": {
          "type": "gauge",
          "description": "Memory information field Writeback_bytes",
          "group": null,
          "included": false
        },
        "node_netstat_Icmp6_InErrors": {
          "type": "gauge",
          "description": "Statistic Icmp6InErrors",
          "group": null,
          "included": false
        },
        "node_netstat_Icmp6_InMsgs": {
          "type": "gauge",
          "description": "Statistic Icmp6InMsgs",
          "group": null,
          "included": false
        },
        "node_netstat_Icmp6_OutMsgs": {
          "type": "gauge",
          "description": "Statistic Icmp6OutMsgs",
          "group": null,
          "included": false
        },
        "node_netstat_Icmp_InErrors": {
          "type": "gauge",
          "description": "Statistic IcmpInErrors",
          "group": null,
          "included": false
        },
        "node_netstat_Icmp_InMsgs": {
          "type": "gauge",
          "description": "Statistic IcmpInMsgs",
          "group": null,
          "included": false
        },
        "node_netstat_Icmp_OutMsgs": {
          "type": "gauge",
          "description": "Statistic IcmpOutMsgs",
          "group": null,
          "included": false
        },
        "node_netstat_Ip6_InOctets": {
          "type": "gauge",
          "description": "Statistic Ip6InOctets",
          "group": null,
          "included": false
        },
        "node_netstat_Ip6_OutOctets": {
          "type": "gauge",
          "description": "Statistic Ip6OutOctets",
          "group": null,
          "included": false
        },
        "node_netstat_IpExt_InOctets": {
          "type": "gauge",
          "description": "Statistic IpExtInOctets",
          "group": null,
          "included": false
        },
        "node_netstat_IpExt_OutOctets": {
          "type": "gauge",
          "description": "Statistic IpExtOutOctets",
          "group": null,
          "included": false
        },
        "node_netstat_Ip_Forwarding": {
          "type": "gauge",
          "description": "Statistic IpForwarding",
          "group": null,
          "included": false
        },
        "node_netstat_TcpExt_ListenDrops": {
          "type": "gauge",
          "description": "Statistic TcpExtListenDrops",
          "group": null,
          "included": false
        },
        "node_netstat_TcpExt_ListenOverflows": {
          "type": "gauge",
          "description": "Statistic TcpExtListenOverflows",
          "group": null,
          "included": false
        },
        "node_netstat_TcpExt_SyncookiesFailed": {
          "type": "gauge",
          "description": "Statistic TcpExtSyncookiesFailed",
          "group": null,
          "included": false
        },
        "node_netstat_TcpExt_SyncookiesRecv": {
          "type": "gauge",
          "description": "Statistic TcpExtSyncookiesRecv",
          "group": null,
          "included": false
        },
        "node_netstat_TcpExt_SyncookiesSent": {
          "type": "gauge",
          "description": "Statistic TcpExtSyncookiesSent",
          "group": null,
          "included": false
        },
        "node_netstat_Tcp_ActiveOpens": {
          "type": "gauge",
          "description": "Statistic TcpActiveOpens",
          "group": null,
          "included": false
        },
        "node_netstat_Tcp_CurrEstab": {
          "type": "gauge",
          "description": "Statistic TcpCurrEstab",
          "group": null,
          "included": false
        },
        "node_netstat_Tcp_InErrs": {
          "type": "gauge",
          "description": "Statistic TcpInErrs",
          "group": null,
          "included": false
        },
        "node_netstat_Tcp_PassiveOpens": {
          "type": "gauge",
          "description": "Statistic TcpPassiveOpens",
          "group": null,
          "included": false
        },
        "node_netstat_Tcp_RetransSegs": {
          "type": "gauge",
          "description": "Statistic TcpRetransSegs",
          "group": null,
          "included": false
        },
        "node_netstat_Udp6_InDatagrams": {
          "type": "gauge",
          "description": "Statistic Udp6InDatagrams",
          "group": null,
          "included": false
        },
        "node_netstat_Udp6_InErrors": {
          "type": "gauge",
          "description": "Statistic Udp6InErrors",
          "group": null,
          "included": false
        },
        "node_netstat_Udp6_NoPorts": {
          "type": "gauge",
          "description": "Statistic Udp6NoPorts",
          "group": null,
          "included": false
        },
        "node_netstat_Udp6_OutDatagrams": {
          "type": "gauge",
          "description": "Statistic Udp6OutDatagrams",
          "group": null,
          "included": false
        },
        "node_netstat_UdpLite6_InErrors": {
          "type": "gauge",
          "description": "Statistic UdpLite6InErrors",
          "group": null,
          "included": false
        },
        "node_netstat_UdpLite_InErrors": {
          "type": "gauge",
          "description": "Statistic UdpLiteInErrors",
          "group": null,
          "included": false
        },
        "node_netstat_Udp_InDatagrams": {
          "type": "gauge",
          "description": "Statistic UdpInDatagrams",
          "group": null,
          "included": false
        },
        "node_netstat_Udp_InErrors": {
          "type": "gauge",
          "description": "Statistic UdpInErrors",
          "group": null,
          "included": false
        },
        "node_netstat_Udp_NoPorts": {
          "type": "gauge",
          "description": "Statistic UdpNoPorts",
          "group": null,
          "included": false
        },
        "node_netstat_Udp_OutDatagrams": {
          "type": "gauge",
          "description": "Statistic UdpOutDatagrams",
          "group": null,
          "included": false
        },
        "node_network_receive_bytes_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_bytes",
          "group": null,
          "included": false
        },
        "node_network_receive_compressed_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_compressed",
          "group": null,
          "included": false
        },
        "node_network_receive_drop_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_drop",
          "group": null,
          "included": false
        },
        "node_network_receive_errs_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_errs",
          "group": null,
          "included": false
        },
        "node_network_receive_fifo_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_fifo",
          "group": null,
          "included": false
        },
        "node_network_receive_frame_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_frame",
          "group": null,
          "included": false
        },
        "node_network_receive_multicast_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_multicast",
          "group": null,
          "included": false
        },
        "node_network_receive_packets_total": {
          "type": "cumulative",
          "description": "Network device statistic receive_packets",
          "group": null,
          "included": false
        },
        "node_network_transmit_bytes_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_bytes",
          "group": null,
          "included": false
        },
        "node_network_transmit_carrier_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_carrier",
          "group": null,
          "included": false
        },
        "node_network_transmit_colls_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_colls",
          "group": null,
          "included": false
        },
        "node_network_transmit_compressed_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_compressed",
          "group": null,
          "included": false
        },
        "node_network_transmit_drop_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_drop",
          "group": null,
          "included": false
        },
        "node_network_transmit_errs_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_errs",
          "group": null,
          "included": false
        },
        "node_network_transmit_fifo_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_fifo",
          "group": null,
          "included": false
        },
        "node_network_transmit_packets_total": {
          "type": "cumulative",
          "description": "Network device statistic transmit_packets",
          "group": null,
          "included": false
        },
        "node_nf_conntrack_entries": {
          "type": "gauge",
          "description": "Number of currently allocated flow entries for connection tracking",
          "group": null,
          "included": false
        },
        "node_nf_conntrack_entries_limit": {
          "type": "gauge",
          "description": "Maximum size of connection tracking table",
          "group": null,
          "included": false
        },
        "node_procs_blocked": {
          "type": "gauge",
          "description": "Number of processes blocked waiting for I/O to complete",
          "group": null,
          "included": false
        },
        "node_procs_running": {
          "type": "gauge",
          "description": "Number of processes in runnable state",
          "group": null,
          "included": false
        },
        "node_scrape_collector_duration_seconds": {
          "type": "gauge",
          "description": "Duration of a collector scrape",
          "group": null,
          "included": false
        },
        "node_scrape_collector_success": {
          "type": "gauge",
          "description": "Whether a collector succeeded",
          "group": null,
          "included": false
        },
        "node_sockstat_FRAG_inuse": {
          "type": "gauge",
          "description": "Number of FRAG sockets in state inuse",
          "group": null,
          "included": false
        },
        "node_sockstat_FRAG_memory": {
          "type": "gauge",
          "description": "Number of FRAG sockets in state memory",
          "group": null,
          "included": false
        },
        "node_sockstat_RAW_inuse": {
          "type": "gauge",
          "description": "Number of RAW sockets in state inuse",
          "group": null,
          "included": false
        },
        "node_sockstat_TCP_alloc": {
          "type": "gauge",
          "description": "Number of TCP sockets in state alloc",
          "group": null,
          "included": false
        },
        "node_sockstat_TCP_inuse": {
          "type": "gauge",
          "description": "Number of TCP sockets in state inuse",
          "group": null,
          "included": false
        },
        "node_sockstat_TCP_mem": {
          "type": "gauge",
          "description": "Number of TCP sockets in state mem",
          "group": null,
          "included": false
        },
        "node_sockstat_TCP_mem_bytes": {
          "type": "gauge",
          "description": "Number of TCP sockets in state mem_bytes",
          "group": null,
          "included": false
        },
        "node_sockstat_TCP_orphan": {
          "type": "gauge",
          "description": "Number of TCP sockets in state orphan",
          "group": null,
          "included": false
        },
        "node_sockstat_TCP_tw": {
          "type": "gauge",
          "description": "Number of TCP sockets in state tw",
          "group": null,
          "included": false
        },
        "node_sockstat_UDPLITE_inuse": {
          "type": "gauge",
          "description": "Number of UDPLITE sockets in state inuse",
          "group": null,
          "included": false
        },
        "node_sockstat_UDP_inuse": {
          "type": "gauge",
          "description": "Number of UDP sockets in state inuse",
          "group": null,
          "included": false
        },
        "node_sockstat_UDP_mem": {
          "type": "gauge",
          "description": "Number of UDP sockets in state mem",
          "group": null,
          "included": false
        },
        "node_sockstat_UDP_mem_bytes": {
          "type": "gauge",
          "description": "Number of UDP sockets in state mem_bytes",
          "group": null,
          "included": false
        },
        "node_sockstat_sockets_used": {
          "type": "gauge",
          "description": "Number of sockets sockets in state used",
          "group": null,
          "included": false
        },
        "node_textfile_scrape_error": {
          "type": "gauge",
          "description": "1 if there was an error opening or reading a file, 0 otherwise",
          "group": null,
          "included": false
        },
        "node_time_seconds": {
          "type": "gauge",
          "description": "System time in seconds since epoch (1970)",
          "group": null,
          "included": false
        },
        "node_uname_info": {
          "type": "gauge",
          "description": "Labeled system information as provided by the uname system call",
          "group": null,
          "included": false
        },
        "node_vmstat_pgfault": {
          "type": "gauge",
          "description": "/proc/vmstat information field pgfault",
          "group": null,
          "included": false
        },
        "node_vmstat_pgmajfault": {
          "type": "gauge",
          "description": "/proc/vmstat information field pgmajfault",
          "group": null,
          "included": false
        },
        "node_vmstat_pgpgin": {
          "type": "gauge",
          "description": "/proc/vmstat information field pgpgin",
          "group": null,
          "included": false
        },
        "node_vmstat_pgpgout": {
          "type": "gauge",
          "description": "/proc/vmstat information field pgpgout",
          "group": null,
          "included": false
        },
        "node_vmstat_pswpin": {
          "type": "gauge",
          "description": "/proc/vmstat information field pswpin",
          "group": null,
          "included": false
        },
        "node_vmstat_pswpout": {
          "type": "gauge",
          "description": "/proc/vmstat information field pswpout",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/prometheus/node",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/postgres",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus PostgreSQL Server\nExporter](https://github.com/wrouesnel/postgres_exporter) metrics and sends\nthem to SignalFx.  It is a wrapper around the\n[prometheus-exporter](./prometheus-exporter.md) monitor that provides a\nrestricted but expandable set of metrics.\n",
      "groups": null,
      "metrics": {
        "pg_exporter_last_scrape_duration_seconds": {
          "type": "gauge",
          "description": "Duration of the last scrape of metrics from PostgresSQL.",
          "group": null,
          "included": false
        },
        "pg_exporter_last_scrape_error": {
          "type": "gauge",
          "description": "Whether the last scrape of metrics from PostgreSQL resulted in an error (1 for error, 0 for success).",
          "group": null,
          "included": false
        },
        "pg_exporter_scrapes_total": {
          "type": "cumulative",
          "description": "Total number of times PostgresSQL was scraped for metrics.",
          "group": null,
          "included": false
        },
        "pg_exporter_user_queries_load_error": {
          "type": "gauge",
          "description": "Whether the user queries file was loaded and parsed successfully (1 for error, 0 for success).",
          "group": null,
          "included": false
        },
        "pg_locks_count": {
          "type": "gauge",
          "description": "Number of locks",
          "group": null,
          "included": false
        },
        "pg_postmaster_start_time_seconds": {
          "type": "gauge",
          "description": "Time at which postmaster started",
          "group": null,
          "included": false
        },
        "pg_replication_is_replica": {
          "type": "gauge",
          "description": "Indicates if this host is a slave",
          "group": null,
          "included": false
        },
        "pg_replication_lag": {
          "type": "gauge",
          "description": "Replication lag behind master in seconds",
          "group": null,
          "included": false
        },
        "pg_settings_allow_system_table_mods": {
          "type": "gauge",
          "description": "Allows modifications of the structure of system tables.",
          "group": null,
          "included": false
        },
        "pg_settings_archive_timeout_seconds": {
          "type": "gauge",
          "description": "Forces a switch to the next xlog file if a new file has not been started within N seconds. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_array_nulls": {
          "type": "gauge",
          "description": "Enable input of NULL elements in arrays.",
          "group": null,
          "included": false
        },
        "pg_settings_authentication_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum allowed time to complete client authentication. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum": {
          "type": "gauge",
          "description": "Starts the autovacuum subprocess.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_analyze_scale_factor": {
          "type": "gauge",
          "description": "Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_analyze_threshold": {
          "type": "gauge",
          "description": "Minimum number of tuple inserts, updates, or deletes prior to analyze.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_freeze_max_age": {
          "type": "gauge",
          "description": "Age at which to autovacuum a table to prevent transaction ID wraparound.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_max_workers": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously running autovacuum worker processes.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_multixact_freeze_max_age": {
          "type": "gauge",
          "description": "Multixact age at which to autovacuum a table to prevent multixact wraparound.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_naptime_seconds": {
          "type": "gauge",
          "description": "Time to sleep between autovacuum runs. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_vacuum_cost_delay_seconds": {
          "type": "gauge",
          "description": "Vacuum cost delay in milliseconds, for autovacuum. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_vacuum_cost_limit": {
          "type": "gauge",
          "description": "Vacuum cost amount available before napping, for autovacuum.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_vacuum_scale_factor": {
          "type": "gauge",
          "description": "Number of tuple updates or deletes prior to vacuum as a fraction of reltuples.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_vacuum_threshold": {
          "type": "gauge",
          "description": "Minimum number of tuple updates or deletes prior to vacuum.",
          "group": null,
          "included": false
        },
        "pg_settings_autovacuum_work_mem_bytes": {
          "type": "gauge",
          "description": "Sets the maximum memory to be used by each autovacuum worker process. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_backend_flush_after_bytes": {
          "type": "gauge",
          "description": "Number of pages after which previously performed writes are flushed to disk. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_bgwriter_delay_seconds": {
          "type": "gauge",
          "description": "Background writer sleep time between rounds. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_bgwriter_flush_after_bytes": {
          "type": "gauge",
          "description": "Number of pages after which previously performed writes are flushed to disk. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_bgwriter_lru_maxpages": {
          "type": "gauge",
          "description": "Background writer maximum number of LRU pages to flush per round.",
          "group": null,
          "included": false
        },
        "pg_settings_bgwriter_lru_multiplier": {
          "type": "gauge",
          "description": "Multiple of the average buffer usage to free per round.",
          "group": null,
          "included": false
        },
        "pg_settings_block_size": {
          "type": "gauge",
          "description": "Shows the size of a disk block.",
          "group": null,
          "included": false
        },
        "pg_settings_bonjour": {
          "type": "gauge",
          "description": "Enables advertising the server via Bonjour.",
          "group": null,
          "included": false
        },
        "pg_settings_check_function_bodies": {
          "type": "gauge",
          "description": "Check function bodies during CREATE FUNCTION.",
          "group": null,
          "included": false
        },
        "pg_settings_checkpoint_completion_target": {
          "type": "gauge",
          "description": "Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval.",
          "group": null,
          "included": false
        },
        "pg_settings_checkpoint_flush_after_bytes": {
          "type": "gauge",
          "description": "Number of pages after which previously performed writes are flushed to disk. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_checkpoint_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum time between automatic WAL checkpoints. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_checkpoint_warning_seconds": {
          "type": "gauge",
          "description": "Enables warnings if checkpoint segments are filled more frequently than this. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_commit_delay": {
          "type": "gauge",
          "description": "Sets the delay in microseconds between transaction commit and flushing WAL to disk.",
          "group": null,
          "included": false
        },
        "pg_settings_commit_siblings": {
          "type": "gauge",
          "description": "Sets the minimum concurrent open transactions before performing commit_delay.",
          "group": null,
          "included": false
        },
        "pg_settings_cpu_index_tuple_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of processing each index entry during an index scan.",
          "group": null,
          "included": false
        },
        "pg_settings_cpu_operator_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of processing each operator or function call.",
          "group": null,
          "included": false
        },
        "pg_settings_cpu_tuple_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of processing each tuple (row).",
          "group": null,
          "included": false
        },
        "pg_settings_cursor_tuple_fraction": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the fraction of a cursor's rows that will be retrieved.",
          "group": null,
          "included": false
        },
        "pg_settings_data_checksums": {
          "type": "gauge",
          "description": "Shows whether data checksums are turned on for this cluster.",
          "group": null,
          "included": false
        },
        "pg_settings_db_user_namespace": {
          "type": "gauge",
          "description": "Enables per-database user names.",
          "group": null,
          "included": false
        },
        "pg_settings_deadlock_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the time to wait on a lock before checking for deadlock. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_debug_assertions": {
          "type": "gauge",
          "description": "Shows whether the running server has assertion checks enabled.",
          "group": null,
          "included": false
        },
        "pg_settings_debug_pretty_print": {
          "type": "gauge",
          "description": "Indents parse and plan tree displays.",
          "group": null,
          "included": false
        },
        "pg_settings_debug_print_parse": {
          "type": "gauge",
          "description": "Logs each query's parse tree.",
          "group": null,
          "included": false
        },
        "pg_settings_debug_print_plan": {
          "type": "gauge",
          "description": "Logs each query's execution plan.",
          "group": null,
          "included": false
        },
        "pg_settings_debug_print_rewritten": {
          "type": "gauge",
          "description": "Logs each query's rewritten parse tree.",
          "group": null,
          "included": false
        },
        "pg_settings_default_statistics_target": {
          "type": "gauge",
          "description": "Sets the default statistics target.",
          "group": null,
          "included": false
        },
        "pg_settings_default_transaction_deferrable": {
          "type": "gauge",
          "description": "Sets the default deferrable status of new transactions.",
          "group": null,
          "included": false
        },
        "pg_settings_default_transaction_read_only": {
          "type": "gauge",
          "description": "Sets the default read-only status of new transactions.",
          "group": null,
          "included": false
        },
        "pg_settings_default_with_oids": {
          "type": "gauge",
          "description": "Create new tables with OIDs by default.",
          "group": null,
          "included": false
        },
        "pg_settings_effective_cache_size_bytes": {
          "type": "gauge",
          "description": "Sets the planner's assumption about the size of the data cache. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_effective_io_concurrency": {
          "type": "gauge",
          "description": "Number of simultaneous requests that can be handled efficiently by the disk subsystem.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_bitmapscan": {
          "type": "gauge",
          "description": "Enables the planner's use of bitmap-scan plans.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_hashagg": {
          "type": "gauge",
          "description": "Enables the planner's use of hashed aggregation plans.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_hashjoin": {
          "type": "gauge",
          "description": "Enables the planner's use of hash join plans.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_indexonlyscan": {
          "type": "gauge",
          "description": "Enables the planner's use of index-only-scan plans.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_indexscan": {
          "type": "gauge",
          "description": "Enables the planner's use of index-scan plans.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_material": {
          "type": "gauge",
          "description": "Enables the planner's use of materialization.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_mergejoin": {
          "type": "gauge",
          "description": "Enables the planner's use of merge join plans.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_nestloop": {
          "type": "gauge",
          "description": "Enables the planner's use of nested-loop join plans.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_seqscan": {
          "type": "gauge",
          "description": "Enables the planner's use of sequential-scan plans.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_sort": {
          "type": "gauge",
          "description": "Enables the planner's use of explicit sort steps.",
          "group": null,
          "included": false
        },
        "pg_settings_enable_tidscan": {
          "type": "gauge",
          "description": "Enables the planner's use of TID scan plans.",
          "group": null,
          "included": false
        },
        "pg_settings_escape_string_warning": {
          "type": "gauge",
          "description": "Warn about backslash escapes in ordinary string literals.",
          "group": null,
          "included": false
        },
        "pg_settings_exit_on_error": {
          "type": "gauge",
          "description": "Terminate session on any error.",
          "group": null,
          "included": false
        },
        "pg_settings_extra_float_digits": {
          "type": "gauge",
          "description": "Sets the number of digits displayed for floating-point values.",
          "group": null,
          "included": false
        },
        "pg_settings_from_collapse_limit": {
          "type": "gauge",
          "description": "Sets the FROM-list size beyond which subqueries are not collapsed.",
          "group": null,
          "included": false
        },
        "pg_settings_fsync": {
          "type": "gauge",
          "description": "Forces synchronization of updates to disk.",
          "group": null,
          "included": false
        },
        "pg_settings_full_page_writes": {
          "type": "gauge",
          "description": "Writes full pages to WAL when first modified after a checkpoint.",
          "group": null,
          "included": false
        },
        "pg_settings_geqo": {
          "type": "gauge",
          "description": "Enables genetic query optimization.",
          "group": null,
          "included": false
        },
        "pg_settings_geqo_effort": {
          "type": "gauge",
          "description": "GEQO: effort is used to set the default for other GEQO parameters.",
          "group": null,
          "included": false
        },
        "pg_settings_geqo_generations": {
          "type": "gauge",
          "description": "GEQO: number of iterations of the algorithm.",
          "group": null,
          "included": false
        },
        "pg_settings_geqo_pool_size": {
          "type": "gauge",
          "description": "GEQO: number of individuals in the population.",
          "group": null,
          "included": false
        },
        "pg_settings_geqo_seed": {
          "type": "gauge",
          "description": "GEQO: seed for random path selection.",
          "group": null,
          "included": false
        },
        "pg_settings_geqo_selection_bias": {
          "type": "gauge",
          "description": "GEQO: selective pressure within the population.",
          "group": null,
          "included": false
        },
        "pg_settings_geqo_threshold": {
          "type": "gauge",
          "description": "Sets the threshold of FROM items beyond which GEQO is used.",
          "group": null,
          "included": false
        },
        "pg_settings_gin_fuzzy_search_limit": {
          "type": "gauge",
          "description": "Sets the maximum allowed result for exact search by GIN.",
          "group": null,
          "included": false
        },
        "pg_settings_gin_pending_list_limit_bytes": {
          "type": "gauge",
          "description": "Sets the maximum size of the pending list for GIN index. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_hot_standby": {
          "type": "gauge",
          "description": "Allows connections and queries during recovery.",
          "group": null,
          "included": false
        },
        "pg_settings_hot_standby_feedback": {
          "type": "gauge",
          "description": "Allows feedback from a hot standby to the primary that will avoid query conflicts.",
          "group": null,
          "included": false
        },
        "pg_settings_idle_in_transaction_session_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum allowed duration of any idling transaction. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_ignore_checksum_failure": {
          "type": "gauge",
          "description": "Continues processing after a checksum failure.",
          "group": null,
          "included": false
        },
        "pg_settings_ignore_system_indexes": {
          "type": "gauge",
          "description": "Disables reading from system indexes.",
          "group": null,
          "included": false
        },
        "pg_settings_integer_datetimes": {
          "type": "gauge",
          "description": "Datetimes are integer based.",
          "group": null,
          "included": false
        },
        "pg_settings_join_collapse_limit": {
          "type": "gauge",
          "description": "Sets the FROM-list size beyond which JOIN constructs are not flattened.",
          "group": null,
          "included": false
        },
        "pg_settings_krb_caseins_users": {
          "type": "gauge",
          "description": "Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive.",
          "group": null,
          "included": false
        },
        "pg_settings_lo_compat_privileges": {
          "type": "gauge",
          "description": "Enables backward compatibility mode for privilege checks on large objects.",
          "group": null,
          "included": false
        },
        "pg_settings_lock_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum allowed duration of any wait for a lock. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_log_autovacuum_min_duration_seconds": {
          "type": "gauge",
          "description": "Sets the minimum execution time above which autovacuum actions will be logged. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_log_checkpoints": {
          "type": "gauge",
          "description": "Logs each checkpoint.",
          "group": null,
          "included": false
        },
        "pg_settings_log_connections": {
          "type": "gauge",
          "description": "Logs each successful connection.",
          "group": null,
          "included": false
        },
        "pg_settings_log_disconnections": {
          "type": "gauge",
          "description": "Logs end of a session, including duration.",
          "group": null,
          "included": false
        },
        "pg_settings_log_duration": {
          "type": "gauge",
          "description": "Logs the duration of each completed SQL statement.",
          "group": null,
          "included": false
        },
        "pg_settings_log_executor_stats": {
          "type": "gauge",
          "description": "Writes executor performance statistics to the server log.",
          "group": null,
          "included": false
        },
        "pg_settings_log_file_mode": {
          "type": "gauge",
          "description": "Sets the file permissions for log files.",
          "group": null,
          "included": false
        },
        "pg_settings_log_hostname": {
          "type": "gauge",
          "description": "Logs the host name in the connection logs.",
          "group": null,
          "included": false
        },
        "pg_settings_log_lock_waits": {
          "type": "gauge",
          "description": "Logs long lock waits.",
          "group": null,
          "included": false
        },
        "pg_settings_log_min_duration_statement_seconds": {
          "type": "gauge",
          "description": "Sets the minimum execution time above which statements will be logged. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_log_parser_stats": {
          "type": "gauge",
          "description": "Writes parser performance statistics to the server log.",
          "group": null,
          "included": false
        },
        "pg_settings_log_planner_stats": {
          "type": "gauge",
          "description": "Writes planner performance statistics to the server log.",
          "group": null,
          "included": false
        },
        "pg_settings_log_replication_commands": {
          "type": "gauge",
          "description": "Logs each replication command.",
          "group": null,
          "included": false
        },
        "pg_settings_log_rotation_age_seconds": {
          "type": "gauge",
          "description": "Automatic log file rotation will occur after N minutes. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_log_rotation_size_bytes": {
          "type": "gauge",
          "description": "Automatic log file rotation will occur after N kilobytes. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_log_statement_stats": {
          "type": "gauge",
          "description": "Writes cumulative performance statistics to the server log.",
          "group": null,
          "included": false
        },
        "pg_settings_log_temp_files_bytes": {
          "type": "gauge",
          "description": "Log the use of temporary files larger than this number of kilobytes. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_log_truncate_on_rotation": {
          "type": "gauge",
          "description": "Truncate existing log files of same name during log rotation.",
          "group": null,
          "included": false
        },
        "pg_settings_logging_collector": {
          "type": "gauge",
          "description": "Start a subprocess to capture stderr output and/or csvlogs into log files.",
          "group": null,
          "included": false
        },
        "pg_settings_maintenance_work_mem_bytes": {
          "type": "gauge",
          "description": "Sets the maximum memory to be used for maintenance operations. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_max_connections": {
          "type": "gauge",
          "description": "Sets the maximum number of concurrent connections.",
          "group": null,
          "included": false
        },
        "pg_settings_max_files_per_process": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously open files for each server process.",
          "group": null,
          "included": false
        },
        "pg_settings_max_function_args": {
          "type": "gauge",
          "description": "Shows the maximum number of function arguments.",
          "group": null,
          "included": false
        },
        "pg_settings_max_identifier_length": {
          "type": "gauge",
          "description": "Shows the maximum identifier length.",
          "group": null,
          "included": false
        },
        "pg_settings_max_index_keys": {
          "type": "gauge",
          "description": "Shows the maximum number of index keys.",
          "group": null,
          "included": false
        },
        "pg_settings_max_locks_per_transaction": {
          "type": "gauge",
          "description": "Sets the maximum number of locks per transaction.",
          "group": null,
          "included": false
        },
        "pg_settings_max_parallel_workers_per_gather": {
          "type": "gauge",
          "description": "Sets the maximum number of parallel processes per executor node.",
          "group": null,
          "included": false
        },
        "pg_settings_max_pred_locks_per_transaction": {
          "type": "gauge",
          "description": "Sets the maximum number of predicate locks per transaction.",
          "group": null,
          "included": false
        },
        "pg_settings_max_prepared_transactions": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously prepared transactions.",
          "group": null,
          "included": false
        },
        "pg_settings_max_replication_slots": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously defined replication slots.",
          "group": null,
          "included": false
        },
        "pg_settings_max_stack_depth_bytes": {
          "type": "gauge",
          "description": "Sets the maximum stack depth, in kilobytes. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_max_standby_archive_delay_seconds": {
          "type": "gauge",
          "description": "Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_max_standby_streaming_delay_seconds": {
          "type": "gauge",
          "description": "Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_max_wal_senders": {
          "type": "gauge",
          "description": "Sets the maximum number of simultaneously running WAL sender processes.",
          "group": null,
          "included": false
        },
        "pg_settings_max_wal_size_bytes": {
          "type": "gauge",
          "description": "Sets the WAL size that triggers a checkpoint. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_max_worker_processes": {
          "type": "gauge",
          "description": "Maximum number of concurrent worker processes.",
          "group": null,
          "included": false
        },
        "pg_settings_min_parallel_relation_size_bytes": {
          "type": "gauge",
          "description": "Sets the minimum size of relations to be considered for parallel scan. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_min_wal_size_bytes": {
          "type": "gauge",
          "description": "Sets the minimum size to shrink the WAL to. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_old_snapshot_threshold_seconds": {
          "type": "gauge",
          "description": "Time before a snapshot is too old to read pages changed after the snapshot was taken. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_operator_precedence_warning": {
          "type": "gauge",
          "description": "Emit a warning for constructs that changed meaning since PostgreSQL 9.4.",
          "group": null,
          "included": false
        },
        "pg_settings_parallel_setup_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of starting up worker processes for parallel query.",
          "group": null,
          "included": false
        },
        "pg_settings_parallel_tuple_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of passing each tuple (row) from worker to master backend.",
          "group": null,
          "included": false
        },
        "pg_settings_password_encryption": {
          "type": "gauge",
          "description": "Encrypt passwords.",
          "group": null,
          "included": false
        },
        "pg_settings_port": {
          "type": "gauge",
          "description": "Sets the TCP port the server listens on.",
          "group": null,
          "included": false
        },
        "pg_settings_post_auth_delay_seconds": {
          "type": "gauge",
          "description": "Waits N seconds on connection startup after authentication. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_pre_auth_delay_seconds": {
          "type": "gauge",
          "description": "Waits N seconds on connection startup before authentication. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_quote_all_identifiers": {
          "type": "gauge",
          "description": "When generating SQL fragments, quote all identifiers.",
          "group": null,
          "included": false
        },
        "pg_settings_random_page_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of a nonsequentially fetched disk page.",
          "group": null,
          "included": false
        },
        "pg_settings_replacement_sort_tuples": {
          "type": "gauge",
          "description": "Sets the maximum number of tuples to be sorted using replacement selection.",
          "group": null,
          "included": false
        },
        "pg_settings_restart_after_crash": {
          "type": "gauge",
          "description": "Reinitialize server after backend crash.",
          "group": null,
          "included": false
        },
        "pg_settings_row_security": {
          "type": "gauge",
          "description": "Enable row security.",
          "group": null,
          "included": false
        },
        "pg_settings_segment_size_bytes": {
          "type": "gauge",
          "description": "Shows the number of pages per disk file. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_seq_page_cost": {
          "type": "gauge",
          "description": "Sets the planner's estimate of the cost of a sequentially fetched disk page.",
          "group": null,
          "included": false
        },
        "pg_settings_server_version_num": {
          "type": "gauge",
          "description": "Shows the server version as an integer.",
          "group": null,
          "included": false
        },
        "pg_settings_shared_buffers_bytes": {
          "type": "gauge",
          "description": "Sets the number of shared memory buffers used by the server. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_sql_inheritance": {
          "type": "gauge",
          "description": "Causes subtables to be included by default in various commands.",
          "group": null,
          "included": false
        },
        "pg_settings_ssl": {
          "type": "gauge",
          "description": "Enables SSL connections.",
          "group": null,
          "included": false
        },
        "pg_settings_ssl_prefer_server_ciphers": {
          "type": "gauge",
          "description": "Give priority to server ciphersuite order.",
          "group": null,
          "included": false
        },
        "pg_settings_standard_conforming_strings": {
          "type": "gauge",
          "description": "Causes '...' strings to treat backslashes literally.",
          "group": null,
          "included": false
        },
        "pg_settings_statement_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum allowed duration of any statement. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_superuser_reserved_connections": {
          "type": "gauge",
          "description": "Sets the number of connection slots reserved for superusers.",
          "group": null,
          "included": false
        },
        "pg_settings_synchronize_seqscans": {
          "type": "gauge",
          "description": "Enable synchronized sequential scans.",
          "group": null,
          "included": false
        },
        "pg_settings_syslog_sequence_numbers": {
          "type": "gauge",
          "description": "Add sequence number to syslog messages to avoid duplicate suppression.",
          "group": null,
          "included": false
        },
        "pg_settings_syslog_split_messages": {
          "type": "gauge",
          "description": "Split messages sent to syslog by lines and to fit into 1024 bytes.",
          "group": null,
          "included": false
        },
        "pg_settings_tcp_keepalives_count": {
          "type": "gauge",
          "description": "Maximum number of TCP keepalive retransmits.",
          "group": null,
          "included": false
        },
        "pg_settings_tcp_keepalives_idle_seconds": {
          "type": "gauge",
          "description": "Time between issuing TCP keepalives. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_tcp_keepalives_interval_seconds": {
          "type": "gauge",
          "description": "Time between TCP keepalive retransmits. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_temp_buffers_bytes": {
          "type": "gauge",
          "description": "Sets the maximum number of temporary buffers used by each session. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_temp_file_limit_bytes": {
          "type": "gauge",
          "description": "Limits the total size of all temporary files used by each process. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_trace_notify": {
          "type": "gauge",
          "description": "Generates debugging output for LISTEN and NOTIFY.",
          "group": null,
          "included": false
        },
        "pg_settings_trace_sort": {
          "type": "gauge",
          "description": "Emit information about resource usage in sorting.",
          "group": null,
          "included": false
        },
        "pg_settings_track_activities": {
          "type": "gauge",
          "description": "Collects information about executing commands.",
          "group": null,
          "included": false
        },
        "pg_settings_track_activity_query_size": {
          "type": "gauge",
          "description": "Sets the size reserved for pg_stat_activity.query, in bytes.",
          "group": null,
          "included": false
        },
        "pg_settings_track_commit_timestamp": {
          "type": "gauge",
          "description": "Collects transaction commit time.",
          "group": null,
          "included": false
        },
        "pg_settings_track_counts": {
          "type": "gauge",
          "description": "Collects statistics on database activity.",
          "group": null,
          "included": false
        },
        "pg_settings_track_io_timing": {
          "type": "gauge",
          "description": "Collects timing statistics for database I/O activity.",
          "group": null,
          "included": false
        },
        "pg_settings_transaction_deferrable": {
          "type": "gauge",
          "description": "Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures.",
          "group": null,
          "included": false
        },
        "pg_settings_transaction_read_only": {
          "type": "gauge",
          "description": "Sets the current transaction's read-only status.",
          "group": null,
          "included": false
        },
        "pg_settings_transform_null_equals": {
          "type": "gauge",
          "description": "Treats \"expr=NULL\" as \"expr IS NULL\".",
          "group": null,
          "included": false
        },
        "pg_settings_unix_socket_permissions": {
          "type": "gauge",
          "description": "Sets the access permissions of the Unix-domain socket.",
          "group": null,
          "included": false
        },
        "pg_settings_update_process_title": {
          "type": "gauge",
          "description": "Updates the process title to show the active SQL command.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_cost_delay_seconds": {
          "type": "gauge",
          "description": "Vacuum cost delay in milliseconds. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_cost_limit": {
          "type": "gauge",
          "description": "Vacuum cost amount available before napping.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_cost_page_dirty": {
          "type": "gauge",
          "description": "Vacuum cost for a page dirtied by vacuum.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_cost_page_hit": {
          "type": "gauge",
          "description": "Vacuum cost for a page found in the buffer cache.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_cost_page_miss": {
          "type": "gauge",
          "description": "Vacuum cost for a page not found in the buffer cache.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_defer_cleanup_age": {
          "type": "gauge",
          "description": "Number of transactions by which VACUUM and HOT cleanup should be deferred, if any.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_freeze_min_age": {
          "type": "gauge",
          "description": "Minimum age at which VACUUM should freeze a table row.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_freeze_table_age": {
          "type": "gauge",
          "description": "Age at which VACUUM should scan whole table to freeze tuples.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_multixact_freeze_min_age": {
          "type": "gauge",
          "description": "Minimum age at which VACUUM should freeze a MultiXactId in a table row.",
          "group": null,
          "included": false
        },
        "pg_settings_vacuum_multixact_freeze_table_age": {
          "type": "gauge",
          "description": "Multixact age at which VACUUM should scan whole table to freeze tuples.",
          "group": null,
          "included": false
        },
        "pg_settings_wal_block_size": {
          "type": "gauge",
          "description": "Shows the block size in the write ahead log.",
          "group": null,
          "included": false
        },
        "pg_settings_wal_buffers_bytes": {
          "type": "gauge",
          "description": "Sets the number of disk-page buffers in shared memory for WAL. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_wal_compression": {
          "type": "gauge",
          "description": "Compresses full-page writes written in WAL file.",
          "group": null,
          "included": false
        },
        "pg_settings_wal_keep_segments": {
          "type": "gauge",
          "description": "Sets the number of WAL files held for standby servers.",
          "group": null,
          "included": false
        },
        "pg_settings_wal_log_hints": {
          "type": "gauge",
          "description": "Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modifications.",
          "group": null,
          "included": false
        },
        "pg_settings_wal_receiver_status_interval_seconds": {
          "type": "gauge",
          "description": "Sets the maximum interval between WAL receiver status reports to the primary. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_wal_receiver_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum wait time to receive data from the primary. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_wal_retrieve_retry_interval_seconds": {
          "type": "gauge",
          "description": "Sets the time to wait before retrying to retrieve WAL after a failed attempt. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_wal_segment_size_bytes": {
          "type": "gauge",
          "description": "Shows the number of pages per write ahead log segment. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_wal_sender_timeout_seconds": {
          "type": "gauge",
          "description": "Sets the maximum time to wait for WAL replication. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_wal_writer_delay_seconds": {
          "type": "gauge",
          "description": "Time between WAL flushes performed in the WAL writer. [Units converted to seconds.]",
          "group": null,
          "included": false
        },
        "pg_settings_wal_writer_flush_after_bytes": {
          "type": "gauge",
          "description": "Amount of WAL written out by WAL writer that triggers a flush. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_work_mem_bytes": {
          "type": "gauge",
          "description": "Sets the maximum memory to be used for query workspaces. [Units converted to bytes.]",
          "group": null,
          "included": false
        },
        "pg_settings_zero_damaged_pages": {
          "type": "gauge",
          "description": "Continues processing past damaged page headers.",
          "group": null,
          "included": false
        },
        "pg_slow_queries": {
          "type": "gauge",
          "description": "Current number of slow queries",
          "group": null,
          "included": false
        },
        "pg_stat_activity_count": {
          "type": "gauge",
          "description": "Number of connections in this state",
          "group": null,
          "included": true
        },
        "pg_stat_activity_max_tx_duration": {
          "type": "gauge",
          "description": "Max duration in seconds any active transaction has been running",
          "group": null,
          "included": true
        },
        "pg_stat_bgwriter_buffers_alloc": {
          "type": "cumulative",
          "description": "Number of buffers allocated",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_buffers_backend": {
          "type": "cumulative",
          "description": "Number of buffers written directly by a backend",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_buffers_backend_fsync": {
          "type": "cumulative",
          "description": "Number of times a backend had to execute its own fsync call (normally the background writer handles those even when the backend does its own write)",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_buffers_checkpoint": {
          "type": "cumulative",
          "description": "Number of buffers written during checkpoints",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_buffers_clean": {
          "type": "cumulative",
          "description": "Number of buffers written by the background writer",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_checkpoint_sync_time": {
          "type": "cumulative",
          "description": "Total amount of time that has been spent in the portion of checkpoint processing where files are synchronized to disk, in milliseconds",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_checkpoint_write_time": {
          "type": "cumulative",
          "description": "Total amount of time that has been spent in the portion of checkpoint processing where files are written to disk, in milliseconds",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_checkpoints_req": {
          "type": "cumulative",
          "description": "Number of requested checkpoints that have been performed",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_checkpoints_timed": {
          "type": "cumulative",
          "description": "Number of scheduled checkpoints that have been performed",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_maxwritten_clean": {
          "type": "cumulative",
          "description": "Number of times the background writer stopped a cleaning scan because it had written too many buffers",
          "group": null,
          "included": false
        },
        "pg_stat_bgwriter_stats_reset": {
          "type": "cumulative",
          "description": "Time at which these statistics were last reset",
          "group": null,
          "included": false
        },
        "pg_stat_database_blk_read_time": {
          "type": "cumulative",
          "description": "Time spent reading data file blocks by backends in this database, in milliseconds",
          "group": null,
          "included": true
        },
        "pg_stat_database_blk_write_time": {
          "type": "cumulative",
          "description": "Time spent writing data file blocks by backends in this database, in milliseconds",
          "group": null,
          "included": true
        },
        "pg_stat_database_blks_hit": {
          "type": "cumulative",
          "description": "Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)",
          "group": null,
          "included": true
        },
        "pg_stat_database_blks_read": {
          "type": "cumulative",
          "description": "Number of disk blocks read in this database",
          "group": null,
          "included": true
        },
        "pg_stat_database_conflicts": {
          "type": "cumulative",
          "description": "Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see pg_stat_database_conflicts for details.)",
          "group": null,
          "included": false
        },
        "pg_stat_database_conflicts_confl_bufferpin": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to pinned buffers",
          "group": null,
          "included": true
        },
        "pg_stat_database_conflicts_confl_deadlock": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to deadlocks",
          "group": null,
          "included": true
        },
        "pg_stat_database_conflicts_confl_lock": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to lock timeouts",
          "group": null,
          "included": true
        },
        "pg_stat_database_conflicts_confl_snapshot": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to old snapshots",
          "group": null,
          "included": true
        },
        "pg_stat_database_conflicts_confl_tablespace": {
          "type": "cumulative",
          "description": "Number of queries in this database that have been canceled due to dropped tablespaces",
          "group": null,
          "included": true
        },
        "pg_stat_database_deadlocks": {
          "type": "cumulative",
          "description": "Number of deadlocks detected in this database",
          "group": null,
          "included": false
        },
        "pg_stat_database_numbackends": {
          "type": "gauge",
          "description": "Number of backends currently connected to this database. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.",
          "group": null,
          "included": true
        },
        "pg_stat_database_stats_reset": {
          "type": "cumulative",
          "description": "Time at which these statistics were last reset",
          "group": null,
          "included": false
        },
        "pg_stat_database_temp_bytes": {
          "type": "cumulative",
          "description": "Total amount of data written to temporary files by queries in this database. All temporary files are counted, regardless of why the temporary file was created, and regardless of the log_temp_files setting.",
          "group": null,
          "included": true
        },
        "pg_stat_database_temp_files": {
          "type": "cumulative",
          "description": "Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (e.g., sorting or hashing), and regardless of the log_temp_files setting.",
          "group": null,
          "included": true
        },
        "pg_stat_database_tup_deleted": {
          "type": "cumulative",
          "description": "Number of rows deleted by queries in this database",
          "group": null,
          "included": true
        },
        "pg_stat_database_tup_fetched": {
          "type": "cumulative",
          "description": "Number of rows fetched by queries in this database",
          "group": null,
          "included": true
        },
        "pg_stat_database_tup_inserted": {
          "type": "cumulative",
          "description": "Number of rows inserted by queries in this database",
          "group": null,
          "included": true
        },
        "pg_stat_database_tup_returned": {
          "type": "cumulative",
          "description": "Number of rows returned by queries in this database",
          "group": null,
          "included": true
        },
        "pg_stat_database_tup_updated": {
          "type": "cumulative",
          "description": "Number of rows updated by queries in this database",
          "group": null,
          "included": true
        },
        "pg_stat_database_xact_commit": {
          "type": "cumulative",
          "description": "Number of transactions in this database that have been committed",
          "group": null,
          "included": true
        },
        "pg_stat_database_xact_rollback": {
          "type": "cumulative",
          "description": "Number of transactions in this database that have been rolled back",
          "group": null,
          "included": true
        },
        "pg_static": {
          "type": "gauge",
          "description": "Version string as reported by postgres",
          "group": null,
          "included": false
        },
        "pg_stuck_idle_in_transaction_queries": {
          "type": "gauge",
          "description": "Current number of queries that are stuck being idle in transactions",
          "group": null,
          "included": false
        },
        "pg_total_relation_size_bytes": {
          "type": "gauge",
          "description": "Total disk space usage for the specified table and associated indexes",
          "group": null,
          "included": true
        },
        "pg_up": {
          "type": "gauge",
          "description": "Whether the last scrape of metrics from PostgreSQL was able to connect to the server (1 for yes, 0 for no).",
          "group": null,
          "included": false
        },
        "pg_vacuum_age_in_seconds": {
          "type": "gauge",
          "description": "The current maximum VACUUM query age in seconds",
          "group": null,
          "included": false
        },
        "pg_vacuum_analyze_age_in_seconds": {
          "type": "gauge",
          "description": "The current maximum VACUUM ANALYZE query age in seconds",
          "group": null,
          "included": false
        },
        "pg_vacuum_analyze_queries": {
          "type": "gauge",
          "description": "The current number of VACUUM ANALYZE queries",
          "group": null,
          "included": false
        },
        "pg_vacuum_queries": {
          "type": "gauge",
          "description": "The current number of VACUUM queries",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/prometheus/postgres",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/prometheus",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus server's own internal\ncollector](https://prometheus.io/docs/prometheus/latest/getting_started/#configuring-prometheus-to-monitor-itself)\nmetrics from a Prometheus exporter and sends them to SignalFx.  It is a\nwrapper around the [prometheus-exporter](./prometheus-exporter.md) monitor\nthat provides a restricted but expandable set of metrics.\n",
      "groups": null,
      "metrics": {
        "net_conntrack_dialer_conn_attempted_total": {
          "type": "cumulative",
          "description": "Total number of connections attempted by the given dialer a given name",
          "group": null,
          "included": false
        },
        "net_conntrack_dialer_conn_closed_total": {
          "type": "cumulative",
          "description": "Total number of connections closed which originated from the dialer of a given name",
          "group": null,
          "included": false
        },
        "net_conntrack_dialer_conn_established_total": {
          "type": "cumulative",
          "description": "Total number of connections successfully established by the given dialer a given name",
          "group": null,
          "included": false
        },
        "net_conntrack_dialer_conn_failed_total": {
          "type": "cumulative",
          "description": "Total number of connections failed to dial by the dialer a given name",
          "group": null,
          "included": false
        },
        "net_conntrack_listener_conn_accepted_total": {
          "type": "cumulative",
          "description": "Total number of connections opened to the listener of a given name",
          "group": null,
          "included": false
        },
        "net_conntrack_listener_conn_closed_total": {
          "type": "cumulative",
          "description": "Total number of connections closed that were made to the listener of a given name",
          "group": null,
          "included": false
        },
        "prometheus_api_remote_read_queries": {
          "type": "gauge",
          "description": "The current number of remote read queries being executed or waiting",
          "group": null,
          "included": false
        },
        "prometheus_build_info": {
          "type": "gauge",
          "description": "A metric with a constant '1' value labeled by version, revision, branch, and goversion from which prometheus was built",
          "group": null,
          "included": false
        },
        "prometheus_config_last_reload_success_timestamp_seconds": {
          "type": "gauge",
          "description": "Timestamp of the last successful configuration reload",
          "group": null,
          "included": false
        },
        "prometheus_config_last_reload_successful": {
          "type": "gauge",
          "description": "Whether the last configuration reload attempt was successful",
          "group": null,
          "included": false
        },
        "prometheus_engine_queries": {
          "type": "gauge",
          "description": "The current number of queries being executed or waiting",
          "group": null,
          "included": false
        },
        "prometheus_engine_queries_concurrent_max": {
          "type": "gauge",
          "description": "The max number of concurrent queries",
          "group": null,
          "included": false
        },
        "prometheus_engine_query_duration_seconds": {
          "type": "cumulative",
          "description": "Query timings",
          "group": null,
          "included": false
        },
        "prometheus_engine_query_duration_seconds_count": {
          "type": "cumulative",
          "description": "Query timings (count)",
          "group": null,
          "included": false
        },
        "prometheus_http_request_duration_seconds": {
          "type": "cumulative",
          "description": "Histogram of latencies for HTTP requests",
          "group": null,
          "included": false
        },
        "prometheus_http_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Histogram of latencies for HTTP requests in the respective bucket",
          "group": null,
          "included": false
        },
        "prometheus_http_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "Histogram of latencies for HTTP requests (count)",
          "group": null,
          "included": false
        },
        "prometheus_http_response_size_bytes": {
          "type": "cumulative",
          "description": "Histogram of response size for HTTP requests",
          "group": null,
          "included": false
        },
        "prometheus_http_response_size_bytes_bucket": {
          "type": "cumulative",
          "description": "Histogram of response size for HTTP requests in the respective bucket",
          "group": null,
          "included": false
        },
        "prometheus_http_response_size_bytes_count": {
          "type": "cumulative",
          "description": "Histogram of response size for HTTP requests",
          "group": null,
          "included": false
        },
        "prometheus_notifications_alertmanagers_discovered": {
          "type": "gauge",
          "description": "The number of alertmanagers discovered and active",
          "group": null,
          "included": false
        },
        "prometheus_notifications_dropped_total": {
          "type": "cumulative",
          "description": "Total number of alerts dropped due to errors when sending to Alertmanager",
          "group": null,
          "included": false
        },
        "prometheus_notifications_queue_capacity": {
          "type": "gauge",
          "description": "The capacity of the alert notifications queue",
          "group": null,
          "included": false
        },
        "prometheus_notifications_queue_length": {
          "type": "gauge",
          "description": "The number of alert notifications in the queue",
          "group": null,
          "included": false
        },
        "prometheus_rule_evaluation_duration_seconds": {
          "type": "cumulative",
          "description": "The duration for a rule to execute",
          "group": null,
          "included": false
        },
        "prometheus_rule_evaluation_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration for a rule to execute (count)",
          "group": null,
          "included": false
        },
        "prometheus_rule_evaluation_failures_total": {
          "type": "cumulative",
          "description": "The total number of rule evaluation failures",
          "group": null,
          "included": false
        },
        "prometheus_rule_group_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of rule group evaluations",
          "group": null,
          "included": false
        },
        "prometheus_rule_group_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of rule group evaluations (count)",
          "group": null,
          "included": false
        },
        "prometheus_rule_group_interval_seconds": {
          "type": "gauge",
          "description": "The interval of a rule group",
          "group": null,
          "included": false
        },
        "prometheus_rule_group_iterations_missed_total": {
          "type": "cumulative",
          "description": "The total number of rule group evaluations missed due to slow rule group evaluation",
          "group": null,
          "included": false
        },
        "prometheus_rule_group_iterations_total": {
          "type": "cumulative",
          "description": "The total number of scheduled rule group evaluations, whether executed or missed",
          "group": null,
          "included": false
        },
        "prometheus_rule_group_last_duration_seconds": {
          "type": "gauge",
          "description": "The duration of the last rule group evaluation",
          "group": null,
          "included": false
        },
        "prometheus_sd_azure_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a Azure-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_azure_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a Azure-SD refresh in seconds (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_azure_refresh_failures_total": {
          "type": "cumulative",
          "description": "Number of Azure-SD refresh failures",
          "group": null,
          "included": false
        },
        "prometheus_sd_configs_failed_total": {
          "type": "cumulative",
          "description": "Total number of service discovery configurations that failed to load",
          "group": null,
          "included": false
        },
        "prometheus_sd_consul_rpc_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a Consul RPC call in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_consul_rpc_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a Consul RPC call in seconds (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_consul_rpc_failures_total": {
          "type": "cumulative",
          "description": "The number of Consul RPC call failures",
          "group": null,
          "included": false
        },
        "prometheus_sd_discovered_targets": {
          "type": "gauge",
          "description": "Current number of discovered targets",
          "group": null,
          "included": false
        },
        "prometheus_sd_dns_lookup_failures_total": {
          "type": "cumulative",
          "description": "The number of DNS-SD lookup failures",
          "group": null,
          "included": false
        },
        "prometheus_sd_dns_lookups_total": {
          "type": "cumulative",
          "description": "The number of DNS-SD lookups",
          "group": null,
          "included": false
        },
        "prometheus_sd_ec2_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a EC2-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_ec2_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a EC2-SD refresh in seconds (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_ec2_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of EC2-SD scrape failures",
          "group": null,
          "included": false
        },
        "prometheus_sd_file_read_errors_total": {
          "type": "cumulative",
          "description": "The number of File-SD read errors",
          "group": null,
          "included": false
        },
        "prometheus_sd_file_scan_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of the File-SD scan in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_file_scan_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of the File-SD scan in seconds (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_gce_refresh_duration": {
          "type": "cumulative",
          "description": "The duration of a GCE-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_gce_refresh_duration_count": {
          "type": "cumulative",
          "description": "The duration of a GCE-SD refresh in seconds (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_gce_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of GCE-SD refresh failures",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_last_resource_version": {
          "type": "gauge",
          "description": "Last resource version from the Kubernetes API",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_list_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of a Kubernetes API call in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_list_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of a Kubernetes API call in seconds (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_list_items": {
          "type": "cumulative",
          "description": "Count of items in a list from the Kubernetes API",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_list_items_count": {
          "type": "cumulative",
          "description": "Count of items in a list from the Kubernetes API (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_list_total": {
          "type": "cumulative",
          "description": "Total number of list operations",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_short_watches_total": {
          "type": "cumulative",
          "description": "Total number of short watch operations",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_watch_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of watches on the Kubernetes API",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_watch_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of watches on the Kubernetes API (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_watch_events": {
          "type": "cumulative",
          "description": "Number of items in watches on the Kubernetes API",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_watch_events_count": {
          "type": "cumulative",
          "description": "Number of items in watches on the Kubernetes API (count)",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_cache_watches_total": {
          "type": "cumulative",
          "description": "Total number of watch operations",
          "group": null,
          "included": false
        },
        "prometheus_sd_kubernetes_events_total": {
          "type": "cumulative",
          "description": "The number of Kubernetes events handled",
          "group": null,
          "included": false
        },
        "prometheus_sd_marathon_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a Marathon-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_marathon_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a Marathon-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_marathon_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of Marathon-SD refresh failures",
          "group": null,
          "included": false
        },
        "prometheus_sd_openstack_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of an OpenStack-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_openstack_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of an OpenStack-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_openstack_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of OpenStack-SD scrape failures",
          "group": null,
          "included": false
        },
        "prometheus_sd_received_updates_total": {
          "type": "cumulative",
          "description": "Total number of update events received from the SD providers",
          "group": null,
          "included": false
        },
        "prometheus_sd_triton_refresh_duration_seconds": {
          "type": "cumulative",
          "description": "The duration of a Triton-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_triton_refresh_duration_seconds_count": {
          "type": "cumulative",
          "description": "The duration of a Triton-SD refresh in seconds",
          "group": null,
          "included": false
        },
        "prometheus_sd_triton_refresh_failures_total": {
          "type": "cumulative",
          "description": "The number of Triton-SD scrape failures",
          "group": null,
          "included": false
        },
        "prometheus_sd_updates_delayed_total": {
          "type": "cumulative",
          "description": "Total number of update events that couldn't be sent immediately",
          "group": null,
          "included": false
        },
        "prometheus_sd_updates_total": {
          "type": "cumulative",
          "description": "Total number of update events sent to the SD consumers",
          "group": null,
          "included": false
        },
        "prometheus_target_interval_length_seconds": {
          "type": "cumulative",
          "description": "Actual intervals between scrapes",
          "group": null,
          "included": false
        },
        "prometheus_target_interval_length_seconds_count": {
          "type": "cumulative",
          "description": "Actual intervals between scrapes",
          "group": null,
          "included": false
        },
        "prometheus_target_scrape_pool_sync_total": {
          "type": "cumulative",
          "description": "Total number of syncs that were executed on a scrape pool",
          "group": null,
          "included": false
        },
        "prometheus_target_scrapes_exceeded_sample_limit_total": {
          "type": "cumulative",
          "description": "Total number of scrapes that hit the sample limit and were rejected",
          "group": null,
          "included": false
        },
        "prometheus_target_scrapes_sample_duplicate_timestamp_total": {
          "type": "cumulative",
          "description": "Total number of samples rejected due to duplicate timestamps but different values",
          "group": null,
          "included": false
        },
        "prometheus_target_scrapes_sample_out_of_bounds_total": {
          "type": "cumulative",
          "description": "Total number of samples rejected due to timestamp falling outside of the time bounds",
          "group": null,
          "included": false
        },
        "prometheus_target_scrapes_sample_out_of_order_total": {
          "type": "cumulative",
          "description": "Total number of samples rejected due to not being out of the expected order",
          "group": null,
          "included": false
        },
        "prometheus_target_sync_length_seconds": {
          "type": "cumulative",
          "description": "Actual interval to sync the scrape pool",
          "group": null,
          "included": false
        },
        "prometheus_target_sync_length_seconds_count": {
          "type": "cumulative",
          "description": "Actual interval to sync the scrape pool",
          "group": null,
          "included": false
        },
        "prometheus_treecache_watcher_goroutines": {
          "type": "gauge",
          "description": "The current number of watcher goroutines",
          "group": null,
          "included": false
        },
        "prometheus_treecache_zookeeper_failures_total": {
          "type": "cumulative",
          "description": "The total number of ZooKeeper failures",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_blocks_loaded": {
          "type": "gauge",
          "description": "Number of currently loaded data blocks",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_checkpoint_creations_failed_total": {
          "type": "cumulative",
          "description": "Total number of checkpoint creations that failed",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_checkpoint_creations_total": {
          "type": "cumulative",
          "description": "Total number of checkpoint creations attempted",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_checkpoint_deletions_failed_total": {
          "type": "cumulative",
          "description": "Total number of checkpoint deletions that failed",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_checkpoint_deletions_total": {
          "type": "cumulative",
          "description": "Total number of checkpoint deletions attempted",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_range_seconds": {
          "type": "cumulative",
          "description": "Final time range of chunks on their first compaction",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_range_seconds_bucket": {
          "type": "cumulative",
          "description": "Final time range of chunks on their first compaction in the respective bucket",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_range_seconds_count": {
          "type": "cumulative",
          "description": "Final time range of chunks on their first compaction (count)",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_samples": {
          "type": "cumulative",
          "description": "Final number of samples on their first compaction",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_samples_bucket": {
          "type": "cumulative",
          "description": "Final number of samples on their first compaction in the respective bucket",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_samples_count": {
          "type": "cumulative",
          "description": "Final number of samples on their first compaction (count)",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_size_bytes": {
          "type": "cumulative",
          "description": "Final size of chunks on their first compaction",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_size_bytes_bucket": {
          "type": "cumulative",
          "description": "Final size of chunks on their first compaction in the respective bucket",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_chunk_size_bytes_count": {
          "type": "cumulative",
          "description": "Final size of chunks on their first compaction",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of compaction runs",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "Duration of compaction runs in the respective bucket",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compaction_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of compaction runs (count)",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compactions_failed_total": {
          "type": "cumulative",
          "description": "Total number of compactions that failed for the partition",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compactions_total": {
          "type": "cumulative",
          "description": "Total number of compactions that were executed for the partition",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_compactions_triggered_total": {
          "type": "cumulative",
          "description": "Total number of triggered compactions for the partition",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_active_appenders": {
          "type": "gauge",
          "description": "Number of currently active appender transactions",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_chunks": {
          "type": "gauge",
          "description": "Total number of chunks in the head block",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_chunks_created_total": {
          "type": "cumulative",
          "description": "Total number of chunks created in the head",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_chunks_removed_total": {
          "type": "cumulative",
          "description": "Total number of chunks removed in the head",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_gc_duration_seconds": {
          "type": "cumulative",
          "description": "Runtime of garbage collection in the head block",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "Runtime of garbage collection in the head block (count)",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_max_time": {
          "type": "gauge",
          "description": "Maximum timestamp of the head block",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_min_time": {
          "type": "gauge",
          "description": "Minimum time bound of the head block",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_samples_appended_total": {
          "type": "cumulative",
          "description": "Total number of appended samples",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_series": {
          "type": "gauge",
          "description": "Total number of series in the head block",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_series_created_total": {
          "type": "cumulative",
          "description": "Total number of series created in the head",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_series_not_found_total": {
          "type": "cumulative",
          "description": "Total number of requests for series that were not found",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_series_removed_total": {
          "type": "cumulative",
          "description": "Total number of series removed in the head",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_truncations_failed_total": {
          "type": "cumulative",
          "description": "Total number of head truncations that failed",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_head_truncations_total": {
          "type": "cumulative",
          "description": "Total number of head truncations attempted",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_lowest_timestamp": {
          "type": "gauge",
          "description": "Lowest timestamp value stored in the database",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_reloads_failures_total": {
          "type": "cumulative",
          "description": "Number of times the database failed to reload block data from disk",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_reloads_total": {
          "type": "cumulative",
          "description": "Number of times the database reloaded block data from disk",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_retention_cutoffs_failures_total": {
          "type": "cumulative",
          "description": "Number of times the database failed to cut off block data from disk",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_retention_cutoffs_total": {
          "type": "cumulative",
          "description": "Number of times the database cut off block data from disk",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_symbol_table_size_bytes": {
          "type": "gauge",
          "description": "Size of symbol table on disk (in bytes)",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_tombstone_cleanup_seconds": {
          "type": "cumulative",
          "description": "The time taken to recompact blocks to remove tombstones",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_tombstone_cleanup_seconds_bucket": {
          "type": "cumulative",
          "description": "The time taken to recompact blocks to remove tombstones in the respective bucket",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_tombstone_cleanup_seconds_count": {
          "type": "cumulative",
          "description": "The time taken to recompact blocks to remove tombstones (count)",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_wal_completed_pages_total": {
          "type": "cumulative",
          "description": "Total number of completed pages",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_wal_fsync_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of WAL fsync",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_wal_fsync_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of WAL fsync (count)",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_wal_page_flushes_total": {
          "type": "cumulative",
          "description": "Total number of page flushes",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_wal_truncate_duration_seconds": {
          "type": "cumulative",
          "description": "Duration of WAL truncation",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_wal_truncate_duration_seconds_count": {
          "type": "cumulative",
          "description": "Duration of WAL truncation (count)",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_wal_truncations_failed_total": {
          "type": "cumulative",
          "description": "Total number of WAL truncations that failed",
          "group": null,
          "included": false
        },
        "prometheus_tsdb_wal_truncations_total": {
          "type": "cumulative",
          "description": "Total number of WAL truncations attempted",
          "group": null,
          "included": false
        },
        "promhttp_metric_handler_requests_in_flight": {
          "type": "gauge",
          "description": "Current number of scrapes being served",
          "group": null,
          "included": false
        },
        "promhttp_metric_handler_requests_total": {
          "type": "cumulative",
          "description": "Total number of scrapes by HTTP status code",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/prometheus/prometheus",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "prometheus/redis",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor scrapes [Prmoetheus Redis\nExporter](https://github.com/oliver006/redis_exporter) metrics and sends\nthem to SignalFx.  It is a wrapper around the\n[prometheus-exporter](./prometheus-exporter.md) monitor that provides a\nrestricted but expandable set of metrics.\n",
      "groups": null,
      "metrics": {
        "redis_aof_current_rewrite_duration_sec": {
          "type": "gauge",
          "description": "aof_current_rewrite_duration_sec metric",
          "group": null,
          "included": false
        },
        "redis_aof_enabled": {
          "type": "gauge",
          "description": "aof_enabled metric",
          "group": null,
          "included": false
        },
        "redis_aof_last_rewrite_duration_sec": {
          "type": "gauge",
          "description": "aof_last_rewrite_duration_sec metric",
          "group": null,
          "included": false
        },
        "redis_aof_rewrite_in_progress": {
          "type": "gauge",
          "description": "aof_rewrite_in_progress metric",
          "group": null,
          "included": false
        },
        "redis_aof_rewrite_scheduled": {
          "type": "gauge",
          "description": "aof_rewrite_scheduled metric",
          "group": null,
          "included": false
        },
        "redis_blocked_clients": {
          "type": "gauge",
          "description": "blocked_clients metric",
          "group": null,
          "included": false
        },
        "redis_client_biggest_input_buf": {
          "type": "gauge",
          "description": "client_biggest_input_buf metric",
          "group": null,
          "included": false
        },
        "redis_client_longest_output_list": {
          "type": "gauge",
          "description": "client_longest_output_list metric",
          "group": null,
          "included": false
        },
        "redis_cluster_enabled": {
          "type": "gauge",
          "description": "cluster_enabled metric",
          "group": null,
          "included": false
        },
        "redis_command_call_duration_seconds_count": {
          "type": "gauge",
          "description": "command_call_duration_seconds_count metric",
          "group": null,
          "included": false
        },
        "redis_command_call_duration_seconds_sum": {
          "type": "gauge",
          "description": "Total amount of time in seconds spent per command",
          "group": null,
          "included": false
        },
        "redis_commands_processed_total": {
          "type": "gauge",
          "description": "commands_processed_total metric",
          "group": null,
          "included": false
        },
        "redis_config_maxclients": {
          "type": "gauge",
          "description": "config_maxclients metric",
          "group": null,
          "included": false
        },
        "redis_config_maxmemory": {
          "type": "gauge",
          "description": "config_maxmemory metric",
          "group": null,
          "included": false
        },
        "redis_connected_clients": {
          "type": "gauge",
          "description": "connected_clients metric",
          "group": null,
          "included": false
        },
        "redis_connected_slaves": {
          "type": "gauge",
          "description": "connected_slaves metric",
          "group": null,
          "included": false
        },
        "redis_connections_received_total": {
          "type": "gauge",
          "description": "connections_received_total metric",
          "group": null,
          "included": false
        },
        "redis_db_avg_ttl_seconds": {
          "type": "gauge",
          "description": "Avg TTL in seconds",
          "group": null,
          "included": false
        },
        "redis_db_keys": {
          "type": "gauge",
          "description": "Total number of keys by DB",
          "group": null,
          "included": false
        },
        "redis_db_keys_expiring": {
          "type": "gauge",
          "description": "Total number of expiring keys by DB",
          "group": null,
          "included": false
        },
        "redis_evicted_keys_total": {
          "type": "gauge",
          "description": "evicted_keys_total metric",
          "group": null,
          "included": false
        },
        "redis_expired_keys_total": {
          "type": "gauge",
          "description": "expired_keys_total metric",
          "group": null,
          "included": false
        },
        "redis_exporter_build_info": {
          "type": "gauge",
          "description": "redis exporter build_info",
          "group": null,
          "included": false
        },
        "redis_exporter_last_scrape_duration_seconds": {
          "type": "gauge",
          "description": "The last scrape duration",
          "group": null,
          "included": false
        },
        "redis_exporter_last_scrape_error": {
          "type": "gauge",
          "description": "The last scrape error status",
          "group": null,
          "included": false
        },
        "redis_exporter_scrapes_total": {
          "type": "gauge",
          "description": "Current total redis scrapes",
          "group": null,
          "included": false
        },
        "redis_instance_info": {
          "type": "gauge",
          "description": "Information about the Redis instance",
          "group": null,
          "included": false
        },
        "redis_instantaneous_input_kbps": {
          "type": "gauge",
          "description": "instantaneous_input_kbps metric",
          "group": null,
          "included": false
        },
        "redis_instantaneous_ops_per_sec": {
          "type": "gauge",
          "description": "instantaneous_ops_per_sec metric",
          "group": null,
          "included": false
        },
        "redis_instantaneous_output_kbps": {
          "type": "gauge",
          "description": "instantaneous_output_kbps metric",
          "group": null,
          "included": false
        },
        "redis_keyspace_hits_total": {
          "type": "gauge",
          "description": "keyspace_hits_total metric",
          "group": null,
          "included": false
        },
        "redis_keyspace_misses_total": {
          "type": "gauge",
          "description": "keyspace_misses_total metric",
          "group": null,
          "included": false
        },
        "redis_latest_fork_usec": {
          "type": "gauge",
          "description": "latest_fork_usec metric",
          "group": null,
          "included": false
        },
        "redis_loading_dump_file": {
          "type": "gauge",
          "description": "loading_dump_file metric",
          "group": null,
          "included": false
        },
        "redis_master_repl_offset": {
          "type": "gauge",
          "description": "master_repl_offset metric",
          "group": null,
          "included": false
        },
        "redis_memory_fragmentation_ratio": {
          "type": "gauge",
          "description": "memory_fragmentation_ratio metric",
          "group": null,
          "included": false
        },
        "redis_memory_max_bytes": {
          "type": "gauge",
          "description": "memory_max_bytes metric",
          "group": null,
          "included": false
        },
        "redis_memory_used_bytes": {
          "type": "gauge",
          "description": "memory_used_bytes metric",
          "group": null,
          "included": false
        },
        "redis_memory_used_lua_bytes": {
          "type": "gauge",
          "description": "memory_used_lua_bytes metric",
          "group": null,
          "included": false
        },
        "redis_memory_used_peak_bytes": {
          "type": "gauge",
          "description": "memory_used_peak_bytes metric",
          "group": null,
          "included": false
        },
        "redis_memory_used_rss_bytes": {
          "type": "gauge",
          "description": "memory_used_rss_bytes metric",
          "group": null,
          "included": false
        },
        "redis_net_input_bytes_total": {
          "type": "gauge",
          "description": "net_input_bytes_total metric",
          "group": null,
          "included": false
        },
        "redis_net_output_bytes_total": {
          "type": "gauge",
          "description": "net_output_bytes_total metric",
          "group": null,
          "included": false
        },
        "redis_process_id": {
          "type": "gauge",
          "description": "process_id metric",
          "group": null,
          "included": false
        },
        "redis_pubsub_channels": {
          "type": "gauge",
          "description": "pubsub_channels metric",
          "group": null,
          "included": false
        },
        "redis_pubsub_patterns": {
          "type": "gauge",
          "description": "pubsub_patterns metric",
          "group": null,
          "included": false
        },
        "redis_rdb_changes_since_last_save": {
          "type": "gauge",
          "description": "rdb_changes_since_last_save metric",
          "group": null,
          "included": false
        },
        "redis_rdb_current_bgsave_duration_sec": {
          "type": "gauge",
          "description": "rdb_current_bgsave_duration_sec metric",
          "group": null,
          "included": false
        },
        "redis_rdb_last_bgsave_duration_sec": {
          "type": "gauge",
          "description": "rdb_last_bgsave_duration_sec metric",
          "group": null,
          "included": false
        },
        "redis_rejected_connections_total": {
          "type": "gauge",
          "description": "rejected_connections_total metric",
          "group": null,
          "included": false
        },
        "redis_replication_backlog_bytes": {
          "type": "gauge",
          "description": "replication_backlog_bytes metric",
          "group": null,
          "included": false
        },
        "redis_slowlog_length": {
          "type": "gauge",
          "description": "Total slowlog",
          "group": null,
          "included": false
        },
        "redis_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the Redis instance since unix epoch in seconds",
          "group": null,
          "included": false
        },
        "redis_up": {
          "type": "gauge",
          "description": "up metric",
          "group": null,
          "included": false
        },
        "redis_uptime_in_seconds": {
          "type": "gauge",
          "description": "uptime_in_seconds metric",
          "group": null,
          "included": false
        },
        "redis_used_cpu_sys": {
          "type": "gauge",
          "description": "used_cpu_sys metric",
          "group": null,
          "included": false
        },
        "redis_used_cpu_sys_children": {
          "type": "gauge",
          "description": "used_cpu_sys_children metric",
          "group": null,
          "included": false
        },
        "redis_used_cpu_user": {
          "type": "gauge",
          "description": "used_cpu_user metric",
          "group": null,
          "included": false
        },
        "redis_used_cpu_user_children": {
          "type": "gauge",
          "description": "used_cpu_user_children metric",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/prometheus/redis",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "python-monitor",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor allows you to generate metrics from a Python script.\n\nYour Python code should be Python 2.7+ *AND* 3.0+ compatible.  The Python\nruntime bundled with the agent is currently version 2.7 but this could be\nupgraded at anytime to Python 3.  If you want to use Python 3 at this time,\nyou can specify a custom Python binary with the `pythonBinary` config\noption.\n\n## Module Loading\nThe full file path to the Python script that you want to run should be\nspecified in the `scriptFilePath` config option.  This file will be loaded in\nPython by adding the directory containing the file to the front of the Python\npath (`sys.path`) and then dynamically importing the file as a module.  For\na hypothetical script at `/opt/scripts/mymonitor.py`, this is roughly\nequivalent to the following Python code:\n\n```\nimport sys\nsys.path.insert(0, \"/opt/scripts\")\n\nimport mymodule\n```\n\nThere are two ways you can implement a monitor in Python, a simple way or a\ncomplex, but more powerful way.  \n\n## Simple monitor \nThe simple way is to write a script that has a `run` function in it.  This\nfunction should accept two parameters: `config` and `output`.  The `run`\nfunction will be called on a regular interval, specified by the common\n`intervalSeconds` config option on the monitor config.\n\nHere is [an example of a simple monitor](https://github.com/signalfx/signalfx-agent/tree/master/python/sample/monitor_simple.py).\n\n## Complex monitor\n\nIf you need more power and flexibility in defining your monitor, you can\nuse the complex monitor format.  With this, you define a class called\n`Monitor` in a Python module. Here is [a documented example of a complex\nmonitor](https://github.com/signalfx/signalfx-agent/tree/master/python/sample/monitor_complex.py).\n\n## Auto-discovery\n\nThis monitor works with auto-discovery just like other monitors.  If you\nset a `discoveryRule` on the monitor config, a new instance of the monitor\nwill be created for each matching endpoint and the `host` and `port` config\nfields will be populated with the appropriate values and passed to the\nPython script in the `config` dictionary.\n\n## Example Config\n\nThis shows loading a Python module from the agent repo using a single custom config value (`myconfig`):\n\n```yaml\nmonitors:\n - type: python-monitor\n   # pythonBinary: /usr/bin/python\n   scriptFilePath: /usr/src/signalfx-agent/python/sample/monitor_complex.py\n   myconfig: [1,2,3]\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config specifies configurations that are specific to the individual python based monitor",
        "package": "internal/monitors/pyrunner/signalfx",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host will be filled in by auto-discovery if this monitor has a discovery rule.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port will be filled in by auto-discovery if this monitor has a discovery rule.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "scriptFilePath",
            "doc": "Path to the Python script that implements the monitoring logic.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pythonBinary",
            "doc": "By default, the agent will use its bundled Python runtime (version 2.7). If you wish to use a Python runtime that already exists on the system, specify the full path to the `python` binary here, e.g. `/usr/bin/python3`.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pythonPath",
            "doc": "The PYTHONPATH that will be used when importing the script specified at `scriptFilePath`.  The directory of `scriptFilePath` will always be included in the path.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "sql",
      "sendAll": true,
      "dimensions": null,
      "doc": "Run arbitrary SQL queries against a relational database and use the results to generate dataponts.\n\nFor example, if you had a database table `customers` that looked like:\n\n| id | name       | country | status   |\n|----|------------|---------|----------|\n| 1  | Bill       | USA     | active   |\n| 2  | Mary       | USA     | inactive |\n| 3  | Joe        | USA     | active   |\n| 4  | Elizabeth  | Germany | active   |\n\nYou could use the following monitor config to generate metrics about active users and customer counts by country:\n\n```yaml\nmonitors:\n  - type: sql\n    host: localhost\n    port: 5432\n    dbDriver: postgres\n    params:\n      user: admin\n      password: s3cr3t\n    # The `host` and `port` values from above (or provided through auto-discovery) should be interpolated\n    # to the connection string as appropriate for your database driver.\n    # Also, the values from the `params` config option above can be\n    # interpolated.\n    connectionString: 'host={{.host}} port={{.port}} dbname=main user={{.user}} password={{.password}} sslmode=disabled'\n    queries:\n      - query: 'SELECT COUNT(*) as count, country, status FROM customers GROUP BY country, status;'\n        metrics:\n          - metricName: \"customers\"\n            valueColumn: \"count\"\n            dimensionColumns: [\"country\", \"status\"]\n```\n\nThis would generate a series of timeseries, all with the metric name\n`customers` that includes a `county` and `status` dimension.  The value\nis the number of customers that belong to that combination of `country`\nand `status`.  You could also specify multiple `metrics` items to\ngenerate more than one metric from a single query.\n\n## Supported Drivers\n\nThe `dbDriver` config option must specify the database driver to use.\nThese are equivalent to the name of the Golang SQL driver used in the\nagent.  The `connectionString` option will be formatted according to the\ndriver that is going to receive it.  Here is a list of the drivers we\ncurrently support and documentation on the connection string:\n\n  - `postgres`: https://godoc.org/github.com/lib/pq#hdr-Connection_String_Parameters\n  - `mysql`: https://github.com/go-sql-driver/mysql#dsn-data-source-name\n  - `mssql`: https://github.com/denisenkom/go-mssqldb#connection-parameters-and-dsn\n\n## Parameterized Connection String\n\nThe `connectionString` config option acts as a template with a context\nconsisting of the variables: `host`, `port`, and all the values from\nthe `params` config option map.  You interpolate variables into it\nwith the Go template syntax `{{.varname}}` (see example config\nabove).\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/sql",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "params",
            "doc": "Parameters to the connectionString that can be templated into that option using Go template syntax (e.g. `{{.key}}`).",
            "default": null,
            "required": false,
            "type": "map",
            "elementKind": "string"
          },
          {
            "yamlName": "dbDriver",
            "doc": "The database driver to use, valid values are `postgres` and `mysql`.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "connectionString",
            "doc": "A URL or simple option string used to connect to the database. If using PostgreSQL, [see the list of connection string params](https://godoc.org/github.com/lib/pq#hdr-Connection_String_Parameters).",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "queries",
            "doc": "A list of queries to make against the database that are used to generate datapoints.",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Query",
              "doc": "Query is used to configure a query statement and the resulting datapoints",
              "package": "internal/monitors/sql",
              "fields": [
                {
                  "yamlName": "query",
                  "doc": "A SQL query text that selects one or more rows from a database",
                  "default": null,
                  "required": true,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "params",
                  "doc": "Optional parameters that will replace placeholders in the query string.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "interface"
                },
                {
                  "yamlName": "metrics",
                  "doc": "Metrics that should be generated from the query.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "Metric",
                    "doc": "Metric describes how to derive a metric from the individual rows of a query result.",
                    "package": "internal/monitors/sql",
                    "fields": [
                      {
                        "yamlName": "metricName",
                        "doc": "The name of the metric as it will appear in SignalFx.",
                        "default": null,
                        "required": true,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "valueColumn",
                        "doc": "The column name that holds the datapoint value",
                        "default": null,
                        "required": true,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "dimensionColumns",
                        "doc": "The names of the columns that should make up the dimensions of the datapoint.",
                        "default": null,
                        "required": false,
                        "type": "slice",
                        "elementKind": "string"
                      },
                      {
                        "yamlName": "isCumulative",
                        "doc": "Whether the value is a cumulative counters (true) or gauge (false).  If you set this to the wrong value and send in your first datapoint for the metric name with the wrong type, you will have to manually change the type in SignalFx, as it is set in the system based on the first type seen.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "yamlName": "logQueries",
            "doc": "If true, query results will be logged at the info level.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "statsd",
      "sendAll": true,
      "dimensions": null,
      "doc": "\n\n### USAGE\n\n#### Adding dimensions to StatsD metrics\n\nThe StatsD monitor can parse keywords from a statsd metric name by a set of\nconverters that was configured by user.\n\n```\nconverters:\n  - pattern: \"cluster.cds_{traffic}_{mesh}_{service}-vn_{}.{action}\"\n    ...\n```\n\nThis converter will parse `traffic`, `mesh`, `service` and `action` as dimensions\nfrom a metric name `cluster.cds_egress_ecommerce-demo-mesh_gateway-vn_tcp_8080.update_success`.\nIf a section has only a pair of brackets without a name, it will not capture a dimension.\n\nWhen multiple converters were provided, a metric will be converted by the first converter with a\nmatching pattern to the metric name.\n\n#### Formatting metric name\n\nYou can customize a metric name by providing a format string within the converter configuration.\n\n```\nconverters:\n  - pattern: \"cluster.cds_{traffic}_{mesh}_{service}-vn_{}.{action}\"\n    metric: \"{traffic}.{action}\"\n```\n\nThe metrics which match to the given pattern will be reported to SignalFx as `{traffic}.{action}`.\nFor instance, metric `cluster.cds_egress_ecommerce-demo-mesh_gateway-vn_tcp_8080.update_success`\nwill be reported as `egress.update_success`.\n\n`metric` is required for a converter configuration. A converter will be disabled if `metric` is not provided.\n\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/statsd",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host/address on which to bind the UDP listener that accepts statsd datagrams",
            "default": "localhost",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "listenPort",
            "doc": "The port on which to listen for statsd messages (**default:** `8125`)",
            "default": null,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "metricPrefix",
            "doc": "A prefix in metric names that needs to be removed before metric name conversion",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "converters",
            "doc": "A list converters to convert StatsD metric names into SignalFx metric names and dimensions",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "ConverterInput",
              "doc": "ConverterInput is to receive configs to setup metric converters",
              "package": "internal/monitors/statsd",
              "fields": [
                {
                  "yamlName": "pattern",
                  "doc": "A pattern to match against StatsD metric names",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "metricName",
                  "doc": "A format to compose a metric name to report to SignalFx",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/logparser",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor is based on the Telegraf logparser plugin.\nThe monitor tails log files. More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/logparser).\nAll metrics emitted from this monitor will have the `plugin` dimension set to `telegraf-logparser`\n\nSample YAML configuration:\n\n```yaml\n - type: telegraf/logparser\n   files:\n    - '$file'\n   watchMethod: poll       # specify the file watch method (\"inotify\" or \"poll\")\n   fromBeginning: true     # specify to read from the beginning\n   measurementName: test-measurement # the metric name prefix\n   patterns:\n    - \"%{COMMON_LOG_FORMAT}\" # specifies the apache common log format\n   timezone: UTC\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/telegraf/monitors/telegraflogparser",
        "fields": [
          {
            "yamlName": "files",
            "doc": "Paths to files to be tailed",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "watchMethod",
            "doc": "Method for watching changes to files (\"ionotify\" or \"poll\")",
            "default": "poll",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "fromBeginning",
            "doc": "Whether to start tailing from the beginning of the file",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "measurementName",
            "doc": "Name of the measurement",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "patterns",
            "doc": "A list of patterns to match.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "namedPatterns",
            "doc": "A list of named grok patterns to match.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "customPatterns",
            "doc": "Custom grok patterns. (`grok` only)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "customPatternFiles",
            "doc": "List of paths to custom grok pattern files.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "timezone",
            "doc": "Specifies the timezone.  The default is UTC time.  Other options are `Local` for the local time on the machine, `UTC`, and `Canada/Eastern` (unix style timezones).",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/procstat",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reports metrics about processes.\nThis monitor is based on the Telegraf procstat plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/procstat).\n\nPlease note that the Smart Agent only supports the `native` pid finder and the options\n`cgroup` and `systemd unit` are not supported at this time.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\nSample Yaml Configuration\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: telegraf/procstat\n   exe: \"signalfx-agent*\"\n```\n",
      "groups": null,
      "metrics": {
        "procstat.cpu_time": {
          "type": "gauge",
          "description": "Amount of cpu time consumed by the process.",
          "group": null,
          "included": false
        },
        "procstat.cpu_usage": {
          "type": "gauge",
          "description": "CPU used by the process.",
          "group": null,
          "included": false
        },
        "procstat.involuntary_context_switches": {
          "type": "gauge",
          "description": "Number of involuntary context switches.",
          "group": null,
          "included": false
        },
        "procstat.memory_data": {
          "type": "gauge",
          "description": "VMData memory used by the process.",
          "group": null,
          "included": false
        },
        "procstat.memory_locked": {
          "type": "gauge",
          "description": "VMLocked memory used by the process.",
          "group": null,
          "included": false
        },
        "procstat.memory_rss": {
          "type": "gauge",
          "description": "VMRSS memory used by the process.",
          "group": null,
          "included": false
        },
        "procstat.memory_stack": {
          "type": "gauge",
          "description": "VMStack memory used by the process.",
          "group": null,
          "included": false
        },
        "procstat.memory_swap": {
          "type": "gauge",
          "description": "VMSwap memory used by the process.",
          "group": null,
          "included": false
        },
        "procstat.memory_vms": {
          "type": "gauge",
          "description": "VMS memory used by the process.",
          "group": null,
          "included": false
        },
        "procstat.nice_priority": {
          "type": "gauge",
          "description": "Nice priority number of the process.",
          "group": null,
          "included": false
        },
        "procstat.num_fds": {
          "type": "gauge",
          "description": "Number of file descriptors.  This may require the agent to be running as root.",
          "group": null,
          "included": false
        },
        "procstat.num_threads": {
          "type": "gauge",
          "description": "Number of threads used by the process.",
          "group": null,
          "included": false
        },
        "procstat.read_bytes": {
          "type": "gauge",
          "description": "Number of bytes read by the process.  This may require the agent to be running as root.",
          "group": null,
          "included": false
        },
        "procstat.read_count": {
          "type": "gauge",
          "description": "Number of read operations by the process.  This may require the agent to be running as root.",
          "group": null,
          "included": false
        },
        "procstat.realtime_priority": {
          "type": "gauge",
          "description": "Real time priority of the process.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_cpu_time_hard": {
          "type": "gauge",
          "description": "The hard cpu rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_cpu_time_soft": {
          "type": "gauge",
          "description": "The soft cpu rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_file_locks_hard": {
          "type": "gauge",
          "description": "The hard file lock rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_file_locks_soft": {
          "type": "gauge",
          "description": "The soft file lock rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_data_hard": {
          "type": "gauge",
          "description": "The hard data memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_data_soft": {
          "type": "gauge",
          "description": "The soft data memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_locked_hard": {
          "type": "gauge",
          "description": "The hard locked memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_locked_soft": {
          "type": "gauge",
          "description": "The soft locked memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_rss_hard": {
          "type": "gauge",
          "description": "The hard rss memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_rss_soft": {
          "type": "gauge",
          "description": "The soft rss memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_stack_hard": {
          "type": "gauge",
          "description": "The hard stack memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_stack_soft": {
          "type": "gauge",
          "description": "The soft stack memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_vms_hard": {
          "type": "gauge",
          "description": "The hard vms memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_memory_vms_soft": {
          "type": "gauge",
          "description": "The soft vms memory rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_nice_priority_hard": {
          "type": "gauge",
          "description": "The hard nice priority rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_nice_priority_soft": {
          "type": "gauge",
          "description": "The soft nice priority rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_num_fds_hard": {
          "type": "gauge",
          "description": "The hard file descriptor rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_num_fds_soft": {
          "type": "gauge",
          "description": "The soft file descriptor rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_realtime_priority_hard": {
          "type": "gauge",
          "description": "The hard realtime priority rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_realtime_priority_soft": {
          "type": "gauge",
          "description": "The soft realtime priority rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_signals_pending_hard": {
          "type": "gauge",
          "description": "The hard pending signal rlimit.",
          "group": null,
          "included": false
        },
        "procstat.rlimit_signals_pending_soft": {
          "type": "gauge",
          "description": "The soft pendidng signal rlimit.",
          "group": null,
          "included": false
        },
        "procstat.signals_pending": {
          "type": "gauge",
          "description": "The number of signals pending.",
          "group": null,
          "included": false
        },
        "procstat.write_bytes": {
          "type": "gauge",
          "description": "Number of bytes written by the process.  This may require the agent to be running as root.",
          "group": null,
          "included": false
        },
        "procstat.write_count": {
          "type": "gauge",
          "description": "Number of write operations by the process.  This may require the agent to be running as root.",
          "group": null,
          "included": false
        },
        "procstat_lookup.pid_count": {
          "type": "gauge",
          "description": "The number of pids. This metric emits with the plugin dimension set to \"procstat_lookup\".",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/telegraf/monitors/procstat",
        "fields": [
          {
            "yamlName": "exe",
            "doc": "The name of an executable to monitor.  (ie: `exe: \"signalfx-agent*\"`)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pattern",
            "doc": "Pattern to match against.  On Windows the pattern should be in the form of a WMI query. (ie: `pattern: \"%signalfx-agent%\"`)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "user",
            "doc": "Username to match against",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pidFile",
            "doc": "Path to Pid file to monitor.  (ie: `pidFile: \"/var/run/signalfx-agent.pid\"`)",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "processName",
            "doc": "Used to override the process name dimension",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "prefix",
            "doc": "Prefix to be added to each dimension",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pidTag",
            "doc": "Whether to add PID as a dimension instead of part of the metric name",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "cGroup",
            "doc": "The name of the cgroup to monitor.  This cgroup name will be appended to the configured `sysPath`.  See the agent config schema for more information about the `sysPath` agent configuration.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "WinService",
            "doc": "The name of a windows service to report procstat information on.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/snmp",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reports metrics from snmp agents.\nThis monitor is based on the Telegraf SNMP plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/snmp).\n\n**NOTE:** This snmp monitor does not currently support MIB look ups because of a dependency on `net-snmp`\nand specifically the commands `snmptranslate` and `snmptable`.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/snmp\n   agents:\n     - \"127.0.0.1:161\"\n   version: 2\n   community: \"public\"\n   fields:\n     - name: \"uptime\"\n       oid: \".1.3.6.1.2.1.1.3.0\"\n```\n\nUsing a discovery rule to discover and configure for a specific snmp agent\n```yaml\nmonitors:\n - type: telegraf/snmp\n   discoveryRule: container_name =~ \"snmp\" \u0026\u0026 port == 161\n   version: 2\n   community: \"public\"\n   fields:\n     - name: \"uptime\"\n       oid: \".1.3.6.1.2.1.1.3.0\"\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/telegraf/monitors/telegrafsnmp",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host and port will be concatenated and appended to the list of SNMP agents to connect to.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port and Host will be concatenated and appended to the list of SNMP agents to connect to.",
            "default": 0,
            "required": false,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "agents",
            "doc": "SNMP agent address and ports to query for information.  An example address is `0.0.0.0:5555` If an address is supplied with out a port, the default port `161` will be used.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "retries",
            "doc": "The number of times to retry.",
            "default": 0,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "community",
            "doc": "The SNMP community to use.",
            "default": "public",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "maxRepetitions",
            "doc": "Maximum number of iterations for reqpeating variables",
            "default": 50,
            "required": false,
            "type": "uint8",
            "elementKind": ""
          },
          {
            "yamlName": "contextName",
            "doc": "SNMP v3 context name to use with requests",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "secLevel",
            "doc": "Security level to use for SNMP v3 messages: `noAuthNoPriv` `authNoPriv`, `authPriv`.",
            "default": "noAuthNoPriv",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "secName",
            "doc": "Name to used to authenticate with SNMP v3 requests.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "authProtocol",
            "doc": "Protocol to used to authenticate SNMP v3 requests: `\"MD5\"`, `\"SHA\"`, and `\"\"` (default).",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "authPassword",
            "doc": "Password used to authenticate SNMP v3 requests.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "privProtocol",
            "doc": "Protocol used for encrypted SNMP v3 messages: `DES`, `AES`, `\"\"` (default).",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "privPassword",
            "doc": "Password used to encrypt SNMP v3 messages.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "engineID",
            "doc": "The SNMP v3 engine ID.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "engineBoots",
            "doc": "The SNMP v3 engine boots.",
            "default": 0,
            "required": false,
            "type": "uint32",
            "elementKind": ""
          },
          {
            "yamlName": "engineTime",
            "doc": "The SNMP v3 engine time.",
            "default": 0,
            "required": false,
            "type": "uint32",
            "elementKind": ""
          },
          {
            "yamlName": "name",
            "doc": "The top-level measurement name",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "fields",
            "doc": "The top-level SNMP fields",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Field",
              "doc": "Field represents an SNMP field",
              "package": "internal/monitors/telegraf/monitors/telegrafsnmp",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "Name of the field.  The OID will be used if no value is supplied.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "oid",
                  "doc": "The OID to fetch.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "oidIndexSuffix",
                  "doc": "The sub-identifier to strip off when matching indexes to other fields.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "oidIndexLength",
                  "doc": "The index length after the table OID.  The index will be truncated after this length in order to remove length index suffixes or non-fixed values.",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "isTag",
                  "doc": "Whether to output the field as a tag.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "conversion",
                  "doc": "Controls the type conversion applied to the value: `\"float(X)\"`, `\"float\"`, `\"int\"`, `\"hwaddr\"`, `\"ipaddr\"` or `\"\"` (default).",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "tables",
            "doc": "SNMP Tables",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "Table",
              "doc": "Table represents an SNMP table",
              "package": "internal/monitors/telegraf/monitors/telegrafsnmp",
              "fields": [
                {
                  "yamlName": "name",
                  "doc": "Metric name.  If not supplied the OID will be used.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "inheritTags",
                  "doc": "Top level tags to inherit.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "indexAsTag",
                  "doc": "Add a tag for the table index for each row.",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "field",
                  "doc": "Specifies the ags and values to look up.",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "struct",
                  "elementStruct": {
                    "name": "Field",
                    "doc": "Field represents an SNMP field",
                    "package": "internal/monitors/telegraf/monitors/telegrafsnmp",
                    "fields": [
                      {
                        "yamlName": "name",
                        "doc": "Name of the field.  The OID will be used if no value is supplied.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "oid",
                        "doc": "The OID to fetch.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "oidIndexSuffix",
                        "doc": "The sub-identifier to strip off when matching indexes to other fields.",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "oidIndexLength",
                        "doc": "The index length after the table OID.  The index will be truncated after this length in order to remove length index suffixes or non-fixed values.",
                        "default": 0,
                        "required": false,
                        "type": "int",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "isTag",
                        "doc": "Whether to output the field as a tag.",
                        "default": false,
                        "required": false,
                        "type": "bool",
                        "elementKind": ""
                      },
                      {
                        "yamlName": "conversion",
                        "doc": "Controls the type conversion applied to the value: `\"float(X)\"`, `\"float\"`, `\"int\"`, `\"hwaddr\"`, `\"ipaddr\"` or `\"\"` (default).",
                        "default": "",
                        "required": false,
                        "type": "string",
                        "elementKind": ""
                      }
                    ]
                  }
                },
                {
                  "yamlName": "oid",
                  "doc": "The OID to fetch.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/sqlserver",
      "sendAll": false,
      "dimensions": null,
      "doc": "This monitor reports metrics about Microsoft SQL servers.\nThis monitor is based on the telegraf sqlserver plugin.  More information about the telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/sqlserver).\n\nYou will need to create a login on the SQL server for the monitor to use.  You can create this login by\nexecuting the following commands in an a SQL client while logged in as an administrator.\n\n```\nUSE master;\nGO\nCREATE LOGIN [signalfxagent] WITH PASSWORD = N'\u003cYOUR PASSWORD HERE\u003e';\nGO\nGRANT VIEW SERVER STATE TO [signalfxagent];\nGO\nGRANT VIEW ANY DEFINITION TO [signalfxagent];\nGO\n```\n\nTroubleshooting:\n\nOn some Windows based SQL server distributions TCP/IP has been disabled by default.  This behavior\nhas been observed on Azure SQL server instances.  You may need to explicitly turn on TCP/IP for the\nSQL server if you see error messages simillar to the following.\n\n```\nCannot read handshake packet: read tcp: wsarecv: An existing connection was forcibly closed by the remote host.\n```\n\n1. Verify agent configurations are correct.\n2. Ensure TCP/IP is enabled for the SQL server by going to `Start` -\u003e `Administrative Tools` -\u003e `Computer Management`\n3. In the `Computer Management` side bar, drill down to `Services and Applications` -\u003e `SQL Server Configuration Manager` -\u003e `SQL Server Network Configuration`\n4. Select `Protocols for \u003cYOUR SQL SERVER NAME\u003e`.\n5. In the protocol list to the right, right-click on the `TCP/IP` protocol and `enable` it.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/sqlserver\n   host: hostname\n   port: 1433\n   userID: sa\n   password: P@ssw0rd!\n   appName: signalfxagent\n```\n",
      "groups": null,
      "metrics": {
        "sqlserver_database_io.read_bytes": {
          "type": "gauge",
          "description": "Bytes read by the database.",
          "group": null,
          "included": true
        },
        "sqlserver_database_io.read_latency_ms": {
          "type": "gauge",
          "description": "Latency in milliseconds reading from the database.",
          "group": null,
          "included": true
        },
        "sqlserver_database_io.reads": {
          "type": "gauge",
          "description": "Number of reads from the database.",
          "group": null,
          "included": true
        },
        "sqlserver_database_io.write_bytes": {
          "type": "gauge",
          "description": "Bytes written to the database.",
          "group": null,
          "included": true
        },
        "sqlserver_database_io.write_latency_ms": {
          "type": "gauge",
          "description": "Latency in milliseconds writing to the database.",
          "group": null,
          "included": true
        },
        "sqlserver_database_io.writes": {
          "type": "gauge",
          "description": "Number of writes to the database.",
          "group": null,
          "included": true
        },
        "sqlserver_memory_clerks.size_kb.bound_trees": {
          "type": "gauge",
          "description": "Size in KB of bound trees memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.buffer_pool": {
          "type": "gauge",
          "description": "Size in KB of buffer pool memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.connection_pool": {
          "type": "gauge",
          "description": "Size in KB of connection pool memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.general": {
          "type": "gauge",
          "description": "Size in KB of general memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.in-memory_oltp": {
          "type": "gauge",
          "description": "Size in KB of in in-memoory oltp memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.log_pool": {
          "type": "gauge",
          "description": "Size in KB of log pool memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.memoryclerk_sqltrace": {
          "type": "gauge",
          "description": "Size in KB of sql trace memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.schema_manager_user_store": {
          "type": "gauge",
          "description": "Size in KB of user store schema manager memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.sos_node": {
          "type": "gauge",
          "description": "Size in KB of sos node memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.sql_optimizer": {
          "type": "gauge",
          "description": "Size in KB of SQL optimizer memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.sql_plans": {
          "type": "gauge",
          "description": "Size in KB of sql plans memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.sql_reservations": {
          "type": "gauge",
          "description": "Size in KB of sql reservations memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.sql_storage_engine": {
          "type": "gauge",
          "description": "Size in KB of sql storage engine memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_memory_clerks.size_kb.system_rowset_store": {
          "type": "gauge",
          "description": "Size in KB of system rowset store memory clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.active_memory_grant_amount_kb": {
          "type": "gauge",
          "description": "Amount of active memory in KB granted.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.active_temp_tables": {
          "type": "gauge",
          "description": "Number of active temporary tables.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.background_writer_pages_sec": {
          "type": "gauge",
          "description": "Rate per second of pages written in the background.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.backup_restore_throughput_sec": {
          "type": "gauge",
          "description": "Rate per second of backup/restore throughput.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.batch_requests_sec": {
          "type": "gauge",
          "description": "Rate per second of batch requests.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.blocked_tasks": {
          "type": "gauge",
          "description": "Number of blocked tasks.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.buffer_cache_hit_ratio": {
          "type": "gauge",
          "description": "Buffer cache hit ration.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.bytes_received_from_replica_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes received from replicas.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.bytes_sent_to_replica_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes sent to replicas.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.bytes_sent_to_transport_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes sent to transports.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.checkpoint_pages_sec": {
          "type": "gauge",
          "description": "Rate per second of checkpoint pages.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.cpu_limit_violation_count": {
          "type": "gauge",
          "description": "Number of cpu limit violations.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.cpu_usage_pct": {
          "type": "gauge",
          "description": "CPU usage percentage.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.cpu_usage_time": {
          "type": "gauge",
          "description": "CPU usage time.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.data_file_size_kb": {
          "type": "gauge",
          "description": "Size in KB of data files.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.disk_read_bytes_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes from disk.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.disk_read_io_sec": {
          "type": "gauge",
          "description": "Rate per second of read operations from disk.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.disk_read_io_throttled_sec": {
          "type": "gauge",
          "description": "Rate per second of throttled read operations.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.disk_write_bytes_sec": {
          "type": "gauge",
          "description": "Rate per second of bytes written to disk.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.disk_write_io_sec": {
          "type": "gauge",
          "description": "Rate per second of write operations to disk.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.disk_write_io_throttled_sec": {
          "type": "gauge",
          "description": "Rate per second of write operations throttled.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.errors_sec": {
          "type": "gauge",
          "description": "Rate of errors per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.flow_control_sec": {
          "type": "gauge",
          "description": "Rate per second of flow control.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.flow_control_time_ms_sec": {
          "type": "gauge",
          "description": "Rate per second of ms of flow control time.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.forwarded_records_sec": {
          "type": "gauge",
          "description": "Rate per second of record forwarding.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.free_list_stalls_sec": {
          "type": "gauge",
          "description": "Rate per second of stalled free list.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.free_space_in_tempdb_kb": {
          "type": "gauge",
          "description": "Free space in KB of tempdb.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.full_scans_sec": {
          "type": "gauge",
          "description": "Rate per second of full scans.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.index_searches_sec": {
          "type": "gauge",
          "description": "Rate per second of index searches.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.latch_waits_sec": {
          "type": "gauge",
          "description": "Rate per second of latch waits.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.lazy_writes_sec": {
          "type": "gauge",
          "description": "Rate per second of lazy writes.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.lock_timeouts_sec": {
          "type": "gauge",
          "description": "Rate per second of lock timeouts.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.lock_wait_count": {
          "type": "gauge",
          "description": "Number of lock waits.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.lock_wait_time": {
          "type": "gauge",
          "description": "Lock wait time.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.lock_waits_sec": {
          "type": "gauge",
          "description": "Rate per second of lock waits.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_apply_pending_queue": {
          "type": "gauge",
          "description": "Size of the log apply pending queue.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_apply_ready_queue": {
          "type": "gauge",
          "description": "Size of log apply ready queue.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_bytes_flushed_sec": {
          "type": "gauge",
          "description": "Rate per second of log bytes flushed.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_bytes_received_sec": {
          "type": "gauge",
          "description": "Rate per second of log bytes received.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_file_size_kb": {
          "type": "gauge",
          "description": "Size in KB of log file.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_file_used_size_kb": {
          "type": "gauge",
          "description": "Size in KB of log file used.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_flush_wait_time": {
          "type": "gauge",
          "description": "Time spent flushing the log.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_flushes_sec": {
          "type": "gauge",
          "description": "Rate per second of log flushes.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.log_send_queue": {
          "type": "gauge",
          "description": "Size of the log send queue.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.logins_sec": {
          "type": "gauge",
          "description": "Rate of logins per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.logouts_sec": {
          "type": "gauge",
          "description": "Rate of logouts per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.memory_broker_clerk_size": {
          "type": "gauge",
          "description": "Size of memory broker clerk.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.memory_grants_outstanding": {
          "type": "gauge",
          "description": "Number of outstanding memory grants.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.memory_grants_pending": {
          "type": "gauge",
          "description": "Number of pending memory grants.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.number_of_deadlocks_sec": {
          "type": "gauge",
          "description": "Rate of deadlocks per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.page_life_expectancy": {
          "type": "gauge",
          "description": "Page life expectancy.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.page_lookups_sec": {
          "type": "gauge",
          "description": "Rate of page look ups per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.page_reads_sec": {
          "type": "gauge",
          "description": "Rate of page reads per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.page_splits_sec": {
          "type": "gauge",
          "description": "Rate of page splits per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.page_writes_sec": {
          "type": "gauge",
          "description": "Rate of page writes per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.pct_log_used": {
          "type": "gauge",
          "description": "Percentage of log used.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.processes_blocked": {
          "type": "gauge",
          "description": "Number of blocked processes.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.query": {
          "type": "gauge",
          "description": "[User settable](https://docs.microsoft.com/en-us/sql/relational-databases/performance-monitor/sql-server-user-settable-object?view=sql-server-2017) performance counters\n",
          "group": null,
          "included": false
        },
        "sqlserver_performance.queued_request_count": {
          "type": "gauge",
          "description": "Number of queued requests.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.queued_requests": {
          "type": "gauge",
          "description": "Average number of queued requests.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.readahead_pages_sec": {
          "type": "gauge",
          "description": "Rate per second of read ahead pages.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.receives_from_replica_sec": {
          "type": "gauge",
          "description": "Rate receives from replicas per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.recovery_queue": {
          "type": "gauge",
          "description": "Size of recovery queue.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.redone_bytes_sec": {
          "type": "gauge",
          "description": "Rate of redone bytes per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.reduced_memory_grant_count": {
          "type": "gauge",
          "description": "Number of reduced memory grants.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.request_count": {
          "type": "gauge",
          "description": "Number of requests.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.requests_completed_sec": {
          "type": "gauge",
          "description": "Rate of completed requests per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.resent_messages_sec": {
          "type": "gauge",
          "description": "Rate of resent messages per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.sends_to_replica_sec": {
          "type": "gauge",
          "description": "Rate of sends to replicas per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.sends_to_transport_sec": {
          "type": "gauge",
          "description": "Rate of sends to transports per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.sql_compilations_sec": {
          "type": "gauge",
          "description": "Rate of sql compilations per second.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.sql_re-compilations_sec": {
          "type": "gauge",
          "description": "Rate of sql recompilations per sec.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.target_server_memory_kb": {
          "type": "gauge",
          "description": "Size of target server memory in KB.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.temp_tables_creation_rate": {
          "type": "gauge",
          "description": "Rate of temporary table creations.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.temp_tables_for_destruction": {
          "type": "gauge",
          "description": "Number of temporary tables marked for destruction.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.total_server_memory_kb": {
          "type": "gauge",
          "description": "Total server memory in KB.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.transaction_delay": {
          "type": "gauge",
          "description": "Number of delayed transactions.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.transactions_sec": {
          "type": "gauge",
          "description": "Rate of transactions per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.used_memory_kb": {
          "type": "gauge",
          "description": "Used memory in KB.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.user_connections": {
          "type": "gauge",
          "description": "Number of user connections.",
          "group": null,
          "included": true
        },
        "sqlserver_performance.version_store_size_kb": {
          "type": "gauge",
          "description": "Size of the version store in KB.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.write_transactions_sec": {
          "type": "gauge",
          "description": "Rate of write transactions per second.",
          "group": null,
          "included": false
        },
        "sqlserver_performance.xtp_memory_used_kb": {
          "type": "gauge",
          "description": "Size of xtp memory used in KB.",
          "group": null,
          "included": false
        },
        "sqlserver_server_properties.available_storage_mb": {
          "type": "gauge",
          "description": "Available storage in MB.",
          "group": null,
          "included": false
        },
        "sqlserver_server_properties.cpu_count": {
          "type": "gauge",
          "description": "Number of cpus.",
          "group": null,
          "included": false
        },
        "sqlserver_server_properties.db_offline": {
          "type": "gauge",
          "description": "Number of offline databases.",
          "group": null,
          "included": true
        },
        "sqlserver_server_properties.db_online": {
          "type": "gauge",
          "description": "Number of online databases.",
          "group": null,
          "included": true
        },
        "sqlserver_server_properties.db_recovering": {
          "type": "gauge",
          "description": "Number of databases recovering.",
          "group": null,
          "included": true
        },
        "sqlserver_server_properties.db_recoverypending": {
          "type": "gauge",
          "description": "Number of databases pending recovery.",
          "group": null,
          "included": true
        },
        "sqlserver_server_properties.db_restoring": {
          "type": "gauge",
          "description": "Number of databases restoring.",
          "group": null,
          "included": true
        },
        "sqlserver_server_properties.db_suspect": {
          "type": "gauge",
          "description": "Number of suspect databases.",
          "group": null,
          "included": true
        },
        "sqlserver_server_properties.engine_edition": {
          "type": "gauge",
          "description": "Sql server engine edition version.",
          "group": null,
          "included": false
        },
        "sqlserver_server_properties.server_memory": {
          "type": "gauge",
          "description": "Amount of memory on the sql server.",
          "group": null,
          "included": false
        },
        "sqlserver_server_properties.total_storage_mb": {
          "type": "gauge",
          "description": "Amount of storage in MB of the sql server.",
          "group": null,
          "included": false
        },
        "sqlserver_server_properties.uptime": {
          "type": "gauge",
          "description": "Uptime of the sql server.",
          "group": null,
          "included": false
        },
        "sqlserver_waitstats.max_wait_time_ms": {
          "type": "gauge",
          "description": "Maximum time in millisecond spent waiting.",
          "group": null,
          "included": false
        },
        "sqlserver_waitstats.resource_wait_ms": {
          "type": "gauge",
          "description": "Time in milliseconds spent waiting on a resource.",
          "group": null,
          "included": false
        },
        "sqlserver_waitstats.signal_wait_time_ms": {
          "type": "gauge",
          "description": "Time in milliseconds waiting on a signal.",
          "group": null,
          "included": false
        },
        "sqlserver_waitstats.wait_time_ms": {
          "type": "gauge",
          "description": "Time in milliseconds waiting.",
          "group": null,
          "included": false
        },
        "sqlserver_waitstats.waiting_tasks_count": {
          "type": "gauge",
          "description": "Time in milliseconds",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/telegraf/monitors/mssqlserver",
        "fields": [
          {
            "yamlName": "host",
            "doc": "",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "userID",
            "doc": "UserID used to access the SQL Server instance.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Password used to access the SQL Server instance.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "appName",
            "doc": "The app name used by the monitor when connecting to the SQLServer.",
            "default": "signalfxagent",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "queryVersion",
            "doc": "The version of queries to use when accessing the cluster. Please refer to the telegraf documentation for more information.",
            "default": 2,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "azureDB",
            "doc": "Whether the database is an azure database or not.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "excludedQueries",
            "doc": "Queries to exclude possible values are `PerformanceCounters`, `WaitStatsCategorized`, `DatabaseIO`, `DatabaseProperties`, `CPUHistory`, `DatabaseSize`, `DatabaseStats`, `MemoryClerk` `VolumeSpace`, and `PerformanceMetrics`.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "log",
            "doc": "Log level to use when accessing the database",
            "default": 1,
            "required": false,
            "type": "uint",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/statsd",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor acts as a Telegraf StatsD listener for receiving telegrafstatsd metrics.\nThis monitor is based on the Telegraf Statsd input plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/statsd).\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/statsd\n   protocol: udp\n   serviceAddress: \":8125\"\n   parseDataDogTags: true\n```\n\n```yaml\nmonitors:\n - type: telegraf/statsd\n   protocol: udp\n   serviceAddress: \"127.0.0.1:0\"\n   parseDataDogTags: true\n   metricSeparator: '.'\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/telegraf/monitors/telegrafstatsd",
        "fields": [
          {
            "yamlName": "protocol",
            "doc": "Protocol to use with the listener: `tcp`, `udp4`, `udp6`, or `udp`.",
            "default": "udp",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serviceAddress",
            "doc": "The address and port to serve from",
            "default": ":8125",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "maxTCPConnections",
            "doc": "Maximum number of tcp connections allowed.",
            "default": 250,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "TCPKeepAlive",
            "doc": "Indicates whether to keep the tcp connection alive.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteGauges",
            "doc": "Whether to clear the gauge cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteCounters",
            "doc": "Whether to clear the counter cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteSets",
            "doc": "Whether to clear the sets cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "deleteTimings",
            "doc": "Whether to clear the timings cache every interval.  Setting this to false means the cache will only be cleared when the monitor is restarted.",
            "default": true,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "percentiles",
            "doc": "The percentiles that are collected for timing and histogram stats.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "int"
          },
          {
            "yamlName": "allowedPendingMessages",
            "doc": "Number of messages allowed to queue up between each collection interval. Packets will be dropped until the next collection interval if this buffer fills up.",
            "default": 10000,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "percentileLimit",
            "doc": "The maximum number of histogram values to track each measurement when calculating percentiles. Increasing the limit will increase memory consumption but will also improve accuracy.",
            "default": 1000,
            "required": false,
            "type": "int",
            "elementKind": ""
          },
          {
            "yamlName": "metricSeparator",
            "doc": "The separator used to separate parts of a metric name",
            "default": "_",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "templates",
            "doc": "Templates that transform telegrafstatsd metrics into influx tags and measurements. Please refer to the Telegraf (documentation)[https://github.com/influxdata/telegraf/tree/master/plugins/inputs/statsd#statsd-bucket---influxdb-line-protocol-templates] for more information on templates.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "parseDataDogTags",
            "doc": "Indicates whether to parse dogstatsd tags",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/tail",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor is based on the Telegraf tail plugin.  The monitor tails files and\nnamed pipes.  The Telegraf parser configured with this monitor extracts metrics in different\n[formats](https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md)\nfrom the tailed output. More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/tail).\nAll metrics emitted from this monitor will have the `plugin` dimension set to `telegraf-tail`\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/tail\n   files:\n    - '/logs/**.log'       # find all .log files in /logs\n    - '/logs/*/*.log'      # find all .log files who are contained in a directory under /logs/\n    - '/var/log/agent.log' # tail the specified log file\n   watchMethod: inotify    # specify the file watch method (\"ionotify\" or \"poll\")\n```\n\nSample YAML configuration that specifies a parser:\n\n```yaml\nmonitors:\n - type: telegraf/tail\n   files:\n    - '/logs/**.log'       # find all .log files in /logs\n    - '/logs/*/*.log'      # find all .log files who are contained in a directory under /logs/\n    - '/var/log/agent.log' # tail the specified log file\n   watchMethod: inotify    # specify the file watch method (\"inotify\" or \"poll\")\n   telegrafParser:         # specify a parser\n     dataFormat: \"influx\"  # set the parser's dataFormat\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/telegraf/monitors/tail",
        "fields": [
          {
            "yamlName": "files",
            "doc": "Paths to files to be tailed",
            "default": null,
            "required": true,
            "type": "slice",
            "elementKind": "string"
          },
          {
            "yamlName": "watchMethod",
            "doc": "Method for watching changes to files (\"ionotify\" or \"poll\")",
            "default": "poll",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "pipe",
            "doc": "Indicates if the file is a named pipe",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "fromBeginning",
            "doc": "Whether to start tailing from the beginning of the file",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "telegrafParser",
            "doc": "telegrafParser is a nested object that defines configurations for a Telegraf parser. Please refer to the Telegraf documentation for more information on Telegraf parsers.",
            "default": null,
            "required": false,
            "type": "struct",
            "elementKind": "",
            "elementStruct": {
              "name": "Config",
              "doc": "Config implements Telegraf parsers.Config, but with SignalFx Smart Agent struct tags and a methods for returning a Telegraf parsers.Config struct and a Telegraf parsers.Parser. Please refer to Telegraf's documentation for more information about the different parsers and their specific configurations",
              "package": "internal/monitors/telegraf/common/parser",
              "fields": [
                {
                  "yamlName": "dataFormat",
                  "doc": "dataFormat specifies a data format to parse: `json`, `value`, `influx`, `graphite`, `value`, `nagios`, `collectd`, `dropwizard`, `wavefront`, `grok`, `csv`, or `logfmt`.",
                  "default": "influx",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "defaultTags",
                  "doc": "defaultTags are tags that will be added to all metrics. (`json`, `value`, `graphite`, `collectd`, `dropwizard`, `wavefront`, `grok`, `csv` and `logfmt` only)",
                  "default": null,
                  "required": false,
                  "type": "map",
                  "elementKind": "string"
                },
                {
                  "yamlName": "metricName",
                  "doc": "metricName applies to (`json` and `value`). This will be the name of the measurement.",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dataType",
                  "doc": "dataType specifies the value type to parse the value to: `integer`, `float`, `long`, `string`, or `boolean`. (`value` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONTagKeys",
                  "doc": "A list of tag names to fetch from JSON data. (`json` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "JSONStringFields",
                  "doc": "A list of fields in JSON to extract and use as string fields. (json only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "JSONNameKey",
                  "doc": "A path used to extract the metric name in JSON data.  (`json` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONQuery",
                  "doc": "A gjson path for json parser. (`json` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONTimeKey",
                  "doc": "The name of the timestamp key. (`json` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "JSONTimeFormat",
                  "doc": "Specifies the timestamp format. (`json` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "separator",
                  "doc": "Separator for Graphite data. (`graphite` only).",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "templates",
                  "doc": "A list of templates for Graphite data. (`graphite` only).",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "collectdAuthFile",
                  "doc": "The path to the collectd authentication file (`collectd` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "collectdSecurityLevel",
                  "doc": "Specifies the security level: `none` (default), `sign`, or `encrypt`. (`collectd only`)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "collectdTypesDB",
                  "doc": "A list of paths to collectd TypesDB files. (`collectd` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "collectdSplit",
                  "doc": "Indicates whether to separate or join multivalue metrics. (`collectd` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardMetricRegistryPath",
                  "doc": "An optional gjson path used to locate a metric registry inside of JSON data. The default behavior is to consider the entire JSON document. (`dropwizard` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardTimePath",
                  "doc": "An optional gjson path used to identify the drop wizard metric timestamp. (`dropwizard` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardTimeFormat",
                  "doc": "The format used for parsing the drop wizard metric timestamp. The default format is time.RFC3339. (`dropwizard` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardTagsPath",
                  "doc": "An optional gjson path used to locate drop wizard tags. (`dropwizard` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "dropwizardTagPathsMap",
                  "doc": "A map of gjson tag names and gjson paths used to extract tag values from the JSON document. This is only used if `dropwizardTagsPath` is not specified. (`dropwizard` only)",
                  "default": null,
                  "required": false,
                  "type": "map",
                  "elementKind": "string"
                },
                {
                  "yamlName": "grokPatterns",
                  "doc": "A list of patterns to match. (`grok` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "grokNamedPatterns",
                  "doc": "A list of named grok patterns to match.  (`grok` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "grokCustomPatterns",
                  "doc": "Custom grok patterns. (`grok` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "grokCustomPatternFiles",
                  "doc": "List of paths to custom grok pattern files. (`grok` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "grokTimezone",
                  "doc": "Specifies the timezone.  The default is UTC time.  Other options are `Local` for the local time on the machine, `UTC`, and `Canada/Eastern` (unix style timezones).  (`grok` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVDelimiter",
                  "doc": "The delimiter used between fields in the csv. (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVComment",
                  "doc": "The character used to mark rows as comments. (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVTrimSpace",
                  "doc": "Indicates whether to trim leading white from fields. (`csv` only)",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVColumnNames",
                  "doc": "List of custom column names.  All columns must have names.  Unnamed columns are ignored. This configuration must be set when `CSVHeaderRowCount` is 0. (`csv` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "CSVColumnTypes",
                  "doc": "List of types to assign to columns.  Acceptable values are `int`, `float`, `bool`, or `string` (`csv` only).",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "CSVTagColumns",
                  "doc": "List of columns that should be added as tags.  Unspecified columns will be added as fields. (`csv` only)",
                  "default": null,
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "CSVMeasurementColumn",
                  "doc": "The name of the column to extract the metric name from (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVTimestampColumn",
                  "doc": "The name of the column to extract the metric timestamp from. `CSVTimestampFormat` must be set when using this option.  (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVTimestampFormat",
                  "doc": "The format to use for extracting timestamps. (`csv` only)",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVHeaderRowCount",
                  "doc": "The number of rows that are headers.  By default no rows are treated as headers.  (`csv` only)",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVSkipRows",
                  "doc": "The number of rows to ignore before looking for headers. (`csv` only)",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                },
                {
                  "yamlName": "CSVSkipColumns",
                  "doc": "The number of columns to ignore before parsing data on a given row. (`csv` only)",
                  "default": 0,
                  "required": false,
                  "type": "int",
                  "elementKind": ""
                }
              ]
            }
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/win_perf_counters",
      "sendAll": true,
      "dimensions": null,
      "doc": "This monitor reads Windows performance\ncounters\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/win_perf_counters\n   printValid: true\n   objects:\n    - objectName: \"Processor\"\n      instances:\n       - \"*\"\n      counters:\n       - \"% Idle Time\"\n       - \"% Interrupt Time\"\n       - \"% Privileged Time\"\n       - \"% User Time\"\n       - \"% Processor Time\"\n      includeTotal: true\n      measurement: \"win_cpu\"\n```\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/telegraf/monitors/winperfcounters",
        "fields": [
          {
            "yamlName": "objects",
            "doc": "",
            "default": "",
            "required": false,
            "type": "slice",
            "elementKind": "struct",
            "elementStruct": {
              "name": "PerfCounterObj",
              "doc": "PerfCounterObj represents a windows performance counter object to monitor",
              "package": "internal/monitors/telegraf/monitors/winperfcounters",
              "fields": [
                {
                  "yamlName": "objectName",
                  "doc": "The name of a windows performance counter object",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "counters",
                  "doc": "The name of the counters to collect from the performance counter object",
                  "default": "",
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "instances",
                  "doc": "The windows performance counter instances to fetch for the performance counter object",
                  "default": "",
                  "required": false,
                  "type": "slice",
                  "elementKind": "string"
                },
                {
                  "yamlName": "measurement",
                  "doc": "The name of the telegraf measurement that will be used as a metric name",
                  "default": "",
                  "required": false,
                  "type": "string",
                  "elementKind": ""
                },
                {
                  "yamlName": "warnOnMissing",
                  "doc": "Log a warning if the perf counter object is missing",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "failOnMissing",
                  "doc": "Panic if the performance counter object is missing (this will stop the agent)",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                },
                {
                  "yamlName": "includeTotal",
                  "doc": "Include the total instance when collecting performance counter metrics",
                  "default": false,
                  "required": false,
                  "type": "bool",
                  "elementKind": ""
                }
              ]
            }
          },
          {
            "yamlName": "counterRefreshInterval",
            "doc": "The frequency that counter paths should be expanded and how often to refresh counters from configuration. This is expressed as a duration.",
            "default": "5s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "useWildCardExpansion",
            "doc": "If `true`, instance indexes will be included in instance names, and wildcards will be expanded and localized (if applicable).  If `false`, non partial wildcards will be expanded and instance names will not include instance indexes.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "Print out the configurations that match available performance counters",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "pcrMetricNames",
            "doc": "If `true`, metric names will be emitted in the format emitted by the SignalFx PerfCounterReporter",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "telegraf/win_services",
      "sendAll": true,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics about Windows services.\nThis monitor is based on the Telegraf win_services plugin.  More information about the Telegraf plugin\ncan be found [here](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/win_services).\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: telegraf/win_services  # monitor all services\n```\n\n```yaml\nmonitors:\n - type: telegraf/win_services\n   serviceNames:\n     - exampleService1  # only monitor exampleService1\n```\n",
      "groups": null,
      "metrics": {
        "win_services.startup_mode": {
          "type": "gauge",
          "description": "The configured start up mode of the window windows service.  Possible values are: `0` (Boot Start), `1` (System Start), `2` (Auto Start), `3` (Demand Start), `4` (disabled).",
          "group": null,
          "included": false
        },
        "win_services.state": {
          "type": "gauge",
          "description": "The state of the windows service.  Possible values are: `1` (Stopped), `2` (Start Pending), `3` (Stop Pending), `4` (Running), `5` (Continue Pending), `6` (Pause Pending), and `7` (Paused).",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/telegraf/monitors/winservices",
        "fields": [
          {
            "yamlName": "serviceNames",
            "doc": "Names of services to monitor.  All services will be monitored if none are specified.",
            "default": null,
            "required": false,
            "type": "slice",
            "elementKind": "string"
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": false
    },
    {
      "monitorType": "trace-forwarder",
      "sendAll": false,
      "dimensions": null,
      "doc": "Runs an HTTP server that listens for trace spans\nand forwards them to SignalFx (or the configured ingest host in the `writer`\nsection of the agent config).  This supports the same span formats that our\ningest server supports and at the same path (`/v1/trace`).  By default, the\nserver listens on localhost port 9080 but can be configured to anything.\n",
      "groups": null,
      "metrics": null,
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/traceforwarder",
        "fields": [
          {
            "yamlName": "listenAddress",
            "doc": "The host:port on which to listen for spans.  This server accepts spans in all of the formats that we support on our regular ingest server.  The listening server accepts spans on the same HTTP path that ingest accepts them (e.g. `/v1/trace`).  Requests to other paths will return 404s.",
            "default": "127.0.0.1:9080",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "serverTimeout",
            "doc": "HTTP timeout duration for both read and writes. This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration",
            "default": "5s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "sendInternalMetrics",
            "doc": "Whether to send internal metrics about the HTTP listener",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "traefik",
      "sendAll": false,
      "dimensions": null,
      "doc": "Traefik is an open-source HTTP reverse proxy and load balancer. Traefik exports Prometheus metrics that can be\nscraped by the SignalFx Smart Agent. These metrics can be categorized into Traefik-related, entrypoint-related and\nbackend-related metrics. The Traefik-related metrics are prefixed by `go_` and `process_`. The entrypoint-related\nmetrics are prefixed by `traefik_entrypoint_` and the backend-related metrics prefixed by `traefik_backend_`.\n\nThe Traefik-related metrics are for monitoring Traefik itself. For instance, the `go_memstats_sys_bytes` metric can\nbe used to plot Traefik memory usage. The entrypoint-related and backend-related metrics are the number and duration\nof requests measured at entrypoints and backends. These metrics are used to compute measurements such as the average\nrequest duration.\n\n## Requirements and Dependencies\n\n| Software          | Version        |\n|-------------------|----------------|\n| signalfx-agent    |     4.7.0+     |\n\n## Traefik Configuration\n\nEdit the Traefik configuration file, typically `traefik.toml`, to enable Traefik to expose prometheus metrics at an\nendpoint. The endpoint is on path `/metrics` by default. When running the Traefik binary, the configuration file is\ntypically passed in as a command line argument. For example,\n\n`./traefik -c traefik.toml`\n\nHowever, when running the Traefik Docker image, the configuration file is mounted to volume\n`/etc/traefik/traefik.toml`. For example,\n\n`docker run -d -p 8080:8080 -p 80:80 -v $PWD/traefik.toml:/etc/traefik/traefik.toml`\n\nIf the Traefik configuration file is not available use the sample configuration file\n\u003ca target=\"_blank\" href=\"https://raw.githubusercontent.com/containous/traefik/master/traefik.sample.toml\"\u003ehere\u003c/a\u003e\nto get started.\n\nSee \u003ca target=\"_blank\" href=\"https://docs.traefik.io/\"\u003ehere\u003c/a\u003e for complete Traefik docs.\n\n## Smart Agent Configuration\n\nSignalFx Smart Agent docs can be found \u003ca target=\"_blank\" href=\"https://github.com/signalfx/signalfx-agent\"\u003ehere\u003c/a\u003e.\nChoose deployment specific configuration instruction\n\u003ca target=\"_blank\" href=\"https://github.com/signalfx/signalfx-agent/tree/master/deployments\"\u003ehere\u003c/a\u003e. The\nSignalFx Smart Agent must have network access to Traefik.\n\nBelow is an example configuration that enables the traefik monitor. For the given configuration below, the monitor\nwill scrape Prometheus metrics in the default path `/metrics` on port 8080, add dimension\n`metric_source=traefik` to the metrics and export them to SignalFx.\n\n```\nmonitors:\n- type: traefik\n  discoveryRule: port == 8080\n  extraDimensions:\n    metric_source: traefik\n```\n",
      "groups": null,
      "metrics": {
        "go_gc_duration_seconds": {
          "type": "cumulative",
          "description": "A summary of the GC invocation durations.",
          "group": null,
          "included": false
        },
        "go_gc_duration_seconds_count": {
          "type": "cumulative",
          "description": "A count of the GC invocation durations.",
          "group": null,
          "included": false
        },
        "go_gc_duration_seconds_sum": {
          "type": "cumulative",
          "description": "The sum of the GC invocation durations, in seconds.",
          "group": null,
          "included": false
        },
        "go_goroutines": {
          "type": "cumulative",
          "description": "Number of goroutines that currently exist.",
          "group": null,
          "included": false
        },
        "go_memstats_alloc_bytes": {
          "type": "gauge",
          "description": "Number of bytes allocated and still in use.",
          "group": null,
          "included": false
        },
        "go_memstats_alloc_bytes_total": {
          "type": "cumulative",
          "description": "Total number of bytes allocated, even if freed.",
          "group": null,
          "included": false
        },
        "go_memstats_buck_hash_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used by the profiling bucket hash table.",
          "group": null,
          "included": false
        },
        "go_memstats_frees_total": {
          "type": "cumulative",
          "description": "Total number of frees.",
          "group": null,
          "included": false
        },
        "go_memstats_gc_cpu_fraction": {
          "type": "gauge",
          "description": "The fraction of this program's available CPU time used by the GC since the program started.",
          "group": null,
          "included": false
        },
        "go_memstats_gc_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for garbage collection system metadata.",
          "group": null,
          "included": false
        },
        "go_memstats_heap_alloc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes allocated and still in use.",
          "group": null,
          "included": false
        },
        "go_memstats_heap_idle_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes waiting to be used.",
          "group": null,
          "included": false
        },
        "go_memstats_heap_inuse_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes that are in use.",
          "group": null,
          "included": false
        },
        "go_memstats_heap_objects": {
          "type": "gauge",
          "description": "Number of allocated objects.",
          "group": null,
          "included": false
        },
        "go_memstats_heap_released_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes released to OS.",
          "group": null,
          "included": false
        },
        "go_memstats_heap_sys_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes obtained from system.",
          "group": null,
          "included": false
        },
        "go_memstats_last_gc_time_seconds": {
          "type": "gauge",
          "description": "Length of time since last garbage collection, in seconds since unix epoch.",
          "group": null,
          "included": false
        },
        "go_memstats_lookups_total": {
          "type": "cumulative",
          "description": "Total number of pointer lookups.",
          "group": null,
          "included": false
        },
        "go_memstats_mallocs_total": {
          "type": "cumulative",
          "description": "Total number of mallocs.",
          "group": null,
          "included": false
        },
        "go_memstats_mcache_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mcache structures.",
          "group": null,
          "included": false
        },
        "go_memstats_mcache_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mcache structures obtained from system.",
          "group": null,
          "included": false
        },
        "go_memstats_mspan_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by mspan structures.",
          "group": null,
          "included": false
        },
        "go_memstats_mspan_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for mspan structures obtained from system.",
          "group": null,
          "included": false
        },
        "go_memstats_next_gc_bytes": {
          "type": "gauge",
          "description": "Number of heap bytes when next garbage collection will take place.",
          "group": null,
          "included": false
        },
        "go_memstats_other_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes used for other system allocations.",
          "group": null,
          "included": false
        },
        "go_memstats_stack_inuse_bytes": {
          "type": "gauge",
          "description": "Number of bytes in use by the stack allocator.",
          "group": null,
          "included": false
        },
        "go_memstats_stack_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system for stack allocator.",
          "group": null,
          "included": false
        },
        "go_memstats_sys_bytes": {
          "type": "gauge",
          "description": "Number of bytes obtained from system.",
          "group": null,
          "included": false
        },
        "go_threads": {
          "type": "gauge",
          "description": "Number of OS threads created",
          "group": null,
          "included": false
        },
        "process_cpu_seconds_total": {
          "type": "cumulative",
          "description": "Total user and system CPU time spent, in seconds.",
          "group": null,
          "included": false
        },
        "process_max_fds": {
          "type": "gauge",
          "description": "Maximum number of open file descriptors.",
          "group": null,
          "included": false
        },
        "process_open_fds": {
          "type": "gauge",
          "description": "Number of open file descriptors.",
          "group": null,
          "included": false
        },
        "process_resident_memory_bytes": {
          "type": "gauge",
          "description": "Resident memory size in bytes.",
          "group": null,
          "included": false
        },
        "process_start_time_seconds": {
          "type": "gauge",
          "description": "Start time of the process since unix epoch in seconds.",
          "group": null,
          "included": true
        },
        "process_virtual_memory_bytes": {
          "type": "gauge",
          "description": "Virtual memory size in bytes.",
          "group": null,
          "included": false
        },
        "traefik_backend_open_connections": {
          "type": "gauge",
          "description": "How many open connections exist on a backend, partitioned by method and protocol.",
          "group": null,
          "included": true
        },
        "traefik_backend_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The sum of request durations that are within a configured time interval. The request durations are measured at a backend in seconds. This value is partitioned by status code, protocol, and method.",
          "group": null,
          "included": false
        },
        "traefik_backend_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "The number of request durations that were measured on a backend. The values are partitioned by status code, protocol, and method.",
          "group": null,
          "included": false
        },
        "traefik_backend_request_duration_seconds_sum": {
          "type": "cumulative",
          "description": "The sum of the request durations in seconds, measured on a backend, partitioned by status code, protocol, and method.",
          "group": null,
          "included": true
        },
        "traefik_backend_requests_total": {
          "type": "cumulative",
          "description": "How many HTTP requests were processed on a backend, partitioned by status code, protocol, and method.",
          "group": null,
          "included": true
        },
        "traefik_backend_server_up": {
          "type": "gauge",
          "description": "Backend server is up, described by gauge value of 0 (down) or 1 (up).",
          "group": null,
          "included": true
        },
        "traefik_config_last_reload_failure": {
          "type": "gauge",
          "description": "Last config reload failure",
          "group": null,
          "included": false
        },
        "traefik_config_last_reload_success": {
          "type": "gauge",
          "description": "Last config reload success",
          "group": null,
          "included": false
        },
        "traefik_config_reloads_failure_total": {
          "type": "cumulative",
          "description": "Total number of config reloads that failed",
          "group": null,
          "included": false
        },
        "traefik_config_reloads_total": {
          "type": "cumulative",
          "description": "Config reloads",
          "group": null,
          "included": false
        },
        "traefik_entrypoint_open_connections": {
          "type": "gauge",
          "description": "How many open connections exist on an entrypoint, partitioned by method and protocol.",
          "group": null,
          "included": true
        },
        "traefik_entrypoint_request_duration_seconds_bucket": {
          "type": "cumulative",
          "description": "The sum of request durations that are within a configured time interval. The request durations are measured at an entrypoint in seconds. This value is partitioned by status code, protocol, and method.",
          "group": null,
          "included": false
        },
        "traefik_entrypoint_request_duration_seconds_count": {
          "type": "cumulative",
          "description": "The number of request durations that were measured on an entrypoint. The values are partitioned by status code, protocol, and method.",
          "group": null,
          "included": true
        },
        "traefik_entrypoint_request_duration_seconds_sum": {
          "type": "cumulative",
          "description": "The sum of the request durations in seconds measured on an entrypoint, partitioned by status code, protocol, and method.",
          "group": null,
          "included": true
        },
        "traefik_entrypoint_requests_total": {
          "type": "cumulative",
          "description": "How many HTTP requests processed on an entrypoint, partitioned by status code, protocol, and method.",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/traefik",
        "fields": [
          {
            "yamlName": "host",
            "doc": "Host of the exporter",
            "default": null,
            "required": true,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "port",
            "doc": "Port of the exporter",
            "default": null,
            "required": true,
            "type": "uint16",
            "elementKind": ""
          },
          {
            "yamlName": "username",
            "doc": "Basic Auth username to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "password",
            "doc": "Basic Auth password to use on each request, if any.",
            "default": "",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "useHTTPS",
            "doc": "If true, the agent will connect to the exporter using HTTPS instead of plain HTTP.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "skipVerify",
            "doc": "If useHTTPS is true and this option is also true, the exporter's TLS cert will not be verified.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          },
          {
            "yamlName": "metricPath",
            "doc": "Path to the metrics endpoint on the exporter server, usually `/metrics` (the default).",
            "default": "/metrics",
            "required": false,
            "type": "string",
            "elementKind": ""
          },
          {
            "yamlName": "sendAllMetrics",
            "doc": "Send all the metrics that come out of the Prometheus exporter without any filtering.  This option has no effect when using the prometheus exporter monitor directly since there is no built-in filtering, only when embedding it in other monitors.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": true,
      "singleInstance": false
    },
    {
      "monitorType": "vmem",
      "sendAll": false,
      "dimensions": null,
      "doc": "Collects information about the virtual memory\nsubsystem of the kernel.\n\nOn Linux hosts, this monitor relies on the `/proc` filesystem.\nIf the underlying host's `/proc` file system is mounted somewhere other than\n/proc please specify the path using the top level configuration `procPath`.\n\n```yaml\nprocPath: /proc\nmonitors:\n - type: vmem\n```\n",
      "groups": null,
      "metrics": {
        "vmpage.swap.in_per_second": {
          "type": "gauge",
          "description": "(Windows Only)",
          "group": null,
          "included": false
        },
        "vmpage.swap.out_per_second": {
          "type": "gauge",
          "description": "(Windows Only)",
          "group": null,
          "included": false
        },
        "vmpage.swap.total.per_second": {
          "type": "gauge",
          "description": "(Windows Only)",
          "group": null,
          "included": false
        },
        "vmpage_faults.majflt": {
          "type": "cumulative",
          "description": "(Linux Only) Number of major page faults on the system",
          "group": null,
          "included": false
        },
        "vmpage_faults.minflt": {
          "type": "cumulative",
          "description": "(Linux Only) Number of minor page faults on the system",
          "group": null,
          "included": false
        },
        "vmpage_io.memory.in": {
          "type": "cumulative",
          "description": "(Linux Only) Page Ins for Memory",
          "group": null,
          "included": false
        },
        "vmpage_io.memory.out": {
          "type": "cumulative",
          "description": "(Linux Only) Page Outs for Memory",
          "group": null,
          "included": false
        },
        "vmpage_io.swap.in": {
          "type": "cumulative",
          "description": "(Linux Only) Page Ins for Swap",
          "group": null,
          "included": true
        },
        "vmpage_io.swap.out": {
          "type": "cumulative",
          "description": "(Linux Only) Page Outs for Swap",
          "group": null,
          "included": true
        },
        "vmpage_number.free_pages": {
          "type": "gauge",
          "description": "(Linux Only) Number of free memory pages",
          "group": null,
          "included": false
        },
        "vmpage_number.mapped": {
          "type": "gauge",
          "description": "(Linux Only) Number of mapped pages",
          "group": null,
          "included": false
        },
        "vmpage_number.shmem_pmdmapped": {
          "type": "gauge",
          "description": "(Linux Only) The amount of shared (shmem/tmpfs) memory backed by huge pages",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/vmem",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) The frequency that wildcards in counter paths should be expanded and how often to refresh counters from configuration. This is expressed as a duration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "windows-iis",
      "sendAll": false,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics for Windows Internet Information Services.\nIt is used to drive the Windows IIS dashboard content.\n\n## Windows Performance Counters\nThe underlying source for these metrics are Windows Performance Counters.\nMost of the performance counters that we query in this monitor are actually Gauges\nthat represent rates per second and percentages.\n\nThis monitor reports the instantaneous values for these Windows Performance Counters.\nThis means that in between a collection interval, spikes could occur on the\nPerformance Counters.  The best way to mitigate this limitation is to increase\nthe reporting interval on this monitor to collect more frequently.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: windows-iis\n```\n",
      "groups": null,
      "metrics": {
        "process.handle_count": {
          "type": "gauge",
          "description": "The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.",
          "group": null,
          "included": false
        },
        "process.id_process": {
          "type": "gauge",
          "description": "The unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.",
          "group": null,
          "included": false
        },
        "process.pct_processor_time": {
          "type": "gauge",
          "description": "The percentage of elapsed time that all process threads used the processor to execution instructions. Code executed to handle some hardware interrupts and trap conditions are included in this count.",
          "group": null,
          "included": false
        },
        "process.private_bytes": {
          "type": "gauge",
          "description": "The current size, in bytes, of memory that this process has allocated that cannot be shared with other processes.",
          "group": null,
          "included": false
        },
        "process.thread_count": {
          "type": "gauge",
          "description": "The number of threads currently active in this process. Every running process has at least one thread.",
          "group": null,
          "included": false
        },
        "process.virtual_bytes": {
          "type": "gauge",
          "description": "The current size, in bytes, of the virtual address space the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries.",
          "group": null,
          "included": false
        },
        "process.working_set": {
          "type": "gauge",
          "description": "The current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed, they will then be soft-faulted back into the Working Set before leaving main memory.",
          "group": null,
          "included": false
        },
        "web_service.anonymous_users_sec": {
          "type": "gauge",
          "description": "Rate at which users are making anonymous requests to the web service",
          "group": null,
          "included": true
        },
        "web_service.bytes_received_sec": {
          "type": "gauge",
          "description": "Rate that data is received by web service",
          "group": null,
          "included": true
        },
        "web_service.bytes_sent_sec": {
          "type": "gauge",
          "description": "Rate that data is sent by web service",
          "group": null,
          "included": true
        },
        "web_service.connection_attempts_sec": {
          "type": "gauge",
          "description": "Rate that connections to web service are attempted Requests",
          "group": null,
          "included": true
        },
        "web_service.current_connections": {
          "type": "gauge",
          "description": "Number of current connections to the web service",
          "group": null,
          "included": true
        },
        "web_service.files_received_sec": {
          "type": "gauge",
          "description": "Rate at which files are received by web service",
          "group": null,
          "included": true
        },
        "web_service.files_sent_sec": {
          "type": "gauge",
          "description": "Rate at which files are sent by web service",
          "group": null,
          "included": true
        },
        "web_service.get_requests_sec": {
          "type": "gauge",
          "description": "Rate of HTTP GET requests",
          "group": null,
          "included": true
        },
        "web_service.isapi_extension_requests_sec": {
          "type": "gauge",
          "description": "Rate of ISAPI extension request processed simultaneously by the web service",
          "group": null,
          "included": false
        },
        "web_service.nonanonymous_users_sec": {
          "type": "gauge",
          "description": "Rate at which users are making nonanonymous requests to the web service",
          "group": null,
          "included": true
        },
        "web_service.not_found_errors_sec": {
          "type": "gauge",
          "description": "Rate of 'Not Found' Errors",
          "group": null,
          "included": true
        },
        "web_service.post_requests_sec": {
          "type": "gauge",
          "description": "Rate of HTTP POST requests",
          "group": null,
          "included": true
        },
        "web_service.service_uptime": {
          "type": "gauge",
          "description": "Service uptime",
          "group": null,
          "included": false
        },
        "web_service.total_method_requests_sec": {
          "type": "gauge",
          "description": "Rate at which all HTTP requests are received",
          "group": null,
          "included": true
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/windowsiis",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) Number of seconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    },
    {
      "monitorType": "windows-legacy",
      "sendAll": false,
      "dimensions": null,
      "doc": "(Windows Only) This monitor reports metrics for Windows system Performance Counters.\nThe metric names are intended to match what was originally reported by\nthe SignalFx [PerfCounterReporter](https://github.com/signalfx/PerfCounterReporter)\nThe metric types are all gauges as originally reported by the PerfCounterReporter.\n\n## Windows Performance Counters\nThe underlying source for these metrics are Windows Performance Counters.\nMost of the performance counters that we query in this monitor are actually\nrates per second and percentages that we report as instantaneous Gauge values\neach collection interval.\n\nSample YAML configuration:\n\n```yaml\nmonitors:\n - type: windows-legacy\n```\n",
      "groups": null,
      "metrics": {
        "logicaldisk.disk_read_bytes_sec": {
          "type": "gauge",
          "description": "The number of bytes read from disk per second.",
          "group": null,
          "included": false
        },
        "logicaldisk.disk_reads_sec": {
          "type": "gauge",
          "description": "The number of read operations per second.",
          "group": null,
          "included": true
        },
        "logicaldisk.disk_transfers_sec": {
          "type": "gauge",
          "description": "The number of transfers per second.",
          "group": null,
          "included": false
        },
        "logicaldisk.disk_write_bytes_sec": {
          "type": "gauge",
          "description": "The number of bytes written to disk per second.",
          "group": null,
          "included": false
        },
        "logicaldisk.disk_writes_sec": {
          "type": "gauge",
          "description": "The number of write operations per second.",
          "group": null,
          "included": true
        },
        "logicaldisk.free_megabytes": {
          "type": "gauge",
          "description": "The number of available megabytes.",
          "group": null,
          "included": true
        },
        "logicaldisk.pct_free_space": {
          "type": "gauge",
          "description": "The percentage of free disk space available.",
          "group": null,
          "included": true
        },
        "memory.available_mbytes": {
          "type": "gauge",
          "description": "Unused physical memory (not page file).",
          "group": null,
          "included": true
        },
        "memory.pages_input_sec": {
          "type": "gauge",
          "description": "Reads from hard disk per second to resolve hard pages.",
          "group": null,
          "included": true
        },
        "network_interface.bytes_received_sec": {
          "type": "gauge",
          "description": "Bytes Received/sec is the rate at which bytes are received over each network adapter, including framing characters.",
          "group": null,
          "included": true
        },
        "network_interface.bytes_sent_sec": {
          "type": "gauge",
          "description": "Bytes Sent/sec is the rate at which bytes are sent over each network adapter, including framing characters.",
          "group": null,
          "included": true
        },
        "network_interface.bytes_total_sec": {
          "type": "gauge",
          "description": "The number of bytes sent and received over a specific network adapter, including framing characters.",
          "group": null,
          "included": true
        },
        "network_interface.current_bandwidth": {
          "type": "gauge",
          "description": "Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).",
          "group": null,
          "included": false
        },
        "network_interface.packets_outbound_discarded": {
          "type": "gauge",
          "description": "The number of outbound packets discarded",
          "group": null,
          "included": false
        },
        "network_interface.packets_outbound_errors": {
          "type": "gauge",
          "description": "The number of packets sent that encountered an error.",
          "group": null,
          "included": true
        },
        "network_interface.packets_received_discarded": {
          "type": "gauge",
          "description": "The number of received packets discarded.",
          "group": null,
          "included": false
        },
        "network_interface.packets_received_errors": {
          "type": "gauge",
          "description": "The number of packets received that encountered an error.",
          "group": null,
          "included": true
        },
        "network_interface.packets_received_sec": {
          "type": "gauge",
          "description": "Tracking the packets received over time can give you a good indication of the typical use of the system's network.",
          "group": null,
          "included": false
        },
        "network_interface.packets_sent_sec": {
          "type": "gauge",
          "description": "The number of packets sent per second.",
          "group": null,
          "included": false
        },
        "paging_file.pct_usage": {
          "type": "gauge",
          "description": "Amount of Page File in use, which indicates the server is substituting disk space for memory.",
          "group": null,
          "included": true
        },
        "paging_file.pct_usage_peak": {
          "type": "gauge",
          "description": "Highest %Usage metric since the last time the server was restarted.",
          "group": null,
          "included": false
        },
        "physicaldisk.avg_disk_sec_read": {
          "type": "gauge",
          "description": "The average time, in milliseconds, of each read from disk.",
          "group": null,
          "included": false
        },
        "physicaldisk.avg_disk_sec_transfer": {
          "type": "gauge",
          "description": "The average time in milliseconds spent transfering data on disk.",
          "group": null,
          "included": false
        },
        "physicaldisk.avg_disk_sec_write": {
          "type": "gauge",
          "description": "The average time, in milliseconds, of each write to disk.",
          "group": null,
          "included": false
        },
        "processor.interrupts_sec": {
          "type": "gauge",
          "description": "Rate of processor interrupts per second.",
          "group": null,
          "included": false
        },
        "processor.pct_privileged_time": {
          "type": "gauge",
          "description": "Percentage of elapsed time the processor spends on privileged tasks.",
          "group": null,
          "included": false
        },
        "processor.pct_processor_time": {
          "type": "gauge",
          "description": "Percentage of elapsed time the processor spends executing non-idle threads.",
          "group": null,
          "included": true
        },
        "processor.pct_user_time": {
          "type": "gauge",
          "description": "Percentage of elapsed time the processor spends executing user threads.",
          "group": null,
          "included": false
        },
        "system.context_switches_sec": {
          "type": "gauge",
          "description": "Number of execution contexts switched in the last second, where \u003e6000 is poor, \u003c3000 is good, and \u003c1500 is excellent.",
          "group": null,
          "included": false
        },
        "system.processor_queue_length": {
          "type": "gauge",
          "description": "Number of threads waiting for CPU cycles, where \u003c 12 per CPU is good/fair, \u003c 8 is better, \u003c 4 is best",
          "group": null,
          "included": false
        },
        "system.system_calls_sec": {
          "type": "gauge",
          "description": "The number of system calls being serviced by the CPU per second.",
          "group": null,
          "included": false
        }
      },
      "properties": null,
      "metricsExhaustive": false,
      "config": {
        "name": "Config",
        "doc": "Config for this monitor",
        "package": "internal/monitors/windowslegacy",
        "fields": [
          {
            "yamlName": "counterRefreshInterval",
            "doc": "(Windows Only) Number of seconds that wildcards in counter paths should be expanded and how often to refresh counters from configuration.",
            "default": "60s",
            "required": false,
            "type": "int64",
            "elementKind": ""
          },
          {
            "yamlName": "printValid",
            "doc": "(Windows Only) Print out the configurations that match available performance counters.  This used for debugging.",
            "default": false,
            "required": false,
            "type": "bool",
            "elementKind": ""
          }
        ]
      },
      "acceptsEndpoints": false,
      "singleInstance": true
    }
  ],
  "Observers": [
    {
      "name": "Config",
      "doc": " Queries the Docker Engine API for running containers.  If\nyou are using Kubernetes, you should use the [k8s-api\nobserver](./k8s-api.md) instead of this.\n\nRequires Docker API version 1.22+.\n\nNote that you will need permissions to access the Docker engine API.  For a\nDocker domain socket URL, this means that the agent needs to have read\npermissions on the socket.  We don't currently support authentication for\nHTTP URLs.\n\n## Configuration from Labels\nYou can configure monitors by putting special labels on your Docker\ncontainers.  You can either specify all of the configuration in container\nlabels, or you can use the more traditional agent configuration with\ndiscovery rules and specify configuration overrides with labels.\n\nThe config labels are of the form `agent.signalfx.com.config.\u003cport\nnumber\u003e.\u003cconfig_key\u003e: \u003cconfig value\u003e`.  The `\u003cconfig value\u003e` must be a\nstring in a container label, but it will be deserialized as a YAML value to\nthe most appropriate type when consumed by the agent.  For example, if you\nhave a Redis container and want to monitor it at a higher frequency than\nother Redis containers, you could have an agent config that looks like the\nfollowing:\n\n```\nobservers:\n - type: docker\nmonitors:\n - type: collectd/redis\n   discoveryRule: container_image =~ \"redis\" \u0026\u0026 port == 6379\n   auth: mypassword\n   intervalSeconds: 10\n```\n\nAnd then launch the Redis container with the label:\n\n`agent.signalfx.com.config.6379.intervalSeconds`: `1`\n\nThis would cause the config value for `intervalSeconds` to be overwritten to\nthe more frequent 1 second interval.\n\nYou can also specify the monitor configuration entirely with Docker labels\nand completely omit monitor config from the agent config.  With the agent\nconfig:\n\n```\nobservers:\n - type: docker\n```\n\nYou can then launch a Redis container with the following labels:\n\n - `agent.signalfx.com.monitorType.6379`: `collectd/redis`\n - `agent.signalfx.com.config.6379.auth`: `mypassword`\n\nWhich would configure a Redis monitor with the given authentication\nconfiguration.  No Redis configuration is required in the agent config file.\n\nThe distinction is that the `monitorType` label was added to the Docker\ncontainer.  If a `monitorType` label is present, **no discovery rules will\nbe considered for this endpoint**, and thus, no agent configuration can be\nused anyway.\n\n### Multiple Monitors per Port\nIf you want to configure multiple monitors per port, you can specify the\nport name in the form `\u003cport number\u003e-\u003cport name\u003e` instead of just the port\nnumber.  For example, if you had two different Prometheus exporters running\non the same port, but on different paths in a given container, you could\nprovide labels like the following:\n\n```\n - `agent.signalfx.com.monitorType.8080-app`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.monitorType.8080-goruntime`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n```\n\nThe name that is given to the port will populate the `name` field of the\ndiscovered endpoint and can be used in discovery rules as such.  For\nexample, with the following agent config:\n\n```\nobservers:\n - type: docker\nmonitors:\n - type: prometheus-exporter\n   discoveryRule: name == \"app\" \u0026\u0026 port == 8080\n   intervalSeconds: 1\n```\n\nAnd given docker labels as follows (remember that discovery rules are\nirrelevant to endpoints that specify `monitorType` labels):\n\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n\nWould result in the `app` endpoint getting an interval of 1 second and the\n`goruntime` endpoint getting the default interval of the agent.\n",
      "package": "internal/observers/docker",
      "fields": [
        {
          "yamlName": "dockerURL",
          "doc": "",
          "default": "unix:///var/run/docker.sock",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "labelsToDimensions",
          "doc": "A mapping of container label names to dimension names that will get applied to the metrics of all discovered services. The corresponding label values will become the dimension values for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        },
        {
          "yamlName": "useHostnameIfPresent",
          "doc": "If true, the \"Config.Hostname\" field (if present) of the docker container will be used as the discovered host that is used to configure monitors.  If false or if no hostname is configured, the field `NetworkSettings.IPAddress` is used instead.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "useHostBindings",
          "doc": "If true, the observer will configure monitors for matching container endpoints using the host bound ip and port.  This is useful if containers exist that are not accessible to an instance of the agent running outside of the docker network stack.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        },
        {
          "yamlName": "ignoreNonHostBindings",
          "doc": "If true, the observer will ignore discovered container endpoints that are not bound to host ports.  This is useful if containers exist that are not accessible to an instance of the agent running outside of the docker network stack.",
          "default": false,
          "required": false,
          "type": "bool",
          "elementKind": ""
        }
      ],
      "observerType": "docker",
      "dimensions": {
        "container_image": {
          "description": "The image name (including tags) of the running container"
        },
        "container_name": {
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        }
      },
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Queries the [ECS Task Metadata Endpoint version 2](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v2.html) for running containers.\n\nThe Smart Agent needs to run in the same task with the containers to be\nmonitored to get access to the data through ECS task metadata endpoint.\n\n## Configuration from Labels\nYou must put at least one special label to identify an exposed port on your Docker\ncontainers in the ECS task definition since ECS metadata does not contain any port\ninformation. You can either specify all of the configuration in container labels,\nor you can use the more traditional agent configuration with discovery rules and\nspecify configuration overrides with labels.\n\nThe config labels are of the form `agent.signalfx.com.config.\u003cport\nnumber\u003e.\u003cconfig_key\u003e: \u003cconfig value\u003e`.  The `\u003cconfig value\u003e` must be a\nstring in a container label, but it will be deserialized as a YAML value to\nthe most appropriate type when consumed by the agent.  For example, if you\nhave a Redis container and want to monitor it at a higher frequency than\nother Redis containers, you could have an agent config that looks like the\nfollowing:\n\n```\nobservers:\n - type: ecs\nmonitors:\n - type: collectd/redis\n   discoveryRule: container_image =~ \"redis\" \u0026\u0026 port == 6379\n   auth: mypassword\n   intervalSeconds: 10\n```\n\nAnd then launch the Redis container with the label:\n\n`agent.signalfx.com.config.6379.intervalSeconds`: `1`\n\nThis would cause the config value for `intervalSeconds` to be overwritten to\nthe more frequent 1 second interval.\n\nYou can also specify the monitor configuration entirely with Docker labels\nand completely omit monitor config from the agent config.  With the agent\nconfig:\n\n```\nobservers:\n - type: ecs\n```\n\nYou can then launch a Redis container with the following labels:\n\n - `agent.signalfx.com.monitorType.6379`: `collectd/redis`\n - `agent.signalfx.com.config.6379.auth`: `mypassword`\n\nWhich would configure a Redis monitor with the given authentication\nconfiguration.  No Redis configuration is required in the agent config file.\n\nThe distinction is that the `monitorType` label was added to the Docker\ncontainer.  If a `monitorType` label is present, **no discovery rules will\nbe considered for this endpoint**, and thus, no agent configuration can be\nused anyway.\n\n### Multiple Monitors per Port\nIf you want to configure multiple monitors per port, you can specify the\nport name in the form `\u003cport number\u003e-\u003cport name\u003e` instead of just the port\nnumber.  For example, if you had two different Prometheus exporters running\non the same port, but on different paths in a given container, you could\nprovide labels like the following:\n\n```\n - `agent.signalfx.com.monitorType.8080-app`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.monitorType.8080-goruntime`: `prometheus-exporter`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n```\n\nThe name that is given to the port will populate the `name` field of the\ndiscovered endpoint and can be used in discovery rules as such.  For\nexample, with the following agent config:\n\n```\nobservers:\n - type: ecs\nmonitors:\n - type: prometheus-exporter\n   discoveryRule: name == \"app\" \u0026\u0026 port == 8080\n   intervalSeconds: 1\n```\n\nAnd given docker labels as follows (remember that discovery rules are\nirrelevant to endpoints that specify `monitorType` labels):\n\n - `agent.signalfx.com.config.8080-app.metricPath`: `/appMetrics`\n - `agent.signalfx.com.config.8080-goruntime.metricPath`: `/goMetrics`\n\nWould result in the `app` endpoint getting an interval of 1 second and the\n`goruntime` endpoint getting the default interval of the agent.\n",
      "package": "internal/observers/ecs",
      "fields": [
        {
          "yamlName": "metadataEndpoint",
          "doc": "The URL of the ECS task metadata. Default is http://169.254.170.2/v2/metadata, which is hardcoded by AWS for version 2.",
          "default": "http://169.254.170.2/v2/metadata",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "labelsToDimensions",
          "doc": "A mapping of container label names to dimension names that will get applied to the metrics of all discovered services. The corresponding label values will become the dimension values for the mapped name.  E.g. `io.kubernetes.container.name: container_spec_name` would result in a dimension called `container_spec_name` that has the value of the `io.kubernetes.container.name` container label.",
          "default": null,
          "required": false,
          "type": "map",
          "elementKind": "string"
        }
      ],
      "observerType": "ecs",
      "dimensions": {
        "container_image": {
          "description": "The image name (including tags) of the running container"
        },
        "container_name": {
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        }
      },
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Looks at the current host for listening network endpoints.\nIt uses the `/proc` filesystem and requires the `SYS_PTRACE` and\n`DAC_READ_SEARCH` capabilities so that it can determine what processes own\nthe listening sockets.\n\nIt will look for all listening sockets on TCP and UDP over IPv4 and IPv6.\n",
      "package": "internal/observers/host",
      "fields": [
        {
          "yamlName": "pollIntervalSeconds",
          "doc": "",
          "default": 10,
          "required": false,
          "type": "int",
          "elementKind": ""
        }
      ],
      "observerType": "host",
      "dimensions": {
        "pid": {
          "description": "The PID of the process that owns the listening endpoint"
        }
      },
      "endpointVariables": [
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Discovers services running in a Kubernetes cluster by\nquerying the Kubernetes API server.  This observer is designed to only\ndiscover pod endpoints exposed on the same node that the agent is running,\nso that the monitoring of services does not generate cross-node traffic.  To\nknow which node the agent is running on, you should set an environment\nvariable called `MY_NODE_NAME` using the downward API `spec.nodeName` value\nin the pod spec.  Our provided K8s DaemonSet resource does this already and\nprovides an example.\n\nNote that this observer discovers exposed ports on pod containers, not K8s\nEndpoint resources, so don't let the terminology of agent \"endpoints\"\nconfuse you.\n",
      "package": "internal/observers/kubernetes",
      "fields": [
        {
          "yamlName": "namespace",
          "doc": "If specified, only pods within the given namespace on the same node as the agent will be discovered. If blank, all pods on the same node as the agent will be discovered.",
          "default": "",
          "required": false,
          "type": "string",
          "elementKind": ""
        },
        {
          "yamlName": "kubernetesAPI",
          "doc": "Configuration for the K8s API client",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains options relevant to connecting to the K8s API",
            "package": "internal/core/common/kubernetes",
            "fields": [
              {
                "yamlName": "authType",
                "doc": "How to authenticate to the K8s API server.  This can be one of `none` (for no auth), `tls` (to use manually specified TLS client certs, not recommended), `serviceAccount` (to use the standard service account token provided to the agent pod), or `kubeConfig` to use credentials from `~/.kube/config`.",
                "default": "serviceAccount",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verifying the TLS cert from the API server.  Almost never needed.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "The path to the TLS client cert on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "The path to the TLS client key on the pod's filesystem, if using `tls` auth.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to a CA certificate to use when verifying the API server's TLS cert.  Generally this is provided by K8s alongside the service account token, which will be picked up automatically, so this should rarely be necessary to specify.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "observerType": "k8s-api",
      "dimensions": {
        "container_image": {
          "description": "The image name (including tags) of the running container"
        },
        "container_name": {
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        },
        "container_spec_name": {
          "description": "The short name of the container in the pod spec, **NOT** the running container's name in the Docker engine"
        },
        "kubernetes_namespace": {
          "description": "The namespace that the discovered service endpoint is running in."
        },
        "kubernetes_pod_name": {
          "description": "The name of the running pod that is exposing the discovered endpoint"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that is exposing the discovered endpoint"
        }
      },
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    },
    {
      "name": "Config",
      "doc": " Discovers service endpoints running on the same node\nas the agent by querying the local kubelet instance.  It is generally\nrecommended to use the [k8s-api](./k8s-api.md) observer because\nauthentication to the local kubelet can be more difficult to setup, and also\nthe kubelet API is technically not documented for public consumption, so\nthis observer may break more easily in future K8s versions.\n",
      "package": "internal/observers/kubelet",
      "fields": [
        {
          "yamlName": "pollIntervalSeconds",
          "doc": "How often to poll the Kubelet instance for pod information",
          "default": 10,
          "required": false,
          "type": "int",
          "elementKind": ""
        },
        {
          "yamlName": "kubeletAPI",
          "doc": "Config for the Kubelet HTTP client",
          "default": "",
          "required": false,
          "type": "struct",
          "elementKind": "",
          "elementStruct": {
            "name": "APIConfig",
            "doc": "APIConfig contains config specific to the KubeletAPI",
            "package": "internal/core/common/kubelet",
            "fields": [
              {
                "yamlName": "url",
                "doc": "URL of the Kubelet instance.  This will default to `https://\u003ccurrent node hostname\u003e:10250` if not provided.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "authType",
                "doc": "Can be `none` for no auth, `tls` for TLS client cert auth, or `serviceAccount` to use the pod's default service account token to authenticate.",
                "default": "none",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "skipVerify",
                "doc": "Whether to skip verification of the Kubelet's TLS cert",
                "default": true,
                "required": false,
                "type": "bool",
                "elementKind": ""
              },
              {
                "yamlName": "caCertPath",
                "doc": "Path to the CA cert that has signed the Kubelet's TLS cert, unnecessary if `skipVerify` is set to false.",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientCertPath",
                "doc": "Path to the client TLS cert to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "clientKeyPath",
                "doc": "Path to the client TLS key to use if `authType` is set to `tls`",
                "default": "",
                "required": false,
                "type": "string",
                "elementKind": ""
              },
              {
                "yamlName": "logResponses",
                "doc": "Whether to log the raw cadvisor response at the debug level for debugging purposes.",
                "default": false,
                "required": false,
                "type": "bool",
                "elementKind": ""
              }
            ]
          }
        }
      ],
      "observerType": "k8s-kubelet",
      "dimensions": {
        "container_image": {
          "description": "The image name (including tags) of the running container"
        },
        "container_name": {
          "description": "The primary name of the running container -- Docker containers can have multiple names but this will be the first name, if any."
        },
        "container_spec_name": {
          "description": "The short name of the container in the pod spec, **NOT** the running container's name in the Docker engine"
        },
        "kubernetes_namespace": {
          "description": "The namespace that the discovered service endpoint is running in."
        },
        "kubernetes_pod_name": {
          "description": "The name of the running pod that is exposing the discovered endpoint"
        },
        "kubernetes_pod_uid": {
          "description": "The UID of the pod that is exposing the discovered endpoint"
        }
      },
      "endpointVariables": [
        {
          "name": "container_name",
          "type": "string",
          "elementKind": "",
          "description": "The first and primary name of the container as it is known to the container runtime (e.g. Docker)."
        },
        {
          "name": "ip_address",
          "type": "string",
          "elementKind": "",
          "description": "The IP address of the endpoint if the `host` is in the from of an IPv4 address"
        },
        {
          "name": "network_port",
          "type": "string",
          "elementKind": "",
          "description": "An alias for `port`"
        },
        {
          "name": "private_port",
          "type": "string",
          "elementKind": "",
          "description": "The port that the service endpoint runs on inside the container"
        },
        {
          "name": "public_port",
          "type": "string",
          "elementKind": "",
          "description": "The port exposed outside the container"
        },
        {
          "name": "alternate_port",
          "type": "uint16",
          "elementKind": "",
          "description": "Used for services that are accessed through some kind of NAT redirection as Docker does.  This could be either the public port or the private one."
        },
        {
          "name": "container_command",
          "type": "string",
          "elementKind": "",
          "description": "The command used when running the container exposing the endpoint"
        },
        {
          "name": "container_id",
          "type": "string",
          "elementKind": "",
          "description": "The ID of the container exposing the endpoint"
        },
        {
          "name": "container_image",
          "type": "string",
          "elementKind": "",
          "description": "The image name of the container exposing the endpoint"
        },
        {
          "name": "container_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map that contains container label key/value pairs. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "container_names",
          "type": "slice",
          "elementKind": "string",
          "description": "A list of container names of the container exposing the endpoint"
        },
        {
          "name": "container_state",
          "type": "string",
          "elementKind": "",
          "description": "The container state, will usually be \"running\" since otherwise the container wouldn't have a port exposed to be discovered."
        },
        {
          "name": "discovered_by",
          "type": "string",
          "elementKind": "",
          "description": "The observer that discovered this endpoint"
        },
        {
          "name": "host",
          "type": "string",
          "elementKind": "",
          "description": "The hostname/IP address of the endpoint"
        },
        {
          "name": "id",
          "type": "string",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "name",
          "type": "string",
          "elementKind": "",
          "description": "A observer assigned name of the endpoint"
        },
        {
          "name": "orchestrator",
          "type": "int",
          "elementKind": "",
          "description": ""
        },
        {
          "name": "port",
          "type": "uint16",
          "elementKind": "",
          "description": "The TCP/UDP port number of the endpoint"
        },
        {
          "name": "port_labels",
          "type": "map",
          "elementKind": "string",
          "description": "A map of labels on the container port. You can use the `Contains` and `Get` helper functions in discovery rules to make use of this. See [Endpoint Discovery](../auto-discovery.md#additional-functions)."
        },
        {
          "name": "port_type",
          "type": "string",
          "elementKind": "",
          "description": "TCP or UDP"
        }
      ]
    }
  ],
  "SourceConfig": {
    "name": "SourceConfig",
    "doc": "SourceConfig represents configuration for various config sources that we support.",
    "package": "internal/core/config/sources",
    "fields": [
      {
        "yamlName": "watch",
        "doc": "Whether to watch config sources for changes.  If this is `true` and any of the config changes (either the main agent.yaml, or remote config values), the agent will dynamically reconfigure itself with minimal disruption.  This is generally better than restarting the agent on config changes since that can result in larger gaps in metric data.  The main disadvantage of watching is slightly greater network and compute resource usage. This option is not itself watched for changes. If you change the value of this option, you must restart the agent.",
        "default": true,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "file",
        "doc": "Configuration for other file sources",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for the file-based config source",
          "package": "internal/core/config/sources/file",
          "fields": [
            {
              "yamlName": "pollRateSeconds",
              "doc": "How often to poll files (in seconds) to test for changes.  There are so many edge cases that break inotify that it is more robust to simply poll files than rely on that. This option is not subject to watching and changes to it will require an agent restart.",
              "default": 5,
              "required": false,
              "type": "int",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "zookeeper",
        "doc": "Configuration for a Zookeeper remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config is used to configure the Zookeeper client",
          "package": "internal/core/config/sources/zookeeper",
          "fields": [
            {
              "yamlName": "endpoints",
              "doc": "A list of Zookeeper servers to use for the client",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "timeoutSeconds",
              "doc": "Client timeout",
              "default": 10,
              "required": false,
              "type": "uint",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "etcd2",
        "doc": "Configuration for an Etcd 2 remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for an Etcd2 source",
          "package": "internal/core/config/sources/etcd2",
          "fields": [
            {
              "yamlName": "endpoints",
              "doc": "A list of Etcd2 servers to use",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "username",
              "doc": "An optional username to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "password",
              "doc": "An optional password to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "consul",
        "doc": "Configuration for a Consul remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for the consul client",
          "package": "internal/core/config/sources/consul",
          "fields": [
            {
              "yamlName": "endpoint",
              "doc": "A Consul server URL",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "username",
              "doc": "An optional username to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "password",
              "doc": "An optional password to use when connecting",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "token",
              "doc": "An authentication token, if needed",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "datacenter",
              "doc": "The Consul datacenter to use",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "vault",
        "doc": "Configuration for a Hashicorp Vault remote config source",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "Config",
          "doc": "Config for the vault remote config",
          "package": "internal/core/config/sources/vault",
          "fields": [
            {
              "yamlName": "vaultAddr",
              "doc": "The Vault Address.  Can also be provided by the standard Vault envvar `VAULT_ADDR`.  This option takes priority over the envvar if provided.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "vaultToken",
              "doc": "The Vault token, can also be provided by it the standard Vault envvar `VAULT_TOKEN`.  This option takes priority over the envvar if provided.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "kvV2PollInterval",
              "doc": "The polling interval for checking KV V2 secrets for a new version.  This can be any string value that can be parsed by https://golang.org/pkg/time/#ParseDuration.",
              "default": "60s",
              "required": false,
              "type": "int64",
              "elementKind": ""
            },
            {
              "yamlName": "authMethod",
              "doc": "The authetication method to use, if any, to obtain the Vault token.  If `vaultToken` is specified above, this option will have no effect. Currently supported values are: `iam`.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "iam",
              "doc": "Further config options for the `iam` auth method.  These options are identical to the [CLI helper tool options](https://github.com/hashicorp/vault/blob/v1.1.0/builtin/credential/aws/cli.go#L148)",
              "default": "",
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "IAMConfig",
                "doc": "IAMConfig is the config for the AWS Auth method in Vault",
                "package": "internal/core/config/sources/vault/auth",
                "fields": [
                  {
                    "yamlName": "awsAccessKeyId",
                    "doc": "Explicit AWS access key ID",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "awsSecretAccessKey",
                    "doc": "Explicit AWS secret access key",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "awsSecurityToken",
                    "doc": "Explicit AWS security token for temporary credentials",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "headerValue",
                    "doc": "Value for the x-vault-aws-iam-server-id header in requests",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "mount",
                    "doc": "Path where the AWS credential method is mounted. This is usually provided via the -path flag in the \"vault login\" command, but it can be specified here as well. If specified here, it takes precedence over the value for -path. The default value is \"aws\".",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "role",
                    "doc": "Name of the Vault role to request a token against",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "gcp",
              "doc": "Further config options for the `gcp` auth method. These options are identical to the [CLI helper tool options](https://github.com/hashicorp/vault-plugin-auth-gcp/blob/e1f6784b379d277038ca0661606aa8d23791e392/plugin/cli.go#L120). You must provide a valid GCP IAM credential JSON either explicitly via the `credentials` option (not recommended), or through any GCP Application Default Credentials.",
              "default": "",
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "GCPConfig",
                "doc": "GCPConfig is the config for the GCP Auth method in Vault",
                "package": "internal/core/config/sources/vault/auth",
                "fields": [
                  {
                    "yamlName": "role",
                    "doc": "Required. The name of the role you're requesting a token for.",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "mount",
                    "doc": "This is usually provided via the -path flag in the \"vault login\" command, but it can be specified here as well. If specified here, it takes precedence over the value for -path.  Defaults to `gcp`.",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "credentials",
                    "doc": "Explicitly specified GCP credentials in JSON string format (not recommended)",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "jwt_exp",
                    "doc": "Time until the generated JWT expires in minutes. The given IAM role will have a max_jwt_exp field, the time in minutes that all valid authentication JWTs must expire within (from time of authentication). Defaults to 15 minutes, the default max_jwt_exp for a role. Must be less than an hour.",
                    "default": null,
                    "required": false,
                    "type": "int",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "service_account",
                    "doc": "Service account to generate a JWT for. Defaults to credentials \"client_email\" if \"credentials\" specified and this value is not. The actual credential must have the \"iam.serviceAccounts.signJWT\" permissions on this service account.",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "project",
                    "doc": "Project for the service account who will be authenticating to Vault. Defaults to the credential's \"project_id\" (if credentials are specified).\"",
                    "default": null,
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            }
          ]
        }
      }
    ]
  },
  "TopConfig": {
    "name": "Config",
    "doc": "Config is the top level config struct for configurations that are common to all platoforms",
    "package": "internal/core/config",
    "fields": [
      {
        "yamlName": "signalFxAccessToken",
        "doc": "The access token for the org that should receive the metrics emitted by the agent.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "ingestUrl",
        "doc": "The URL of SignalFx ingest server.  Should be overridden if using the SignalFx Gateway.  If not set, this will be determined by the `signalFxRealm` option below.  If you want to send trace spans to a different location, set the `traceEndpointUrl` option.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "traceEndpointUrl",
        "doc": "The full URL (including path) to the trace ingest server.  If this is not set, all trace spans will be sent to the same place as `ingestUrl` above.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "apiUrl",
        "doc": "The SignalFx API base URL.  If not set, this will determined by the `signalFxRealm` option below.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "signalFxRealm",
        "doc": "The SignalFx Realm that the organization you want to send to is a part of.  This defaults to the original realm (`us0`) but if you are setting up the agent for the first time, you quite likely need to change this.",
        "default": "us0",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "hostname",
        "doc": "The hostname that will be reported as the `host` dimension. If blank, this will be auto-determined by the agent based on a reverse lookup of the machine's IP address.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "useFullyQualifiedHost",
        "doc": "If true (the default), and the `hostname` option is not set, the hostname will be determined by doing a reverse DNS query on the IP address that is returned by querying for the bare hostname.  This is useful in cases where the hostname reported by the kernel is a short name. (**default**: `true`)",
        "default": null,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "disableHostDimensions",
        "doc": "Our standard agent model is to collect metrics for services running on the same host as the agent.  Therefore, host-specific dimensions (e.g. `host`, `AWSUniqueId`, etc) are automatically added to every datapoint that is emitted from the agent by default.  Set this to true if you are using the agent primarily to monitor things on other hosts.  You can set this option at the monitor level as well.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "intervalSeconds",
        "doc": "How often to send metrics to SignalFx.  Monitors can override this individually.",
        "default": 10,
        "required": false,
        "type": "int",
        "elementKind": ""
      },
      {
        "yamlName": "globalDimensions",
        "doc": "Dimensions (key:value pairs) that will be added to every datapoint emitted by the agent. To specify that all metrics should be high-resolution, add the dimension `sf_hires: 1`",
        "default": "",
        "required": false,
        "type": "map",
        "elementKind": "string"
      },
      {
        "yamlName": "sendMachineID",
        "doc": "Whether to send the machine-id dimension on all host-specific datapoints generated by the agent.  This dimension is derived from the Linux machine-id value.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "validateDiscoveryRules",
        "doc": "If true, a warning will be emitted if a discovery rule contains variables that will never possibly match a rule.  If using multiple observers, it is convenient to set this to false to suppress spurious errors.",
        "default": true,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "observers",
        "doc": "A list of observers to use (see observer config)",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "ObserverConfig",
          "doc": "ObserverConfig holds the configuration for an observer",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "type",
              "doc": "The type of the observer",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "monitors",
        "doc": "A list of monitors to use (see monitor config)",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MonitorConfig",
          "doc": "MonitorConfig is used to configure monitor instances.  One instance of MonitorConfig may be used to configure multiple monitor instances.  If a monitor's discovery rule does not match any discovered services, the monitor will not run.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "type",
              "doc": "The type of the monitor",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "discoveryRule",
              "doc": "The rule used to match up this configuration with a discovered endpoint. If blank, the configuration will be run immediately when the agent is started.  If multiple endpoints match this rule, multiple instances of the monitor type will be created with the same configuration (except different host/port).",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "validateDiscoveryRule",
              "doc": "If true, a warning will be emitted if a discovery rule contains variables that will never possibly match a rule.  If using multiple observers, it is convenient to set this to false to suppress spurious errors.  The top-level setting `validateDiscoveryRules` acts as a default if this isn't set.",
              "default": "false",
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "extraDimensions",
              "doc": "A set of extra dimensions (key:value pairs) to include on datapoints emitted by the monitor(s) created from this configuration. To specify metrics from this monitor should be high-resolution, add the dimension `sf_hires: 1`",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "extraDimensionsFromEndpoint",
              "doc": "A mapping of extra dimension names to a [discovery rule expression](https://docs.signalfx.com/en/latest/integrations/agent/auto-discovery.html) that is used to derive the value of the dimension.  For example, to use a certain container label as a dimension, you could use something like this in your monitor config block: `extraDimensionsFromEndpoint: {env: 'Get(container_labels, \"myapp.com/environment\")'}`",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "configEndpointMappings",
              "doc": "A set of mappings from a configuration option on this monitor to attributes of a discovered endpoint.  The keys are the config option on this monitor and the value can be any valid expression used in discovery rules.",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "intervalSeconds",
              "doc": "The interval (in seconds) at which to emit datapoints from the monitor(s) created by this configuration.  If not set (or set to 0), the global agent intervalSeconds config option will be used instead.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "solo",
              "doc": "If one or more configurations have this set to true, only those configurations will be considered. This setting can be useful for testing.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "metricsToExclude",
              "doc": "DEPRECATED in favor of the `datapointsToExclude` option.  That option handles negation of filter items differently.",
              "default": "",
              "required": false,
              "type": "slice",
              "elementKind": "struct",
              "elementStruct": {
                "name": "MetricFilter",
                "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
                "package": "internal/core/config",
                "fields": [
                  {
                    "yamlName": "dimensions",
                    "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
                    "default": "",
                    "required": false,
                    "type": "map",
                    "elementKind": "interface"
                  },
                  {
                    "yamlName": "metricNames",
                    "doc": "A list of metric names to match against",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "metricName",
                    "doc": "A single metric name to match against",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "monitorType",
                    "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "negated",
                    "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
                    "default": false,
                    "required": false,
                    "type": "bool",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "datapointsToExclude",
              "doc": "A list of datapoint filters.  These filters allow you to comprehensively define which datapoints to exclude by metric name or dimension set, as well as the ability to define overrides to re-include metrics excluded by previous patterns within the same filter item.  See [monitor filtering](https://github.com/signalfx/signalfx-agent/tree/master/docs/filtering.md#monitor-level-filtering) for examples and more information.",
              "default": "",
              "required": false,
              "type": "slice",
              "elementKind": "struct",
              "elementStruct": {
                "name": "MetricFilter",
                "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
                "package": "internal/core/config",
                "fields": [
                  {
                    "yamlName": "dimensions",
                    "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
                    "default": "",
                    "required": false,
                    "type": "map",
                    "elementKind": "interface"
                  },
                  {
                    "yamlName": "metricNames",
                    "doc": "A list of metric names to match against",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "metricName",
                    "doc": "A single metric name to match against",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "monitorType",
                    "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "negated",
                    "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
                    "default": false,
                    "required": false,
                    "type": "bool",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "disableHostDimensions",
              "doc": "Some monitors pull metrics from services not running on the same host and should not get the host-specific dimensions set on them (e.g. `host`, `AWSUniqueId`, etc).  Setting this to `true` causes those dimensions to be omitted.  You can disable this globally with the `disableHostDimensions` option on the top level of the config.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "disableEndpointDimensions",
              "doc": "This can be set to true if you don't want to include the dimensions that are specific to the endpoint that was discovered by an observer.  This is useful when you have an endpoint whose identity is not particularly important since it acts largely as a proxy or adapter for other metrics.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "dimensionTransformations",
              "doc": "A map from dimension names emitted by the monitor to the desired dimension name that will be emitted in the datapoint that goes to SignalFx.  This can be useful if you have custom metrics from your applications and want to make the dimensions from a monitor match those. Also can be useful when scraping free-form metrics, say with the `prometheus-exporter` monitor.  Right now, only static key/value transformations are supported.  Note that filtering by dimensions will be done on the *original* dimension name and not the new name.",
              "default": null,
              "required": false,
              "type": "map",
              "elementKind": "string"
            },
            {
              "yamlName": "extraMetrics",
              "doc": "Extra metrics to enable besides the default included ones.",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "extraGroups",
              "doc": "Extra metric groups to enable besides the metrics that are included by default.",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            }
          ]
        }
      },
      {
        "yamlName": "writer",
        "doc": "Configuration of the datapoint/event writer",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "WriterConfig",
          "doc": "WriterConfig holds configuration for the datapoint writer.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "datapointMaxBatchSize",
              "doc": "The maximum number of datapoints to include in a batch before sending the batch to the ingest server.  Smaller batch sizes than this will be sent if datapoints originate in smaller chunks.  Larger batch sizes may also be used if the `maxRequests` requests limit is hit -- the next request will consist of all of the datapoints queued in the meantime.",
              "default": 1000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "maxDatapointsBuffered",
              "doc": "The maximum number of datapoints that are allowed to be buffered in the agent (i.e. received from a monitor but have not yet received confirmation of successful receipt by the target ingest/gateway server downstream).  Any datapoints that come in beyond this number will overwrite existing datapoints if they have not been sent yet, starting with the oldest.",
              "default": 5000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "traceSpanMaxBatchSize",
              "doc": "The analogue of `datapointMaxBatchSize` for trace spans.",
              "default": 1000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "datapointMaxRequests",
              "doc": "Deprecated: use `maxRequests` instead.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "maxRequests",
              "doc": "The maximum number of concurrent requests to make to a single ingest server with datapoints/events/trace spans.  This number multiplied by `datapointMaxBatchSize` is more or less the maximum number of datapoints that can be \"in-flight\" at any given time.  Same thing for the `traceSpanMaxBatchSize` option and trace spans.",
              "default": 10,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "eventSendIntervalSeconds",
              "doc": "The agent does not send events immediately upon a monitor generating them, but buffers them and sends them in batches.  The lower this number, the less delay for events to appear in SignalFx.",
              "default": 1,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesMaxRequests",
              "doc": "The analogue of `maxRequests` for dimension property requests.",
              "default": 20,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesMaxBuffered",
              "doc": "How many dimension property updates to hold pending being sent before dropping subsequent property updates.  Property updates will be resent eventually and they are slow to change so dropping them (esp on agent start up) usually isn't a big deal.",
              "default": 10000,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesSendDelaySeconds",
              "doc": "How long to wait for property updates to be sent once they are generated.  Any duplicate updates to the same dimension within this time frame will result in the latest property set being sent.  This helps prevent spurious updates that get immediately overwritten by very flappy property generation.",
              "default": 30,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "propertiesHistorySize",
              "doc": "Properties that are synced to SignalFx are cached to prevent duplicate requests from being sent, causing unnecessary load on our backend.",
              "default": 10000,
              "required": false,
              "type": "uint",
              "elementKind": ""
            },
            {
              "yamlName": "logDatapoints",
              "doc": "If the log level is set to `debug` and this is true, all datapoints generated by the agent will be logged.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logEvents",
              "doc": "The analogue of `logDatapoints` for events.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logTraceSpans",
              "doc": "The analogue of `logDatapoints` for trace spans.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "logDroppedDatapoints",
              "doc": "If true, and the log level is `debug`, filtered out datapoints will be logged.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "sendTraceHostCorrelationMetrics",
              "doc": "Whether to send host correlation metrics to correlation traced services with the underlying host",
              "default": true,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "staleServiceTimeout",
              "doc": "How long to wait after a trace span's service name is last seen to continue sending the correlation datapoints for that service.  This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration.  This option is irrelvant if `sendTraceHostCorrelationMetrics` is false.",
              "default": "5m",
              "required": false,
              "type": "int64",
              "elementKind": ""
            },
            {
              "yamlName": "traceHostCorrelationMetricsInterval",
              "doc": "How frequently to send host correlation metrics that are generated from the service name seen in trace spans sent through or by the agent.  This should be a duration string that is accepted by https://golang.org/pkg/time/#ParseDuration.  This option is irrelvant if `sendTraceHostCorrelationMetrics` is false.",
              "default": "1m",
              "required": false,
              "type": "int64",
              "elementKind": ""
            },
            {
              "yamlName": "maxTraceSpansInFlight",
              "doc": "How many trace spans are allowed to be in the process of sending.  While this number is exceeded, existing pending spans will be randomly dropped if possible to accommodate new spans generated to avoid memory exhaustion.  If you see log messages about \"Aborting pending trace requests...\" or \"Dropping new trace spans...\" it means that the downstream target for traces is not able to accept them fast enough. Usually if the downstream is offline you will get connection refused errors and most likely spans will not build up in the agent (there is no retry mechanism). In the case of slow downstreams, you might be able to increase `maxRequests` to increase the concurrent stream of spans downstream (if the target can make efficient use of additional connections) or, less likely, increase `traceSpanMaxBatchSize` if your batches are maxing out (turn on debug logging to see the batch sizes being sent) and being split up too much. If neither of those options helps, your downstream is likely too slow to handle the volume of trace spans and should be upgraded to more powerful hardware/networking.",
              "default": 100000,
              "required": false,
              "type": "uint",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "logging",
        "doc": "Log configuration",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "LogConfig",
          "doc": "LogConfig contains configuration related to logging",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "level",
              "doc": "Valid levels include `debug`, `info`, `warn`, `error`.  Note that `debug` logging may leak sensitive configuration (e.g. passwords) to the agent output.",
              "default": "info",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "format",
              "doc": "The log output format to use.  Valid values are: `text`, `json`.",
              "default": "text",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "collectd",
        "doc": "Configuration of the managed collectd subprocess",
        "default": "",
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "CollectdConfig",
          "doc": "CollectdConfig high-level configurations",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "disableCollectd",
              "doc": "If you won't be using any collectd monitors, this can be set to true to prevent collectd from pre-initializing",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "timeout",
              "doc": "How many read intervals before abandoning a metric. Doesn't affect much in normal usage. See [Timeout](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#timeout_iterations).",
              "default": 40,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "readThreads",
              "doc": "Number of threads dedicated to executing read callbacks. See [ReadThreads](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#readthreads_num)",
              "default": 5,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeThreads",
              "doc": "Number of threads dedicated to writing value lists to write callbacks. This should be much less than readThreads because writing is batched in the write_http plugin that writes back to the agent. See [WriteThreads](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writethreads_num).",
              "default": 2,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeQueueLimitHigh",
              "doc": "The maximum numbers of values in the queue to be written back to the agent from collectd.  Since the values are written to a local socket that the agent exposes, there should be almost no queuing and the default should be more than sufficient. See [WriteQueueLimitHigh](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writequeuelimithigh_highnum)",
              "default": 500000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeQueueLimitLow",
              "doc": "The lowest number of values in the collectd queue before which metrics begin being randomly dropped.  See [WriteQueueLimitLow](https://collectd.org/documentation/manpages/collectd.conf.5.shtml#writequeuelimitlow_lownum)",
              "default": 400000,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "logLevel",
              "doc": "Collectd's log level -- info, notice, warning, or err",
              "default": "notice",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "intervalSeconds",
              "doc": "A default read interval for collectd plugins.  If zero or undefined, will default to the global agent interval.  Some collectd python monitors do not support overridding the interval at the monitor level, but this setting will apply to them.",
              "default": 0,
              "required": false,
              "type": "int",
              "elementKind": ""
            },
            {
              "yamlName": "writeServerIPAddr",
              "doc": "The local IP address of the server that the agent exposes to which collectd will send metrics.  This defaults to an arbitrary address in the localhost subnet, but can be overridden if needed.",
              "default": "127.9.8.7",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "writeServerPort",
              "doc": "The port of the agent's collectd metric sink server.  If set to zero (the default) it will allow the OS to assign it a free port.",
              "default": 0,
              "required": false,
              "type": "uint16",
              "elementKind": ""
            },
            {
              "yamlName": "configDir",
              "doc": "This is where the agent will write the collectd config files that it manages.  If you have secrets in those files, consider setting this to a path on a tmpfs mount.  The files in this directory should be considered transient -- there is no value in editing them by hand.  If you want to add your own collectd config, see the collectd/custom monitor.",
              "default": "/var/run/signalfx-agent/collectd",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "enableBuiltInFiltering",
        "doc": "If true, the agent will inherently filter non-bundled metrics without having to rely on the `whitelist.json` filter that was previously included under `metricsToExclude`.  Whether a metric is bundled or not is documented in each monitor's documentation.  Now every monitor's default configuration (i.e. the minimum amount of configuration to make it work) will only send bundled metrics, but if you enable certain flags or config options on the monitor, non-bundled metrics will also be sent without having to modify the whitelist via `metricsToInclude`.",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "metricsToInclude",
        "doc": "A list of metric filters that will whitelist/include metrics.  These filters take priority over the filters specified in `metricsToExclude`.",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "interface"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "metricsToExclude",
        "doc": "A list of metric filters",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "MetricFilter",
          "doc": "MetricFilter describes a set of subtractive filters applied to datapoints right before they are sent.",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "dimensions",
              "doc": "A map of dimension key/values to match against.  All key/values must match a datapoint for it to be matched.  The map values can be either a single string or a list of strings.",
              "default": "",
              "required": false,
              "type": "map",
              "elementKind": "interface"
            },
            {
              "yamlName": "metricNames",
              "doc": "A list of metric names to match against",
              "default": null,
              "required": false,
              "type": "slice",
              "elementKind": "string"
            },
            {
              "yamlName": "metricName",
              "doc": "A single metric name to match against",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "monitorType",
              "doc": "(**Only applicable for the top level filters**) Limits this scope of the filter to datapoints from a specific monitor. If specified, any datapoints not from this monitor type will never match against this filter.",
              "default": "",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "negated",
              "doc": "(**Only applicable for the top level filters**) Negates the result of the match so that it matches all datapoints that do NOT match the metric name and dimension values given. This does not negate monitorType, if given.",
              "default": false,
              "required": false,
              "type": "bool",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "propertiesToExclude",
        "doc": "A list of properties filters",
        "default": "",
        "required": false,
        "type": "slice",
        "elementKind": "struct",
        "elementStruct": {
          "name": "PropertyFilterConfig",
          "doc": "PropertyFilterConfig describes a set of subtractive filters applied to properties used to create a PropertyFilter",
          "package": "internal/core/config",
          "fields": [
            {
              "yamlName": "propertyName",
              "doc": "A single property name to match",
              "default": "*",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "propertyValue",
              "doc": "A property value to match",
              "default": "*",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "dimensionName",
              "doc": "A dimension name to match",
              "default": "*",
              "required": false,
              "type": "string",
              "elementKind": ""
            },
            {
              "yamlName": "dimensionValue",
              "doc": "A dimension value to match",
              "default": "*",
              "required": false,
              "type": "string",
              "elementKind": ""
            }
          ]
        }
      },
      {
        "yamlName": "internalStatusHost",
        "doc": "The host on which the internal status server will listen.  The internal status HTTP server serves internal metrics and diagnostic information about the agent and can be scraped by the `internal-metrics` monitor. Can be set to `0.0.0.0` if you want to monitor the agent from another host.  If you set this to blank/null, the internal status server will not be started.  See `internalStatusPort`.",
        "default": "localhost",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "internalStatusPort",
        "doc": "The port on which the internal status server will listen.  See `internalStatusHost`.",
        "default": 8095,
        "required": false,
        "type": "uint16",
        "elementKind": ""
      },
      {
        "yamlName": "profiling",
        "doc": "Enables Go pprof endpoint on port 6060 that serves profiling data for development",
        "default": false,
        "required": false,
        "type": "bool",
        "elementKind": ""
      },
      {
        "yamlName": "profilingHost",
        "doc": "The host/ip address for the pprof profile server to listen on. `profiling` must be enabled for this to have any effect.",
        "default": "127.0.0.1",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "profilingPort",
        "doc": "The port for the pprof profile server to listen on. `profiling` must be enabled for this to have any effect.",
        "default": 6060,
        "required": false,
        "type": "int",
        "elementKind": ""
      },
      {
        "yamlName": "bundleDir",
        "doc": "Path to the directory holding the agent dependencies.  This will normally be derived automatically. Overrides the envvar SIGNALFX_BUNDLE_DIR if set.",
        "default": "",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "scratch",
        "doc": "This exists purely to give the user a place to put common yaml values to reference in other parts of the config file.",
        "default": null,
        "required": false,
        "type": "interface",
        "elementKind": ""
      },
      {
        "yamlName": "configSources",
        "doc": "Configuration of remote config stores",
        "default": null,
        "required": false,
        "type": "struct",
        "elementKind": "",
        "elementStruct": {
          "name": "SourceConfig",
          "doc": "SourceConfig represents configuration for various config sources that we support.",
          "package": "internal/core/config/sources",
          "fields": [
            {
              "yamlName": "watch",
              "doc": "Whether to watch config sources for changes.  If this is `true` and any of the config changes (either the main agent.yaml, or remote config values), the agent will dynamically reconfigure itself with minimal disruption.  This is generally better than restarting the agent on config changes since that can result in larger gaps in metric data.  The main disadvantage of watching is slightly greater network and compute resource usage. This option is not itself watched for changes. If you change the value of this option, you must restart the agent.",
              "default": true,
              "required": false,
              "type": "bool",
              "elementKind": ""
            },
            {
              "yamlName": "file",
              "doc": "Configuration for other file sources",
              "default": "",
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for the file-based config source",
                "package": "internal/core/config/sources/file",
                "fields": [
                  {
                    "yamlName": "pollRateSeconds",
                    "doc": "How often to poll files (in seconds) to test for changes.  There are so many edge cases that break inotify that it is more robust to simply poll files than rely on that. This option is not subject to watching and changes to it will require an agent restart.",
                    "default": 5,
                    "required": false,
                    "type": "int",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "zookeeper",
              "doc": "Configuration for a Zookeeper remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config is used to configure the Zookeeper client",
                "package": "internal/core/config/sources/zookeeper",
                "fields": [
                  {
                    "yamlName": "endpoints",
                    "doc": "A list of Zookeeper servers to use for the client",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "timeoutSeconds",
                    "doc": "Client timeout",
                    "default": 10,
                    "required": false,
                    "type": "uint",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "etcd2",
              "doc": "Configuration for an Etcd 2 remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for an Etcd2 source",
                "package": "internal/core/config/sources/etcd2",
                "fields": [
                  {
                    "yamlName": "endpoints",
                    "doc": "A list of Etcd2 servers to use",
                    "default": null,
                    "required": false,
                    "type": "slice",
                    "elementKind": "string"
                  },
                  {
                    "yamlName": "username",
                    "doc": "An optional username to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "password",
                    "doc": "An optional password to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "consul",
              "doc": "Configuration for a Consul remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for the consul client",
                "package": "internal/core/config/sources/consul",
                "fields": [
                  {
                    "yamlName": "endpoint",
                    "doc": "A Consul server URL",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "username",
                    "doc": "An optional username to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "password",
                    "doc": "An optional password to use when connecting",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "token",
                    "doc": "An authentication token, if needed",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "datacenter",
                    "doc": "The Consul datacenter to use",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  }
                ]
              }
            },
            {
              "yamlName": "vault",
              "doc": "Configuration for a Hashicorp Vault remote config source",
              "default": null,
              "required": false,
              "type": "struct",
              "elementKind": "",
              "elementStruct": {
                "name": "Config",
                "doc": "Config for the vault remote config",
                "package": "internal/core/config/sources/vault",
                "fields": [
                  {
                    "yamlName": "vaultAddr",
                    "doc": "The Vault Address.  Can also be provided by the standard Vault envvar `VAULT_ADDR`.  This option takes priority over the envvar if provided.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "vaultToken",
                    "doc": "The Vault token, can also be provided by it the standard Vault envvar `VAULT_TOKEN`.  This option takes priority over the envvar if provided.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "kvV2PollInterval",
                    "doc": "The polling interval for checking KV V2 secrets for a new version.  This can be any string value that can be parsed by https://golang.org/pkg/time/#ParseDuration.",
                    "default": "60s",
                    "required": false,
                    "type": "int64",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "authMethod",
                    "doc": "The authetication method to use, if any, to obtain the Vault token.  If `vaultToken` is specified above, this option will have no effect. Currently supported values are: `iam`.",
                    "default": "",
                    "required": false,
                    "type": "string",
                    "elementKind": ""
                  },
                  {
                    "yamlName": "iam",
                    "doc": "Further config options for the `iam` auth method.  These options are identical to the [CLI helper tool options](https://github.com/hashicorp/vault/blob/v1.1.0/builtin/credential/aws/cli.go#L148)",
                    "default": "",
                    "required": false,
                    "type": "struct",
                    "elementKind": "",
                    "elementStruct": {
                      "name": "IAMConfig",
                      "doc": "IAMConfig is the config for the AWS Auth method in Vault",
                      "package": "internal/core/config/sources/vault/auth",
                      "fields": [
                        {
                          "yamlName": "awsAccessKeyId",
                          "doc": "Explicit AWS access key ID",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "awsSecretAccessKey",
                          "doc": "Explicit AWS secret access key",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "awsSecurityToken",
                          "doc": "Explicit AWS security token for temporary credentials",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "headerValue",
                          "doc": "Value for the x-vault-aws-iam-server-id header in requests",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "mount",
                          "doc": "Path where the AWS credential method is mounted. This is usually provided via the -path flag in the \"vault login\" command, but it can be specified here as well. If specified here, it takes precedence over the value for -path. The default value is \"aws\".",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "role",
                          "doc": "Name of the Vault role to request a token against",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        }
                      ]
                    }
                  },
                  {
                    "yamlName": "gcp",
                    "doc": "Further config options for the `gcp` auth method. These options are identical to the [CLI helper tool options](https://github.com/hashicorp/vault-plugin-auth-gcp/blob/e1f6784b379d277038ca0661606aa8d23791e392/plugin/cli.go#L120). You must provide a valid GCP IAM credential JSON either explicitly via the `credentials` option (not recommended), or through any GCP Application Default Credentials.",
                    "default": "",
                    "required": false,
                    "type": "struct",
                    "elementKind": "",
                    "elementStruct": {
                      "name": "GCPConfig",
                      "doc": "GCPConfig is the config for the GCP Auth method in Vault",
                      "package": "internal/core/config/sources/vault/auth",
                      "fields": [
                        {
                          "yamlName": "role",
                          "doc": "Required. The name of the role you're requesting a token for.",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "mount",
                          "doc": "This is usually provided via the -path flag in the \"vault login\" command, but it can be specified here as well. If specified here, it takes precedence over the value for -path.  Defaults to `gcp`.",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "credentials",
                          "doc": "Explicitly specified GCP credentials in JSON string format (not recommended)",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "jwt_exp",
                          "doc": "Time until the generated JWT expires in minutes. The given IAM role will have a max_jwt_exp field, the time in minutes that all valid authentication JWTs must expire within (from time of authentication). Defaults to 15 minutes, the default max_jwt_exp for a role. Must be less than an hour.",
                          "default": null,
                          "required": false,
                          "type": "int",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "service_account",
                          "doc": "Service account to generate a JWT for. Defaults to credentials \"client_email\" if \"credentials\" specified and this value is not. The actual credential must have the \"iam.serviceAccounts.signJWT\" permissions on this service account.",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        },
                        {
                          "yamlName": "project",
                          "doc": "Project for the service account who will be authenticating to Vault. Defaults to the credential's \"project_id\" (if credentials are specified).\"",
                          "default": null,
                          "required": false,
                          "type": "string",
                          "elementKind": ""
                        }
                      ]
                    }
                  }
                ]
              }
            }
          ]
        }
      },
      {
        "yamlName": "procPath",
        "doc": "Path to the host's `/proc` filesystem. This is useful for containerized environments.",
        "default": "/proc",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "etcPath",
        "doc": "Path to the host's `/etc` directory. This is useful for containerized environments.",
        "default": "/etc",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "varPath",
        "doc": "Path to the host's `/var` directory. This is useful for containerized environments.",
        "default": "/var",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "runPath",
        "doc": "Path to the host's `/run` directory. This is useful for containerized environments.",
        "default": "/run",
        "required": false,
        "type": "string",
        "elementKind": ""
      },
      {
        "yamlName": "sysPath",
        "doc": "Path to the host's `/sys` directory. This is useful for containerized environments.",
        "default": "/sys",
        "required": false,
        "type": "string",
        "elementKind": ""
      }
    ]
  }
}
